import {
  require_react_dom
} from "/build/_shared/chunk-6DAQMQYB.js";
import {
  require_jsx_dev_runtime,
  require_react
} from "/build/_shared/chunk-JR7JHID7.js";
import {
  __commonJS,
  __export,
  __toESM
} from "/build/_shared/chunk-4D7IJTTE.js";

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has3 = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has3;
    function checkPropTypes(typeSpecs, values5, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has3(typeSpecs, typeSpecName)) {
            var error2;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error2 = typeSpecs[typeSpecName](values5, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error2 = ex;
            }
            if (error2 && !(error2 instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
              loggedTypeFailures[error2.message] = true;
              var stack2 = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error2.message + (stack2 != null ? stack2 : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has3 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement3, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error2 = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error2 instanceof Error) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement3(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has3(propValue, key)) {
              var error2 = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has3(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has3(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement3(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/hammerjs/hammer.js
var require_hammer = __commonJS({
  "node_modules/hammerjs/hammer.js"(exports, module) {
    (function(window2, document2, exportName, undefined2) {
      "use strict";
      var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
      var TEST_ELEMENT = document2.createElement("div");
      var TYPE_FUNCTION = "function";
      var round5 = Math.round;
      var abs3 = Math.abs;
      var now3 = Date.now;
      function setTimeoutContext(fn, timeout, context2) {
        return setTimeout(bindFn(fn, context2), timeout);
      }
      function invokeArrayArg(arg, fn, context2) {
        if (Array.isArray(arg)) {
          each(arg, context2[fn], context2);
          return true;
        }
        return false;
      }
      function each(obj, iterator, context2) {
        var i;
        if (!obj) {
          return;
        }
        if (obj.forEach) {
          obj.forEach(iterator, context2);
        } else if (obj.length !== undefined2) {
          i = 0;
          while (i < obj.length) {
            iterator.call(context2, obj[i], i, obj);
            i++;
          }
        } else {
          for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context2, obj[i], i, obj);
          }
        }
      }
      function deprecate(method, name2, message) {
        var deprecationMessage = "DEPRECATED METHOD: " + name2 + "\n" + message + " AT \n";
        return function() {
          var e = new Error("get-stack-trace");
          var stack2 = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
          var log3 = window2.console && (window2.console.warn || window2.console.log);
          if (log3) {
            log3.call(window2.console, deprecationMessage, stack2);
          }
          return method.apply(this, arguments);
        };
      }
      var assign;
      if (typeof Object.assign !== "function") {
        assign = function assign2(target) {
          if (target === undefined2 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined2 && source !== null) {
              for (var nextKey in source) {
                if (source.hasOwnProperty(nextKey)) {
                  output[nextKey] = source[nextKey];
                }
              }
            }
          }
          return output;
        };
      } else {
        assign = Object.assign;
      }
      var extend15 = deprecate(function extend16(dest, src, merge2) {
        var keys2 = Object.keys(src);
        var i = 0;
        while (i < keys2.length) {
          if (!merge2 || merge2 && dest[keys2[i]] === undefined2) {
            dest[keys2[i]] = src[keys2[i]];
          }
          i++;
        }
        return dest;
      }, "extend", "Use `assign`.");
      var merge = deprecate(function merge2(dest, src) {
        return extend15(dest, src, true);
      }, "merge", "Use `assign`.");
      function inherit(child, base, properties) {
        var baseP = base.prototype, childP;
        childP = child.prototype = Object.create(baseP);
        childP.constructor = child;
        childP._super = baseP;
        if (properties) {
          assign(childP, properties);
        }
      }
      function bindFn(fn, context2) {
        return function boundFn() {
          return fn.apply(context2, arguments);
        };
      }
      function boolOrFn(val, args) {
        if (typeof val == TYPE_FUNCTION) {
          return val.apply(args ? args[0] || undefined2 : undefined2, args);
        }
        return val;
      }
      function ifUndefined(val1, val2) {
        return val1 === undefined2 ? val2 : val1;
      }
      function addEventListeners2(target, types, handler) {
        each(splitStr(types), function(type) {
          target.addEventListener(type, handler, false);
        });
      }
      function removeEventListeners2(target, types, handler) {
        each(splitStr(types), function(type) {
          target.removeEventListener(type, handler, false);
        });
      }
      function hasParent2(node2, parent) {
        while (node2) {
          if (node2 == parent) {
            return true;
          }
          node2 = node2.parentNode;
        }
        return false;
      }
      function inStr(str, find2) {
        return str.indexOf(find2) > -1;
      }
      function splitStr(str) {
        return str.trim().split(/\s+/g);
      }
      function inArray2(src, find2, findByKey) {
        if (src.indexOf && !findByKey) {
          return src.indexOf(find2);
        } else {
          var i = 0;
          while (i < src.length) {
            if (findByKey && src[i][findByKey] == find2 || !findByKey && src[i] === find2) {
              return i;
            }
            i++;
          }
          return -1;
        }
      }
      function toArray(obj) {
        return Array.prototype.slice.call(obj, 0);
      }
      function uniqueArray(src, key, sort) {
        var results = [];
        var values5 = [];
        var i = 0;
        while (i < src.length) {
          var val = key ? src[i][key] : src[i];
          if (inArray2(values5, val) < 0) {
            results.push(src[i]);
          }
          values5[i] = val;
          i++;
        }
        if (sort) {
          if (!key) {
            results = results.sort();
          } else {
            results = results.sort(function sortUniqueArray(a, b) {
              return a[key] > b[key];
            });
          }
        }
        return results;
      }
      function prefixed(obj, property) {
        var prefix, prop;
        var camelProp = property[0].toUpperCase() + property.slice(1);
        var i = 0;
        while (i < VENDOR_PREFIXES.length) {
          prefix = VENDOR_PREFIXES[i];
          prop = prefix ? prefix + camelProp : property;
          if (prop in obj) {
            return prop;
          }
          i++;
        }
        return undefined2;
      }
      var _uniqueId = 1;
      function uniqueId() {
        return _uniqueId++;
      }
      function getWindowForElement(element2) {
        var doc = element2.ownerDocument || element2;
        return doc.defaultView || doc.parentWindow || window2;
      }
      var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
      var SUPPORT_TOUCH = "ontouchstart" in window2;
      var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
      var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
      var INPUT_TYPE_TOUCH = "touch";
      var INPUT_TYPE_PEN = "pen";
      var INPUT_TYPE_MOUSE = "mouse";
      var INPUT_TYPE_KINECT = "kinect";
      var COMPUTE_INTERVAL = 25;
      var INPUT_START = 1;
      var INPUT_MOVE = 2;
      var INPUT_END = 4;
      var INPUT_CANCEL = 8;
      var DIRECTION_NONE = 1;
      var DIRECTION_LEFT = 2;
      var DIRECTION_RIGHT = 4;
      var DIRECTION_UP = 8;
      var DIRECTION_DOWN = 16;
      var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
      var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
      var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
      var PROPS_XY = ["x", "y"];
      var PROPS_CLIENT_XY = ["clientX", "clientY"];
      function Input(manager, callback) {
        var self2 = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        this.domHandler = function(ev) {
          if (boolOrFn(manager.options.enable, [manager])) {
            self2.handler(ev);
          }
        };
        this.init();
      }
      Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {
        },
        /**
         * bind the events
         */
        init: function() {
          this.evEl && addEventListeners2(this.element, this.evEl, this.domHandler);
          this.evTarget && addEventListeners2(this.target, this.evTarget, this.domHandler);
          this.evWin && addEventListeners2(getWindowForElement(this.element), this.evWin, this.domHandler);
        },
        /**
         * unbind the events
         */
        destroy: function() {
          this.evEl && removeEventListeners2(this.element, this.evEl, this.domHandler);
          this.evTarget && removeEventListeners2(this.target, this.evTarget, this.domHandler);
          this.evWin && removeEventListeners2(getWindowForElement(this.element), this.evWin, this.domHandler);
        }
      };
      function createInputInstance(manager) {
        var Type;
        var inputClass = manager.options.inputClass;
        if (inputClass) {
          Type = inputClass;
        } else if (SUPPORT_POINTER_EVENTS) {
          Type = PointerEventInput;
        } else if (SUPPORT_ONLY_TOUCH) {
          Type = TouchInput;
        } else if (!SUPPORT_TOUCH) {
          Type = MouseInput;
        } else {
          Type = TouchMouseInput;
        }
        return new Type(manager, inputHandler);
      }
      function inputHandler(manager, eventType, input) {
        var pointersLen = input.pointers.length;
        var changedPointersLen = input.changedPointers.length;
        var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
        var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
        input.isFirst = !!isFirst;
        input.isFinal = !!isFinal;
        if (isFirst) {
          manager.session = {};
        }
        input.eventType = eventType;
        computeInputData(manager, input);
        manager.emit("hammer.input", input);
        manager.recognize(input);
        manager.session.prevInput = input;
      }
      function computeInputData(manager, input) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        if (!session.firstInput) {
          session.firstInput = simpleCloneInputData(input);
        }
        if (pointersLength > 1 && !session.firstMultiple) {
          session.firstMultiple = simpleCloneInputData(input);
        } else if (pointersLength === 1) {
          session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter(pointers);
        input.timeStamp = now3();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle(offsetCenter, center);
        input.distance = getDistance(offsetCenter, center);
        computeDeltaXY(session, input);
        input.offsetDirection = getDirection(input.deltaX, input.deltaY);
        var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
        input.overallVelocityX = overallVelocity.x;
        input.overallVelocityY = overallVelocity.y;
        input.overallVelocity = abs3(overallVelocity.x) > abs3(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
        input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
        input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
        input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
        computeIntervalInputData(session, input);
        var target = manager.element;
        if (hasParent2(input.srcEvent.target, target)) {
          target = input.srcEvent.target;
        }
        input.target = target;
      }
      function computeDeltaXY(session, input) {
        var center = input.center;
        var offset3 = session.offsetDelta || {};
        var prevDelta = session.prevDelta || {};
        var prevInput = session.prevInput || {};
        if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
          prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
          };
          offset3 = session.offsetDelta = {
            x: center.x,
            y: center.y
          };
        }
        input.deltaX = prevDelta.x + (center.x - offset3.x);
        input.deltaY = prevDelta.y + (center.y - offset3.y);
      }
      function computeIntervalInputData(session, input) {
        var last3 = session.lastInterval || input, deltaTime = input.timeStamp - last3.timeStamp, velocity, velocityX, velocityY, direction;
        if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last3.velocity === undefined2)) {
          var deltaX = input.deltaX - last3.deltaX;
          var deltaY = input.deltaY - last3.deltaY;
          var v = getVelocity(deltaTime, deltaX, deltaY);
          velocityX = v.x;
          velocityY = v.y;
          velocity = abs3(v.x) > abs3(v.y) ? v.x : v.y;
          direction = getDirection(deltaX, deltaY);
          session.lastInterval = input;
        } else {
          velocity = last3.velocity;
          velocityX = last3.velocityX;
          velocityY = last3.velocityY;
          direction = last3.direction;
        }
        input.velocity = velocity;
        input.velocityX = velocityX;
        input.velocityY = velocityY;
        input.direction = direction;
      }
      function simpleCloneInputData(input) {
        var pointers = [];
        var i = 0;
        while (i < input.pointers.length) {
          pointers[i] = {
            clientX: round5(input.pointers[i].clientX),
            clientY: round5(input.pointers[i].clientY)
          };
          i++;
        }
        return {
          timeStamp: now3(),
          pointers,
          center: getCenter(pointers),
          deltaX: input.deltaX,
          deltaY: input.deltaY
        };
      }
      function getCenter(pointers) {
        var pointersLength = pointers.length;
        if (pointersLength === 1) {
          return {
            x: round5(pointers[0].clientX),
            y: round5(pointers[0].clientY)
          };
        }
        var x = 0, y = 0, i = 0;
        while (i < pointersLength) {
          x += pointers[i].clientX;
          y += pointers[i].clientY;
          i++;
        }
        return {
          x: round5(x / pointersLength),
          y: round5(y / pointersLength)
        };
      }
      function getVelocity(deltaTime, x, y) {
        return {
          x: x / deltaTime || 0,
          y: y / deltaTime || 0
        };
      }
      function getDirection(x, y) {
        if (x === y) {
          return DIRECTION_NONE;
        }
        if (abs3(x) >= abs3(y)) {
          return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
        }
        return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
      }
      function getDistance(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.sqrt(x * x + y * y);
      }
      function getAngle(p1, p2, props) {
        if (!props) {
          props = PROPS_XY;
        }
        var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
        return Math.atan2(y, x) * 180 / Math.PI;
      }
      function getRotation(start, end) {
        return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
      }
      function getScale(start, end) {
        return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
      }
      var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
      };
      var MOUSE_ELEMENT_EVENTS = "mousedown";
      var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
      function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.pressed = false;
        Input.apply(this, arguments);
      }
      inherit(MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler(ev) {
          var eventType = MOUSE_INPUT_MAP[ev.type];
          if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
          }
          if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
          }
          if (!this.pressed) {
            return;
          }
          if (eventType & INPUT_END) {
            this.pressed = false;
          }
          this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
          });
        }
      });
      var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
      };
      var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT
        // see https://twitter.com/jacobrossi/status/480596438489890816
      };
      var POINTER_ELEMENT_EVENTS = "pointerdown";
      var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
      if (window2.MSPointerEvent && !window2.PointerEvent) {
        POINTER_ELEMENT_EVENTS = "MSPointerDown";
        POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
      }
      function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply(this, arguments);
        this.store = this.manager.session.pointerEvents = [];
      }
      inherit(PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler(ev) {
          var store = this.store;
          var removePointer = false;
          var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
          var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
          var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
          var isTouch = pointerType == INPUT_TYPE_TOUCH;
          var storeIndex = inArray2(store, ev.pointerId, "pointerId");
          if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
              store.push(ev);
              storeIndex = store.length - 1;
            }
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
          }
          if (storeIndex < 0) {
            return;
          }
          store[storeIndex] = ev;
          this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType,
            srcEvent: ev
          });
          if (removePointer) {
            store.splice(storeIndex, 1);
          }
        }
      });
      var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
      var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
      function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply(this, arguments);
      }
      inherit(SingleTouchInput, Input, {
        handler: function TEhandler(ev) {
          var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
          if (type === INPUT_START) {
            this.started = true;
          }
          if (!this.started) {
            return;
          }
          var touches = normalizeSingleTouches.call(this, ev, type);
          if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function normalizeSingleTouches(ev, type) {
        var all = toArray(ev.touches);
        var changed = toArray(ev.changedTouches);
        if (type & (INPUT_END | INPUT_CANCEL)) {
          all = uniqueArray(all.concat(changed), "identifier", true);
        }
        return [all, changed];
      }
      var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
      };
      var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
      function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply(this, arguments);
      }
      inherit(TouchInput, Input, {
        handler: function MTEhandler(ev) {
          var type = TOUCH_INPUT_MAP[ev.type];
          var touches = getTouches2.call(this, ev, type);
          if (!touches) {
            return;
          }
          this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
          });
        }
      });
      function getTouches2(ev, type) {
        var allTouches = toArray(ev.touches);
        var targetIds = this.targetIds;
        if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
          targetIds[allTouches[0].identifier] = true;
          return [allTouches, allTouches];
        }
        var i, targetTouches, changedTouches = toArray(ev.changedTouches), changedTargetTouches = [], target = this.target;
        targetTouches = allTouches.filter(function(touch) {
          return hasParent2(touch.target, target);
        });
        if (type === INPUT_START) {
          i = 0;
          while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
          }
        }
        i = 0;
        while (i < changedTouches.length) {
          if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
          }
          if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
          }
          i++;
        }
        if (!changedTargetTouches.length) {
          return;
        }
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
          changedTargetTouches
        ];
      }
      var DEDUP_TIMEOUT = 2500;
      var DEDUP_DISTANCE = 25;
      function TouchMouseInput() {
        Input.apply(this, arguments);
        var handler = bindFn(this.handler, this);
        this.touch = new TouchInput(this.manager, handler);
        this.mouse = new MouseInput(this.manager, handler);
        this.primaryTouch = null;
        this.lastTouches = [];
      }
      inherit(TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler(manager, inputEvent, inputData) {
          var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
          if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
          }
          if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
          } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
          }
          this.callback(manager, inputEvent, inputData);
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy2() {
          this.touch.destroy();
          this.mouse.destroy();
        }
      });
      function recordTouches(eventType, eventData) {
        if (eventType & INPUT_START) {
          this.primaryTouch = eventData.changedPointers[0].identifier;
          setLastTouch.call(this, eventData);
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
          setLastTouch.call(this, eventData);
        }
      }
      function setLastTouch(eventData) {
        var touch = eventData.changedPointers[0];
        if (touch.identifier === this.primaryTouch) {
          var lastTouch = { x: touch.clientX, y: touch.clientY };
          this.lastTouches.push(lastTouch);
          var lts = this.lastTouches;
          var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
              lts.splice(i, 1);
            }
          };
          setTimeout(removeLastTouch, DEDUP_TIMEOUT);
        }
      }
      function isSyntheticEvent(eventData) {
        var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
        for (var i = 0; i < this.lastTouches.length; i++) {
          var t = this.lastTouches[i];
          var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
          if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
          }
        }
        return false;
      }
      var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
      var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
      var TOUCH_ACTION_COMPUTE = "compute";
      var TOUCH_ACTION_AUTO = "auto";
      var TOUCH_ACTION_MANIPULATION = "manipulation";
      var TOUCH_ACTION_NONE = "none";
      var TOUCH_ACTION_PAN_X = "pan-x";
      var TOUCH_ACTION_PAN_Y = "pan-y";
      var TOUCH_ACTION_MAP = getTouchActionProps();
      function TouchAction(manager, value) {
        this.manager = manager;
        this.set(value);
      }
      TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function(value) {
          if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
          }
          if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
          }
          this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
          this.set(this.manager.options.touchAction);
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
          var actions = [];
          each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
              actions = actions.concat(recognizer.getTouchAction());
            }
          });
          return cleanTouchActions(actions.join(" "));
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function(input) {
          var srcEvent = input.srcEvent;
          var direction = input.offsetDirection;
          if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
          }
          var actions = this.actions;
          var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
          if (hasNone) {
            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;
            if (isTapPointer && isTapMovement && isTapTouchTime) {
              return;
            }
          }
          if (hasPanX && hasPanY) {
            return;
          }
          if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
            return this.preventSrc(srcEvent);
          }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function(srcEvent) {
          this.manager.session.prevented = true;
          srcEvent.preventDefault();
        }
      };
      function cleanTouchActions(actions) {
        if (inStr(actions, TOUCH_ACTION_NONE)) {
          return TOUCH_ACTION_NONE;
        }
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
        if (hasPanX && hasPanY) {
          return TOUCH_ACTION_NONE;
        }
        if (hasPanX || hasPanY) {
          return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
        }
        if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
          return TOUCH_ACTION_MANIPULATION;
        }
        return TOUCH_ACTION_AUTO;
      }
      function getTouchActionProps() {
        if (!NATIVE_TOUCH_ACTION) {
          return false;
        }
        var touchMap = {};
        var cssSupports = window2.CSS && window2.CSS.supports;
        ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
          touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
        });
        return touchMap;
      }
      var STATE_POSSIBLE = 1;
      var STATE_BEGAN = 2;
      var STATE_CHANGED = 4;
      var STATE_ENDED = 8;
      var STATE_RECOGNIZED = STATE_ENDED;
      var STATE_CANCELLED = 16;
      var STATE_FAILED = 32;
      function Recognizer(options2) {
        this.options = assign({}, this.defaults, options2 || {});
        this.id = uniqueId();
        this.manager = null;
        this.options.enable = ifUndefined(this.options.enable, true);
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
      }
      Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function(options2) {
          assign(this.options, options2);
          this.manager && this.manager.touchAction.update();
          return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
            return this;
          }
          var simultaneous = this.simultaneous;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
          }
          return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          delete this.simultaneous[otherRecognizer.id];
          return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
            return this;
          }
          var requireFail = this.requireFail;
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          if (inArray2(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
          }
          return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function(otherRecognizer) {
          if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
            return this;
          }
          otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
          var index = inArray2(this.requireFail, otherRecognizer);
          if (index > -1) {
            this.requireFail.splice(index, 1);
          }
          return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
          return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function(otherRecognizer) {
          return !!this.simultaneous[otherRecognizer.id];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function(input) {
          var self2 = this;
          var state = this.state;
          function emit(event) {
            self2.manager.emit(event, input);
          }
          if (state < STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
          emit(self2.options.event);
          if (input.additionalEvent) {
            emit(input.additionalEvent);
          }
          if (state >= STATE_ENDED) {
            emit(self2.options.event + stateStr(state));
          }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function(input) {
          if (this.canEmit()) {
            return this.emit(input);
          }
          this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
          var i = 0;
          while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
              return false;
            }
            i++;
          }
          return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var inputDataClone = assign({}, inputData);
          if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
          }
          if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
          }
          this.state = this.process(inputDataClone);
          if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
          }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function(inputData) {
        },
        // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {
        },
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {
        }
      };
      function stateStr(state) {
        if (state & STATE_CANCELLED) {
          return "cancel";
        } else if (state & STATE_ENDED) {
          return "end";
        } else if (state & STATE_CHANGED) {
          return "move";
        } else if (state & STATE_BEGAN) {
          return "start";
        }
        return "";
      }
      function directionStr(direction) {
        if (direction == DIRECTION_DOWN) {
          return "down";
        } else if (direction == DIRECTION_UP) {
          return "up";
        } else if (direction == DIRECTION_LEFT) {
          return "left";
        } else if (direction == DIRECTION_RIGHT) {
          return "right";
        }
        return "";
      }
      function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
        var manager = recognizer.manager;
        if (manager) {
          return manager.get(otherRecognizer);
        }
        return otherRecognizer;
      }
      function AttrRecognizer() {
        Recognizer.apply(this, arguments);
      }
      inherit(AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
          /**
           * @type {Number}
           * @default 1
           */
          pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function(input) {
          var optionPointers = this.options.pointers;
          return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function(input) {
          var state = this.state;
          var eventType = input.eventType;
          var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
          var isValid = this.attrTest(input);
          if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
          } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
              return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
              return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
          }
          return STATE_FAILED;
        }
      });
      function PanRecognizer() {
        AttrRecognizer.apply(this, arguments);
        this.pX = null;
        this.pY = null;
      }
      inherit(PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: DIRECTION_ALL
        },
        getTouchAction: function() {
          var direction = this.options.direction;
          var actions = [];
          if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
          }
          if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
          }
          return actions;
        },
        directionTest: function(input) {
          var options2 = this.options;
          var hasMoved = true;
          var distance = input.distance;
          var direction = input.direction;
          var x = input.deltaX;
          var y = input.deltaY;
          if (!(direction & options2.direction)) {
            if (options2.direction & DIRECTION_HORIZONTAL) {
              direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
              hasMoved = x != this.pX;
              distance = Math.abs(input.deltaX);
            } else {
              direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
              hasMoved = y != this.pY;
              distance = Math.abs(input.deltaY);
            }
          }
          input.direction = direction;
          return hasMoved && distance > options2.threshold && direction & options2.direction;
        },
        attrTest: function(input) {
          return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
        },
        emit: function(input) {
          this.pX = input.deltaX;
          this.pY = input.deltaY;
          var direction = directionStr(input.direction);
          if (direction) {
            input.additionalEvent = this.options.event + direction;
          }
          this._super.emit.call(this, input);
        }
      });
      function PinchRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
        },
        emit: function(input) {
          if (input.scale !== 1) {
            var inOut = input.scale < 1 ? "in" : "out";
            input.additionalEvent = this.options.event + inOut;
          }
          this._super.emit.call(this, input);
        }
      });
      function PressRecognizer() {
        Recognizer.apply(this, arguments);
        this._timer = null;
        this._input = null;
      }
      inherit(PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          // minimal time of the pointer to be pressed
          threshold: 9
          // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_AUTO];
        },
        process: function(input) {
          var options2 = this.options;
          var validPointers = input.pointers.length === options2.pointers;
          var validMovement = input.distance < options2.threshold;
          var validTime = input.deltaTime > options2.time;
          this._input = input;
          if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
            this.reset();
          } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
              this.state = STATE_RECOGNIZED;
              this.tryEmit();
            }, options2.time, this);
          } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
          }
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function(input) {
          if (this.state !== STATE_RECOGNIZED) {
            return;
          }
          if (input && input.eventType & INPUT_END) {
            this.manager.emit(this.options.event + "up", input);
          } else {
            this._input.timeStamp = now3();
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function RotateRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_NONE];
        },
        attrTest: function(input) {
          return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
        }
      });
      function SwipeRecognizer() {
        AttrRecognizer.apply(this, arguments);
      }
      inherit(SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
          event: "swipe",
          threshold: 10,
          velocity: 0.3,
          direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
          pointers: 1
        },
        getTouchAction: function() {
          return PanRecognizer.prototype.getTouchAction.call(this);
        },
        attrTest: function(input) {
          var direction = this.options.direction;
          var velocity;
          if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
          } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
          } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
          }
          return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs3(velocity) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function(input) {
          var direction = directionStr(input.offsetDirection);
          if (direction) {
            this.manager.emit(this.options.event + direction, input);
          }
          this.manager.emit(this.options.event, input);
        }
      });
      function TapRecognizer() {
        Recognizer.apply(this, arguments);
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
      }
      inherit(TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          // max time between the multi-tap taps
          time: 250,
          // max time of the pointer to be down (like finger on the screen)
          threshold: 9,
          // a minimal movement is ok, but keep it low
          posThreshold: 10
          // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
          return [TOUCH_ACTION_MANIPULATION];
        },
        process: function(input) {
          var options2 = this.options;
          var validPointers = input.pointers.length === options2.pointers;
          var validMovement = input.distance < options2.threshold;
          var validTouchTime = input.deltaTime < options2.time;
          this.reset();
          if (input.eventType & INPUT_START && this.count === 0) {
            return this.failTimeout();
          }
          if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
              return this.failTimeout();
            }
            var validInterval = this.pTime ? input.timeStamp - this.pTime < options2.interval : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options2.posThreshold;
            this.pTime = input.timeStamp;
            this.pCenter = input.center;
            if (!validMultiTap || !validInterval) {
              this.count = 1;
            } else {
              this.count += 1;
            }
            this._input = input;
            var tapCount = this.count % options2.taps;
            if (tapCount === 0) {
              if (!this.hasRequireFailures()) {
                return STATE_RECOGNIZED;
              } else {
                this._timer = setTimeoutContext(function() {
                  this.state = STATE_RECOGNIZED;
                  this.tryEmit();
                }, options2.interval, this);
                return STATE_BEGAN;
              }
            }
          }
          return STATE_FAILED;
        },
        failTimeout: function() {
          this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
          }, this.options.interval, this);
          return STATE_FAILED;
        },
        reset: function() {
          clearTimeout(this._timer);
        },
        emit: function() {
          if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
          }
        }
      });
      function Hammer(element2, options2) {
        options2 = options2 || {};
        options2.recognizers = ifUndefined(options2.recognizers, Hammer.defaults.preset);
        return new Manager(element2, options2);
      }
      Hammer.VERSION = "2.0.7";
      Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
          // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, { enable: false }],
          [PinchRecognizer, { enable: false }, ["rotate"]],
          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
          [TapRecognizer],
          [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
          [PressRecognizer]
        ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
          /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userSelect: "none",
          /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */
          touchSelect: "none",
          /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */
          touchCallout: "none",
          /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */
          contentZooming: "none",
          /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */
          userDrag: "none",
          /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */
          tapHighlightColor: "rgba(0,0,0,0)"
        }
      };
      var STOP = 1;
      var FORCED_STOP = 2;
      function Manager(element2, options2) {
        this.options = assign({}, Hammer.defaults, options2 || {});
        this.options.inputTarget = this.options.inputTarget || element2;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.oldCssProps = {};
        this.element = element2;
        this.input = createInputInstance(this);
        this.touchAction = new TouchAction(this, this.options.touchAction);
        toggleCssProps(this, true);
        each(this.options.recognizers, function(item) {
          var recognizer = this.add(new item[0](item[1]));
          item[2] && recognizer.recognizeWith(item[2]);
          item[3] && recognizer.requireFailure(item[3]);
        }, this);
      }
      Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function(options2) {
          assign(this.options, options2);
          if (options2.touchAction) {
            this.touchAction.update();
          }
          if (options2.inputTarget) {
            this.input.destroy();
            this.input.target = options2.inputTarget;
            this.input.init();
          }
          return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function(force) {
          this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function(inputData) {
          var session = this.session;
          if (session.stopped) {
            return;
          }
          this.touchAction.preventDefaults(inputData);
          var recognizer;
          var recognizers = this.recognizers;
          var curRecognizer = session.curRecognizer;
          if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
            curRecognizer = session.curRecognizer = null;
          }
          var i = 0;
          while (i < recognizers.length) {
            recognizer = recognizers[i];
            if (session.stopped !== FORCED_STOP && // 1
            (!curRecognizer || recognizer == curRecognizer || // 2
            recognizer.canRecognizeWith(curRecognizer))) {
              recognizer.recognize(inputData);
            } else {
              recognizer.reset();
            }
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
              curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
          }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function(recognizer) {
          if (recognizer instanceof Recognizer) {
            return recognizer;
          }
          var recognizers = this.recognizers;
          for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
              return recognizers[i];
            }
          }
          return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function(recognizer) {
          if (invokeArrayArg(recognizer, "add", this)) {
            return this;
          }
          var existing = this.get(recognizer.options.event);
          if (existing) {
            this.remove(existing);
          }
          this.recognizers.push(recognizer);
          recognizer.manager = this;
          this.touchAction.update();
          return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function(recognizer) {
          if (invokeArrayArg(recognizer, "remove", this)) {
            return this;
          }
          recognizer = this.get(recognizer);
          if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray2(recognizers, recognizer);
            if (index !== -1) {
              recognizers.splice(index, 1);
              this.touchAction.update();
            }
          }
          return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function(events2, handler) {
          if (events2 === undefined2) {
            return;
          }
          if (handler === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events2), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
          });
          return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function(events2, handler) {
          if (events2 === undefined2) {
            return;
          }
          var handlers = this.handlers;
          each(splitStr(events2), function(event) {
            if (!handler) {
              delete handlers[event];
            } else {
              handlers[event] && handlers[event].splice(inArray2(handlers[event], handler), 1);
            }
          });
          return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function(event, data) {
          if (this.options.domEvents) {
            triggerDomEvent(event, data);
          }
          var handlers = this.handlers[event] && this.handlers[event].slice();
          if (!handlers || !handlers.length) {
            return;
          }
          data.type = event;
          data.preventDefault = function() {
            data.srcEvent.preventDefault();
          };
          var i = 0;
          while (i < handlers.length) {
            handlers[i](data);
            i++;
          }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
          this.element && toggleCssProps(this, false);
          this.handlers = {};
          this.session = {};
          this.input.destroy();
          this.element = null;
        }
      };
      function toggleCssProps(manager, add3) {
        var element2 = manager.element;
        if (!element2.style) {
          return;
        }
        var prop;
        each(manager.options.cssProps, function(value, name2) {
          prop = prefixed(element2.style, name2);
          if (add3) {
            manager.oldCssProps[prop] = element2.style[prop];
            element2.style[prop] = value;
          } else {
            element2.style[prop] = manager.oldCssProps[prop] || "";
          }
        });
        if (!add3) {
          manager.oldCssProps = {};
        }
      }
      function triggerDomEvent(event, data) {
        var gestureEvent = document2.createEvent("Event");
        gestureEvent.initEvent(event, true, true);
        gestureEvent.gesture = data;
        data.target.dispatchEvent(gestureEvent);
      }
      assign(Hammer, {
        INPUT_START,
        INPUT_MOVE,
        INPUT_END,
        INPUT_CANCEL,
        STATE_POSSIBLE,
        STATE_BEGAN,
        STATE_CHANGED,
        STATE_ENDED,
        STATE_RECOGNIZED,
        STATE_CANCELLED,
        STATE_FAILED,
        DIRECTION_NONE,
        DIRECTION_LEFT,
        DIRECTION_RIGHT,
        DIRECTION_UP,
        DIRECTION_DOWN,
        DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL,
        DIRECTION_ALL,
        Manager,
        Input,
        TouchAction,
        TouchInput,
        MouseInput,
        PointerEventInput,
        TouchMouseInput,
        SingleTouchInput,
        Recognizer,
        AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners2,
        off: removeEventListeners2,
        each,
        merge,
        extend: extend15,
        assign,
        inherit,
        bindFn,
        prefixed
      });
      var freeGlobal = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
      freeGlobal.Hammer = Hammer;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Hammer;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = Hammer;
      } else {
        window2[exportName] = Hammer;
      }
    })(window, document, "Hammer");
  }
});

// node_modules/@progress/kendo-react-charts/dist/es/Chart.js
var React13 = __toESM(require_react());

// node_modules/@progress/kendo-react-charts/dist/es/BaseChart.js
var React11 = __toESM(require_react());
var PropTypes2 = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-intl/dist/es/globalization/GlobalizationContext.js
var React = __toESM(require_react());

// node_modules/@progress/kendo-intl/dist/es/cldr/default-data.js
var defaultData = {
  en: {
    name: "en",
    identity: {
      version: {
        _unicodeVersion: "14.0.0",
        _cldrVersion: "41"
      },
      language: "en"
    },
    territory: "US",
    numbers: {
      symbols: {
        decimal: ".",
        group: ",",
        list: ";",
        percentSign: "%",
        plusSign: "+",
        minusSign: "-",
        exponential: "E",
        superscriptingExponent: "\xD7",
        perMille: "\u2030",
        infinity: "\u221E",
        nan: "NaN",
        timeSeparator: ":",
        approximatelySign: "~"
      },
      decimal: {
        patterns: [
          "n"
        ],
        groupSize: [
          3
        ]
      },
      scientific: {
        patterns: [
          "nEn"
        ],
        groupSize: []
      },
      percent: {
        patterns: [
          "n%"
        ],
        groupSize: [
          3
        ]
      },
      currency: {
        patterns: [
          "$n"
        ],
        groupSize: [
          3
        ],
        "unitPattern-count-one": "n $",
        "unitPattern-count-other": "n $"
      },
      currencies: {
        BGN: {
          displayName: "Bulgarian Lev",
          "displayName-count-one": "Bulgarian lev",
          "displayName-count-other": "Bulgarian leva",
          symbol: "BGN"
        },
        EUR: {
          displayName: "Euro",
          "displayName-count-one": "euro",
          "displayName-count-other": "euros",
          symbol: "\u20AC",
          "symbol-alt-narrow": "\u20AC"
        },
        USD: {
          displayName: "US Dollar",
          "displayName-count-one": "US dollar",
          "displayName-count-other": "US dollars",
          symbol: "$",
          "symbol-alt-narrow": "$"
        }
      },
      localeCurrency: "USD",
      accounting: {
        patterns: [
          "$n",
          "($n)"
        ],
        groupSize: [
          3
        ]
      }
    },
    calendar: {
      gmtFormat: "GMT{0}",
      gmtZeroFormat: "GMT",
      patterns: {
        d: "M/d/y",
        D: "EEEE, MMMM d, y",
        m: "MMM d",
        M: "MMMM d",
        y: "MMM y",
        Y: "MMMM y",
        F: "EEEE, MMMM d, y h:mm:ss a",
        g: "M/d/y h:mm a",
        G: "M/d/y h:mm:ss a",
        t: "h:mm a",
        T: "h:mm:ss a",
        s: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
        u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"
      },
      dateTimeFormats: {
        full: "{1} 'at' {0}",
        long: "{1} 'at' {0}",
        medium: "{1}, {0}",
        short: "{1}, {0}",
        availableFormats: {
          Bh: "h B",
          Bhm: "h:mm B",
          Bhms: "h:mm:ss B",
          d: "d",
          E: "ccc",
          EBhm: "E h:mm B",
          EBhms: "E h:mm:ss B",
          Ed: "d E",
          Ehm: "E h:mm a",
          EHm: "E HH:mm",
          Ehms: "E h:mm:ss a",
          EHms: "E HH:mm:ss",
          Gy: "y G",
          GyMd: "M/d/y GGGGG",
          GyMMM: "MMM y G",
          GyMMMd: "MMM d, y G",
          GyMMMEd: "E, MMM d, y G",
          h: "h a",
          H: "HH",
          hm: "h:mm a",
          Hm: "HH:mm",
          hms: "h:mm:ss a",
          Hms: "HH:mm:ss",
          hmsv: "h:mm:ss a v",
          Hmsv: "HH:mm:ss v",
          hmv: "h:mm a v",
          Hmv: "HH:mm v",
          M: "L",
          Md: "M/d",
          MEd: "E, M/d",
          MMM: "LLL",
          MMMd: "MMM d",
          MMMEd: "E, MMM d",
          MMMMd: "MMMM d",
          "MMMMW-count-one": "'week' W 'of' MMMM",
          "MMMMW-count-other": "'week' W 'of' MMMM",
          ms: "mm:ss",
          y: "y",
          yM: "M/y",
          yMd: "M/d/y",
          yMEd: "E, M/d/y",
          yMMM: "MMM y",
          yMMMd: "MMM d, y",
          yMMMEd: "E, MMM d, y",
          yMMMM: "MMMM y",
          yQQQ: "QQQ y",
          yQQQQ: "QQQQ y",
          "yw-count-one": "'week' w 'of' Y",
          "yw-count-other": "'week' w 'of' Y"
        }
      },
      timeFormats: {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      },
      dateFormats: {
        full: "EEEE, MMMM d, y",
        long: "MMMM d, y",
        medium: "MMM d, y",
        short: "M/d/yy"
      },
      days: {
        format: {
          abbreviated: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
          ],
          narrow: [
            "S",
            "M",
            "T",
            "W",
            "T",
            "F",
            "S"
          ],
          short: [
            "Su",
            "Mo",
            "Tu",
            "We",
            "Th",
            "Fr",
            "Sa"
          ],
          wide: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
          ],
          narrow: [
            "S",
            "M",
            "T",
            "W",
            "T",
            "F",
            "S"
          ],
          short: [
            "Su",
            "Mo",
            "Tu",
            "We",
            "Th",
            "Fr",
            "Sa"
          ],
          wide: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        }
      },
      months: {
        format: {
          abbreviated: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          narrow: [
            "J",
            "F",
            "M",
            "A",
            "M",
            "J",
            "J",
            "A",
            "S",
            "O",
            "N",
            "D"
          ],
          wide: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          narrow: [
            "J",
            "F",
            "M",
            "A",
            "M",
            "J",
            "J",
            "A",
            "S",
            "O",
            "N",
            "D"
          ],
          wide: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        }
      },
      quarters: {
        format: {
          abbreviated: [
            "Q1",
            "Q2",
            "Q3",
            "Q4"
          ],
          narrow: [
            "1",
            "2",
            "3",
            "4"
          ],
          wide: [
            "1st quarter",
            "2nd quarter",
            "3rd quarter",
            "4th quarter"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Q1",
            "Q2",
            "Q3",
            "Q4"
          ],
          narrow: [
            "1",
            "2",
            "3",
            "4"
          ],
          wide: [
            "1st quarter",
            "2nd quarter",
            "3rd quarter",
            "4th quarter"
          ]
        }
      },
      dayPeriods: {
        format: {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          narrow: {
            midnight: "mi",
            am: "a",
            "am-alt-variant": "am",
            noon: "n",
            pm: "p",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          }
        },
        "stand-alone": {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          narrow: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          }
        }
      },
      eras: {
        format: {
          wide: {
            "0": "Before Christ",
            "1": "Anno Domini",
            "0-alt-variant": "Before Common Era",
            "1-alt-variant": "Common Era"
          },
          abbreviated: {
            "0": "BC",
            "1": "AD",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          },
          narrow: {
            "0": "B",
            "1": "A",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          }
        }
      },
      dateFields: {
        era: {
          wide: "era",
          short: "era",
          narrow: "era"
        },
        year: {
          wide: "year",
          short: "yr.",
          narrow: "yr."
        },
        quarter: {
          wide: "quarter",
          short: "qtr.",
          narrow: "qtr."
        },
        month: {
          wide: "month",
          short: "mo.",
          narrow: "mo."
        },
        week: {
          wide: "week",
          short: "wk.",
          narrow: "wk."
        },
        weekOfMonth: {
          wide: "week of month",
          short: "wk. of mo.",
          narrow: "wk. of mo."
        },
        day: {
          wide: "day",
          short: "day",
          narrow: "day"
        },
        dayOfYear: {
          wide: "day of year",
          short: "day of yr.",
          narrow: "day of yr."
        },
        weekday: {
          wide: "day of the week",
          short: "day of wk.",
          narrow: "day of wk."
        },
        weekdayOfMonth: {
          wide: "weekday of the month",
          short: "wkday. of mo.",
          narrow: "wkday. of mo."
        },
        dayperiod: {
          short: "AM/PM",
          wide: "AM/PM",
          narrow: "AM/PM"
        },
        hour: {
          wide: "hour",
          short: "hr.",
          narrow: "hr."
        },
        minute: {
          wide: "minute",
          short: "min.",
          narrow: "min."
        },
        second: {
          wide: "second",
          short: "sec.",
          narrow: "sec."
        },
        zone: {
          wide: "time zone",
          short: "zone",
          narrow: "zone"
        },
        millisecond: {
          narrow: "ms",
          short: "ms",
          wide: "millisecond"
        }
      }
    }
  },
  supplemental: {
    likelySubtags: {
      en: "en-Latn-US"
    },
    currencyData: {
      region: {
        US: [
          {
            USD: {
              _from: "1792-01-01"
            }
          }
        ]
      }
    },
    weekData: {
      firstDay: {
        US: "sun"
      },
      weekendStart: {
        "001": "sat"
      },
      weekendEnd: {
        "001": "sun"
      }
    }
  }
};
var default_data_default = defaultData;

// node_modules/@progress/kendo-intl/dist/es/common/is-string.js
function isString(value) {
  return typeof value === "string";
}

// node_modules/@progress/kendo-intl/dist/es/error-details.js
var error_details_default = {
  "NoLocale": "Missing locale info for '{0}'",
  "NoCurrency": "Cannot determine currency information. Please load the locale currencies data.",
  "NoSupplementalCurrency": "Cannot determine currency. Please load the supplemental currencyData.",
  "NoCurrencyRegion": "No currency data for region '{0}'",
  "NoCurrencyDisplay": "Cannot determine currency display information. Please load the locale currencies data. The default culture does not include the all currencies data.",
  "NoGMTInfo": "Cannot determine locale GMT format. Please load the locale timeZoneNames data.",
  "NoWeekData": "Cannot determine locale first day of week. Please load the supplemental weekData.",
  "NoFirstDay": "Cannot determine locale first day of week. Please load the supplemental weekData. The default culture includes only the 'en-US' first day info.",
  "NoValidCurrency": "Cannot determine a default currency for the {0} locale. Please specify explicitly the currency with the format options.",
  "NoDateFieldNames": "Cannot determine the locale date field names. Please load the locale dateFields data."
};

// node_modules/@progress/kendo-intl/dist/es/errors.js
var formatRegExp = /\{(\d+)}?\}/g;
var IntlError = function IntlError2(ref2) {
  var name2 = ref2.name;
  var message = ref2.message;
  if (!name2 || !message) {
    throw new Error("{ name: string, message: string } object is required!");
  }
  this.name = name2;
  this.message = message;
};
IntlError.prototype.formatMessage = function formatMessage() {
  var values5 = [], len = arguments.length;
  while (len--)
    values5[len] = arguments[len];
  var flattenValues = flatten(values5);
  var formattedMessage = this.message.replace(formatRegExp, function(match, index) {
    return flattenValues[parseInt(index, 10)];
  });
  return this.name + ": " + formattedMessage;
};
IntlError.prototype.error = function error() {
  var values5 = [], len = arguments.length;
  while (len--)
    values5[len] = arguments[len];
  return new Error(this.formatMessage(values5));
};
var flatten = function(arr) {
  return arr.reduce(function(a, b) {
    return a.concat(b);
  }, []);
};
var toIntlErrors = function(errors2) {
  var predicate = function(prev, name2) {
    prev[name2] = new IntlError({ name: name2, message: errors2[name2] });
    return prev;
  };
  return Object.keys(errors2).reduce(predicate, {});
};
var errors = toIntlErrors(error_details_default);

// node_modules/@progress/kendo-intl/dist/es/cldr/info.js
function availableLocaleInfo(fullName, suffixes) {
  var parts = fullName.split("-");
  var language = parts[0];
  var script = parts[1];
  var territory = parts[2];
  return cldr[fullName] || suffixes.indexOf(territory) !== -1 && cldr[language + "-" + territory] || suffixes.indexOf(script) !== -1 && cldr[language + "-" + script] || cldr[language];
}
function localeFullName(language, suffixes) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  for (var idx = 0; idx < suffixes.length; idx++) {
    var name2 = likelySubtags[language + "-" + suffixes[idx]];
    if (name2) {
      return name2;
    }
  }
  if (likelySubtags[language]) {
    return likelySubtags[language];
  }
}
var cldr = default_data_default;
function getLocaleInfo(locale) {
  var info;
  if (isString(locale)) {
    info = localeInfo(locale);
  } else {
    info = locale;
  }
  return info;
}
function localeInfo(locale) {
  if (cldr[locale]) {
    return cldr[locale];
  }
  var likelySubtags = cldr.supplemental.likelySubtags;
  if (likelySubtags) {
    var parts = locale.split("-");
    var language = parts[0];
    var suffixes = parts.slice(1);
    var fullName = localeFullName(language, suffixes);
    var info = fullName ? availableLocaleInfo(fullName, suffixes) : null;
    if (info) {
      return info;
    }
  }
  throw errors.NoLocale.error(locale);
}

// node_modules/@progress/kendo-intl/dist/es/common/constants.js
var DECIMAL = "decimal";
var CURRENCY = "currency";
var ACCOUNTING = "accounting";
var PERCENT = "percent";
var SCIENTIFIC = "scientific";
var CURRENCY_PLACEHOLDER = "$";
var PERCENT_PLACEHOLDER = "%";
var NUMBER_PLACEHOLDER = "n";
var LIST_SEPARATOR = ";";
var GROUP_SEPARATOR = ",";
var POINT = ".";
var EMPTY = "";
var DEFAULT_LOCALE = "en";

// node_modules/@progress/kendo-intl/dist/es/cldr/territory.js
function territoryFromName(name2, identity) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  var parts = name2.split("-");
  if (likelySubtags) {
    var likelyName = likelySubtags[name2] || likelySubtags[parts[0]];
    if (likelyName) {
      parts = likelyName.split("-");
    }
  }
  if (identity) {
    for (var idx = parts.length - 1; idx >= 1; idx--) {
      var part = parts[idx];
      if (part === identity.variant || part === identity.script) {
        parts.splice(idx, 1);
      }
    }
  }
  var length = parts.length;
  if (length > 1) {
    var territory = parts[length - 1];
    return territory.toUpperCase();
  }
}
function localeTerritory(info) {
  if (info.territory) {
    return info.territory;
  }
  var name2 = info.name;
  var identity = info.identity;
  var territory;
  if (identity && identity.territory) {
    territory = identity.territory;
  } else {
    territory = territoryFromName(name2, identity);
  }
  info.territory = territory;
  return territory;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/date-field-name.js
function dateFieldName(options2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  var info = localeInfo(locale);
  var dateFields = info.calendar.dateFields;
  if (!dateFields) {
    throw errors.NoDateFieldNames.error();
  }
  var fieldNameInfo = dateFields[options2.type] || {};
  return fieldNameInfo[options2.nameType] || fieldNameInfo["wide"];
}

// node_modules/@progress/kendo-intl/dist/es/cldr/date-format-names.js
function lowerArray(arr) {
  var result = [];
  for (var idx = 0; idx < arr.length; idx++) {
    result.push(arr[idx].toLowerCase());
  }
  return result;
}
function lowerObject(obj) {
  var result = {};
  for (var field in obj) {
    result[field] = obj[field].toLowerCase();
  }
  return result;
}
function cloneLower(obj) {
  var result = Array.isArray(obj) ? lowerArray(obj) : lowerObject(obj);
  return result;
}
function dateFormatNames(locale, options2) {
  var type = options2.type;
  var nameType = options2.nameType;
  var standAlone = options2.standAlone;
  var lower = options2.lower;
  var info = getLocaleInfo(locale);
  var formatType = standAlone ? "stand-alone" : "format";
  var lowerNameType = (lower ? "lower-" : EMPTY) + nameType;
  var formatNames2 = info.calendar[type][formatType];
  var result = formatNames2[lowerNameType];
  if (!result && lower) {
    result = formatNames2[lowerNameType] = cloneLower(formatNames2[nameType]);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/parse-range-date.js
function parseRangeDate(value) {
  var parts = value.split("-");
  var year = parseInt(parts[0], 10);
  var month = parseInt(parts[1], 10) - 1;
  var day = parseInt(parts[2], 10);
  return new Date(year, month, day);
}

// node_modules/@progress/kendo-intl/dist/es/cldr/currency.js
var NoCurrency = errors.NoCurrency;
var NoCurrencyDisplay = errors.NoCurrencyDisplay;
var NoSupplementalCurrency = errors.NoSupplementalCurrency;
var NoCurrencyRegion = errors.NoCurrencyRegion;
var NoValidCurrency = errors.NoValidCurrency;
var DEFAULT_CURRENCY_FRACTIONS = 2;
var SYMBOL = "symbol";
var INVALID_CURRENCY_CODE = "XXX";
var GLOBAL_CURRENCIES = {
  "001": "USD",
  // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error
  "150": "EUR"
  // 150 territory for Europe
};
function getCurrencyInfo(locale, currency, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var currencies = info.numbers.currencies;
  if (!currencies) {
    if (throwIfNoValid) {
      throw NoCurrency.error();
    }
    return;
  }
  var currencyDisplayInfo = currencies[currency];
  if (!currencyDisplayInfo) {
    if (throwIfNoValid) {
      throw NoCurrencyDisplay.error();
    }
    return;
  }
  return currencyDisplayInfo;
}
function lengthComparer(a, b) {
  return b.length - a.length;
}
function regionCurrency(regionCurrencies) {
  var latestValidUntil, latestValidUntilRange;
  var latestStillValid, latestStillValidDate;
  for (var idx = 0; idx < regionCurrencies.length; idx++) {
    var currency = regionCurrencies[idx];
    var code = Object.keys(currency)[0];
    var info = currency[code];
    if (code !== INVALID_CURRENCY_CODE && info._tender !== "false" && info._from) {
      if (!info._to) {
        var stillValidDate = parseRangeDate(info._from);
        if (!latestStillValidDate || latestStillValidDate < stillValidDate) {
          latestStillValid = code;
          latestStillValidDate = stillValidDate;
        }
      } else if (!latestStillValid) {
        var validFrom = parseRangeDate(info._from);
        var validTo = parseRangeDate(info._to);
        if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {
          latestValidUntil = code;
          latestValidUntilRange = {
            from: validFrom,
            to: validTo
          };
        }
      }
    }
  }
  return latestStillValid || latestValidUntil;
}
function currencyDisplays(locale, currency, throwIfNoValid) {
  if (throwIfNoValid === void 0)
    throwIfNoValid = true;
  var currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);
  if (!currencyInfo) {
    return;
  }
  if (!currencyInfo.displays) {
    var displays = [currency];
    for (var field in currencyInfo) {
      displays.push(currencyInfo[field]);
    }
    displays.sort(lengthComparer);
    currencyInfo.displays = displays;
  }
  return currencyInfo.displays;
}
function currencyDisplay(locale, options2) {
  var value = options2.value;
  var currency = options2.currency;
  var currencyDisplay2 = options2.currencyDisplay;
  if (currencyDisplay2 === void 0)
    currencyDisplay2 = SYMBOL;
  if (currencyDisplay2 === "code") {
    return currency;
  }
  var currencyInfo = getCurrencyInfo(locale, currency, true);
  var result;
  if (currencyDisplay2 === SYMBOL) {
    result = currencyInfo["symbol-alt-narrow"] || currencyInfo[SYMBOL];
  } else {
    if (typeof value === "undefined" || value !== 1) {
      result = currencyInfo["displayName-count-other"];
    } else {
      result = currencyInfo["displayName-count-one"];
    }
  }
  return result;
}
function currencyFractionOptions(code) {
  var minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code];
  if (fractions && fractions._digits) {
    maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function territoryCurrencyCode(territory, throwIfNoValid) {
  if (throwIfNoValid === void 0)
    throwIfNoValid = true;
  if (GLOBAL_CURRENCIES[territory]) {
    return GLOBAL_CURRENCIES[territory];
  }
  var currencyData = cldr.supplemental.currencyData;
  if (!currencyData) {
    if (throwIfNoValid) {
      throw NoSupplementalCurrency.error();
    }
    return;
  }
  var regionCurrencies = currencyData.region[territory];
  if (!regionCurrencies) {
    if (throwIfNoValid) {
      throw NoCurrencyRegion.error(territory);
    }
    return;
  }
  var currencyCode = regionCurrency(regionCurrencies);
  return currencyCode;
}
function localeCurrency(locale, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var numbers = info.numbers;
  if (!numbers.localeCurrency) {
    var currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);
    if (!currency && throwIfNoValid) {
      throw NoValidCurrency.error(info.name);
    }
    numbers.localeCurrency = currency;
  }
  return numbers.localeCurrency;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/constants.js
var DAYS_OF_WEEK = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var DEFAULT_TERRITORY = "001";

// node_modules/@progress/kendo-intl/dist/es/cldr/first-day.js
var NoWeekData = errors.NoWeekData;
var NoFirstDay = errors.NoFirstDay;
function firstDay(locale) {
  var info = getLocaleInfo(locale);
  if (!isNaN(info.firstDay)) {
    return info.firstDay;
  }
  var weekData = cldr.supplemental.weekData;
  if (!weekData) {
    throw NoWeekData.error();
  }
  var firstDay3 = weekData.firstDay[localeTerritory(info)] || weekData.firstDay[DEFAULT_TERRITORY];
  if (!firstDay3) {
    throw NoFirstDay.error();
  }
  info.firstDay = DAYS_OF_WEEK.indexOf(firstDay3);
  return info.firstDay;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/weekend-range.js
var NoWeekData2 = errors.NoWeekData;

// node_modules/@progress/kendo-intl/dist/es/cldr/number-symbols.js
function numberSymbols(locale) {
  var info = getLocaleInfo(locale);
  return info.numbers.symbols;
}

// node_modules/@progress/kendo-intl/dist/es/common/is-negative-zero.js
function isNegativeZero(value) {
  return 1 / value === -Infinity;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-currency-symbol.js
function formatCurrencySymbol(info, options2) {
  if (options2 === void 0)
    options2 = {};
  if (!options2.currency) {
    options2.currency = localeCurrency(info, true);
  }
  var display = currencyDisplay(info, options2);
  return display;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/group-integer.js
function groupInteger(number2, start, end, options2, info) {
  var symbols = info.numbers.symbols;
  var decimalIndex = number2.indexOf(symbols.decimal);
  var groupSizes = options2.groupSize.slice();
  var groupSize = groupSizes.shift();
  var integerEnd = decimalIndex !== -1 ? decimalIndex : end + 1;
  var integer = number2.substring(start, integerEnd);
  var result = number2;
  var integerLength = integer.length;
  if (integerLength >= groupSize) {
    var idx = integerLength;
    var parts = [];
    while (idx > -1) {
      var value = integer.substring(idx - groupSize, idx);
      if (value) {
        parts.push(value);
      }
      idx -= groupSize;
      var newGroupSize = groupSizes.shift();
      groupSize = newGroupSize !== void 0 ? newGroupSize : groupSize;
      if (groupSize === 0) {
        value = integer.substring(0, idx);
        if (value) {
          parts.push(value);
        }
        break;
      }
    }
    integer = parts.reverse().join(symbols.group);
    result = number2.substring(0, start) + integer + number2.substring(integerEnd);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/is-currency-style.js
function isCurrencyStyle(style) {
  return style === CURRENCY || style === ACCOUNTING;
}

// node_modules/@progress/kendo-intl/dist/es/common/pad.js
function pad(number2, digits, right) {
  if (digits === void 0)
    digits = 2;
  if (right === void 0)
    right = false;
  var count = digits - String(number2).length;
  var result = number2;
  if (count > 0) {
    var padString = new Array(count + 1).join("0");
    result = right ? number2 + padString : padString + number2;
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/common/round.js
var MAX_PRECISION = 20;
function round(value, precision) {
  var result = value;
  var decimals = precision || 0;
  result = result.toString().split("e");
  result = Math.round(Number(result[0] + "e" + (result[1] ? Number(result[1]) + decimals : decimals)));
  result = result.toString().split("e");
  result = Number(result[0] + "e" + (result[1] ? Number(result[1]) - decimals : -decimals));
  return result.toFixed(Math.min(decimals, MAX_PRECISION));
}

// node_modules/@progress/kendo-intl/dist/es/numbers/standard-number-format.js
var DEFAULT_DECIMAL_ROUNDING = 3;
var DEFAULT_PERCENT_ROUNDING = 0;
var trailingZeroRegex = /0+$/;
function fractionOptions(options2) {
  var minimumFractionDigits = options2.minimumFractionDigits;
  var maximumFractionDigits = options2.maximumFractionDigits;
  var style = options2.style;
  var isCurrency = isCurrencyStyle(style);
  var currencyFractions;
  if (isCurrency) {
    currencyFractions = currencyFractionOptions(options2.currency);
  }
  if (minimumFractionDigits === void 0) {
    minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;
  }
  if (maximumFractionDigits === void 0) {
    if (style === PERCENT) {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);
    } else if (isCurrency) {
      maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);
    } else {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);
    }
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function applyPattern(value, pattern, symbol) {
  var result = EMPTY;
  for (var idx = 0, length = pattern.length; idx < length; idx++) {
    var ch = pattern.charAt(idx);
    if (ch === NUMBER_PLACEHOLDER) {
      result += value;
    } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {
      result += symbol;
    } else {
      result += ch;
    }
  }
  return result;
}
function currencyUnitPattern(info, value) {
  var currencyInfo = info.numbers.currency;
  var pattern = value !== 1 ? currencyInfo["unitPattern-count-other"] : currencyInfo["unitPattern-count-one"];
  if (value < 0) {
    pattern = pattern.replace(NUMBER_PLACEHOLDER, "-" + NUMBER_PLACEHOLDER);
  }
  return pattern;
}
function standardNumberFormat(number2, options2, info) {
  var symbols = info.numbers.symbols;
  var style = options2.style;
  var isCurrency = isCurrencyStyle(style);
  if (style === SCIENTIFIC) {
    var exponential = options2.minimumFractionDigits !== void 0 ? number2.toExponential(options2.minimumFractionDigits) : number2.toExponential();
    return exponential.replace(POINT, symbols.decimal);
  }
  var value = number2;
  var symbol;
  if (isCurrency) {
    options2.value = value;
    symbol = formatCurrencySymbol(info, options2);
  }
  if (style === PERCENT) {
    value *= 100;
    symbol = symbols.percentSign;
  }
  var ref2 = fractionOptions(options2);
  var minimumFractionDigits = ref2.minimumFractionDigits;
  var maximumFractionDigits = ref2.maximumFractionDigits;
  value = round(value, maximumFractionDigits);
  var negative = value < 0;
  var negativeZero = isNegativeZero(number2);
  var parts = value.split(POINT);
  var integer = parts[0];
  var fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true);
  if (negative) {
    integer = integer.substring(1);
  }
  if (options2.minimumIntegerDigits) {
    integer = pad(integer, options2.minimumIntegerDigits);
  }
  var formattedValue = options2.useGrouping !== false ? groupInteger(integer, 0, integer.length, options2, info) : integer;
  if (fraction) {
    formattedValue += symbols.decimal + fraction;
  }
  var pattern;
  if (isCurrency && options2.currencyDisplay === "name") {
    pattern = currencyUnitPattern(info, number2);
  } else {
    var patterns = options2.patterns;
    pattern = negative || negativeZero ? patterns[1] || "-" + patterns[0] : patterns[0];
  }
  if (pattern === NUMBER_PLACEHOLDER && !negative) {
    return formattedValue;
  }
  var result = applyPattern(formattedValue, pattern, symbol);
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/utils.js
var literalRegExp = /(\\.)|(['][^']*[']?)|(["][^"]*["]?)/g;
var PLACEHOLDER = "__??__";
function setStyleOptions(formatOptions2, info) {
  var format2 = formatOptions2.format;
  if (format2.indexOf(PERCENT_PLACEHOLDER) !== -1) {
    formatOptions2.style = PERCENT;
    formatOptions2.symbol = info.numbers.symbols.percentSign;
    formatOptions2.number *= 100;
  }
  if (format2.indexOf(CURRENCY_PLACEHOLDER) !== -1) {
    formatOptions2.style = CURRENCY;
    formatOptions2.symbol = formatCurrencySymbol(info);
  }
}
function setFormatLiterals(formatOptions2) {
  var format2 = formatOptions2.format;
  if (format2.indexOf("'") > -1 || format2.indexOf('"') > -1 || format2.indexOf("\\") > -1) {
    var literals2 = formatOptions2.literals = [];
    formatOptions2.format = format2.replace(literalRegExp, function(match) {
      var quoteChar = match.charAt(0).replace("\\", EMPTY);
      var literal = match.slice(1).replace(quoteChar, EMPTY);
      literals2.push(literal);
      return PLACEHOLDER;
    });
  }
}
function replaceLiterals(number2, literals2) {
  var result = number2;
  if (literals2) {
    var length = literals2.length;
    for (var idx = 0; idx < length; idx++) {
      result = result.replace(PLACEHOLDER, literals2[idx]);
    }
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/custom-number-format.js
var SHARP = "#";
var ZERO = "0";
var trailingZerosRegExp = /(\.(?:[0-9]*[1-9])?)0+$/g;
var trailingPointRegExp = /\.$/;
var commaRegExp = /,/g;
function trimTrailingZeros(value, lastZero) {
  var trimRegex;
  if (lastZero === 0) {
    trimRegex = trailingZerosRegExp;
  } else {
    trimRegex = new RegExp("(\\.[0-9]{" + lastZero + "}[1-9]*)0+$", "g");
  }
  return value.replace(trimRegex, "$1").replace(trailingPointRegExp, EMPTY);
}
function roundNumber(formatOptions2) {
  var number2 = formatOptions2.number;
  var format2 = formatOptions2.format;
  var decimalIndex = format2.indexOf(POINT);
  if (decimalIndex !== -1) {
    var zeroIndex = format2.lastIndexOf(ZERO) - decimalIndex;
    var sharpIndex = format2.lastIndexOf(SHARP) - decimalIndex;
    var hasZero = zeroIndex > -1;
    var hasSharp = sharpIndex > -1;
    var fraction = number2.toString().split("e");
    if (fraction[1]) {
      fraction = round(number2, Math.abs(fraction[1]));
    } else {
      fraction = fraction[0];
    }
    fraction = fraction.split(POINT)[1] || EMPTY;
    var precision = fraction.length;
    var trailingZeros = -1;
    if (!hasZero && !hasSharp) {
      formatOptions2.format = format2.substring(0, decimalIndex) + format2.substring(decimalIndex + 1);
      decimalIndex = -1;
      precision = 0;
    } else if (hasZero && zeroIndex > sharpIndex) {
      precision = zeroIndex;
    } else if (sharpIndex > zeroIndex) {
      if (hasSharp && precision > sharpIndex) {
        precision = sharpIndex;
      } else if (hasZero && precision < zeroIndex) {
        precision = zeroIndex;
      }
      trailingZeros = hasZero ? zeroIndex : 0;
    }
    if (precision > -1) {
      number2 = round(number2, precision);
      if (trailingZeros > -1) {
        number2 = trimTrailingZeros(number2, trailingZeros);
      }
    }
  } else {
    number2 = round(number2);
  }
  if (formatOptions2.negative && number2 * -1 >= 0 && !formatOptions2.negativeZero) {
    formatOptions2.negative = false;
  }
  formatOptions2.number = number2;
  formatOptions2.decimalIndex = decimalIndex;
}
function isConstantFormat(format2) {
  return format2.indexOf(SHARP) === -1 && format2.indexOf(ZERO) === -1;
}
function setValueSpecificFormat(formatOptions2) {
  var number2 = formatOptions2.number;
  var format2 = formatOptions2.format;
  format2 = format2.split(LIST_SEPARATOR);
  if ((formatOptions2.negative || formatOptions2.negativeZero) && format2[1]) {
    format2 = format2[1];
    formatOptions2.hasNegativeFormat = true;
  } else if (number2 === 0) {
    var zeroFormat = format2[2];
    format2 = zeroFormat || format2[0];
    if (zeroFormat && isConstantFormat(zeroFormat)) {
      formatOptions2.constant = zeroFormat;
    }
  } else {
    format2 = format2[0];
  }
  formatOptions2.format = format2;
}
function setGroupOptions(formatOptions2) {
  formatOptions2.hasGroup = formatOptions2.format.indexOf(GROUP_SEPARATOR) > -1;
  if (formatOptions2.hasGroup) {
    formatOptions2.format = formatOptions2.format.replace(commaRegExp, EMPTY);
  }
}
function placeholderIndex(index1, index2, start) {
  var index;
  if (index1 === -1 && index2 !== -1) {
    index = index2;
  } else if (index1 !== -1 && index2 === -1) {
    index = index1;
  } else {
    index = start ? Math.min(index1, index2) : Math.max(index1, index2);
  }
  return index;
}
function setPlaceholderIndices(formatOptions2) {
  var format2 = formatOptions2.format;
  var sharpIndex = format2.indexOf(SHARP);
  var zeroIndex = format2.indexOf(ZERO);
  var start = placeholderIndex(sharpIndex, zeroIndex, true);
  sharpIndex = format2.lastIndexOf(SHARP);
  zeroIndex = format2.lastIndexOf(ZERO);
  var end = placeholderIndex(sharpIndex, zeroIndex);
  if (start === format2.length) {
    end = start;
  }
  formatOptions2.start = start;
  formatOptions2.end = end;
  formatOptions2.lastZeroIndex = zeroIndex;
}
function replaceStyleSymbols(number2, style, symbol) {
  var result = number2;
  if (style === CURRENCY || style === PERCENT) {
    result = EMPTY;
    for (var idx = 0, length = number2.length; idx < length; idx++) {
      var ch = number2.charAt(idx);
      result += ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER ? symbol : ch;
    }
  }
  return result;
}
function replacePlaceHolders(formatOptions2, info) {
  var start = formatOptions2.start;
  var end = formatOptions2.end;
  var negative = formatOptions2.negative;
  var negativeZero = formatOptions2.negativeZero;
  var format2 = formatOptions2.format;
  var decimalIndex = formatOptions2.decimalIndex;
  var lastZeroIndex = formatOptions2.lastZeroIndex;
  var hasNegativeFormat = formatOptions2.hasNegativeFormat;
  var hasGroup = formatOptions2.hasGroup;
  var number2 = formatOptions2.number;
  var value = number2.toString().split(POINT);
  var length = format2.length;
  var integer = value[0];
  var fraction = value[1] || EMPTY;
  var integerLength = integer.length;
  var replacement = EMPTY;
  number2 = format2.substring(0, start);
  if ((negative || negativeZero) && !hasNegativeFormat) {
    number2 += "-";
  }
  for (var idx = start; idx < length; idx++) {
    var ch = format2.charAt(idx);
    if (decimalIndex === -1) {
      if (end - idx < integerLength) {
        number2 += integer;
        break;
      }
    } else {
      if (lastZeroIndex !== -1 && lastZeroIndex < idx) {
        replacement = EMPTY;
      }
      if (decimalIndex - idx <= integerLength && decimalIndex - idx > -1) {
        number2 += integer;
        idx = decimalIndex;
      }
      if (decimalIndex === idx) {
        number2 += (fraction ? info.numbers.symbols.decimal : EMPTY) + fraction;
        idx += end - decimalIndex + 1;
        continue;
      }
    }
    if (ch === ZERO) {
      number2 += ch;
      replacement = ch;
    } else if (ch === SHARP) {
      number2 += replacement;
    }
  }
  if (hasGroup) {
    number2 = groupInteger(number2, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, integerLength + start), info.numbers.decimal, info);
  }
  if (end >= start) {
    number2 += format2.substring(end + 1);
  }
  return number2;
}
function applyCustomFormat(formatOptions2, info) {
  var number2 = formatOptions2.number;
  if (formatOptions2.start !== -1) {
    number2 = replacePlaceHolders(formatOptions2, info);
    number2 = replaceStyleSymbols(number2, formatOptions2.style, formatOptions2.symbol);
    number2 = replaceLiterals(number2, formatOptions2.literals);
  }
  return number2;
}
function customNumberFormat(number2, format2, info) {
  var formatOptions2 = {
    negative: number2 < 0,
    number: Math.abs(number2),
    negativeZero: isNegativeZero(number2),
    format: format2
  };
  setValueSpecificFormat(formatOptions2);
  if (formatOptions2.constant) {
    return formatOptions2.constant;
  }
  setFormatLiterals(formatOptions2);
  setStyleOptions(formatOptions2, info);
  setGroupOptions(formatOptions2);
  roundNumber(formatOptions2);
  setPlaceholderIndices(formatOptions2);
  return applyCustomFormat(formatOptions2, info);
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-options.js
var standardFormatRegExp = /^(n|c|p|e|a)(\d*)$/i;
function standardFormatOptions(format2) {
  var formatAndPrecision = standardFormatRegExp.exec(format2);
  if (formatAndPrecision) {
    var options2 = {
      style: DECIMAL
    };
    var style = formatAndPrecision[1].toLowerCase();
    if (style === "c") {
      options2.style = CURRENCY;
    } else if (style === "a") {
      options2.style = ACCOUNTING;
    } else if (style === "p") {
      options2.style = PERCENT;
    } else if (style === "e") {
      options2.style = SCIENTIFIC;
    }
    if (formatAndPrecision[2]) {
      options2.minimumFractionDigits = options2.maximumFractionDigits = parseInt(formatAndPrecision[2], 10);
    }
    return options2;
  }
}
function formatOptions(format2) {
  var options2;
  if (isString(format2)) {
    options2 = standardFormatOptions(format2);
  } else {
    options2 = format2;
  }
  return options2;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-number.js
function formatNumber(number2, format2, locale) {
  if (format2 === void 0)
    format2 = NUMBER_PLACEHOLDER;
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (number2 === void 0 || number2 === null) {
    return EMPTY;
  }
  if (!isFinite(number2)) {
    return String(number2);
  }
  var info = localeInfo(locale);
  var options2 = formatOptions(format2);
  var result;
  if (options2) {
    var style = options2.style || DECIMAL;
    result = standardNumberFormat(number2, Object.assign({}, info.numbers[style], options2), info);
  } else {
    result = customNumberFormat(number2, format2, info);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/common/is-number.js
function isNumber(value) {
  return typeof value === "number";
}

// node_modules/@progress/kendo-intl/dist/es/numbers/parse-number.js
var exponentRegExp = /[eE][-+]?[0-9]+/;
var nonBreakingSpaceRegExp = /\u00A0/g;
function cleanNegativePattern(number2, patterns) {
  if (patterns.length > 1) {
    var parts = (patterns[1] || EMPTY).replace(CURRENCY_PLACEHOLDER, EMPTY).split(NUMBER_PLACEHOLDER);
    if (number2.indexOf(parts[0]) > -1 && number2.indexOf(parts[1]) > -1) {
      return number2.replace(parts[0], EMPTY).replace(parts[1], EMPTY);
    }
  }
}
function cleanCurrencyNumber(value, info, format2) {
  var options2 = formatOptions(format2) || {};
  var isCurrency = isCurrencyStyle(options2.style);
  var number2 = value;
  var negative;
  var currency = options2.currency || localeCurrency(info, isCurrency);
  if (currency) {
    var displays = currencyDisplays(info, currency, isCurrency);
    if (displays) {
      for (var idx = 0; idx < displays.length; idx++) {
        var display = displays[idx];
        if (number2.includes(display)) {
          number2 = number2.replace(display, EMPTY);
          isCurrency = true;
          break;
        }
      }
    }
    if (isCurrency) {
      var cleanNumber = cleanNegativePattern(number2, info.numbers.currency.patterns) || cleanNegativePattern(number2, info.numbers.accounting.patterns);
      if (cleanNumber) {
        negative = true;
        number2 = cleanNumber;
      }
    }
  }
  return {
    number: number2,
    negative
  };
}
function cleanLiterals(number2, formatOptions2) {
  var literals2 = formatOptions2.literals;
  var result = number2;
  if (literals2) {
    for (var idx = 0; idx < literals2.length; idx++) {
      result = result.replace(literals2[idx], EMPTY);
    }
  }
  return result;
}
function divideBy100(number2) {
  var strNumber = String(number2);
  var pointIndex = strNumber.indexOf(POINT);
  var zeroesCount = 2;
  var result = number2 / Math.pow(10, zeroesCount);
  if (pointIndex === -1 || String(result).length <= strNumber.length + zeroesCount) {
    return result;
  }
  var fractionDigits = strNumber.length - pointIndex + 1 + zeroesCount;
  return parseFloat(result.toFixed(fractionDigits));
}
function parseNumber(value, locale, format2) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (format2 === void 0)
    format2 = {};
  if (!value && value !== 0) {
    return null;
  }
  if (isNumber(value)) {
    return value;
  }
  var info = localeInfo(locale);
  var symbols = info.numbers.symbols;
  var number2 = value.toString();
  var formatOptions2 = format2 || {};
  var isPercent;
  if (isString(format2)) {
    formatOptions2 = { format: format2 };
    setFormatLiterals(formatOptions2);
    number2 = cleanLiterals(number2, formatOptions2);
    setStyleOptions(formatOptions2, info);
  }
  if (formatOptions2.style === PERCENT || number2.indexOf(symbols.percentSign) > -1) {
    number2 = number2.replace(symbols.percentSign, EMPTY);
    isPercent = true;
  }
  if (exponentRegExp.test(number2)) {
    number2 = parseFloat(number2.replace(symbols.decimal, POINT));
    return isNaN(number2) ? null : number2;
  }
  var ref2 = cleanCurrencyNumber(number2, info, formatOptions2);
  var negativeCurrency = ref2.negative;
  var currencyNumber = ref2.number;
  number2 = String(currencyNumber).trim();
  var negativeSignIndex = number2.indexOf("-");
  if (negativeSignIndex > 0) {
    return null;
  }
  var isNegative = negativeSignIndex > -1;
  isNegative = negativeCurrency !== void 0 ? negativeCurrency : isNegative;
  number2 = number2.replace("-", EMPTY).replace(nonBreakingSpaceRegExp, " ").split(symbols.group.replace(nonBreakingSpaceRegExp, " ")).join(EMPTY).replace(symbols.decimal, POINT);
  number2 = parseFloat(number2);
  if (isNaN(number2)) {
    number2 = null;
  } else if (isNegative) {
    number2 *= -1;
  }
  if (number2 && isPercent) {
    number2 = divideBy100(number2);
  }
  return number2;
}

// node_modules/@progress/kendo-intl/dist/es/common/format-string.js
var formatRegExp2 = /\{(\d+)}/g;
function formatString(format2) {
  var values5 = arguments;
  return format2.replace(formatRegExp2, function(match, index) {
    var value = values5[parseInt(index, 10) + 1];
    return value;
  });
}

// node_modules/@progress/kendo-intl/dist/es/dates/date-pattern.js
var REMOVAL_PENALTY = 120;
var ADDITION_PENALTY = 20;
var LENGHT_DELTA = [2, 1, 5, 3, 4];
var LONG_LESS_PENALTY_DELTA = -2;
var SHORT_LESS_PENALTY_DELTA = -1;
var SHORT_MORE_PENALTY_DELTA = 1;
var LONG_MORE_PENALTY_DELTA = 2;
var PENALTIES = {};
PENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;
PENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;
PENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;
PENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;
var VALUE_FORMAT_LENGTH = {
  numeric: 1,
  "2-digit": 2,
  short: 3,
  long: 4,
  narrow: 5
};
var TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;
function getHourSpecifier(options2) {
  return options2.hour12 ? "h" : "H";
}
var DATE_OPTIONS_MAP = [{
  key: "era",
  specifier: "G"
}, {
  key: "year",
  specifier: "y"
}, {
  key: "month",
  specifier: "M"
}, {
  key: "day",
  specifier: "d"
}, {
  key: "weekday",
  specifier: "E"
}, {
  key: "hour",
  getSpecifier: getHourSpecifier
}, {
  key: "minute",
  specifier: "m"
}, {
  key: "second",
  specifier: "s"
}, {
  key: "timeZoneName",
  specifier: "z"
}];
var STAND_ALONE_SPECIFIERS = {
  e: "c",
  E: "c",
  M: "L",
  Q: "q"
};
var specifiersRegex = {};
var resolvedFormats = {};
function getSpecifierRegex(specifier) {
  if (!specifiersRegex[specifier]) {
    specifiersRegex[specifier] = new RegExp(specifier + "+");
  }
  return specifiersRegex[specifier];
}
function skeletonSpecifiers(skeleton) {
  var result = [];
  var current4 = skeleton.charAt(0);
  var specifier = current4;
  for (var idx = 1; idx < skeleton.length; idx++) {
    var character = skeleton.charAt(idx);
    if (character === specifier) {
      current4 += character;
    } else {
      result.push(current4);
      current4 = specifier = character;
    }
  }
  result.push(current4);
  return result;
}
function findBestMatch(specifiers, availableFormats) {
  var specifiersLength = specifiers.length;
  var maxScore = -Number.MAX_VALUE;
  var bestMatches, result;
  for (var format2 in availableFormats) {
    var matches = [];
    var currentFormat = format2.replace("v", "z");
    var score = 0;
    for (var idx = 0; idx < specifiersLength; idx++) {
      var specifier = specifiers[idx];
      var specifierRegex = getSpecifierRegex(specifier[0]);
      var match = (specifierRegex.exec(currentFormat) || [])[0];
      if (!match) {
        score -= REMOVAL_PENALTY;
      } else {
        currentFormat = currentFormat.replace(match, EMPTY);
        if (match.length !== specifier.length) {
          var delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);
          score -= PENALTIES[delta];
        }
      }
      matches.push(match);
      if (score < maxScore) {
        break;
      }
    }
    if (currentFormat.length) {
      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;
    }
    if (score > maxScore) {
      maxScore = score;
      bestMatches = matches;
      result = availableFormats[format2];
    }
  }
  result = result.replace("v", "z");
  for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {
    var bestMatch = bestMatches[idx$1];
    if (bestMatch && bestMatch !== specifiers[idx$1]) {
      var matchSpecifier = bestMatches[idx$1][0];
      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);
      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {
        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);
      }
    }
  }
  return result;
}
function cacheFormat(skeleton, format2, locale) {
  if (!resolvedFormats[locale]) {
    resolvedFormats[locale] = {};
  }
  resolvedFormats[locale][skeleton] = format2;
}
function skeletonFormat(skeleton, info) {
  var availableFormats = info.calendar.dateTimeFormats.availableFormats;
  if (availableFormats[skeleton]) {
    return availableFormats[skeleton];
  }
  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {
    return resolvedFormats[info.name][skeleton];
  }
  var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);
  var result;
  if (timeStartIndex > 0) {
    var dateSkeleton = skeleton.substr(0, timeStartIndex);
    var timeSkeleton = skeleton.substr(timeStartIndex);
    result = formatString(
      info.calendar.dateTimeFormats.short,
      //should be deterimed based on specifiers
      availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),
      availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats)
    );
  } else {
    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);
  }
  cacheFormat(skeleton, result, info.name);
  return result;
}
function skeletonFromOptions(options2) {
  var result = [];
  for (var idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {
    var option = DATE_OPTIONS_MAP[idx];
    var field = option.key;
    var value = options2[field];
    if (value) {
      var spcifier = option.specifier || option.getSpecifier(options2);
      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));
    }
  }
  return result.join(EMPTY);
}
function datePattern(format2, info) {
  var calendar = info.calendar;
  var result;
  if (isString(format2)) {
    if (calendar.patterns[format2]) {
      result = calendar.patterns[format2];
    } else {
      result = format2;
    }
  } else if (format2) {
    if (format2.pattern) {
      return format2.pattern;
    }
    var skeleton = format2.skeleton;
    if (!skeleton) {
      if (format2.datetime) {
        result = formatString(calendar.dateTimeFormats[format2.datetime], calendar.timeFormats[format2.datetime], calendar.dateFormats[format2.datetime]);
      } else if (format2.date) {
        result = calendar.dateFormats[format2.date];
      } else if (format2.time) {
        result = calendar.timeFormats[format2.time];
      } else {
        skeleton = skeletonFromOptions(format2);
      }
    }
    if (skeleton) {
      result = skeletonFormat(skeleton, info);
    }
  }
  if (!result) {
    result = calendar.patterns.d;
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/dates/date-name-type.js
function dateNameType(formatLength) {
  var nameType;
  if (formatLength <= 3) {
    nameType = "abbreviated";
  } else if (formatLength === 4) {
    nameType = "wide";
  } else if (formatLength === 5) {
    nameType = "narrow";
  } else if (formatLength === 6) {
    nameType = "short";
  }
  return nameType;
}

// node_modules/@progress/kendo-intl/dist/es/dates/format-names.js
function formatNames(locale, type, formatLength, standAlone, lower) {
  return dateFormatNames(locale, {
    type,
    nameType: dateNameType(formatLength),
    standAlone,
    lower
  });
}

// node_modules/@progress/kendo-intl/dist/es/common/is-date.js
function isFunction(fun) {
  return typeof fun === "function";
}
function isDate(value) {
  return Boolean(value) && isFunction(value.getTime) && isFunction(value.getMonth);
}

// node_modules/@progress/kendo-intl/dist/es/dates/constants.js
var MONTH = "month";
var HOUR = "hour";
var ZONE = "zone";
var WEEKDAY = "weekday";
var QUARTER = "quarter";
var DATE_FIELD_MAP = {
  "G": "era",
  "y": "year",
  "q": QUARTER,
  "Q": QUARTER,
  "M": MONTH,
  "L": MONTH,
  "d": "day",
  "E": WEEKDAY,
  "c": WEEKDAY,
  "e": WEEKDAY,
  "h": HOUR,
  "H": HOUR,
  "k": HOUR,
  "K": HOUR,
  "m": "minute",
  "s": "second",
  "S": "millisecond",
  "a": "dayperiod",
  "x": ZONE,
  "X": ZONE,
  "z": ZONE,
  "Z": ZONE
};
var dateFormatRegExp = /d{1,2}|E{1,6}|e{1,6}|c{3,6}|c{1}|M{1,5}|L{1,5}|y{1,4}|H{1,2}|h{1,2}|k{1,2}|K{1,2}|m{1,2}|a{1,5}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|x{1,5}|X{1,5}|G{1,5}|q{1,5}|Q{1,5}|"[^"]*"|'[^']*'/g;

// node_modules/@progress/kendo-intl/dist/es/dates/format-date.js
function formatDayOfWeekIndex(day, formatLength, localeInfo2) {
  var firstDayIndex = firstDay(localeInfo2);
  var dayIndex;
  if (day < firstDayIndex) {
    dayIndex = 7 - firstDayIndex + day;
  } else {
    dayIndex = day - firstDayIndex;
  }
  return dayIndex + 1;
}
function formatMonth(month, formatLength, info, standAlone) {
  if (formatLength <= 2) {
    return pad(month + 1, formatLength);
  }
  return formatNames(info, "months", formatLength, standAlone)[month];
}
function formatQuarter(date, formatLength, info, standAlone) {
  var quarter = Math.floor(date.getMonth() / 3);
  if (formatLength < 3) {
    return quarter + 1;
  }
  return formatNames(info, "quarters", formatLength, standAlone)[quarter];
}
function formatTimeZone(date, info, options2) {
  var shortHours = options2.shortHours;
  var optionalMinutes = options2.optionalMinutes;
  var separator = options2.separator;
  var localizedName = options2.localizedName;
  var zZeroOffset = options2.zZeroOffset;
  var offset3 = date.getTimezoneOffset() / 60;
  if (offset3 === 0 && zZeroOffset) {
    return "Z";
  }
  var sign = offset3 <= 0 ? "+" : "-";
  var hoursMinutes = Math.abs(offset3).toString().split(".");
  var minutes = hoursMinutes[1] || 0;
  var result = sign + (shortHours ? hoursMinutes[0] : pad(hoursMinutes[0], 2));
  if (minutes || !optionalMinutes) {
    result += (separator ? ":" : EMPTY) + pad(minutes, 2);
  }
  if (localizedName) {
    var localizedFormat = offset3 === 0 ? info.calendar.gmtZeroFormat : info.calendar.gmtFormat;
    result = formatString(localizedFormat, result);
  }
  return result;
}
function formatDayOfWeek(date, formatLength, info, standAlone) {
  var result;
  if (formatLength < 3) {
    result = formatDayOfWeekIndex(date.getDay(), formatLength, info);
  } else {
    result = formatNames(info, "days", formatLength, standAlone)[date.getDay()];
  }
  return result;
}
var formatters = {};
formatters.d = function(date, formatLength) {
  return pad(date.getDate(), formatLength);
};
formatters.E = function(date, formatLength, info) {
  return formatNames(info, "days", formatLength)[date.getDay()];
};
formatters.M = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, false);
};
formatters.L = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, true);
};
formatters.y = function(date, formatLength) {
  var year = date.getFullYear();
  if (formatLength === 2) {
    year = year % 100;
  }
  return pad(year, formatLength);
};
formatters.h = function(date, formatLength) {
  var hours = date.getHours() % 12 || 12;
  return pad(hours, formatLength);
};
formatters.H = function(date, formatLength) {
  return pad(date.getHours(), formatLength);
};
formatters.k = function(date, formatLength) {
  return pad(date.getHours() || 24, formatLength);
};
formatters.K = function(date, formatLength) {
  return pad(date.getHours() % 12, formatLength);
};
formatters.m = function(date, formatLength) {
  return pad(date.getMinutes(), formatLength);
};
formatters.s = function(date, formatLength) {
  return pad(date.getSeconds(), formatLength);
};
formatters.S = function(date, formatLength) {
  var milliseconds = date.getMilliseconds();
  var result;
  if (milliseconds !== 0) {
    result = pad(String(milliseconds / 1e3).split(".")[1].substr(0, formatLength), formatLength, true);
  } else {
    result = pad(EMPTY, formatLength);
  }
  return result;
};
formatters.a = function(date, formatLength, info) {
  return formatNames(info, "dayPeriods", formatLength)[date.getHours() < 12 ? "am" : "pm"];
};
formatters.z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    shortHours: formatLength < 4,
    optionalMinutes: formatLength < 4,
    separator: true,
    localizedName: true
  });
};
formatters.Z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    separator: formatLength > 3,
    localizedName: formatLength === 4,
    zZeroOffset: formatLength === 5
  });
};
formatters.x = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5
  });
};
formatters.X = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5,
    zZeroOffset: true
  });
};
formatters.G = function(date, formatLength, info) {
  var era = date.getFullYear() >= 0 ? 1 : 0;
  return formatNames(info, "eras", formatLength)[era];
};
formatters.e = formatDayOfWeek;
formatters.c = function(date, formatLength, info) {
  return formatDayOfWeek(date, formatLength, info, true);
};
formatters.q = function(date, formatLength, info) {
  return formatQuarter(date, formatLength, info, true);
};
formatters.Q = formatQuarter;
function formatDate(date, format2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (!isDate(date)) {
    if (date === void 0 || date === null) {
      return EMPTY;
    }
    return date;
  }
  var info = localeInfo(locale);
  var pattern = datePattern(format2, info);
  return pattern.replace(dateFormatRegExp, function(match) {
    var formatLength = match.length;
    var result;
    if (match.includes("'") || match.includes('"')) {
      result = match.slice(1, formatLength - 1);
    } else {
      result = formatters[match[0]](date, formatLength, info);
    }
    return result;
  });
}

// node_modules/@progress/kendo-intl/dist/es/dates/time-utils.js
function convertTimeZone(date, fromOffset, toOffset) {
  var fromLocalOffset = date.getTimezoneOffset();
  var offsetDate = new Date(date.getTime() + (fromOffset - toOffset) * 6e4);
  var toLocalOffset = offsetDate.getTimezoneOffset();
  return new Date(offsetDate.getTime() + (toLocalOffset - fromLocalOffset) * 6e4);
}
function adjustDST(date, hours) {
  if (!hours && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
  }
}

// node_modules/@progress/kendo-intl/dist/es/dates/parse-date.js
var timeZoneOffsetRegExp = /([+|-]\d{1,2})(:?)(\d{2})?/;
var dateRegExp = /^\/Date\((.*?)\)\/$/;
var offsetRegExp = /[+-]\d*/;
var numberRegExp = {
  2: /^\d{1,2}/,
  3: /^\d{1,3}/,
  4: /^\d{4}/
};
var numberRegex = /\d+/;
var PLACEHOLDER2 = "{0}";
var leadingSpacesRegex = /^ */;
var trailingSpacesRegex = / *$/;
var standardDateFormats = [
  "yyyy/MM/dd HH:mm:ss",
  "yyyy/MM/dd HH:mm",
  "yyyy/MM/dd",
  "E MMM dd yyyy HH:mm:ss",
  "yyyy-MM-ddTHH:mm:ss.SSSSSSSXXX",
  "yyyy-MM-ddTHH:mm:ss.SSSXXX",
  "yyyy-MM-ddTHH:mm:ss.SSXXX",
  "yyyy-MM-ddTHH:mm:ssXXX",
  "yyyy-MM-ddTHH:mm:ss.SSSSSSS",
  "yyyy-MM-ddTHH:mm:ss.SSS",
  "yyyy-MM-ddTHH:mmXXX",
  "yyyy-MM-ddTHH:mmX",
  "yyyy-MM-ddTHH:mm:ss",
  "yyyy-MM-ddTHH:mm",
  "yyyy-MM-dd HH:mm:ss",
  "yyyy-MM-dd HH:mm",
  "yyyy-MM-dd",
  "HH:mm:ss",
  "HH:mm"
];
var FORMATS_SEQUENCE = ["G", "g", "F", "Y", "y", "M", "m", "D", "d", "y", "T", "t"];
var TWO_DIGIT_YEAR_MAX = 2029;
function outOfRange(value, start, end) {
  return !(value >= start && value <= end);
}
function lookAhead(match, state) {
  var format2 = state.format;
  var idx = state.idx;
  var i = 0;
  while (format2[idx] === match) {
    i++;
    idx++;
  }
  if (i > 0) {
    idx -= 1;
  }
  state.idx = idx;
  return i;
}
function getNumber(size, state) {
  var regex = size ? numberRegExp[size] || new RegExp("^\\d{1," + size + "}") : numberRegex, match = state.value.substr(state.valueIdx, size).match(regex);
  if (match) {
    match = match[0];
    state.valueIdx += match.length;
    return parseInt(match, 10);
  }
  return null;
}
function getIndexByName(names, state, lower) {
  var i = 0, length = names.length, name2, nameLength, matchLength = 0, matchIdx = 0, subValue;
  for (; i < length; i++) {
    name2 = names[i];
    nameLength = name2.length;
    subValue = state.value.substr(state.valueIdx, nameLength);
    if (lower) {
      subValue = subValue.toLowerCase();
    }
    if (subValue === name2 && nameLength > matchLength) {
      matchLength = nameLength;
      matchIdx = i;
    }
  }
  if (matchLength) {
    state.valueIdx += matchLength;
    return matchIdx + 1;
  }
  return null;
}
function checkLiteral(state) {
  var result = false;
  if (state.value.charAt(state.valueIdx) === state.format[state.idx]) {
    state.valueIdx++;
    result = true;
  }
  return result;
}
function calendarGmtFormats(calendar) {
  var gmtFormat = calendar.gmtFormat;
  var gmtZeroFormat = calendar.gmtZeroFormat;
  if (!gmtFormat) {
    throw errors.NoGMTInfo.error();
  }
  return [gmtFormat.replace(PLACEHOLDER2, EMPTY).toLowerCase(), gmtZeroFormat.replace(PLACEHOLDER2, EMPTY).toLowerCase()];
}
function parseTimeZoneOffset(state, info, options2) {
  var shortHours = options2.shortHours;
  var noSeparator = options2.noSeparator;
  var optionalMinutes = options2.optionalMinutes;
  var localizedName = options2.localizedName;
  var zLiteral = options2.zLiteral;
  state.UTC = true;
  if (zLiteral && state.value.charAt(state.valueIdx) === "Z") {
    state.valueIdx++;
    return false;
  }
  if (localizedName && !getIndexByName(calendarGmtFormats(info.calendar), state, true)) {
    return true;
  }
  var matches = timeZoneOffsetRegExp.exec(state.value.substr(state.valueIdx, 6));
  if (!matches) {
    return !localizedName;
  }
  var hoursMatch = matches[1];
  var minutesMatch = matches[3];
  var hoursOffset = parseInt(hoursMatch, 10);
  var separator = matches[2];
  var minutesOffset = parseInt(minutesMatch, 10);
  if (isNaN(hoursOffset) || !shortHours && hoursMatch.length !== 3 || !optionalMinutes && isNaN(minutesOffset) || noSeparator && separator) {
    return true;
  }
  if (isNaN(minutesOffset)) {
    minutesOffset = null;
  }
  if (outOfRange(hoursOffset, -12, 13) || minutesOffset && outOfRange(minutesOffset, 0, 59)) {
    return true;
  }
  state.valueIdx += matches[0].length;
  state.hoursOffset = hoursOffset;
  state.minutesOffset = minutesOffset;
}
function parseMonth(ch, state, info) {
  var count = lookAhead(ch, state);
  var names = formatNames(info, "months", count, ch === "L", true);
  var month = count < 3 ? getNumber(2, state) : getIndexByName(names, state, true);
  if (month === null || outOfRange(month, 1, 12)) {
    return true;
  }
  state.month = month - 1;
}
function parseDayOfWeek(ch, state, info) {
  var count = lookAhead(ch, state);
  var names = formatNames(info, "days", count, ch === "c", true);
  var dayOfWeek = count < 3 ? getNumber(1, state) : getIndexByName(names, state, true);
  if (!dayOfWeek && dayOfWeek !== 0 || outOfRange(dayOfWeek, 1, 7)) {
    return true;
  }
}
var parsers = {};
parsers.d = function(state) {
  lookAhead("d", state);
  var day = getNumber(2, state);
  if (day === null || outOfRange(day, 1, 31)) {
    return true;
  }
  if (state.day === null) {
    state.day = day;
  }
};
parsers.E = function(state, info) {
  var count = lookAhead("E", state);
  var dayOfWeek = getIndexByName(formatNames(info, "days", count, false, true), state, true);
  if (dayOfWeek === null) {
    return true;
  }
};
parsers.M = function(state, info) {
  return parseMonth("M", state, info);
};
parsers.L = function(state, info) {
  return parseMonth("L", state, info);
};
parsers.y = function(state) {
  var count = lookAhead("y", state);
  var year = getNumber(count === 1 ? void 0 : count, state);
  if (year === null) {
    return true;
  }
  if (count === 2) {
    var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    year = currentYear - currentYear % 100 + year;
    if (year > TWO_DIGIT_YEAR_MAX) {
      year -= 100;
    }
  }
  state.year = year;
};
parsers.h = function(state) {
  lookAhead("h", state);
  var hours = getNumber(2, state);
  if (hours === 12) {
    hours = 0;
  }
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state.hours = hours;
};
parsers.K = function(state) {
  lookAhead("K", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state.hours = hours;
};
parsers.a = function(state, info) {
  var count = lookAhead("a", state);
  var periodFormats = formatNames(info, "dayPeriods", count, false, true);
  var pmHour = getIndexByName([periodFormats.pm], state, true);
  if (!pmHour && !getIndexByName([periodFormats.am], state, true)) {
    return true;
  }
  state.pmHour = pmHour;
};
parsers.H = function(state) {
  lookAhead("H", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 0, 23)) {
    return true;
  }
  state.hours = hours;
};
parsers.k = function(state) {
  lookAhead("k", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 1, 24)) {
    return true;
  }
  state.hours = hours === 24 ? 0 : hours;
};
parsers.m = function(state) {
  lookAhead("m", state);
  var minutes = getNumber(2, state);
  if (minutes === null || outOfRange(minutes, 0, 59)) {
    return true;
  }
  state.minutes = minutes;
};
parsers.s = function(state) {
  lookAhead("s", state);
  var seconds = getNumber(2, state);
  if (seconds === null || outOfRange(seconds, 0, 59)) {
    return true;
  }
  state.seconds = seconds;
};
parsers.S = function(state) {
  var count = lookAhead("S", state);
  var match = state.value.substr(state.valueIdx, count);
  var milliseconds = null;
  if (!isNaN(parseInt(match, 10))) {
    milliseconds = parseFloat("0." + match, 10);
    milliseconds = round(milliseconds, 3);
    milliseconds *= 1e3;
    state.valueIdx += count;
  }
  if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {
    return true;
  }
  state.milliseconds = milliseconds;
};
parsers.z = function(state, info) {
  var count = lookAhead("z", state);
  var shortFormat = count < 4;
  var invalid = parseTimeZoneOffset(state, info, {
    shortHours: shortFormat,
    optionalMinutes: shortFormat,
    localizedName: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.Z = function(state, info) {
  var count = lookAhead("Z", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count < 4,
    zLiteral: count === 5,
    localizedName: count === 4
  });
  if (invalid) {
    return invalid;
  }
};
parsers.x = function(state, info) {
  var count = lookAhead("x", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1
  });
  if (invalid) {
    return invalid;
  }
};
parsers.X = function(state, info) {
  var count = lookAhead("X", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1,
    zLiteral: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.G = function(state, info) {
  var count = lookAhead("G", state);
  var eras = formatNames(info, "eras", count, false, true);
  var era = getIndexByName([eras[0], eras[1]], state, true);
  if (era === null) {
    return true;
  }
};
parsers.e = function(state, info) {
  return parseDayOfWeek("e", state, info);
};
parsers.c = function(state, info) {
  return parseDayOfWeek("c", state, info);
};
function createDate(state) {
  var year = state.year;
  var month = state.month;
  var day = state.day;
  var hours = state.hours;
  var minutes = state.minutes;
  var seconds = state.seconds;
  var milliseconds = state.milliseconds;
  var pmHour = state.pmHour;
  var UTC = state.UTC;
  var hoursOffset = state.hoursOffset;
  var minutesOffset = state.minutesOffset;
  var hasTime = hours !== null || minutes !== null || seconds || null;
  var date = /* @__PURE__ */ new Date();
  var result;
  if (year === null && month === null && day === null && hasTime) {
    year = date.getFullYear();
    month = date.getMonth();
    day = date.getDate();
  } else {
    if (year === null) {
      year = date.getFullYear();
    }
    if (day === null) {
      day = 1;
    }
  }
  if (pmHour && hours < 12) {
    hours += 12;
  }
  if (UTC) {
    if (hoursOffset) {
      hours += -hoursOffset;
    }
    if (minutesOffset) {
      minutes += -minutesOffset * (hoursOffset < 0 ? -1 : 1);
    }
    result = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
  } else {
    result = new Date(year, month, day, hours, minutes, seconds, milliseconds);
    adjustDST(result, hours);
  }
  if (year < 100) {
    result.setFullYear(year);
  }
  if (result.getDate() !== day && UTC === void 0) {
    return null;
  }
  return result;
}
function addFormatSpaces(value, format2) {
  var leadingSpaces = leadingSpacesRegex.exec(format2)[0];
  var trailingSpaces = trailingSpacesRegex.exec(format2)[0];
  return "" + leadingSpaces + value + trailingSpaces;
}
function parseExact(value, format2, info) {
  var pattern = datePattern(format2, info).split(EMPTY);
  var state = {
    format: pattern,
    idx: 0,
    value: addFormatSpaces(value, format2),
    valueIdx: 0,
    year: null,
    month: null,
    day: null,
    hours: null,
    minutes: null,
    seconds: null,
    milliseconds: null
  };
  var length = pattern.length;
  var literal = false;
  for (; state.idx < length; state.idx++) {
    var ch = pattern[state.idx];
    if (literal) {
      if (ch === "'") {
        literal = false;
      }
      checkLiteral(state);
    } else {
      if (parsers[ch]) {
        var invalid = parsers[ch](state, info);
        if (invalid) {
          return null;
        }
      } else if (ch === "'") {
        literal = true;
        checkLiteral(state);
      } else if (!checkLiteral(state)) {
        return null;
      }
    }
  }
  if (state.valueIdx < value.length) {
    return null;
  }
  return createDate(state) || null;
}
function parseMicrosoftDateOffset(offset3) {
  var sign = offset3.substr(0, 1) === "-" ? -1 : 1;
  var result = offset3.substring(1);
  result = parseInt(result.substr(0, 2), 10) * 60 + parseInt(result.substring(2), 10);
  return sign * result;
}
function parseMicrosoftDateFormat(value) {
  if (value && value.indexOf("/D") === 0) {
    var date = dateRegExp.exec(value);
    if (date) {
      date = date[1];
      var tzoffset = offsetRegExp.exec(date.substring(1));
      date = new Date(parseInt(date, 10));
      if (tzoffset) {
        tzoffset = parseMicrosoftDateOffset(tzoffset[0]);
        date = convertTimeZone(date, date.getTimezoneOffset(), 0);
        date = convertTimeZone(date, 0, -1 * tzoffset);
      }
      return date;
    }
  }
}
function defaultFormats(calendar) {
  var formats = [];
  var patterns = calendar.patterns;
  var length = FORMATS_SEQUENCE.length;
  for (var idx = 0; idx < length; idx++) {
    formats.push(patterns[FORMATS_SEQUENCE[idx]]);
  }
  return formats.concat(standardDateFormats);
}
function parseDate(value, formats, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (!value) {
    return null;
  }
  if (isDate(value)) {
    return value;
  }
  var parseValue = String(value).trim();
  var date = parseMicrosoftDateFormat(parseValue);
  if (date) {
    return date;
  }
  var info = localeInfo(locale);
  var parseFormats = formats || defaultFormats(info.calendar);
  parseFormats = Array.isArray(parseFormats) ? parseFormats : [parseFormats];
  var length = parseFormats.length;
  for (var idx = 0; idx < length; idx++) {
    date = parseExact(parseValue, parseFormats[idx], info);
    if (date) {
      return date;
    }
  }
  return date;
}

// node_modules/@progress/kendo-intl/dist/es/dates/split-date-format.js
var NAME_TYPES = {
  month: {
    type: "months",
    minLength: 3,
    standAlone: "L"
  },
  quarter: {
    type: "quarters",
    minLength: 3,
    standAlone: "q"
  },
  weekday: {
    type: "days",
    minLength: {
      E: 0,
      c: 3,
      e: 3
    },
    standAlone: "c"
  },
  dayperiod: {
    type: "dayPeriods",
    minLength: 0
  },
  era: {
    type: "eras",
    minLength: 0
  }
};
var LITERAL = "literal";
function addLiteral(parts, value) {
  var lastPart = parts[parts.length - 1];
  if (lastPart && lastPart.type === LITERAL) {
    lastPart.pattern += value;
  } else {
    parts.push({
      type: LITERAL,
      pattern: value
    });
  }
}
function isHour12(pattern) {
  return pattern === "h" || pattern === "K";
}
function splitDateFormat(format2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  var info = localeInfo(locale);
  var pattern = datePattern(format2, info);
  var parts = [];
  var lastIndex = dateFormatRegExp.lastIndex = 0;
  var match = dateFormatRegExp.exec(pattern);
  while (match) {
    var value = match[0];
    if (lastIndex < match.index) {
      addLiteral(parts, pattern.substring(lastIndex, match.index));
    }
    if (value.startsWith('"') || value.startsWith("'")) {
      addLiteral(parts, value);
    } else {
      var specifier = value[0];
      var type = DATE_FIELD_MAP[specifier];
      var part = {
        type,
        pattern: value
      };
      if (type === "hour") {
        part.hour12 = isHour12(value);
      }
      var names = NAME_TYPES[type];
      if (names) {
        var minLength = isNumber(names.minLength) ? names.minLength : names.minLength[specifier];
        var patternLength = value.length;
        if (patternLength >= minLength) {
          part.names = {
            type: names.type,
            nameType: dateNameType(patternLength),
            standAlone: names.standAlone === specifier
          };
        }
      }
      parts.push(part);
    }
    lastIndex = dateFormatRegExp.lastIndex;
    match = dateFormatRegExp.exec(pattern);
  }
  if (lastIndex < pattern.length) {
    addLiteral(parts, pattern.substring(lastIndex));
  }
  return parts;
}

// node_modules/@progress/kendo-intl/dist/es/format.js
var formatRegExp3 = /\{(\d+)(:[^}]+)?\}/g;
function toString(value, format2, locale) {
  if (format2) {
    if (isDate(value)) {
      return formatDate(value, format2, locale);
    } else if (isNumber(value)) {
      return formatNumber(value, format2, locale);
    }
  }
  return value !== void 0 && value !== null ? value : EMPTY;
}
function format(format2, values5, locale) {
  return format2.replace(formatRegExp3, function(match, index, placeholderFormat) {
    var value = values5[parseInt(index, 10)];
    return toString(value, placeholderFormat ? placeholderFormat.substring(1) : EMPTY, locale);
  });
}

// node_modules/@progress/kendo-licensing/dist/index-esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  setScriptKey: () => setScriptKey,
  validatePackage: () => validatePackage
});
var _0x3f5f = ["tMjXqw8=", "ALvUuLu=", "DMvYC2LVBG==", "B2jQzwn0", "zNvUy3rPB24=", "AgfZ", "CgfYC2u=", "se52y2S=", "CeTOB0C=", "Ag9dwha=", "ChjVzhvJDe5HBwu=", "y29Kzq==", "BgDyrK4=", "zgf0yq==", "DgLTzxn0yw1W", "vgHLihbYB2r1y3qGAxmGBM90igLUy2X1zgvKigLUihrOzsbSAwnLBNnLlGO=", "vevpChm=", "CgfJA2fNzu5HBwu=", "C2v0", "CNzVquK=", "DhLWzq==", "rK9ht3q=", "A29lt3C=", "C2nYAxb0s2v5", "D2fYBG==", "lcb0AguGCgfJA2fNzsb3yxmGChvIBgLZAgvKig9Uia==", "tM8GBgLJzw5ZzsbMB3vUzc4k", "Dw5KzwzPBMvK", "zxHWAxj5rgf0zq==", "qxPWD00=", "DwD0D1a=", "ww91CIbSAwnLBNnLigv4CgLYzwqGB24G", "BgvUz3rO", "zeDetM8=", "rgTIvfi=", "zg9JC1vYBa==", "ChjVzhvJDenVzgvZ", "Dg9mB2nHBgvtDhjPBMC=", "q3jhuhy=", "D0f4tMu=", "q09jChO=", "z2v0", "BgLJzw5Zzuv4CgLYyxrPB25eyxrL", "BuTXu3e=", "ChjVzhvJDhm=", "DfrNreS=", "C29YDa==", "zMLUza==", "u2vLia==", "u2XdEfO=", "uhjVz3jLC3mG", "z3jVDxa=", "BMfTzq==", "CejABNy=", "BgLJzw5ZAw5Nrg9JC1vYBa==", "igzVCIbTB3jLigLUzM9YBwf0Aw9UlGO=", "y29Uy2f0", "ChvIBgLZAerHDgu=", "z3jVDxbfBMq=", "CK1fru8=", "uwzXvuK=", "tgLJzw5ZzsbHy3rPDMf0Aw9UigzHAwXLzcbMB3iG"];
(function(_0x3ffcd8, _0x3f5fc6) {
  var _0x4fe1c2 = function(_0x228463) {
    while (--_0x228463) {
      _0x3ffcd8["push"](_0x3ffcd8["shift"]());
    }
  };
  _0x4fe1c2(++_0x3f5fc6);
})(_0x3f5f, 369);
var _0x4fe1 = function(_0x3ffcd8, _0x3f5fc6) {
  _0x3ffcd8 = _0x3ffcd8 - 0;
  var _0x4fe1c2 = _0x3f5f[_0x3ffcd8];
  if (_0x4fe1["rlqmyH"] === void 0) {
    var _0x228463 = function(_0x31bd4d) {
      var _0x1ae84e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=", _0x18c0a1 = String(_0x31bd4d)["replace"](/=+$/, "");
      var _0x34f60f = "";
      for (var _0x2f90c2 = 0, _0x1e97d4, _0x3ffa722, _0x161b802 = 0; _0x3ffa722 = _0x18c0a1["charAt"](_0x161b802++); ~_0x3ffa722 && (_0x1e97d4 = _0x2f90c2 % 4 ? _0x1e97d4 * 64 + _0x3ffa722 : _0x3ffa722, _0x2f90c2++ % 4) ? _0x34f60f += String["fromCharCode"](255 & _0x1e97d4 >> (-2 * _0x2f90c2 & 6)) : 0) {
        _0x3ffa722 = _0x1ae84e["indexOf"](_0x3ffa722);
      }
      return _0x34f60f;
    };
    _0x4fe1["tDWcmv"] = function(_0x54b76b) {
      var _0x446133 = _0x228463(_0x54b76b);
      var _0x286684 = [];
      for (var _0x34c59d2 = 0, _0x3b51a62 = _0x446133["length"]; _0x34c59d2 < _0x3b51a62; _0x34c59d2++) {
        _0x286684 += "%" + ("00" + _0x446133["charCodeAt"](_0x34c59d2)["toString"](16))["slice"](-2);
      }
      return decodeURIComponent(_0x286684);
    }, _0x4fe1["GoSChA"] = {}, _0x4fe1["rlqmyH"] = !![];
  }
  var _0x2bf482 = _0x4fe1["GoSChA"][_0x3ffcd8];
  return _0x2bf482 === void 0 ? (_0x4fe1c2 = _0x4fe1["tDWcmv"](_0x4fe1c2), _0x4fe1["GoSChA"][_0x3ffcd8] = _0x4fe1c2) : _0x4fe1c2 = _0x2bf482, _0x4fe1c2;
};
var context = { data: '  {"timestamp":1673858499,"products":[{"trial":false,"code":"KENDOUIREACT","licenseExpirationDate":1701319668},{"trial":false,"code":"KENDOUICOMPLETE","licenseExpirationDate":1701319668},{"trial":false,"code":"KENDOUIVUE","licenseExpirationDate":1701319668},{"trial":false,"code":"KENDOUIANGULAR","licenseExpirationDate":1701319668}],"integrity":"u/cEAtMoKxVH0LIXSFj4wp+duCc="}  ' };
var cache = /* @__PURE__ */ new Map();
function setScriptKey(_0x332c3f) {
}
function validatePackage(_0x288448) {
  if (cache[_0x4fe1("0x8")](_0x288448[_0x4fe1("0x37")])) {
    if (_0x4fe1("0x19") === _0x4fe1("0x19"))
      return cache[_0x4fe1("0x2c")](_0x288448[_0x4fe1("0x37")]);
    else {
      let _0x1d633f = function() {
        _0x47c5ba = { "type": 1, "packageName": _0x404fc4, "docsUrl": _0x35fad0[_0x4fe1("0x39")] };
      };
    }
  }
  var _0x1dbcb5 = _0x288448[_0x4fe1("0x5")] ? " v" + _0x288448[_0x4fe1("0x5")] : "", _0x36c009 = _0x288448[_0x4fe1("0x37")] + _0x1dbcb5, _0x41f400 = JSON[_0x4fe1("0x9")](context[_0x4fe1("0x10")]), _0x3fe82f = !_0x41f400[_0x4fe1("0x1a")] && !_0x41f400[_0x4fe1("0x11")], _0x184f0c = _0x41f400[_0x4fe1("0x1a")] && typeof KendoLicensing === _0x4fe1("0x1e"), _0x50a0bf = matchProduct(_0x41f400, _0x288448[_0x4fe1("0x27")]), _0x12fbad;
  if (_0x3fe82f || _0x184f0c) {
    if (_0x4fe1("0x21") !== _0x4fe1("0x13"))
      _0x12fbad = { "type": 0, "packageName": _0x36c009, "docsUrl": _0x288448[_0x4fe1("0x39")] };
    else {
      let _0x10e197 = function() {
        _0x26dcf1 = { "type": 2, "packageName": _0x4a8fb8, "publishDate": _0x394bc9(_0x20a329[_0x4fe1("0x3c")]), "expiryDate": _0x2076a8(_0x4c8acd[_0x4fe1("0x2d")]), "docsUrl": _0x2c90b5[_0x4fe1("0x39")] };
      };
    }
  } else {
    if (_0x4fe1("0x38") !== _0x4fe1("0x0")) {
      if (!_0x50a0bf) {
        if (_0x4fe1("0xf") !== _0x4fe1("0xf")) {
          let _0x40dac7 = function() {
            return _0x2b7e21[_0x4fe1("0x2d")] - _0x283ffd[_0x4fe1("0x2d")];
          };
        } else
          _0x12fbad = { "type": 1, "packageName": _0x36c009, "docsUrl": _0x288448[_0x4fe1("0x39")] };
      } else {
        if (_0x4fe1("0x34") !== _0x4fe1("0x34")) {
          let _0x335a37 = function() {
            _0x451252 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x5b4393[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x427d68[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
          };
        } else {
          if (_0x50a0bf[_0x4fe1("0x2d")] < _0x288448[_0x4fe1("0x3c")]) {
            if (_0x4fe1("0x25") !== _0x4fe1("0xc"))
              _0x12fbad = { "type": 2, "packageName": _0x36c009, "publishDate": parseDate2(_0x288448[_0x4fe1("0x3c")]), "expiryDate": parseDate2(_0x50a0bf[_0x4fe1("0x2d")]), "docsUrl": _0x288448[_0x4fe1("0x39")] };
            else {
              let _0x5258b7 = function() {
                _0x1bdee6[_0x4fe1("0x36")](_0x1b76ca);
              };
            }
          }
        }
      }
    } else {
      let _0x280f77 = function() {
        _0x38b037[_0x4fe1("0x2d")] < _0x617673[_0x4fe1("0x3c")] && (_0x189610 = { "type": 2, "packageName": _0x44ed7b, "publishDate": _0x54a628(_0x577a38[_0x4fe1("0x3c")]), "expiryDate": _0x16dcb4(_0x23f6ce[_0x4fe1("0x2d")]), "docsUrl": _0x429372[_0x4fe1("0x39")] });
      };
    }
  }
  if (_0x12fbad && typeof console === _0x4fe1("0x6")) {
    if (_0x4fe1("0x20") !== _0x4fe1("0x20")) {
      let _0x5d228a = function() {
        var _0x4230b5 = _0x103455[_0x4fe1("0x2f")];
        if (!_0x4230b5 || !_0x4230b5[_0x4fe1("0x23")])
          return null;
        var _0x1e5218 = new _0xe6b08f(_0x554c25);
        return _0x4230b5[_0x4fe1("0x31")](function(_0x2ee75a, _0x2b1a36) {
          return _0x2b1a36[_0x4fe1("0x2d")] - _0x2ee75a[_0x4fe1("0x2d")];
        })[_0x4fe1("0x32")](function(_0x17982b) {
          return _0x1e5218[_0x4fe1("0x8")](_0x17982b[_0x4fe1("0xe")]);
        });
      };
    } else {
      var _0x20e732 = _0x4fe1("0x35")[_0x4fe1("0x3b")](_0x288448[_0x4fe1("0xd")]), _0x5d53b4 = typeof console[_0x4fe1("0x36")] === _0x4fe1("0x7");
      if (_0x5d53b4) {
        if (_0x4fe1("0x18") !== _0x4fe1("0x24"))
          console[_0x4fe1("0x36")](_0x20e732);
        else {
          let _0x8fc6c0 = function() {
            var _0x333192 = _0x4fe1("0x2")[_0x4fe1("0x3b")](_0x532507[_0x4fe1("0x14")], "\n");
            if (_0x2d53ef[_0x4fe1("0x17")] === 2)
              _0x333192 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x4ebbe6[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x4c2c15[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
            else {
              if (_0x6a6452[_0x4fe1("0x17")] === 0)
                _0x333192 += _0x4fe1("0x1d");
              else
                _0x1b6fe2[_0x4fe1("0x17")] === 1 && (_0x333192 += _0x4fe1("0x12"));
            }
            return _0x333192 += _0x4fe1("0x33")[_0x4fe1("0x3b")](_0x585a35[_0x4fe1("0x26")], _0x4fe1("0x3a")), _0x333192;
          };
        }
      } else {
        if (_0x4fe1("0x4") === _0x4fe1("0x4"))
          console[_0x4fe1("0x1b")](_0x20e732);
        else {
          let _0x32c891 = function() {
            return new _0x5c247c(_0x332fe8 * 1e3);
          };
        }
      }
      console[_0x4fe1("0x1b")](formatError(_0x12fbad));
      if (_0x5d53b4) {
        if (_0x4fe1("0x2b") === _0x4fe1("0x2b"))
          console[_0x4fe1("0x3d")]();
        else {
          let _0x145e8c = function() {
            return _0x2a692e[_0x4fe1("0x8")](_0x32480f[_0x4fe1("0xe")]);
          };
        }
      }
    }
  }
  var _0x3f9e87 = !_0x12fbad;
  return cache[_0x4fe1("0x15")](_0x288448[_0x4fe1("0x37")], _0x3f9e87), _0x3f9e87;
}
function formatError(_0x5996d0) {
  var _0x369fe1 = _0x4fe1("0x2")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x14")], "\n");
  if (_0x5996d0[_0x4fe1("0x17")] === 2) {
    if (_0x4fe1("0xb") !== _0x4fe1("0xb")) {
      let _0x42b4e8 = function() {
        _0x57e852 += _0x4fe1("0x12");
      };
    } else
      _0x369fe1 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
  } else {
    if (_0x5996d0[_0x4fe1("0x17")] === 0) {
      if (_0x4fe1("0x2e") !== _0x4fe1("0x2e")) {
        let _0x170217 = function() {
          return null;
        };
      } else
        _0x369fe1 += _0x4fe1("0x1d");
    } else {
      if (_0x5996d0[_0x4fe1("0x17")] === 1) {
        if (_0x4fe1("0x2a") === _0x4fe1("0x2a"))
          _0x369fe1 += _0x4fe1("0x12");
        else {
          let _0x589fb9 = function() {
            return _0x3ffa72[_0x4fe1("0x2c")](_0x161b80[_0x4fe1("0x37")]);
          };
        }
      }
    }
  }
  return _0x369fe1 += _0x4fe1("0x33")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x26")], _0x4fe1("0x3a")), _0x369fe1;
}
function matchProduct(_0x2fe56c, _0x1db63e) {
  var _0x48173a = _0x2fe56c[_0x4fe1("0x2f")];
  if (!_0x48173a || !_0x48173a[_0x4fe1("0x23")]) {
    if (_0x4fe1("0x29") !== _0x4fe1("0x16"))
      return null;
    else {
      let _0x5d3cfe = function() {
        _0x3e8f7b += _0x4fe1("0x1d");
      };
    }
  }
  var _0x1dd0f6 = new Set(_0x1db63e);
  return _0x48173a[_0x4fe1("0x31")](function(_0xd163b7, _0x23878c) {
    if (_0x4fe1("0x30") === _0x4fe1("0x3")) {
      let _0x134c08 = function() {
        !_0xbcc2ed ? _0xb3f5b6 = { "type": 1, "packageName": _0x495d13, "docsUrl": _0x4dead0[_0x4fe1("0x39")] } : _0xa8b7ca[_0x4fe1("0x2d")] < _0x177345[_0x4fe1("0x3c")] && (_0x2625da = { "type": 2, "packageName": _0x5e46dc, "publishDate": _0x10f6c5(_0x357f8a[_0x4fe1("0x3c")]), "expiryDate": _0x70483f(_0x32abbc[_0x4fe1("0x2d")]), "docsUrl": _0x4a4999[_0x4fe1("0x39")] });
      };
    } else
      return _0x23878c[_0x4fe1("0x2d")] - _0xd163b7[_0x4fe1("0x2d")];
  })[_0x4fe1("0x32")](function(_0x1d8f83) {
    if (_0x4fe1("0xa") === _0x4fe1("0x1")) {
      let _0x428ed6 = function() {
        _0x34c59d = { "type": 0, "packageName": _0x3b51a6, "docsUrl": _0x3d18c6[_0x4fe1("0x39")] };
      };
    } else
      return _0x1dd0f6[_0x4fe1("0x8")](_0x1d8f83[_0x4fe1("0xe")]);
  });
}
function parseDate2(_0x9d6621) {
  return new Date(_0x9d6621 * 1e3);
}

// node_modules/@progress/kendo-react-intl/dist/es/package-metadata.js
var packageMetadata = {
  name: "@progress/kendo-react-intl",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1686225061,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-react-intl/dist/es/Intl/IntlService.js
var IntlService = (
  /** @class */
  function() {
    function IntlService4(locale) {
      this.locale = locale;
      if (typeof index_esm_exports !== "undefined") {
        validatePackage(packageMetadata);
      } else {
        var message = "License activation failed for ".concat(packageMetadata.name, "\n");
        message += "The @progress/kendo-licensing script is not loaded.\n";
        message += "See ".concat(packageMetadata.licensingDocsUrl, " for more information.\n");
        console.warn(message);
      }
      if (locale === "" && true) {
        throw "Locale should not be empty string";
      }
    }
    IntlService4.prototype.format = function(format2) {
      var values5 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        values5[_i - 1] = arguments[_i];
      }
      if (values5.length === 1 && Array.isArray(values5[0])) {
        return format(format2, values5[0], this.locale);
      }
      return format(format2, values5, this.locale);
    };
    IntlService4.prototype.formatDate = function(value, format2) {
      return formatDate(value, format2, this.locale);
    };
    IntlService4.prototype.toString = function(value, format2) {
      return toString(value, format2, this.locale);
    };
    IntlService4.prototype.parseNumber = function(value, format2) {
      return parseNumber(value, this.locale, format2);
    };
    IntlService4.prototype.parseDate = function(value, format2) {
      return parseDate(value, format2, this.locale);
    };
    IntlService4.prototype.formatNumber = function(value, format2) {
      return formatNumber(value, format2, this.locale);
    };
    IntlService4.prototype.dateFieldName = function(options2) {
      return dateFieldName(options2, this.locale);
    };
    IntlService4.prototype.dateFormatNames = function(options2) {
      return dateFormatNames(this.locale, options2);
    };
    IntlService4.prototype.splitDateFormat = function(format2) {
      return splitDateFormat(format2, this.locale);
    };
    IntlService4.prototype.numberSymbols = function() {
      return numberSymbols(this.locale);
    };
    IntlService4.prototype.firstDay = function() {
      return firstDay(this.locale);
    };
    IntlService4.prototype.localeInfo = function() {
      return localeInfo(this.locale);
    };
    return IntlService4;
  }()
);

// node_modules/@progress/kendo-react-intl/dist/es/Localization/messages.js
var messages = /* @__PURE__ */ Object.create({});

// node_modules/@progress/kendo-react-intl/dist/es/Localization/LocalizationService.js
var LocalizationService = (
  /** @class */
  function() {
    function LocalizationService2(language) {
      this.language = language;
      if (language === "" && true) {
        throw "Language should not be an empty string";
      }
    }
    LocalizationService2.prototype.toLanguageString = function(key, defaultValue) {
      if (this.language && messages[this.language] && messages[this.language].hasOwnProperty(key)) {
        return messages[this.language][key];
      } else {
        return defaultValue;
      }
    };
    return LocalizationService2;
  }()
);

// node_modules/@progress/kendo-react-intl/dist/es/globalization/GlobalizationContext.js
var GlobalizationContext = React.createContext({
  intl: new IntlService("en"),
  localization: new LocalizationService()
});

// node_modules/@progress/kendo-react-intl/dist/es/intlUtils.js
function provideIntlService(component) {
  if (!component && true) {
    throw "Passed component - ".concat(component, " is invalid.");
  }
  var context2 = component.context;
  return context2 && context2.intl ? context2.intl : new IntlService("en");
}
function registerForIntl(component) {
  component.contextType = GlobalizationContext;
}

// node_modules/@progress/kendo-charts/dist/es/common/constants.js
var ARC = "arc";
var AXIS_LABEL_CLICK = "axisLabelClick";
var BLACK = "#000";
var BOTTOM = "bottom";
var CENTER = "center";
var CIRCLE = "circle";
var COORD_PRECISION = 3;
var CROSS = "cross";
var DATE = "date";
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_HEIGHT = 400;
var DEFAULT_PRECISION = 10;
var DEFAULT_WIDTH = 600;
var END = "end";
var FORMAT_REGEX = /\{\d+:?/;
var HEIGHT = "height";
var HIGHLIGHT_ZINDEX = 100;
var INSIDE = "inside";
var LEFT = "left";
var MAX_VALUE = Number.MAX_VALUE;
var MIN_VALUE = -Number.MAX_VALUE;
var NONE = "none";
var NOTE_CLICK = "noteClick";
var NOTE_HOVER = "noteHover";
var NOTE_LEAVE = "noteLeave";
var OBJECT = "object";
var OUTSIDE = "outside";
var RIGHT = "right";
var ROUNDED_RECT = "roundedRect";
var START = "start";
var STRING = "string";
var TOP = "top";
var TRIANGLE = "triangle";
var VALUE = "value";
var WHITE = "#fff";
var WIDTH = "width";
var X = "x";
var Y = "y";
var DEFAULT_SERIES_OPACITY = 1;

// node_modules/@progress/kendo-charts/dist/es/common/is-array.js
function isArray(value) {
  return Array.isArray(value);
}

// node_modules/@progress/kendo-charts/dist/es/common/add-class.js
function addClass(element2, classes) {
  var classArray = isArray(classes) ? classes : [classes];
  for (var idx = 0; idx < classArray.length; idx++) {
    var className = classArray[idx];
    if (element2.className.indexOf(className) === -1) {
      element2.className += " " + className;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/remove-class.js
var SPACE_REGEX = /\s+/g;
function removeClass(element2, className) {
  if (element2 && element2.className) {
    element2.className = element2.className.replace(className, "").replace(SPACE_REGEX, " ");
  }
}

// node_modules/@progress/kendo-drawing/dist/es/drawing.js
var drawing_exports = {};
__export(drawing_exports, {
  Animation: () => animation_default,
  AnimationFactory: () => animation_factory_default,
  Arc: () => arc_default2,
  BaseNode: () => base_node_default,
  Circle: () => circle_default2,
  Element: () => element_default,
  Gradient: () => gradient_default,
  GradientStop: () => gradient_stop_default,
  Group: () => group_default,
  HasObservers: () => has_observers_default,
  Image: () => image_default,
  Layout: () => layout_default,
  LinearGradient: () => linear_gradient_default,
  MultiPath: () => MultiPath,
  OptionsStore: () => options_store_default,
  Path: () => Path,
  PathParser: () => path_parser_default,
  QuadNode: () => quad_node_default,
  RadialGradient: () => radial_gradient_default,
  Rect: () => rect_default2,
  ShapesQuadTree: () => shapes_quad_tree_default,
  Surface: () => surface_default4,
  SurfaceFactory: () => surface_factory_default,
  Text: () => text_default,
  align: () => align,
  canvas: () => canvas_exports,
  exportImage: () => exportImage,
  exportSVG: () => exportSVG,
  fit: () => fit,
  parsePath: () => parse_path_default,
  stack: () => stack,
  svg: () => svg_exports,
  util: () => util_exports,
  vAlign: () => vAlign,
  vStack: () => vStack,
  vWrap: () => vWrap,
  wrap: () => wrap
});

// node_modules/@progress/kendo-drawing/dist/es/common/class.js
var Class = function Class2() {
};
var class_default = Class;

// node_modules/@progress/kendo-drawing/dist/es/common/observable.js
var Observable = function(Class3) {
  function Observable3() {
    Class3.call(this);
    this._events = {};
  }
  if (Class3)
    Observable3.__proto__ = Class3;
  Observable3.prototype = Object.create(Class3 && Class3.prototype);
  Observable3.prototype.constructor = Observable3;
  Observable3.prototype.bind = function bind(eventName, handlers, one) {
    var arguments$1 = arguments;
    var this$1 = this;
    var eventNames = getArray(eventName);
    var handlersIsFunction = isFunction2(handlers);
    var length = eventNames.length;
    if (handlers === void 0) {
      for (var field in eventName) {
        this$1.bind(field, eventName[field]);
      }
      return this;
    }
    var loop = function(idx2) {
      var eventName$1 = eventNames[idx2];
      var handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        if (one) {
          var original = handler;
          handler = function() {
            this$1.unbind(eventName$1, handler);
            original.apply(this$1, arguments$1);
          };
          handler.original = original;
        }
        var events2 = this$1._events[eventName$1] = this$1._events[eventName$1] || [];
        events2.push(handler);
      }
    };
    for (var idx = 0; idx < length; idx++)
      loop(idx);
    return this;
  };
  Observable3.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable3.prototype.first = function first(eventName, handlers) {
    var this$1 = this;
    var eventNames = getArray(eventName);
    var handlersIsFunction = isFunction2(handlers);
    for (var idx = 0, length = eventNames.length; idx < length; idx++) {
      var eventName$1 = eventNames[idx];
      var handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        var events2 = this$1._events[eventName$1] = this$1._events[eventName$1] || [];
        events2.unshift(handler);
      }
    }
    return this;
  };
  Observable3.prototype.trigger = function trigger2(eventName, e) {
    var this$1 = this;
    if (e === void 0)
      e = {};
    var events2 = this._events[eventName];
    if (events2) {
      var length = events2.length;
      e.sender = this;
      e._defaultPrevented = false;
      e.preventDefault = preventDefault;
      e.isDefaultPrevented = isDefaultPrevented;
      events2 = events2.slice();
      for (var idx = 0; idx < length; idx++) {
        events2[idx].call(this$1, e);
      }
      return e._defaultPrevented === true;
    }
    return false;
  };
  Observable3.prototype.unbind = function unbind(eventName, handler) {
    var events2 = this._events[eventName];
    if (eventName === void 0) {
      this._events = {};
    } else if (events2) {
      if (handler) {
        for (var idx = events2.length - 1; idx >= 0; idx--) {
          if (events2[idx] === handler || events2[idx].original === handler) {
            events2.splice(idx, 1);
          }
        }
      } else {
        this._events[eventName] = [];
      }
    }
    return this;
  };
  return Observable3;
}(class_default);
function isFunction2(value) {
  return typeof value === "function";
}
function getArray(value) {
  return typeof value === "string" ? [value] : value;
}
function preventDefault() {
  this._defaultPrevented = true;
}
function isDefaultPrevented() {
  return this._defaultPrevented === true;
}
var observable_default = Observable;

// node_modules/@progress/kendo-drawing/dist/es/common/animation-frame.js
var animationFrameProxy = function(callback) {
  var wnd = typeof window !== "undefined" ? window : {};
  var animationFrame2 = wnd.requestAnimationFrame || wnd.webkitRequestAnimationFrame || wnd.mozRequestAnimationFrame || wnd.oRequestAnimationFrame || wnd.msRequestAnimationFrame || function(callback2) {
    setTimeout(callback2, 1e3 / 60);
  };
  animationFrameProxy = function(callback2) {
    return animationFrame2.call(wnd, callback2);
  };
  animationFrameProxy(callback);
};
var animation_frame_default = animationFrameProxy;

// node_modules/@progress/kendo-drawing/dist/es/common/html-encode.js
var ampRegExp = /&/g;
var ltRegExp = /</g;
var quoteRegExp = /"/g;
var aposRegExp = /'/g;
var gtRegExp = />/g;
function htmlEncode(value) {
  return String(value).replace(ampRegExp, "&amp;").replace(ltRegExp, "&lt;").replace(gtRegExp, "&gt;").replace(quoteRegExp, "&quot;").replace(aposRegExp, "&#39;");
}

// node_modules/@progress/kendo-drawing/dist/es/common/log-to-console.js
function logToConsole(message) {
  var console2 = window.console;
  if (typeof console2 != "undefined" && console2.log) {
    console2.log(message);
  }
}

// node_modules/@progress/kendo-drawing/dist/es/common/support.js
function matchUserAgent(userAgent) {
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+))/i
  };
  var browser5 = {};
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      var match = userAgent.match(browserRxs[agent]);
      if (match) {
        browser5[agent] = true;
        browser5[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser5.version = parseInt(document.documentMode || match[2], 10);
        break;
      }
    }
  }
  return browser5;
}
var browser = null;
var support = {
  get browser() {
    if (typeof window === "undefined" || browser) {
      return browser;
    }
    browser = matchUserAgent(window.navigator.userAgent);
    return browser;
  }
};
var support_default = support;

// node_modules/@progress/kendo-drawing/dist/es/util/now.js
var now = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
var now_default = now;

// node_modules/@progress/kendo-drawing/dist/es/common/throttle.js
function throttle(fn, delay) {
  var lastExecTime = 0;
  var timeout;
  if (!delay || delay <= 0) {
    return fn;
  }
  var throttled = function() {
    var elapsed = now_default() - lastExecTime;
    var args = arguments;
    var exec = function() {
      fn.apply(null, args);
      lastExecTime = now_default();
    };
    if (!lastExecTime) {
      return exec();
    }
    if (timeout) {
      clearTimeout(timeout);
    }
    if (elapsed > delay) {
      exec();
    } else {
      timeout = setTimeout(exec, delay - elapsed);
    }
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
  };
  return throttled;
}

// node_modules/@progress/kendo-drawing/dist/es/common/color/named-colors.js
var namedColors = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgrey: "a9a9a9",
  darkgreen: "006400",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  grey: "808080",
  green: "008000",
  greenyellow: "adff2f",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgrey: "d3d3d3",
  lightgreen: "90ee90",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "778899",
  lightslategrey: "778899",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "00ff00",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "ff00ff",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370d8",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "d87093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  red: "ff0000",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "ffffff",
  whitesmoke: "f5f5f5",
  yellow: "ffff00",
  yellowgreen: "9acd32"
};
var named_colors_default = namedColors;

// node_modules/@progress/kendo-drawing/dist/es/common/color/parse-color.js
var browser2 = support_default.browser;
var matchNamedColor = function(color) {
  var colorNames = Object.keys(named_colors_default);
  colorNames.push("transparent");
  var regexp = new RegExp("^(" + colorNames.join("|") + ")(\\W|$)", "i");
  matchNamedColor = function(color2) {
    return regexp.exec(color2);
  };
  return regexp.exec(color);
};
var BaseColor = function(Class3) {
  function BaseColor2() {
    Class3.call(this);
  }
  if (Class3)
    BaseColor2.__proto__ = Class3;
  BaseColor2.prototype = Object.create(Class3 && Class3.prototype);
  BaseColor2.prototype.constructor = BaseColor2;
  BaseColor2.prototype.toHSV = function toHSV() {
    return this;
  };
  BaseColor2.prototype.toRGB = function toRGB() {
    return this;
  };
  BaseColor2.prototype.toHex = function toHex(options2) {
    return this.toBytes().toHex(options2);
  };
  BaseColor2.prototype.toBytes = function toBytes() {
    return this;
  };
  BaseColor2.prototype.toCss = function toCss(options2) {
    return "#" + this.toHex(options2);
  };
  BaseColor2.prototype.toCssRgba = function toCssRgba() {
    var rgb = this.toBytes();
    return "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + parseFloat(Number(this.a).toFixed(3)) + ")";
  };
  BaseColor2.prototype.toDisplay = function toDisplay() {
    if (browser2.msie && browser2.version < 9) {
      return this.toCss();
    }
    return this.toCssRgba();
  };
  BaseColor2.prototype.equals = function equals(c) {
    return c === this || c !== null && c !== void 0 && this.toCssRgba() === parseColor(c).toCssRgba();
  };
  BaseColor2.prototype.diff = function diff(other) {
    if (other === null) {
      return NaN;
    }
    var c1 = this.toBytes();
    var c2 = other.toBytes();
    return Math.sqrt(Math.pow((c1.r - c2.r) * 0.3, 2) + Math.pow((c1.g - c2.g) * 0.59, 2) + Math.pow((c1.b - c2.b) * 0.11, 2));
  };
  BaseColor2.prototype.clone = function clone2() {
    var c = this.toBytes();
    if (c === this) {
      c = new Bytes(c.r, c.g, c.b, c.a);
    }
    return c;
  };
  return BaseColor2;
}(class_default);
var RGB = function(BaseColor2) {
  function RGB2(r, g, b, a) {
    BaseColor2.call(this);
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  if (BaseColor2)
    RGB2.__proto__ = BaseColor2;
  RGB2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  RGB2.prototype.constructor = RGB2;
  RGB2.prototype.toHSV = function toHSV() {
    var ref2 = this;
    var r = ref2.r;
    var g = ref2.g;
    var b = ref2.b;
    var min3 = Math.min(r, g, b);
    var max2 = Math.max(r, g, b);
    var delta = max2 - min3;
    var v = max2;
    var h, s;
    if (delta === 0) {
      return new HSV(0, 0, v, this.a);
    }
    if (max2 !== 0) {
      s = delta / max2;
      if (r === max2) {
        h = (g - b) / delta;
      } else if (g === max2) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h *= 60;
      if (h < 0) {
        h += 360;
      }
    } else {
      s = 0;
      h = -1;
    }
    return new HSV(h, s, v, this.a);
  };
  RGB2.prototype.toHSL = function toHSL() {
    var ref2 = this;
    var r = ref2.r;
    var g = ref2.g;
    var b = ref2.b;
    var max2 = Math.max(r, g, b);
    var min3 = Math.min(r, g, b);
    var h, s, l = (max2 + min3) / 2;
    if (max2 === min3) {
      h = s = 0;
    } else {
      var d = max2 - min3;
      s = l > 0.5 ? d / (2 - max2 - min3) : d / (max2 + min3);
      switch (max2) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
    }
    return new HSL(h * 60, s * 100, l * 100, this.a);
  };
  RGB2.prototype.toBytes = function toBytes() {
    return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);
  };
  return RGB2;
}(BaseColor);
var Bytes = function(RGB2) {
  function Bytes2(r, g, b, a) {
    RGB2.call(this, Math.round(r), Math.round(g), Math.round(b), a);
  }
  if (RGB2)
    Bytes2.__proto__ = RGB2;
  Bytes2.prototype = Object.create(RGB2 && RGB2.prototype);
  Bytes2.prototype.constructor = Bytes2;
  Bytes2.prototype.toRGB = function toRGB() {
    return new RGB2(this.r / 255, this.g / 255, this.b / 255, this.a);
  };
  Bytes2.prototype.toHSV = function toHSV() {
    return this.toRGB().toHSV();
  };
  Bytes2.prototype.toHSL = function toHSL() {
    return this.toRGB().toHSL();
  };
  Bytes2.prototype.toHex = function toHex(options2) {
    var value = hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);
    if (options2 && options2.alpha) {
      value += hex(Math.round(this.a * 255), 2);
    }
    return value;
  };
  Bytes2.prototype.toBytes = function toBytes() {
    return this;
  };
  return Bytes2;
}(RGB);
function hex(n, width, pad3) {
  if (pad3 === void 0)
    pad3 = "0";
  var result = n.toString(16);
  while (width > result.length) {
    result = pad3 + result;
  }
  return result;
}
var HSV = function(BaseColor2) {
  function HSV2(h, s, v, a) {
    BaseColor2.call(this);
    this.h = h;
    this.s = s;
    this.v = v;
    this.a = a;
  }
  if (BaseColor2)
    HSV2.__proto__ = BaseColor2;
  HSV2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  HSV2.prototype.constructor = HSV2;
  HSV2.prototype.toRGB = function toRGB() {
    var ref2 = this;
    var h = ref2.h;
    var s = ref2.s;
    var v = ref2.v;
    var r, g, b;
    if (s === 0) {
      r = g = b = v;
    } else {
      h /= 60;
      var i = Math.floor(h);
      var f = h - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        default:
          r = v;
          g = p;
          b = q;
          break;
      }
    }
    return new RGB(r, g, b, this.a);
  };
  HSV2.prototype.toHSL = function toHSL() {
    return this.toRGB().toHSL();
  };
  HSV2.prototype.toBytes = function toBytes() {
    return this.toRGB().toBytes();
  };
  return HSV2;
}(BaseColor);
var HSL = function(BaseColor2) {
  function HSL2(h, s, l, a) {
    BaseColor2.call(this);
    this.h = h;
    this.s = s;
    this.l = l;
    this.a = a;
  }
  if (BaseColor2)
    HSL2.__proto__ = BaseColor2;
  HSL2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  HSL2.prototype.constructor = HSL2;
  HSL2.prototype.toRGB = function toRGB() {
    var h = this.h / 360;
    var s = this.s / 100;
    var l = this.l / 100;
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }
    return new RGB(r, g, b, this.a);
  };
  HSL2.prototype.toHSV = function toHSV() {
    return this.toRGB().toHSV();
  };
  HSL2.prototype.toBytes = function toBytes() {
    return this.toRGB().toBytes();
  };
  return HSL2;
}(BaseColor);
function hue2rgb(p, q, s) {
  var t = s;
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p + (q - p) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p + (q - p) * (2 / 3 - t) * 6;
  }
  return p;
}
function alphaFromHex(a) {
  return parseFloat(parseFloat(parseInt(a, 16) / 255).toFixed(3));
}
function parseColor(value, safe) {
  var m, ret;
  if (value == null || value === "none") {
    return null;
  }
  if (value instanceof BaseColor) {
    return value;
  }
  var color = value.toLowerCase();
  if (m = matchNamedColor(color)) {
    if (m[1] === "transparent") {
      color = new RGB(1, 1, 1, 0);
    } else {
      color = parseColor(named_colors_default[m[1]], safe);
    }
    color.match = [m[1]];
    return color;
  }
  if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 16),
      parseInt(m[2], 16),
      parseInt(m[3], 16),
      1
    );
  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1] + m[1], 16),
      parseInt(m[2] + m[2], 16),
      parseInt(m[3] + m[3], 16),
      1
    );
  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1] + m[1], 16),
      parseInt(m[2] + m[2], 16),
      parseInt(m[3] + m[3], 16),
      alphaFromHex(m[4] + m[4])
    );
  } else if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 16),
      parseInt(m[2], 16),
      parseInt(m[3], 16),
      alphaFromHex(m[4])
    );
  } else if (m = /^rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 10),
      parseInt(m[2], 10),
      parseInt(m[3], 10),
      1
    );
  } else if (m = /^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 10),
      parseInt(m[2], 10),
      parseInt(m[3], 10),
      parseFloat(m[4])
    );
  } else if (m = /^rgb\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m[1]) / 100,
      parseFloat(m[2]) / 100,
      parseFloat(m[3]) / 100,
      1
    );
  } else if (m = /^rgba\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m[1]) / 100,
      parseFloat(m[2]) / 100,
      parseFloat(m[3]) / 100,
      parseFloat(m[4])
    );
  }
  if (ret) {
    ret.match = m;
  } else if (!safe) {
    throw new Error("Cannot parse color: " + color);
  }
  return ret;
}

// node_modules/@progress/kendo-drawing/dist/es/common/color/color.js
var DARK_TRESHOLD = 180;
var Color = function(Class3) {
  function Color2(value) {
    var this$1 = this;
    Class3.call(this);
    if (arguments.length === 1) {
      var formats = Color2.formats;
      var resolvedColor = this.resolveColor(value);
      for (var idx = 0; idx < formats.length; idx++) {
        var formatRegex = formats[idx].re;
        var processor = formats[idx].process;
        var parts = formatRegex.exec(resolvedColor);
        if (parts) {
          var channels = processor(parts);
          this$1.r = channels[0];
          this$1.g = channels[1];
          this$1.b = channels[2];
        }
      }
    } else {
      this.r = arguments[0];
      this.g = arguments[1];
      this.b = arguments[2];
    }
    this.r = this.normalizeByte(this.r);
    this.g = this.normalizeByte(this.g);
    this.b = this.normalizeByte(this.b);
  }
  if (Class3)
    Color2.__proto__ = Class3;
  Color2.prototype = Object.create(Class3 && Class3.prototype);
  Color2.prototype.constructor = Color2;
  Color2.prototype.toHex = function toHex() {
    var pad3 = this.padDigit;
    var r = this.r.toString(16);
    var g = this.g.toString(16);
    var b = this.b.toString(16);
    return "#" + pad3(r) + pad3(g) + pad3(b);
  };
  Color2.prototype.resolveColor = function resolveColor(value) {
    var color = value || "black";
    if (color.charAt(0) === "#") {
      color = color.substr(1, 6);
    }
    color = color.replace(/ /g, "");
    color = color.toLowerCase();
    color = Color2.namedColors[color] || color;
    return color;
  };
  Color2.prototype.normalizeByte = function normalizeByte(value) {
    if (value < 0 || isNaN(value)) {
      return 0;
    }
    return value > 255 ? 255 : value;
  };
  Color2.prototype.padDigit = function padDigit(value) {
    return value.length === 1 ? "0" + value : value;
  };
  Color2.prototype.brightness = function brightness(value) {
    var round5 = Math.round;
    this.r = round5(this.normalizeByte(this.r * value));
    this.g = round5(this.normalizeByte(this.g * value));
    this.b = round5(this.normalizeByte(this.b * value));
    return this;
  };
  Color2.prototype.percBrightness = function percBrightness() {
    return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);
  };
  Color2.prototype.isDark = function isDark() {
    return this.percBrightness() < DARK_TRESHOLD;
  };
  Color2.fromBytes = function fromBytes(r, g, b, a) {
    return new Bytes(r, g, b, a != null ? a : 1);
  };
  Color2.fromRGB = function fromRGB(r, g, b, a) {
    return new RGB(r, g, b, a != null ? a : 1);
  };
  Color2.fromHSV = function fromHSV(h, s, v, a) {
    return new HSV(h, s, v, a != null ? a : 1);
  };
  Color2.fromHSL = function fromHSL(h, s, l, a) {
    return new HSL(h, s, l, a != null ? a : 1);
  };
  return Color2;
}(class_default);
Color.formats = [{
  re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function(parts) {
    return [
      parseInt(parts[1], 10),
      parseInt(parts[2], 10),
      parseInt(parts[3], 10)
    ];
  }
}, {
  re: /^(\w{2})(\w{2})(\w{2})$/,
  process: function(parts) {
    return [
      parseInt(parts[1], 16),
      parseInt(parts[2], 16),
      parseInt(parts[3], 16)
    ];
  }
}, {
  re: /^(\w{1})(\w{1})(\w{1})$/,
  process: function(parts) {
    return [
      parseInt(parts[1] + parts[1], 16),
      parseInt(parts[2] + parts[2], 16),
      parseInt(parts[3] + parts[3], 16)
    ];
  }
}];
Color.namedColors = named_colors_default;
var color_default = Color;

// node_modules/@progress/kendo-drawing/dist/es/core/has-observers.js
var HasObservers = function(Class3) {
  function HasObservers2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    HasObservers2.__proto__ = Class3;
  HasObservers2.prototype = Object.create(Class3 && Class3.prototype);
  HasObservers2.prototype.constructor = HasObservers2;
  HasObservers2.prototype.observers = function observers() {
    this._observers = this._observers || [];
    return this._observers;
  };
  HasObservers2.prototype.addObserver = function addObserver(element2) {
    if (!this._observers) {
      this._observers = [element2];
    } else {
      this._observers.push(element2);
    }
    return this;
  };
  HasObservers2.prototype.removeObserver = function removeObserver(element2) {
    var observers = this.observers();
    var index = observers.indexOf(element2);
    if (index !== -1) {
      observers.splice(index, 1);
    }
    return this;
  };
  HasObservers2.prototype.trigger = function trigger2(methodName, event) {
    var observers = this._observers;
    if (observers && !this._suspended) {
      for (var idx = 0; idx < observers.length; idx++) {
        var observer = observers[idx];
        if (observer[methodName]) {
          observer[methodName](event);
        }
      }
    }
    return this;
  };
  HasObservers2.prototype.optionsChange = function optionsChange(e) {
    if (e === void 0)
      e = {};
    e.element = this;
    this.trigger("optionsChange", e);
  };
  HasObservers2.prototype.geometryChange = function geometryChange() {
    this.trigger("geometryChange", {
      element: this
    });
  };
  HasObservers2.prototype.suspend = function suspend() {
    this._suspended = (this._suspended || 0) + 1;
    return this;
  };
  HasObservers2.prototype.resume = function resume() {
    this._suspended = Math.max((this._suspended || 0) - 1, 0);
    return this;
  };
  HasObservers2.prototype._observerField = function _observerField(field, value) {
    if (this[field]) {
      this[field].removeObserver(this);
    }
    this[field] = value;
    value.addObserver(this);
  };
  return HasObservers2;
}(class_default);
var has_observers_default = HasObservers;

// node_modules/@progress/kendo-drawing/dist/es/util.js
var util_exports = {};
__export(util_exports, {
  DEG_TO_RAD: () => DEG_TO_RAD,
  LRUCache: () => lru_cache_default,
  MAX_NUM: () => MAX_NUM,
  MIN_NUM: () => MIN_NUM,
  TextMetrics: () => text_metrics_default,
  append: () => append,
  arabicToRoman: () => arabicToRoman,
  bindEvents: () => bindEvents,
  createPromise: () => createPromise,
  defined: () => defined,
  definitionId: () => definitionId,
  deg: () => deg,
  elementOffset: () => elementOffset,
  elementPadding: () => elementPadding,
  elementScale: () => elementScale,
  elementSize: () => elementSize,
  elementStyles: () => elementStyles,
  encodeBase64: () => encodeBase64,
  eventCoordinates: () => eventCoordinates,
  eventElement: () => eventElement,
  hashKey: () => hashKey,
  isTransparent: () => isTransparent,
  last: () => last,
  limitValue: () => limitValue,
  measureText: () => measureText,
  mergeSort: () => mergeSort,
  normalizeText: () => normalizeText,
  now: () => now_default,
  objectKey: () => objectKey,
  promiseAll: () => promiseAll,
  rad: () => rad,
  round: () => round2,
  unbindEvents: () => unbindEvents,
  valueOrDefault: () => valueOrDefault
});

// node_modules/@progress/kendo-drawing/dist/es/util/append.js
function append(first, second) {
  first.push.apply(first, second);
  return first;
}

// node_modules/@progress/kendo-drawing/dist/es/util/arabic-to-roman.js
var literals = {
  1: "i",
  10: "x",
  100: "c",
  2: "ii",
  20: "xx",
  200: "cc",
  3: "iii",
  30: "xxx",
  300: "ccc",
  4: "iv",
  40: "xl",
  400: "cd",
  5: "v",
  50: "l",
  500: "d",
  6: "vi",
  60: "lx",
  600: "dc",
  7: "vii",
  70: "lxx",
  700: "dcc",
  8: "viii",
  80: "lxxx",
  800: "dccc",
  9: "ix",
  90: "xc",
  900: "cm",
  1e3: "m"
};
function arabicToRoman(n) {
  var values5 = [
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ];
  var roman = "";
  while (n > 0) {
    if (n < values5[0]) {
      values5.shift();
    } else {
      roman += literals[values5[0]];
      n -= values5[0];
    }
  }
  return roman;
}

// node_modules/@progress/kendo-drawing/dist/es/util/create-promise.js
function createPromise() {
  var resolveFn, rejectFn;
  var promise = new Promise(function(resolve, reject) {
    resolveFn = function(data) {
      promise._state = "resolved";
      resolve(data);
      return promise;
    };
    rejectFn = function(data) {
      promise._state = "rejected";
      reject(data);
      return promise;
    };
  });
  promise._state = "pending";
  promise.resolve = resolveFn;
  promise.reject = rejectFn;
  promise.state = function() {
    return promise._state;
  };
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/util/defined.js
var UNDEFINED = "undefined";
function defined(value) {
  return typeof value !== UNDEFINED;
}

// node_modules/@progress/kendo-drawing/dist/es/util/definition-id.js
var defId = 1;
function definitionId() {
  return "kdef" + defId++;
}

// node_modules/@progress/kendo-drawing/dist/es/util/constants.js
var DEG_TO_RAD = Math.PI / 180;
var MAX_NUM = Number.MAX_VALUE;
var MIN_NUM = -Number.MAX_VALUE;

// node_modules/@progress/kendo-drawing/dist/es/util/deg.js
function deg(radians) {
  return radians / DEG_TO_RAD;
}

// node_modules/@progress/kendo-drawing/dist/es/util/encode-utf.js
var fromCharCode = String.fromCharCode;
function encodeUTF8(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    var code = input.charCodeAt(i);
    if (55296 <= code && code <= 56319) {
      var hi = code;
      var low = input.charCodeAt(++i);
      if (!isNaN(low)) {
        code = (hi - 55296) * 1024 + (low - 56320) + 65536;
      }
    }
    if (code < 128) {
      output += fromCharCode(code);
    } else if (code < 2048) {
      output += fromCharCode(192 | code >>> 6);
      output += fromCharCode(128 | code & 63);
    } else if (code < 65536) {
      output += fromCharCode(224 | code >>> 12);
      output += fromCharCode(128 | code >>> 6 & 63);
      output += fromCharCode(128 | code & 63);
    } else if (code < 1114111) {
      output += fromCharCode(240 | code >>> 18);
      output += fromCharCode(128 | code >>> 12 & 63);
      output += fromCharCode(128 | code >>> 6 & 63);
      output += fromCharCode(128 | code & 63);
    }
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/util/encode-base64.js
var KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBase64(input) {
  var output = "";
  var i = 0;
  var utfInput = encodeUTF8(input);
  while (i < utfInput.length) {
    var chr1 = utfInput.charCodeAt(i++);
    var chr2 = utfInput.charCodeAt(i++);
    var chr3 = utfInput.charCodeAt(i++);
    var enc1 = chr1 >> 2;
    var enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    var enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    var enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/util/event-coordinates.js
function eventCoordinates(e) {
  if (defined((e.x || {}).location)) {
    return {
      x: e.x.location,
      y: e.y.location
    };
  }
  return {
    x: e.pageX || e.clientX || 0,
    y: e.pageY || e.clientY || 0
  };
}

// node_modules/@progress/kendo-drawing/dist/es/util/event-element.js
function eventElement(e) {
  if (e === void 0)
    e = {};
  return e.touch ? e.touch.initialTouch : e.target;
}

// node_modules/@progress/kendo-drawing/dist/es/util/is-transparent.js
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);
}

// node_modules/@progress/kendo-drawing/dist/es/util/last.js
function last(array) {
  if (array) {
    return array[array.length - 1];
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/limit-value.js
function limitValue(value, min3, max2) {
  return Math.max(Math.min(value, max2), min3);
}

// node_modules/@progress/kendo-drawing/dist/es/util/merge-sort.js
function mergeSort(a, cmp) {
  if (a.length < 2) {
    return a.slice();
  }
  function merge(a2, b) {
    var r = [], ai = 0, bi = 0, i = 0;
    while (ai < a2.length && bi < b.length) {
      if (cmp(a2[ai], b[bi]) <= 0) {
        r[i++] = a2[ai++];
      } else {
        r[i++] = b[bi++];
      }
    }
    if (ai < a2.length) {
      r.push.apply(r, a2.slice(ai));
    }
    if (bi < b.length) {
      r.push.apply(r, b.slice(bi));
    }
    return r;
  }
  return function sort(a2) {
    if (a2.length <= 1) {
      return a2;
    }
    var m = Math.floor(a2.length / 2);
    var left = a2.slice(0, m);
    var right = a2.slice(m);
    left = sort(left);
    right = sort(right);
    return merge(left, right);
  }(a);
}

// node_modules/@progress/kendo-drawing/dist/es/util/promise-all.js
function promiseAll(promises) {
  return Promise.all(promises);
}

// node_modules/@progress/kendo-drawing/dist/es/util/rad.js
function rad(degrees) {
  return degrees * DEG_TO_RAD;
}

// node_modules/@progress/kendo-drawing/dist/es/util/round.js
function pow(p) {
  if (p) {
    return Math.pow(10, p);
  }
  return 1;
}
function round2(value, precision) {
  var power = pow(precision);
  return Math.round(value * power) / power;
}

// node_modules/@progress/kendo-drawing/dist/es/util/value-or-default.js
function valueOrDefault(value, defaultValue) {
  return defined(value) ? value : defaultValue;
}

// node_modules/@progress/kendo-drawing/dist/es/util/bind-events.js
function bindEvents(element2, events2) {
  for (var eventName in events2) {
    var eventNames = eventName.trim().split(" ");
    for (var idx = 0; idx < eventNames.length; idx++) {
      element2.addEventListener(eventNames[idx], events2[eventName], false);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-offset.js
function elementOffset(element2) {
  var box = element2.getBoundingClientRect();
  var documentElement = document.documentElement;
  return {
    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)
  };
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-styles.js
function elementStyles(element2, styles) {
  var result = {};
  var style = window.getComputedStyle(element2) || {};
  var stylesArray = Array.isArray(styles) ? styles : [styles];
  for (var idx = 0; idx < stylesArray.length; idx++) {
    var field = stylesArray[idx];
    result[field] = style[field];
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-size.js
function getPixels(value) {
  if (isNaN(value)) {
    return value;
  }
  return value + "px";
}
function elementSize(element2, size) {
  if (size) {
    var width = size.width;
    var height = size.height;
    if (defined(width)) {
      element2.style.width = getPixels(width);
    }
    if (defined(height)) {
      element2.style.height = getPixels(height);
    }
  } else {
    var size$1 = elementStyles(element2, ["width", "height"]);
    return {
      width: parseInt(size$1.width, 10),
      height: parseInt(size$1.height, 10)
    };
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/unbind-events.js
function unbindEvents(element2, events2) {
  if (events2 === void 0)
    events2 = {};
  for (var name2 in events2) {
    var eventNames = name2.trim().split(" ");
    for (var idx = 0; idx < eventNames.length; idx++) {
      element2.removeEventListener(eventNames[idx], events2[name2], false);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-padding.js
function elementPadding(element2) {
  var ref2 = elementStyles(element2, ["paddingLeft", "paddingTop"]);
  var paddingLeft = ref2.paddingLeft;
  var paddingTop = ref2.paddingTop;
  return {
    top: parseFloat(paddingTop),
    left: parseFloat(paddingLeft)
  };
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/matrix.js
var Matrix = function(Class3) {
  function Matrix3(a, b, c, d, e, f) {
    if (a === void 0)
      a = 0;
    if (b === void 0)
      b = 0;
    if (c === void 0)
      c = 0;
    if (d === void 0)
      d = 0;
    if (e === void 0)
      e = 0;
    if (f === void 0)
      f = 0;
    Class3.call(this);
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
  }
  if (Class3)
    Matrix3.__proto__ = Class3;
  Matrix3.prototype = Object.create(Class3 && Class3.prototype);
  Matrix3.prototype.constructor = Matrix3;
  Matrix3.prototype.multiplyCopy = function multiplyCopy(matrix) {
    return new Matrix3(
      this.a * matrix.a + this.c * matrix.b,
      this.b * matrix.a + this.d * matrix.b,
      this.a * matrix.c + this.c * matrix.d,
      this.b * matrix.c + this.d * matrix.d,
      this.a * matrix.e + this.c * matrix.f + this.e,
      this.b * matrix.e + this.d * matrix.f + this.f
    );
  };
  Matrix3.prototype.invert = function invert() {
    var ref2 = this;
    var a = ref2.a;
    var b = ref2.b;
    var d = ref2.c;
    var e = ref2.d;
    var g = ref2.e;
    var h = ref2.f;
    var det = a * e - b * d;
    if (det === 0) {
      return null;
    }
    return new Matrix3(
      e / det,
      -b / det,
      -d / det,
      a / det,
      (d * h - e * g) / det,
      (b * g - a * h) / det
    );
  };
  Matrix3.prototype.clone = function clone2() {
    return new Matrix3(this.a, this.b, this.c, this.d, this.e, this.f);
  };
  Matrix3.prototype.equals = function equals(other) {
    if (!other) {
      return false;
    }
    return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.e === other.e && this.f === other.f;
  };
  Matrix3.prototype.round = function round$1(precision) {
    this.a = round2(this.a, precision);
    this.b = round2(this.b, precision);
    this.c = round2(this.c, precision);
    this.d = round2(this.d, precision);
    this.e = round2(this.e, precision);
    this.f = round2(this.f, precision);
    return this;
  };
  Matrix3.prototype.toArray = function toArray(precision) {
    var result = [this.a, this.b, this.c, this.d, this.e, this.f];
    if (defined(precision)) {
      for (var i = 0; i < result.length; i++) {
        result[i] = round2(result[i], precision);
      }
    }
    return result;
  };
  Matrix3.prototype.toString = function toString3(precision, separator) {
    if (separator === void 0)
      separator = ",";
    return this.toArray(precision).join(separator);
  };
  Matrix3.translate = function translate2(x, y) {
    return new Matrix3(1, 0, 0, 1, x, y);
  };
  Matrix3.unit = function unit() {
    return new Matrix3(1, 0, 0, 1, 0, 0);
  };
  Matrix3.rotate = function rotate(angle, x, y) {
    var matrix = new Matrix3();
    matrix.a = Math.cos(rad(angle));
    matrix.b = Math.sin(rad(angle));
    matrix.c = -matrix.b;
    matrix.d = matrix.a;
    matrix.e = x - x * matrix.a + y * matrix.b || 0;
    matrix.f = y - y * matrix.a - x * matrix.b || 0;
    return matrix;
  };
  Matrix3.scale = function scale(scaleX, scaleY) {
    return new Matrix3(scaleX, 0, 0, scaleY, 0, 0);
  };
  return Matrix3;
}(class_default);
Matrix.IDENTITY = Matrix.unit();
var matrix_default = Matrix;

// node_modules/@progress/kendo-drawing/dist/es/util/element-scale.js
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  var match = matrixString.match(matrixRegexp);
  if (match === null || match.length !== 2) {
    return matrix_default.unit();
  }
  var members = match[1].split(",").map(function(x) {
    return parseFloat(x);
  });
  return new (Function.prototype.bind.apply(matrix_default, [null].concat(members)))();
}
function transformMatrix(element2) {
  var transform2 = getComputedStyle(element2).transform;
  if (transform2 === "none") {
    return matrix_default.unit();
  }
  return parseMatrix(transform2);
}
function elementScale(element2) {
  if (!element2) {
    return matrix_default.unit();
  }
  var matrix = transformMatrix(element2);
  var parent = element2.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/lru-cache.js
var LRUCache = function(Class3) {
  function LRUCache2(size) {
    Class3.call(this);
    this._size = size;
    this._length = 0;
    this._map = {};
  }
  if (Class3)
    LRUCache2.__proto__ = Class3;
  LRUCache2.prototype = Object.create(Class3 && Class3.prototype);
  LRUCache2.prototype.constructor = LRUCache2;
  LRUCache2.prototype.put = function put(key, value) {
    var map2 = this._map;
    var entry = { key, value };
    map2[key] = entry;
    if (!this._head) {
      this._head = this._tail = entry;
    } else {
      this._tail.newer = entry;
      entry.older = this._tail;
      this._tail = entry;
    }
    if (this._length >= this._size) {
      map2[this._head.key] = null;
      this._head = this._head.newer;
      this._head.older = null;
    } else {
      this._length++;
    }
  };
  LRUCache2.prototype.get = function get2(key) {
    var entry = this._map[key];
    if (entry) {
      if (entry === this._head && entry !== this._tail) {
        this._head = entry.newer;
        this._head.older = null;
      }
      if (entry !== this._tail) {
        if (entry.older) {
          entry.older.newer = entry.newer;
          entry.newer.older = entry.older;
        }
        entry.older = this._tail;
        entry.newer = null;
        this._tail.newer = entry;
        this._tail = entry;
      }
      return entry.value;
    }
  };
  return LRUCache2;
}(class_default);
var lru_cache_default = LRUCache;

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/util.js
var REPLACE_REGEX = /\r?\n|\r|\t/g;
var SPACE = " ";
function normalizeText(text) {
  return String(text).replace(REPLACE_REGEX, SPACE);
}
function objectKey(object2) {
  var parts = [];
  for (var key in object2) {
    parts.push(key + object2[key]);
  }
  return parts.sort().join("");
}
function hashKey(str) {
  var hash = 2166136261;
  for (var i = 0; i < str.length; ++i) {
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    hash ^= str.charCodeAt(i);
  }
  return hash >>> 0;
}

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/text-metrics.js
function zeroSize() {
  return { width: 0, height: 0, baseline: 0 };
}
var DEFAULT_OPTIONS = {
  baselineMarkerSize: 1
};
var defaultMeasureBox;
if (typeof document !== "undefined") {
  defaultMeasureBox = document.createElement("div");
  defaultMeasureBox.style.cssText = "position: absolute !important; top: -4000px !important; width: auto !important; height: auto !important;padding: 0 !important; margin: 0 !important; border: 0 !important;line-height: normal !important; visibility: hidden !important; white-space: pre!important;";
}
var TextMetrics = function(Class3) {
  function TextMetrics2(options2) {
    Class3.call(this);
    this._cache = new lru_cache_default(1e3);
    this.options = Object.assign({}, DEFAULT_OPTIONS, options2);
  }
  if (Class3)
    TextMetrics2.__proto__ = Class3;
  TextMetrics2.prototype = Object.create(Class3 && Class3.prototype);
  TextMetrics2.prototype.constructor = TextMetrics2;
  TextMetrics2.prototype.measure = function measure(text, style, options2) {
    if (options2 === void 0)
      options2 = {};
    if (typeof text === "undefined" || text === null) {
      return zeroSize();
    }
    var styleKey = objectKey(style);
    var cacheKey = hashKey(text + styleKey);
    var cachedResult = this._cache.get(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }
    var size = zeroSize();
    var measureBox = options2.box || defaultMeasureBox;
    var baselineMarker = this._baselineMarker().cloneNode(false);
    for (var key in style) {
      var value = style[key];
      if (typeof value !== "undefined") {
        measureBox.style[key] = value;
      }
    }
    var textStr = options2.normalizeText !== false ? normalizeText(text) : String(text);
    measureBox.textContent = textStr;
    measureBox.appendChild(baselineMarker);
    document.body.appendChild(measureBox);
    if (textStr.length) {
      size.width = measureBox.offsetWidth - this.options.baselineMarkerSize;
      size.height = measureBox.offsetHeight;
      size.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;
    }
    if (size.width > 0 && size.height > 0) {
      this._cache.put(cacheKey, size);
    }
    measureBox.parentNode.removeChild(measureBox);
    return size;
  };
  TextMetrics2.prototype._baselineMarker = function _baselineMarker() {
    var marker = document.createElement("div");
    marker.style.cssText = "display: inline-block; vertical-align: baseline;width: " + this.options.baselineMarkerSize + "px; height: " + this.options.baselineMarkerSize + "px;overflow: hidden;";
    return marker;
  };
  return TextMetrics2;
}(class_default);
TextMetrics.current = new TextMetrics();
var text_metrics_default = TextMetrics;

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/measure-text.js
function measureText(text, style, measureBox) {
  return text_metrics_default.current.measure(text, style, measureBox);
}

// node_modules/@progress/kendo-drawing/dist/es/core/options-store.js
var toString2 = {}.toString;
var OptionsStore = function(HasObservers2) {
  function OptionsStore2(options2, prefix) {
    var this$1 = this;
    if (prefix === void 0)
      prefix = "";
    HasObservers2.call(this);
    this.prefix = prefix;
    for (var field in options2) {
      var member = options2[field];
      member = this$1._wrap(member, field);
      this$1[field] = member;
    }
  }
  if (HasObservers2)
    OptionsStore2.__proto__ = HasObservers2;
  OptionsStore2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  OptionsStore2.prototype.constructor = OptionsStore2;
  OptionsStore2.prototype.get = function get2(field) {
    var parts = field.split(".");
    var result = this;
    while (parts.length && result) {
      var part = parts.shift();
      result = result[part];
    }
    return result;
  };
  OptionsStore2.prototype.set = function set2(field, value) {
    var current4 = this.get(field);
    if (current4 !== value) {
      this._set(field, this._wrap(value, field));
      this.optionsChange({
        field: this.prefix + field,
        value
      });
    }
  };
  OptionsStore2.prototype._set = function _set(field, value) {
    var this$1 = this;
    var composite = field.indexOf(".") >= 0;
    var parentObj = this;
    var fieldName = field;
    if (composite) {
      var parts = fieldName.split(".");
      var prefix = this.prefix;
      while (parts.length > 1) {
        fieldName = parts.shift();
        prefix += fieldName + ".";
        var obj = parentObj[fieldName];
        if (!obj) {
          obj = new OptionsStore2({}, prefix);
          obj.addObserver(this$1);
          parentObj[fieldName] = obj;
        }
        parentObj = obj;
      }
      fieldName = parts[0];
    }
    parentObj._clear(fieldName);
    parentObj[fieldName] = value;
  };
  OptionsStore2.prototype._clear = function _clear(field) {
    var current4 = this[field];
    if (current4 && current4.removeObserver) {
      current4.removeObserver(this);
    }
  };
  OptionsStore2.prototype._wrap = function _wrap(object2, field) {
    var type = toString2.call(object2);
    var wrapped = object2;
    if (wrapped !== null && defined(wrapped) && type === "[object Object]") {
      if (!(object2 instanceof OptionsStore2) && !(object2 instanceof class_default)) {
        wrapped = new OptionsStore2(wrapped, this.prefix + field + ".");
      }
      wrapped.addObserver(this);
    }
    return wrapped;
  };
  return OptionsStore2;
}(has_observers_default);
var options_store_default = OptionsStore;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-accessors.js
function setAccessor(field) {
  return function(value) {
    if (this[field] !== value) {
      this[field] = value;
      this.geometryChange();
    }
    return this;
  };
}
function getAccessor(field) {
  return function() {
    return this[field];
  };
}
function defineAccessors(fn, fields) {
  for (var i = 0; i < fields.length; i++) {
    var name2 = fields[i];
    var capitalized = name2.charAt(0).toUpperCase() + name2.substring(1, name2.length);
    fn["set" + capitalized] = setAccessor(name2);
    fn["get" + capitalized] = getAccessor(name2);
  }
}
var withAccessors = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineAccessors(result.prototype, names);
  return result;
};
var with_accessors_default = withAccessors;

// node_modules/@progress/kendo-drawing/dist/es/geometry/to-matrix.js
function toMatrix(transformation) {
  if (transformation && typeof transformation.matrix === "function") {
    return transformation.matrix();
  }
  return transformation;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/point.js
var Point = function(superclass) {
  function Point8(x, y) {
    superclass.call(this);
    this.x = x || 0;
    this.y = y || 0;
  }
  if (superclass)
    Point8.__proto__ = superclass;
  Point8.prototype = Object.create(superclass && superclass.prototype);
  Point8.prototype.constructor = Point8;
  var staticAccessors2 = { ZERO: { configurable: true } };
  Point8.prototype.equals = function equals(other) {
    return other && other.x === this.x && other.y === this.y;
  };
  Point8.prototype.clone = function clone2() {
    return new Point8(this.x, this.y);
  };
  Point8.prototype.rotate = function rotate(angle, origin) {
    var originPoint = Point8.create(origin) || Point8.ZERO;
    return this.transform(matrix_default.rotate(angle, originPoint.x, originPoint.y));
  };
  Point8.prototype.translate = function translate2(x, y) {
    this.x += x;
    this.y += y;
    this.geometryChange();
    return this;
  };
  Point8.prototype.translateWith = function translateWith(point2) {
    return this.translate(point2.x, point2.y);
  };
  Point8.prototype.move = function move(x, y) {
    this.x = this.y = 0;
    return this.translate(x, y);
  };
  Point8.prototype.scale = function scale(scaleX, scaleY) {
    if (scaleY === void 0)
      scaleY = scaleX;
    this.x *= scaleX;
    this.y *= scaleY;
    this.geometryChange();
    return this;
  };
  Point8.prototype.scaleCopy = function scaleCopy(scaleX, scaleY) {
    return this.clone().scale(scaleX, scaleY);
  };
  Point8.prototype.transform = function transform2(transformation) {
    var matrix = toMatrix(transformation);
    var ref2 = this;
    var x = ref2.x;
    var y = ref2.y;
    this.x = matrix.a * x + matrix.c * y + matrix.e;
    this.y = matrix.b * x + matrix.d * y + matrix.f;
    this.geometryChange();
    return this;
  };
  Point8.prototype.transformCopy = function transformCopy(transformation) {
    var point2 = this.clone();
    if (transformation) {
      point2.transform(transformation);
    }
    return point2;
  };
  Point8.prototype.distanceTo = function distanceTo(point2) {
    var dx = this.x - point2.x;
    var dy = this.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point8.prototype.round = function round$1(digits) {
    this.x = round2(this.x, digits);
    this.y = round2(this.y, digits);
    this.geometryChange();
    return this;
  };
  Point8.prototype.toArray = function toArray(digits) {
    var doRound = defined(digits);
    var x = doRound ? round2(this.x, digits) : this.x;
    var y = doRound ? round2(this.y, digits) : this.y;
    return [x, y];
  };
  Point8.prototype.toString = function toString3(digits, separator) {
    if (separator === void 0)
      separator = " ";
    var ref2 = this;
    var x = ref2.x;
    var y = ref2.y;
    if (defined(digits)) {
      x = round2(x, digits);
      y = round2(y, digits);
    }
    return x + separator + y;
  };
  Point8.create = function create3(arg0, arg1) {
    if (defined(arg0)) {
      if (arg0 instanceof Point8) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new Point8(arg0[0], arg0[1]);
      }
      return new Point8(arg0, arg1);
    }
  };
  Point8.min = function min3() {
    var arguments$1 = arguments;
    var minX = MAX_NUM;
    var minY = MAX_NUM;
    for (var i = 0; i < arguments.length; i++) {
      var point2 = arguments$1[i];
      minX = Math.min(point2.x, minX);
      minY = Math.min(point2.y, minY);
    }
    return new Point8(minX, minY);
  };
  Point8.max = function max2() {
    var arguments$1 = arguments;
    var maxX = MIN_NUM;
    var maxY = MIN_NUM;
    for (var i = 0; i < arguments.length; i++) {
      var point2 = arguments$1[i];
      maxX = Math.max(point2.x, maxX);
      maxY = Math.max(point2.y, maxY);
    }
    return new Point8(maxX, maxY);
  };
  Point8.minPoint = function minPoint() {
    return new Point8(MIN_NUM, MIN_NUM);
  };
  Point8.maxPoint = function maxPoint() {
    return new Point8(MAX_NUM, MAX_NUM);
  };
  staticAccessors2.ZERO.get = function() {
    return new Point8(0, 0);
  };
  Object.defineProperties(Point8, staticAccessors2);
  return Point8;
}(with_accessors_default(has_observers_default, ["x", "y"]));
var point_default = Point;

// node_modules/@progress/kendo-drawing/dist/es/geometry/size.js
var Size = function(superclass) {
  function Size2(width, height) {
    superclass.call(this);
    this.width = width || 0;
    this.height = height || 0;
  }
  if (superclass)
    Size2.__proto__ = superclass;
  Size2.prototype = Object.create(superclass && superclass.prototype);
  Size2.prototype.constructor = Size2;
  var staticAccessors2 = { ZERO: { configurable: true } };
  Size2.prototype.equals = function equals(other) {
    return other && other.width === this.width && other.height === this.height;
  };
  Size2.prototype.clone = function clone2() {
    return new Size2(this.width, this.height);
  };
  Size2.prototype.toArray = function toArray(digits) {
    var doRound = defined(digits);
    var width = doRound ? round2(this.width, digits) : this.width;
    var height = doRound ? round2(this.height, digits) : this.height;
    return [width, height];
  };
  Size2.create = function create3(arg0, arg1) {
    if (defined(arg0)) {
      if (arg0 instanceof Size2) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new Size2(arg0[0], arg0[1]);
      }
      return new Size2(arg0, arg1);
    }
  };
  staticAccessors2.ZERO.get = function() {
    return new Size2(0, 0);
  };
  Object.defineProperties(Size2, staticAccessors2);
  return Size2;
}(with_accessors_default(has_observers_default, ["width", "height"]));
var size_default = Size;

// node_modules/@progress/kendo-drawing/dist/es/geometry/rect.js
var Rect = function(HasObservers2) {
  function Rect3(origin, size, cornerRadius) {
    if (origin === void 0)
      origin = new point_default();
    if (size === void 0)
      size = new size_default();
    if (cornerRadius === void 0)
      cornerRadius = 0;
    HasObservers2.call(this);
    this.setOrigin(origin);
    this.setSize(size);
    this.setCornerRadius(cornerRadius);
  }
  if (HasObservers2)
    Rect3.__proto__ = HasObservers2;
  Rect3.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Rect3.prototype.constructor = Rect3;
  Rect3.prototype.clone = function clone2() {
    return new Rect3(
      this.origin.clone(),
      this.size.clone()
    );
  };
  Rect3.prototype.equals = function equals(other) {
    return other && other.origin.equals(this.origin) && other.size.equals(this.size);
  };
  Rect3.prototype.setOrigin = function setOrigin(value) {
    this._observerField("origin", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Rect3.prototype.getOrigin = function getOrigin() {
    return this.origin;
  };
  Rect3.prototype.setCornerRadius = function setCornerRadius(radius) {
    this.cornerRadius = Array.isArray(radius) ? radius : [radius, radius];
    this.geometryChange();
    return this;
  };
  Rect3.prototype.getCornerRadius = function getCornerRadius() {
    return this.cornerRadius;
  };
  Rect3.prototype.setSize = function setSize(value) {
    this._observerField("size", size_default.create(value));
    this.geometryChange();
    return this;
  };
  Rect3.prototype.getSize = function getSize() {
    return this.size;
  };
  Rect3.prototype.width = function width() {
    return this.size.width;
  };
  Rect3.prototype.height = function height() {
    return this.size.height;
  };
  Rect3.prototype.topLeft = function topLeft() {
    return this.origin.clone();
  };
  Rect3.prototype.bottomRight = function bottomRight() {
    return this.origin.clone().translate(this.width(), this.height());
  };
  Rect3.prototype.topRight = function topRight() {
    return this.origin.clone().translate(this.width(), 0);
  };
  Rect3.prototype.bottomLeft = function bottomLeft() {
    return this.origin.clone().translate(0, this.height());
  };
  Rect3.prototype.center = function center() {
    return this.origin.clone().translate(this.width() / 2, this.height() / 2);
  };
  Rect3.prototype.bbox = function bbox(matrix) {
    var tl = this.topLeft().transformCopy(matrix);
    var tr = this.topRight().transformCopy(matrix);
    var br = this.bottomRight().transformCopy(matrix);
    var bl = this.bottomLeft().transformCopy(matrix);
    return Rect3.fromPoints(tl, tr, br, bl);
  };
  Rect3.prototype.transformCopy = function transformCopy(m) {
    return Rect3.fromPoints(
      this.topLeft().transform(m),
      this.bottomRight().transform(m)
    );
  };
  Rect3.prototype.expand = function expand(x, y) {
    if (y === void 0)
      y = x;
    this.size.width += 2 * x;
    this.size.height += 2 * y;
    this.origin.translate(-x, -y);
    return this;
  };
  Rect3.prototype.expandCopy = function expandCopy(x, y) {
    return this.clone().expand(x, y);
  };
  Rect3.prototype.containsPoint = function containsPoint(point2) {
    var origin = this.origin;
    var bottomRight = this.bottomRight();
    return !(point2.x < origin.x || point2.y < origin.y || bottomRight.x < point2.x || bottomRight.y < point2.y);
  };
  Rect3.prototype._isOnPath = function _isOnPath(point2, width) {
    var rectOuter = this.expandCopy(width, width);
    var rectInner = this.expandCopy(-width, -width);
    return rectOuter.containsPoint(point2) && !rectInner.containsPoint(point2);
  };
  Rect3.fromPoints = function fromPoints() {
    var topLeft = point_default.min.apply(null, arguments);
    var bottomRight = point_default.max.apply(null, arguments);
    var size = new size_default(
      bottomRight.x - topLeft.x,
      bottomRight.y - topLeft.y
    );
    return new Rect3(topLeft, size);
  };
  Rect3.union = function union(a, b) {
    return Rect3.fromPoints(
      point_default.min(a.topLeft(), b.topLeft()),
      point_default.max(a.bottomRight(), b.bottomRight())
    );
  };
  Rect3.intersect = function intersect(a, b) {
    var rect1 = {
      left: a.topLeft().x,
      top: a.topLeft().y,
      right: a.bottomRight().x,
      bottom: a.bottomRight().y
    };
    var rect2 = {
      left: b.topLeft().x,
      top: b.topLeft().y,
      right: b.bottomRight().x,
      bottom: b.bottomRight().y
    };
    if (rect1.left <= rect2.right && rect2.left <= rect1.right && rect1.top <= rect2.bottom && rect2.top <= rect1.bottom) {
      return Rect3.fromPoints(
        new point_default(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)),
        new point_default(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom))
      );
    }
  };
  return Rect3;
}(has_observers_default);
var rect_default = Rect;

// node_modules/@progress/kendo-drawing/dist/es/geometry/transformation.js
var Transformation = function(HasObservers2) {
  function Transformation2(matrix) {
    if (matrix === void 0)
      matrix = matrix_default.unit();
    HasObservers2.call(this);
    this._matrix = matrix;
  }
  if (HasObservers2)
    Transformation2.__proto__ = HasObservers2;
  Transformation2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Transformation2.prototype.constructor = Transformation2;
  Transformation2.prototype.clone = function clone2() {
    return new Transformation2(
      this._matrix.clone()
    );
  };
  Transformation2.prototype.equals = function equals(other) {
    return other && other._matrix.equals(this._matrix);
  };
  Transformation2.prototype.translate = function translate2(x, y) {
    this._matrix = this._matrix.multiplyCopy(matrix_default.translate(x, y));
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.scale = function scale(scaleX, scaleY, origin) {
    if (scaleY === void 0)
      scaleY = scaleX;
    if (origin === void 0)
      origin = null;
    var originPoint = origin;
    if (originPoint) {
      originPoint = point_default.create(originPoint);
      this._matrix = this._matrix.multiplyCopy(matrix_default.translate(originPoint.x, originPoint.y));
    }
    this._matrix = this._matrix.multiplyCopy(matrix_default.scale(scaleX, scaleY));
    if (originPoint) {
      this._matrix = this._matrix.multiplyCopy(matrix_default.translate(-originPoint.x, -originPoint.y));
    }
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.rotate = function rotate(angle, origin) {
    var originPoint = point_default.create(origin) || point_default.ZERO;
    this._matrix = this._matrix.multiplyCopy(matrix_default.rotate(angle, originPoint.x, originPoint.y));
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.multiply = function multiply(transformation) {
    var matrix = toMatrix(transformation);
    this._matrix = this._matrix.multiplyCopy(matrix);
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.matrix = function matrix(value) {
    if (value) {
      this._matrix = value;
      this._optionsChange();
      return this;
    }
    return this._matrix;
  };
  Transformation2.prototype._optionsChange = function _optionsChange() {
    this.optionsChange({
      field: "transform",
      value: this
    });
  };
  return Transformation2;
}(has_observers_default);
var transformation_default = Transformation;

// node_modules/@progress/kendo-drawing/dist/es/geometry/transform.js
function transform(matrix) {
  if (matrix === null) {
    return null;
  }
  if (matrix instanceof transformation_default) {
    return matrix;
  }
  return new transformation_default(matrix);
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/element.js
var Element = function(HasObservers2) {
  function Element2(options2) {
    HasObservers2.call(this);
    this._initOptions(options2);
  }
  if (HasObservers2)
    Element2.__proto__ = HasObservers2;
  Element2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Element2.prototype.constructor = Element2;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Rect";
  };
  Element2.prototype._initOptions = function _initOptions(options2) {
    if (options2 === void 0)
      options2 = {};
    var clip = options2.clip;
    var transform2 = options2.transform;
    if (transform2) {
      options2.transform = transform(transform2);
    }
    if (clip && !clip.id) {
      clip.id = definitionId();
    }
    this.options = new options_store_default(options2);
    this.options.addObserver(this);
  };
  Element2.prototype.transform = function transform2(value) {
    if (defined(value)) {
      this.options.set("transform", transform(value));
    } else {
      return this.options.get("transform");
    }
  };
  Element2.prototype.parentTransform = function parentTransform() {
    var element2 = this;
    var parentMatrix;
    while (element2.parent) {
      element2 = element2.parent;
      var transformation = element2.transform();
      if (transformation) {
        parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || matrix_default.unit());
      }
    }
    if (parentMatrix) {
      return transform(parentMatrix);
    }
  };
  Element2.prototype.currentTransform = function currentTransform(parentTransform) {
    if (parentTransform === void 0)
      parentTransform = this.parentTransform();
    var elementTransform = this.transform();
    var elementMatrix = toMatrix(elementTransform);
    var parentMatrix = toMatrix(parentTransform);
    var combinedMatrix;
    if (elementMatrix && parentMatrix) {
      combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);
    } else {
      combinedMatrix = elementMatrix || parentMatrix;
    }
    if (combinedMatrix) {
      return transform(combinedMatrix);
    }
  };
  Element2.prototype.visible = function visible(value) {
    if (defined(value)) {
      this.options.set("visible", value);
      return this;
    }
    return this.options.get("visible") !== false;
  };
  Element2.prototype.clip = function clip(value) {
    var options2 = this.options;
    if (defined(value)) {
      if (value && !value.id) {
        value.id = definitionId();
      }
      options2.set("clip", value);
      return this;
    }
    return options2.get("clip");
  };
  Element2.prototype.opacity = function opacity(value) {
    if (defined(value)) {
      this.options.set("opacity", value);
      return this;
    }
    return valueOrDefault(this.options.get("opacity"), 1);
  };
  Element2.prototype.clippedBBox = function clippedBBox(transformation) {
    var bbox = this._clippedBBox(transformation);
    if (bbox) {
      var clip = this.clip();
      return clip ? rect_default.intersect(bbox, clip.bbox(transformation)) : bbox;
    }
  };
  Element2.prototype.containsPoint = function containsPoint(point2, parentTransform) {
    if (this.visible()) {
      var transform2 = this.currentTransform(parentTransform);
      var transformedPoint = point2;
      if (transform2) {
        transformedPoint = point2.transformCopy(transform2.matrix().invert());
      }
      return this._hasFill() && this._containsPoint(transformedPoint) || this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint);
    }
    return false;
  };
  Element2.prototype._hasFill = function _hasFill() {
    var fill = this.options.fill;
    return fill && !isTransparent(fill.color);
  };
  Element2.prototype._hasStroke = function _hasStroke() {
    var stroke = this.options.stroke;
    return stroke && stroke.width > 0 && !isTransparent(stroke.color);
  };
  Element2.prototype._clippedBBox = function _clippedBBox(transformation) {
    return this.bbox(transformation);
  };
  Object.defineProperties(Element2.prototype, prototypeAccessors4);
  return Element2;
}(has_observers_default);
var element_default = Element;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/ellipse-extreme-angles.js
function ellipseExtremeAngles(center, rx, ry, matrix) {
  var extremeX = 0;
  var extremeY = 0;
  if (matrix) {
    extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);
    if (matrix.b !== 0) {
      extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);
    }
  }
  return {
    x: extremeX,
    y: extremeY
  };
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/circle.js
var PI_DIV_2 = Math.PI / 2;
var Circle = function(superclass) {
  function Circle4(center, radius) {
    if (center === void 0)
      center = new point_default();
    if (radius === void 0)
      radius = 0;
    superclass.call(this);
    this.setCenter(center);
    this.setRadius(radius);
  }
  if (superclass)
    Circle4.__proto__ = superclass;
  Circle4.prototype = Object.create(superclass && superclass.prototype);
  Circle4.prototype.constructor = Circle4;
  Circle4.prototype.setCenter = function setCenter(value) {
    this._observerField("center", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Circle4.prototype.getCenter = function getCenter() {
    return this.center;
  };
  Circle4.prototype.equals = function equals(other) {
    return other && other.center.equals(this.center) && other.radius === this.radius;
  };
  Circle4.prototype.clone = function clone2() {
    return new Circle4(this.center.clone(), this.radius);
  };
  Circle4.prototype.pointAt = function pointAt(angle) {
    return this._pointAt(rad(angle));
  };
  Circle4.prototype.bbox = function bbox(matrix) {
    var this$1 = this;
    var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);
    var minPoint = point_default.maxPoint();
    var maxPoint = point_default.minPoint();
    for (var i = 0; i < 4; i++) {
      var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);
      var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);
      var currentPoint = new point_default(currentPointX.x, currentPointY.y);
      minPoint = point_default.min(minPoint, currentPoint);
      maxPoint = point_default.max(maxPoint, currentPoint);
    }
    return rect_default.fromPoints(minPoint, maxPoint);
  };
  Circle4.prototype._pointAt = function _pointAt(angle) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    return new point_default(
      center.x + radius * Math.cos(angle),
      center.y + radius * Math.sin(angle)
    );
  };
  Circle4.prototype.containsPoint = function containsPoint(point2) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    var inCircle = Math.pow(point2.x - center.x, 2) + Math.pow(point2.y - center.y, 2) <= Math.pow(radius, 2);
    return inCircle;
  };
  Circle4.prototype._isOnPath = function _isOnPath(point2, width) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    var pointDistance = center.distanceTo(point2);
    return radius - width <= pointDistance && pointDistance <= radius + width;
  };
  return Circle4;
}(with_accessors_default(has_observers_default, ["radius"]));
var circle_default = Circle;

// node_modules/@progress/kendo-drawing/dist/es/mixins/paintable.js
var GRADIENT = "Gradient";
var paintable = function(TBase) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.fill = function fill(color, opacity) {
      var options2 = this.options;
      if (defined(color)) {
        if (color && color.nodeType !== GRADIENT) {
          var newFill = {
            color
          };
          if (defined(opacity)) {
            newFill.opacity = opacity;
          }
          options2.set("fill", newFill);
        } else {
          options2.set("fill", color);
        }
        return this;
      }
      return options2.get("fill");
    };
    anonymous.prototype.stroke = function stroke(color, width, opacity) {
      if (defined(color)) {
        this.options.set("stroke.color", color);
        if (defined(width)) {
          this.options.set("stroke.width", width);
        }
        if (defined(opacity)) {
          this.options.set("stroke.opacity", opacity);
        }
        return this;
      }
      return this.options.get("stroke");
    };
    return anonymous;
  }(TBase);
};
var paintable_default = paintable;

// node_modules/@progress/kendo-drawing/dist/es/mixins/measurable.js
var IDENTITY_MATRIX_HASH = matrix_default.IDENTITY.toString();
var measurable = function(TBase) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.bbox = function bbox(transformation) {
      var combinedMatrix = toMatrix(this.currentTransform(transformation));
      var matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;
      var bbox2;
      if (this._bboxCache && this._matrixHash === matrixHash) {
        bbox2 = this._bboxCache.clone();
      } else {
        bbox2 = this._bbox(combinedMatrix);
        this._bboxCache = bbox2 ? bbox2.clone() : null;
        this._matrixHash = matrixHash;
      }
      var strokeWidth = this.options.get("stroke.width");
      if (strokeWidth && bbox2) {
        bbox2.expand(strokeWidth / 2);
      }
      return bbox2;
    };
    anonymous.prototype.geometryChange = function geometryChange() {
      delete this._bboxCache;
      this.trigger("geometryChange", {
        element: this
      });
    };
    return anonymous;
  }(TBase);
};
var measurable_default = measurable;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-geometry.js
function geometryAccessor(name2) {
  var fieldName = "_" + name2;
  return function(value) {
    if (defined(value)) {
      this._observerField(fieldName, value);
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function defineGeometryAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = geometryAccessor(names[i]);
  }
}
var withGeometry = function(TBase, names) {
  if (names === void 0)
    names = ["geometry"];
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineGeometryAccessors(result.prototype, names);
  return result;
};
var with_geometry_default = withGeometry;

// node_modules/@progress/kendo-drawing/dist/es/shapes/circle.js
var DEFAULT_STROKE = "#000";
var Circle2 = function(superclass) {
  function Circle4(geometry, options2) {
    if (geometry === void 0)
      geometry = new circle_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke(DEFAULT_STROKE);
    }
  }
  if (superclass)
    Circle4.__proto__ = superclass;
  Circle4.prototype = Object.create(superclass && superclass.prototype);
  Circle4.prototype.constructor = Circle4;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Circle";
  };
  Circle4.prototype.rawBBox = function rawBBox() {
    return this._geometry.bbox();
  };
  Circle4.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Circle4.prototype._containsPoint = function _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  };
  Circle4.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Circle4.prototype, prototypeAccessors4);
  return Circle4;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var circle_default2 = Circle2;

// node_modules/@progress/kendo-drawing/dist/es/geometry/constants.js
var PRECISION = 10;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/close.js
function close(a, b, tolerance) {
  if (tolerance === void 0)
    tolerance = PRECISION;
  return round2(Math.abs(a - b), tolerance) === 0;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/close-or-less.js
function closeOrLess(a, b, tolerance) {
  return a < b || close(a, b, tolerance);
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/line-intersection.js
function lineIntersection(p0, p1, p2, p3) {
  var s1x = p1.x - p0.x;
  var s2x = p3.x - p2.x;
  var s1y = p1.y - p0.y;
  var s2y = p3.y - p2.y;
  var nx = p0.x - p2.x;
  var ny = p0.y - p2.y;
  var d = s1x * s2y - s2x * s1y;
  var s = (s1x * ny - s1y * nx) / d;
  var t = (s2x * ny - s2y * nx) / d;
  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
    return new point_default(p0.x + t * s1x, p0.y + t * s1y);
  }
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/arc.js
var MAX_INTERVAL = 45;
var pow2 = Math.pow;
var accessors = ["radiusX", "radiusY", "startAngle", "endAngle", "anticlockwise"];
var Arc = function(superclass) {
  function Arc4(center, options2) {
    if (center === void 0)
      center = new point_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this);
    this.setCenter(center);
    this.radiusX = options2.radiusX;
    this.radiusY = options2.radiusY || options2.radiusX;
    this.startAngle = options2.startAngle;
    this.endAngle = options2.endAngle;
    this.anticlockwise = options2.anticlockwise || false;
    this.xRotation = options2.xRotation;
  }
  if (superclass)
    Arc4.__proto__ = superclass;
  Arc4.prototype = Object.create(superclass && superclass.prototype);
  Arc4.prototype.constructor = Arc4;
  Arc4.prototype.clone = function clone2() {
    return new Arc4(this.center, {
      radiusX: this.radiusX,
      radiusY: this.radiusY,
      startAngle: this.startAngle,
      endAngle: this.endAngle,
      anticlockwise: this.anticlockwise
    });
  };
  Arc4.prototype.setCenter = function setCenter(value) {
    this._observerField("center", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Arc4.prototype.getCenter = function getCenter() {
    return this.center;
  };
  Arc4.prototype.pointAt = function pointAt(angle) {
    var center = this.center;
    var radian = rad(angle);
    return new point_default(
      center.x + this.radiusX * Math.cos(radian),
      center.y + this.radiusY * Math.sin(radian)
    );
  };
  Arc4.prototype.curvePoints = function curvePoints() {
    var this$1 = this;
    var startAngle = this.startAngle;
    var dir = this.anticlockwise ? -1 : 1;
    var curvePoints2 = [this.pointAt(startAngle)];
    var interval = this._arcInterval();
    var intervalAngle = interval.endAngle - interval.startAngle;
    var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);
    var subIntervalAngle = intervalAngle / subIntervalsCount;
    var currentAngle = startAngle;
    var transformation;
    if (this.xRotation) {
      transformation = transform().rotate(this.xRotation, this.center);
    }
    for (var i = 1; i <= subIntervalsCount; i++) {
      var nextAngle = currentAngle + dir * subIntervalAngle;
      var points3 = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);
      curvePoints2.push(points3.cp1, points3.cp2, points3.p2);
      currentAngle = nextAngle;
    }
    return curvePoints2;
  };
  Arc4.prototype.bbox = function bbox(matrix) {
    var this$1 = this;
    var interval = this._arcInterval();
    var startAngle = interval.startAngle;
    var endAngle = interval.endAngle;
    var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);
    var extremeX = deg(extremeAngles.x);
    var extremeY = deg(extremeAngles.y);
    var endPoint = this.pointAt(endAngle).transformCopy(matrix);
    var currentAngleX = bboxStartAngle(extremeX, startAngle);
    var currentAngleY = bboxStartAngle(extremeY, startAngle);
    var currentPoint = this.pointAt(startAngle).transformCopy(matrix);
    var minPoint = point_default.min(currentPoint, endPoint);
    var maxPoint = point_default.max(currentPoint, endPoint);
    while (currentAngleX < endAngle || currentAngleY < endAngle) {
      var currentPointX = void 0;
      if (currentAngleX < endAngle) {
        currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);
        currentAngleX += 90;
      }
      var currentPointY = void 0;
      if (currentAngleY < endAngle) {
        currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);
        currentAngleY += 90;
      }
      currentPoint = new point_default(currentPointX.x, currentPointY.y);
      minPoint = point_default.min(minPoint, currentPoint);
      maxPoint = point_default.max(maxPoint, currentPoint);
    }
    return rect_default.fromPoints(minPoint, maxPoint);
  };
  Arc4.prototype._arcInterval = function _arcInterval() {
    var ref2 = this;
    var startAngle = ref2.startAngle;
    var endAngle = ref2.endAngle;
    var anticlockwise = ref2.anticlockwise;
    if (anticlockwise) {
      var oldStart = startAngle;
      startAngle = endAngle;
      endAngle = oldStart;
    }
    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {
      endAngle += 360;
    }
    return {
      startAngle,
      endAngle
    };
  };
  Arc4.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {
    var p1 = this.pointAt(startAngle);
    var p2 = this.pointAt(endAngle);
    var p1Derivative = this._derivativeAt(startAngle);
    var p2Derivative = this._derivativeAt(endAngle);
    var t = (rad(endAngle) - rad(startAngle)) / 3;
    var cp1 = new point_default(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);
    var cp2 = new point_default(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);
    if (transformation) {
      p1.transform(transformation);
      p2.transform(transformation);
      cp1.transform(transformation);
      cp2.transform(transformation);
    }
    return {
      p1,
      cp1,
      cp2,
      p2
    };
  };
  Arc4.prototype._derivativeAt = function _derivativeAt(angle) {
    var radian = rad(angle);
    return new point_default(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));
  };
  Arc4.prototype.containsPoint = function containsPoint(point2) {
    var interval = this._arcInterval();
    var intervalAngle = interval.endAngle - interval.startAngle;
    var ref2 = this;
    var center = ref2.center;
    var radiusX = ref2.radiusX;
    var radiusY = ref2.radiusY;
    var distance = center.distanceTo(point2);
    var angleRad = Math.atan2(point2.y - center.y, point2.x - center.x);
    var pointRadius = radiusX * radiusY / Math.sqrt(pow2(radiusX, 2) * pow2(Math.sin(angleRad), 2) + pow2(radiusY, 2) * pow2(Math.cos(angleRad), 2));
    var startPoint = this.pointAt(this.startAngle).round(PRECISION);
    var endPoint = this.pointAt(this.endAngle).round(PRECISION);
    var intersection2 = lineIntersection(center, point2.round(PRECISION), startPoint, endPoint);
    var containsPoint2;
    if (intervalAngle < 180) {
      containsPoint2 = intersection2 && closeOrLess(center.distanceTo(intersection2), distance) && closeOrLess(distance, pointRadius);
    } else {
      var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point2.x, point2.y);
      if (angle !== 360) {
        angle = (360 + angle) % 360;
      }
      var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
      containsPoint2 = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection2 || intersection2.equals(point2));
    }
    return containsPoint2;
  };
  Arc4.prototype._isOnPath = function _isOnPath(point2, width) {
    var interval = this._arcInterval();
    var center = this.center;
    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point2.x, point2.y);
    if (angle !== 360) {
      angle = (360 + angle) % 360;
    }
    var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
    return inAngleRange && this.pointAt(angle).distanceTo(point2) <= width;
  };
  Arc4.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {
    var arcParameters = normalizeArcParameters({
      x1: start.x,
      y1: start.y,
      x2: end.x,
      y2: end.y,
      rx,
      ry,
      largeArc,
      swipe,
      rotation
    });
    return new Arc4(arcParameters.center, {
      startAngle: arcParameters.startAngle,
      endAngle: arcParameters.endAngle,
      radiusX: arcParameters.radiusX,
      radiusY: arcParameters.radiusY,
      xRotation: arcParameters.xRotation,
      anticlockwise: swipe === 0
    });
  };
  return Arc4;
}(with_accessors_default(has_observers_default, accessors));
function calculateAngle(cx, cy, rx, ry, x, y) {
  var cos2 = round2((x - cx) / rx, 3);
  var sin3 = round2((y - cy) / ry, 3);
  return round2(deg(Math.atan2(sin3, cos2)));
}
function normalizeArcParameters(parameters) {
  var x1 = parameters.x1;
  var y1 = parameters.y1;
  var x2 = parameters.x2;
  var y2 = parameters.y2;
  var rx = parameters.rx;
  var ry = parameters.ry;
  var largeArc = parameters.largeArc;
  var swipe = parameters.swipe;
  var rotation = parameters.rotation;
  if (rotation === void 0)
    rotation = 0;
  var radians = rad(rotation);
  var cosine = Math.cos(radians);
  var sine = Math.sin(radians);
  var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;
  var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;
  var sign = largeArc !== swipe ? 1 : -1;
  var xt2 = Math.pow(xT, 2);
  var yt2 = Math.pow(yT, 2);
  var rx2 = Math.pow(rx, 2);
  var ry2 = Math.pow(ry, 2);
  var delta = xt2 / rx2 + yt2 / ry2;
  if (delta > 1) {
    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);
    rx = delta * rx;
    rx2 = Math.pow(rx, 2);
    ry = delta * ry;
    ry2 = Math.pow(ry, 2);
  }
  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));
  if (isNaN(constT)) {
    constT = 0;
  }
  var cxT = constT * (rx * yT) / ry;
  var cyT = -constT * (ry * xT) / rx;
  var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;
  var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;
  var uX = (xT - cxT) / rx;
  var uY = (yT - cyT) / ry;
  var vX = -(xT + cxT) / rx;
  var vY = -(yT + cyT) / ry;
  var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));
  var angleCosine = round2((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);
  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));
  if (!swipe && angle > 0) {
    angle -= 360;
  }
  if (swipe && angle < 0) {
    angle += 360;
  }
  var endAngle = startAngle + angle;
  var signEndAngle = endAngle >= 0 ? 1 : -1;
  endAngle = Math.abs(endAngle) % 360 * signEndAngle;
  return {
    center: new point_default(cx, cy),
    startAngle,
    endAngle,
    radiusX: rx,
    radiusY: ry,
    xRotation: rotation
  };
}
function bboxStartAngle(angle, start) {
  var startAngle = angle;
  while (startAngle < start) {
    startAngle += 90;
  }
  return startAngle;
}
var arc_default = Arc;

// node_modules/@progress/kendo-drawing/dist/es/shapes/elements-array.js
var push = [].push;
var pop = [].pop;
var splice = [].splice;
var shift = [].shift;
var slice = [].slice;
var unshift = [].unshift;
var ElementsArray = function(HasObservers2) {
  function ElementsArray2(array) {
    if (array === void 0)
      array = [];
    HasObservers2.call(this);
    this.length = 0;
    this._splice(0, array.length, array);
  }
  if (HasObservers2)
    ElementsArray2.__proto__ = HasObservers2;
  ElementsArray2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  ElementsArray2.prototype.constructor = ElementsArray2;
  ElementsArray2.prototype.elements = function elements(value) {
    if (value) {
      this._splice(0, this.length, value);
      this._change();
      return this;
    }
    return this.slice(0);
  };
  ElementsArray2.prototype.push = function push$1() {
    var elements = arguments;
    var result = push.apply(this, elements);
    this._add(elements);
    return result;
  };
  ElementsArray2.prototype.slice = function slice$1() {
    return slice.call(this);
  };
  ElementsArray2.prototype.pop = function pop$1() {
    var length = this.length;
    var result = pop.apply(this);
    if (length) {
      this._remove([result]);
    }
    return result;
  };
  ElementsArray2.prototype.splice = function splice2(index, howMany) {
    var elements = slice.call(arguments, 2);
    var result = this._splice(index, howMany, elements);
    this._change();
    return result;
  };
  ElementsArray2.prototype.shift = function shift$1() {
    var length = this.length;
    var result = shift.apply(this);
    if (length) {
      this._remove([result]);
    }
    return result;
  };
  ElementsArray2.prototype.unshift = function unshift$1() {
    var elements = arguments;
    var result = unshift.apply(this, elements);
    this._add(elements);
    return result;
  };
  ElementsArray2.prototype.indexOf = function indexOf2(element2) {
    var this$1 = this;
    var length = this.length;
    for (var idx = 0; idx < length; idx++) {
      if (this$1[idx] === element2) {
        return idx;
      }
    }
    return -1;
  };
  ElementsArray2.prototype._splice = function _splice(index, howMany, elements) {
    var result = splice.apply(this, [index, howMany].concat(elements));
    this._clearObserver(result);
    this._setObserver(elements);
    return result;
  };
  ElementsArray2.prototype._add = function _add(elements) {
    this._setObserver(elements);
    this._change();
  };
  ElementsArray2.prototype._remove = function _remove(elements) {
    this._clearObserver(elements);
    this._change();
  };
  ElementsArray2.prototype._setObserver = function _setObserver(elements) {
    var this$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      elements[idx].addObserver(this$1);
    }
  };
  ElementsArray2.prototype._clearObserver = function _clearObserver(elements) {
    var this$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      elements[idx].removeObserver(this$1);
    }
  };
  ElementsArray2.prototype._change = function _change() {
  };
  return ElementsArray2;
}(has_observers_default);
var elements_array_default = ElementsArray;

// node_modules/@progress/kendo-drawing/dist/es/shapes/geometry-elements-array.js
var GeometryElementsArray = function(ElementsArray2) {
  function GeometryElementsArray2() {
    ElementsArray2.apply(this, arguments);
  }
  if (ElementsArray2)
    GeometryElementsArray2.__proto__ = ElementsArray2;
  GeometryElementsArray2.prototype = Object.create(ElementsArray2 && ElementsArray2.prototype);
  GeometryElementsArray2.prototype.constructor = GeometryElementsArray2;
  GeometryElementsArray2.prototype._change = function _change() {
    this.geometryChange();
  };
  return GeometryElementsArray2;
}(elements_array_default);
var geometry_elements_array_default = GeometryElementsArray;

// node_modules/@progress/kendo-drawing/dist/es/geometry.js
var geometry_exports = {};
__export(geometry_exports, {
  Arc: () => arc_default,
  Circle: () => circle_default,
  Matrix: () => matrix_default,
  Point: () => point_default,
  Rect: () => rect_default,
  Segment: () => segment_default,
  Size: () => size_default,
  Transformation: () => transformation_default,
  toMatrix: () => toMatrix,
  transform: () => transform
});

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/is-out-of-end-point.js
function isOutOfEndPoint(endPoint, controlPoint, point2) {
  var angle = deg(Math.atan2(controlPoint.y - endPoint.y, controlPoint.x - endPoint.x));
  var rotatedPoint = point2.transformCopy(transform().rotate(-angle, endPoint));
  return rotatedPoint.x < endPoint.x;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/calculate-curve-at.js
function calculateCurveAt(t, field, points3) {
  var t1 = 1 - t;
  return Math.pow(t1, 3) * points3[0][field] + 3 * Math.pow(t1, 2) * t * points3[1][field] + 3 * Math.pow(t, 2) * t1 * points3[2][field] + Math.pow(t, 3) * points3[3][field];
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/to-cubic-polynomial.js
function toCubicPolynomial(points3, field) {
  return [
    -points3[0][field] + 3 * points3[1][field] - 3 * points3[2][field] + points3[3][field],
    3 * (points3[0][field] - 2 * points3[1][field] + points3[2][field]),
    3 * (-points3[0][field] + points3[1][field]),
    points3[0][field]
  ];
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/complex-number.js
var ComplexNumber = function(Class3) {
  function ComplexNumber2(real, img) {
    if (real === void 0)
      real = 0;
    if (img === void 0)
      img = 0;
    Class3.call(this);
    this.real = real;
    this.img = img;
  }
  if (Class3)
    ComplexNumber2.__proto__ = Class3;
  ComplexNumber2.prototype = Object.create(Class3 && Class3.prototype);
  ComplexNumber2.prototype.constructor = ComplexNumber2;
  ComplexNumber2.prototype.add = function add3(cNumber) {
    return new ComplexNumber2(round2(this.real + cNumber.real, PRECISION), round2(this.img + cNumber.img, PRECISION));
  };
  ComplexNumber2.prototype.addConstant = function addConstant(value) {
    return new ComplexNumber2(this.real + value, this.img);
  };
  ComplexNumber2.prototype.negate = function negate() {
    return new ComplexNumber2(-this.real, -this.img);
  };
  ComplexNumber2.prototype.multiply = function multiply(cNumber) {
    return new ComplexNumber2(
      this.real * cNumber.real - this.img * cNumber.img,
      this.real * cNumber.img + this.img * cNumber.real
    );
  };
  ComplexNumber2.prototype.multiplyConstant = function multiplyConstant(value) {
    return new ComplexNumber2(this.real * value, this.img * value);
  };
  ComplexNumber2.prototype.nthRoot = function nthRoot(n) {
    var rad3 = Math.atan2(this.img, this.real);
    var r = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));
    var nthR = Math.pow(r, 1 / n);
    return new ComplexNumber2(nthR * Math.cos(rad3 / n), nthR * Math.sin(rad3 / n));
  };
  ComplexNumber2.prototype.equals = function equals(cNumber) {
    return this.real === cNumber.real && this.img === cNumber.img;
  };
  ComplexNumber2.prototype.isReal = function isReal() {
    return this.img === 0;
  };
  return ComplexNumber2;
}(class_default);
var complex_number_default = ComplexNumber;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/solve-cubic-equation.js
function numberSign(x) {
  return x < 0 ? -1 : 1;
}
function solveQuadraticEquation(a, b, c) {
  var squareRoot = Math.sqrt(Math.pow(b, 2) - 4 * a * c);
  return [
    (-b + squareRoot) / (2 * a),
    (-b - squareRoot) / (2 * a)
  ];
}
function solveCubicEquation(a, b, c, d) {
  if (a === 0) {
    return solveQuadraticEquation(b, c, d);
  }
  var p = (3 * a * c - Math.pow(b, 2)) / (3 * Math.pow(a, 2));
  var q = (2 * Math.pow(b, 3) - 9 * a * b * c + 27 * Math.pow(a, 2) * d) / (27 * Math.pow(a, 3));
  var Q = Math.pow(p / 3, 3) + Math.pow(q / 2, 2);
  var i = new complex_number_default(0, 1);
  var b3a = -b / (3 * a);
  var x1, x2, y1, y2, y3, z1, z2;
  if (Q < 0) {
    x1 = new complex_number_default(-q / 2, Math.sqrt(-Q)).nthRoot(3);
    x2 = new complex_number_default(-q / 2, -Math.sqrt(-Q)).nthRoot(3);
  } else {
    x1 = -q / 2 + Math.sqrt(Q);
    x1 = new complex_number_default(numberSign(x1) * Math.pow(Math.abs(x1), 1 / 3));
    x2 = -q / 2 - Math.sqrt(Q);
    x2 = new complex_number_default(numberSign(x2) * Math.pow(Math.abs(x2), 1 / 3));
  }
  y1 = x1.add(x2);
  z1 = x1.add(x2).multiplyConstant(-1 / 2);
  z2 = x1.add(x2.negate()).multiplyConstant(Math.sqrt(3) / 2);
  y2 = z1.add(i.multiply(z2));
  y3 = z1.add(i.negate().multiply(z2));
  var result = [];
  if (y1.isReal()) {
    result.push(round2(y1.real + b3a, PRECISION));
  }
  if (y2.isReal()) {
    result.push(round2(y2.real + b3a, PRECISION));
  }
  if (y3.isReal()) {
    result.push(round2(y3.real + b3a, PRECISION));
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/has-roots-in-range.js
function hasRootsInRange(points3, point2, field, rootField, range) {
  var polynomial = toCubicPolynomial(points3, rootField);
  var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2[rootField]);
  var intersection2;
  for (var idx = 0; idx < roots.length; idx++) {
    if (0 <= roots[idx] && roots[idx] <= 1) {
      intersection2 = calculateCurveAt(roots[idx], field, points3);
      if (Math.abs(intersection2 - point2[field]) <= range) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/curve-intersections-count.js
function curveIntersectionsCount(points3, point2, bbox) {
  var polynomial = toCubicPolynomial(points3, "x");
  var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2.x);
  var rayIntersection, intersectsRay;
  var count = 0;
  for (var i = 0; i < roots.length; i++) {
    rayIntersection = calculateCurveAt(roots[i], "y", points3);
    intersectsRay = close(rayIntersection, point2.y) || rayIntersection > point2.y;
    if (intersectsRay && ((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point2.x || 0 < roots[i] && roots[i] < 1)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/line-intersections-count.js
function lineIntersectionsCount(a, b, point2) {
  var intersects;
  if (a.x !== b.x) {
    var minX = Math.min(a.x, b.x);
    var maxX = Math.max(a.x, b.x);
    var minY = Math.min(a.y, b.y);
    var maxY = Math.max(a.y, b.y);
    var inRange = minX <= point2.x && point2.x < maxX;
    if (minY === maxY) {
      intersects = point2.y <= minY && inRange;
    } else {
      intersects = inRange && (maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point2.x - minX : maxX - point2.x) / (maxX - minX) + minY - point2.y >= 0;
    }
  }
  return intersects ? 1 : 0;
}

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-points.js
function pointAccessor(name2) {
  var fieldName = "_" + name2;
  return function(value) {
    if (defined(value)) {
      this._observerField(fieldName, point_default.create(value));
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function definePointAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = pointAccessor(names[i]);
  }
}
var withPoints = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  definePointAccessors(result.prototype, names);
  return result;
};
var with_points_default = withPoints;

// node_modules/@progress/kendo-drawing/dist/es/geometry/segment.js
var points = ["anchor", "controlIn", "controlOut"];
var Segment = function(superclass) {
  function Segment2(anchor, controlIn, controlOut) {
    superclass.call(this);
    this.anchor(anchor || new point_default());
    this.controlIn(controlIn);
    this.controlOut(controlOut);
  }
  if (superclass)
    Segment2.__proto__ = superclass;
  Segment2.prototype = Object.create(superclass && superclass.prototype);
  Segment2.prototype.constructor = Segment2;
  Segment2.prototype.bboxTo = function bboxTo(toSegment, matrix) {
    var segmentAnchor = this.anchor().transformCopy(matrix);
    var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);
    var rect;
    if (this.controlOut() && toSegment.controlIn()) {
      rect = this._curveBoundingBox(
        segmentAnchor,
        this.controlOut().transformCopy(matrix),
        toSegment.controlIn().transformCopy(matrix),
        toSegmentAnchor
      );
    } else {
      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);
    }
    return rect;
  };
  Segment2.prototype._lineBoundingBox = function _lineBoundingBox(p1, p2) {
    return rect_default.fromPoints(p1, p2);
  };
  Segment2.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p2) {
    var points3 = [p1, cp1, cp2, p2];
    var extremesX = this._curveExtremesFor(points3, "x");
    var extremesY = this._curveExtremesFor(points3, "y");
    var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);
    var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);
    return rect_default.fromPoints(new point_default(xLimits.min, yLimits.min), new point_default(xLimits.max, yLimits.max));
  };
  Segment2.prototype._curveExtremesFor = function _curveExtremesFor(points3, field) {
    var extremes = this._curveExtremes(
      points3[0][field],
      points3[1][field],
      points3[2][field],
      points3[3][field]
    );
    return {
      min: calculateCurveAt(extremes.min, field, points3),
      max: calculateCurveAt(extremes.max, field, points3)
    };
  };
  Segment2.prototype._curveExtremes = function _curveExtremes(x1, x2, x3, x4) {
    var a = x1 - 3 * x2 + 3 * x3 - x4;
    var b = -2 * (x1 - 2 * x2 + x3);
    var c = x1 - x2;
    var sqrt = Math.sqrt(b * b - 4 * a * c);
    var t1 = 0;
    var t2 = 1;
    if (a === 0) {
      if (b !== 0) {
        t1 = t2 = -c / b;
      }
    } else if (!isNaN(sqrt)) {
      t1 = (-b + sqrt) / (2 * a);
      t2 = (-b - sqrt) / (2 * a);
    }
    var min3 = Math.max(Math.min(t1, t2), 0);
    if (min3 < 0 || min3 > 1) {
      min3 = 0;
    }
    var max2 = Math.min(Math.max(t1, t2), 1);
    if (max2 > 1 || max2 < 0) {
      max2 = 1;
    }
    return {
      min: min3,
      max: max2
    };
  };
  Segment2.prototype._intersectionsTo = function _intersectionsTo(segment, point2) {
    var intersectionsCount;
    if (this.controlOut() && segment.controlIn()) {
      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point2, this.bboxTo(segment));
    } else {
      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point2);
    }
    return intersectionsCount;
  };
  Segment2.prototype._isOnCurveTo = function _isOnCurveTo(segment, point2, width, endSegment) {
    var bbox = this.bboxTo(segment).expand(width, width);
    if (bbox.containsPoint(point2)) {
      var p1 = this.anchor();
      var p2 = this.controlOut();
      var p3 = segment.controlIn();
      var p4 = segment.anchor();
      if (endSegment === "start" && p1.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p1, p2, point2);
      } else if (endSegment === "end" && p4.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p4, p3, point2);
      }
      var points3 = [p1, p2, p3, p4];
      if (hasRootsInRange(points3, point2, "x", "y", width) || hasRootsInRange(points3, point2, "y", "x", width)) {
        return true;
      }
      var rotation = transform().rotate(45, point2);
      var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];
      return hasRootsInRange(rotatedPoints, point2, "x", "y", width) || hasRootsInRange(rotatedPoints, point2, "y", "x", width);
    }
  };
  Segment2.prototype._isOnLineTo = function _isOnLineTo(segment, point2, width) {
    var p1 = this.anchor();
    var p2 = segment.anchor();
    var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));
    var rect = new rect_default([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);
    return rect.containsPoint(point2.transformCopy(transform().rotate(-angle, p1)));
  };
  Segment2.prototype._isOnPathTo = function _isOnPathTo(segment, point2, width, endSegment) {
    var isOnPath;
    if (this.controlOut() && segment.controlIn()) {
      isOnPath = this._isOnCurveTo(segment, point2, width / 2, endSegment);
    } else {
      isOnPath = this._isOnLineTo(segment, point2, width);
    }
    return isOnPath;
  };
  return Segment2;
}(with_points_default(has_observers_default, points));
function arrayLimits(arr) {
  var length = arr.length;
  var min3 = MAX_NUM;
  var max2 = MIN_NUM;
  for (var i = 0; i < length; i++) {
    max2 = Math.max(max2, arr[i]);
    min3 = Math.min(min3, arr[i]);
  }
  return {
    min: min3,
    max: max2
  };
}
var segment_default = Segment;

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/points-to-curve.js
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var X2 = "x";
var Y2 = "y";
function pointsToCurve(pointsIn, closed) {
  var points3 = pointsIn.slice(0);
  var segments = [];
  var length = points3.length;
  if (length > 2) {
    removeDuplicates(0, points3);
    length = points3.length;
  }
  if (length < 2 || length === 2 && points3[0].equals(points3[1])) {
    return segments;
  }
  var p0 = points3[0];
  var p1 = points3[1];
  var p2 = points3[2];
  segments.push(new segment_default(p0));
  while (p0.equals(points3[length - 1])) {
    closed = true;
    points3.pop();
    length--;
  }
  if (length === 2) {
    var tangent = getTangent(p0, p1, X2, Y2);
    last(segments).controlOut(
      firstControlPoint(tangent, p0, p1, X2, Y2)
    );
    segments.push(new segment_default(
      p1,
      secondControlPoint(tangent, p0, p1, X2, Y2)
    ));
    return segments;
  }
  var initialControlPoint, lastControlPoint;
  if (closed) {
    p0 = points3[length - 1];
    p1 = points3[0];
    p2 = points3[1];
    var controlPoints = getControlPoints(p0, p1, p2);
    initialControlPoint = controlPoints[1];
    lastControlPoint = controlPoints[0];
  } else {
    var tangent$1 = getTangent(p0, p1, X2, Y2);
    initialControlPoint = firstControlPoint(tangent$1, p0, p1, X2, Y2);
  }
  var cp0 = initialControlPoint;
  for (var idx = 0; idx <= length - 3; idx++) {
    removeDuplicates(idx, points3);
    length = points3.length;
    if (idx + 3 <= length) {
      p0 = points3[idx];
      p1 = points3[idx + 1];
      p2 = points3[idx + 2];
      var controlPoints$1 = getControlPoints(p0, p1, p2);
      last(segments).controlOut(cp0);
      cp0 = controlPoints$1[1];
      var cp1 = controlPoints$1[0];
      segments.push(new segment_default(p1, cp1));
    }
  }
  if (closed) {
    p0 = points3[length - 2];
    p1 = points3[length - 1];
    p2 = points3[0];
    var controlPoints$2 = getControlPoints(p0, p1, p2);
    last(segments).controlOut(cp0);
    segments.push(new segment_default(
      p1,
      controlPoints$2[0]
    ));
    last(segments).controlOut(controlPoints$2[1]);
    segments.push(new segment_default(
      p2,
      lastControlPoint
    ));
  } else {
    var tangent$2 = getTangent(p1, p2, X2, Y2);
    last(segments).controlOut(cp0);
    segments.push(new segment_default(
      p2,
      secondControlPoint(tangent$2, p1, p2, X2, Y2)
    ));
  }
  return segments;
}
function removeDuplicates(idx, points3) {
  while (points3[idx + 1] && (points3[idx].equals(points3[idx + 1]) || points3[idx + 1].equals(points3[idx + 2]))) {
    points3.splice(idx + 1, 1);
  }
}
function invertAxis(p0, p1, p2) {
  var invertAxis2 = false;
  if (p0.x === p1.x) {
    invertAxis2 = true;
  } else if (p1.x === p2.x) {
    if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
      invertAxis2 = true;
    }
  } else {
    var fn = lineFunction(p0, p1);
    var y2 = calculateFunction(fn, p2.x);
    if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
      invertAxis2 = true;
    }
  }
  return invertAxis2;
}
function isLine(p0, p1, p2) {
  var fn = lineFunction(p0, p1);
  var y2 = calculateFunction(fn, p2.x);
  return p0.x === p1.x && p1.x === p2.x || round2(y2, 1) === round2(p2.y, 1);
}
function lineFunction(p1, p2) {
  var a = (p2.y - p1.y) / (p2.x - p1.x);
  var b = p1.y - a * p1.x;
  return [b, a];
}
function getControlPoints(p0, p1, p2) {
  var xField = X2;
  var yField = Y2;
  var restrict = false;
  var switchOrientation = false;
  var tangent;
  if (isLine(p0, p1, p2)) {
    tangent = getTangent(p0, p1, X2, Y2);
  } else {
    var monotonic = {
      x: isMonotonicByField(p0, p1, p2, X2),
      y: isMonotonicByField(p0, p1, p2, Y2)
    };
    if (monotonic.x && monotonic.y) {
      tangent = getTangent(p0, p2, X2, Y2);
      restrict = true;
    } else {
      if (invertAxis(p0, p1, p2)) {
        xField = Y2;
        yField = X2;
      }
      if (monotonic[xField]) {
        tangent = 0;
      } else {
        var sign;
        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
          sign = numberSign2((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
        } else {
          sign = -numberSign2((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
        }
        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
        switchOrientation = true;
      }
    }
  }
  var secondCP = secondControlPoint(tangent, p0, p1, xField, yField);
  if (switchOrientation) {
    var oldXField = xField;
    xField = yField;
    yField = oldXField;
  }
  var firstCP = firstControlPoint(tangent, p1, p2, xField, yField);
  if (restrict) {
    restrictControlPoint(p0, p1, secondCP, tangent);
    restrictControlPoint(p1, p2, firstCP, tangent);
  }
  return [secondCP, firstCP];
}
function restrictControlPoint(p1, p2, cp, tangent) {
  if (p1.y < p2.y) {
    if (p2.y < cp.y) {
      cp.x = p1.x + (p2.y - p1.y) / tangent;
      cp.y = p2.y;
    } else if (cp.y < p1.y) {
      cp.x = p2.x - (p2.y - p1.y) / tangent;
      cp.y = p1.y;
    }
  } else {
    if (cp.y < p2.y) {
      cp.x = p1.x - (p1.y - p2.y) / tangent;
      cp.y = p2.y;
    } else if (p1.y < cp.y) {
      cp.x = p2.x + (p1.y - p2.y) / tangent;
      cp.y = p1.y;
    }
  }
}
function getTangent(p0, p1, xField, yField) {
  var x = p1[xField] - p0[xField];
  var y = p1[yField] - p0[yField];
  var tangent;
  if (x === 0) {
    tangent = 0;
  } else {
    tangent = y / x;
  }
  return tangent;
}
function isMonotonicByField(p0, p1, p2, field) {
  return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
}
function firstControlPoint(tangent, p0, p3, xField, yField) {
  var t1 = p0[xField];
  var t2 = p3[xField];
  var distance = (t2 - t1) * WEIGHT;
  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
}
function secondControlPoint(tangent, p0, p3, xField, yField) {
  var t1 = p0[xField];
  var t2 = p3[xField];
  var distance = (t2 - t1) * WEIGHT;
  return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
}
function point(xValue, yValue, xField, yField) {
  var controlPoint = new point_default();
  controlPoint[xField] = xValue;
  controlPoint[yField] = yValue;
  return controlPoint;
}
function calculateFunction(fn, x) {
  var length = fn.length;
  var result = 0;
  for (var i = 0; i < length; i++) {
    result += Math.pow(x, i) * fn[i];
  }
  return result;
}
function numberSign2(value) {
  return value <= 0 ? -1 : 1;
}

// node_modules/@progress/kendo-drawing/dist/es/parsing/shape-map.js
var ShapeMap = {
  l: function(path, options2) {
    var parameters = options2.parameters;
    var position3 = options2.position;
    for (var i = 0; i < parameters.length; i += 2) {
      var point2 = new point_default(parameters[i], parameters[i + 1]);
      if (options2.isRelative) {
        point2.translateWith(position3);
      }
      path.lineTo(point2.x, point2.y);
      position3.x = point2.x;
      position3.y = point2.y;
    }
  },
  c: function(path, options2) {
    var parameters = options2.parameters;
    var position3 = options2.position;
    for (var i = 0; i < parameters.length; i += 6) {
      var controlOut = new point_default(parameters[i], parameters[i + 1]);
      var controlIn = new point_default(parameters[i + 2], parameters[i + 3]);
      var point2 = new point_default(parameters[i + 4], parameters[i + 5]);
      if (options2.isRelative) {
        controlIn.translateWith(position3);
        controlOut.translateWith(position3);
        point2.translateWith(position3);
      }
      path.curveTo(controlOut, controlIn, point2);
      position3.x = point2.x;
      position3.y = point2.y;
    }
  },
  v: function(path, options2) {
    var value = options2.isRelative ? 0 : options2.position.x;
    toLineParamaters(options2.parameters, true, value);
    this.l(path, options2);
  },
  h: function(path, options2) {
    var value = options2.isRelative ? 0 : options2.position.y;
    toLineParamaters(options2.parameters, false, value);
    this.l(path, options2);
  },
  a: function(path, options2) {
    var parameters = options2.parameters;
    var position3 = options2.position;
    for (var i = 0; i < parameters.length; i += 7) {
      var radiusX = parameters[i];
      var radiusY = parameters[i + 1];
      var rotation = parameters[i + 2];
      var largeArc = parameters[i + 3];
      var swipe = parameters[i + 4];
      var endPoint = new point_default(parameters[i + 5], parameters[i + 6]);
      if (options2.isRelative) {
        endPoint.translateWith(position3);
      }
      if (position3.x !== endPoint.x || position3.y !== endPoint.y) {
        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);
        position3.x = endPoint.x;
        position3.y = endPoint.y;
      }
    }
  },
  s: function(path, options2) {
    var parameters = options2.parameters;
    var position3 = options2.position;
    var previousCommand = options2.previousCommand;
    var lastControlIn;
    if (previousCommand === "s" || previousCommand === "c") {
      lastControlIn = last(last(path.paths).segments).controlIn();
    }
    for (var i = 0; i < parameters.length; i += 4) {
      var controlIn = new point_default(parameters[i], parameters[i + 1]);
      var endPoint = new point_default(parameters[i + 2], parameters[i + 3]);
      var controlOut = void 0;
      if (options2.isRelative) {
        controlIn.translateWith(position3);
        endPoint.translateWith(position3);
      }
      if (lastControlIn) {
        controlOut = reflectionPoint(lastControlIn, position3);
      } else {
        controlOut = position3.clone();
      }
      lastControlIn = controlIn;
      path.curveTo(controlOut, controlIn, endPoint);
      position3.x = endPoint.x;
      position3.y = endPoint.y;
    }
  },
  q: function(path, options2) {
    var parameters = options2.parameters;
    var position3 = options2.position;
    for (var i = 0; i < parameters.length; i += 4) {
      var controlPoint = new point_default(parameters[i], parameters[i + 1]);
      var endPoint = new point_default(parameters[i + 2], parameters[i + 3]);
      if (options2.isRelative) {
        controlPoint.translateWith(position3);
        endPoint.translateWith(position3);
      }
      var cubicControlPoints = quadraticToCubicControlPoints(position3, controlPoint, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position3.x = endPoint.x;
      position3.y = endPoint.y;
    }
  },
  t: function(path, options2) {
    var parameters = options2.parameters;
    var position3 = options2.position;
    var previousCommand = options2.previousCommand;
    var controlPoint;
    if (previousCommand === "q" || previousCommand === "t") {
      var lastSegment = last(last(path.paths).segments);
      controlPoint = lastSegment.controlIn().clone().translateWith(position3.scaleCopy(-1 / 3)).scale(3 / 2);
    }
    for (var i = 0; i < parameters.length; i += 2) {
      var endPoint = new point_default(parameters[i], parameters[i + 1]);
      if (options2.isRelative) {
        endPoint.translateWith(position3);
      }
      if (controlPoint) {
        controlPoint = reflectionPoint(controlPoint, position3);
      } else {
        controlPoint = position3.clone();
      }
      var cubicControlPoints = quadraticToCubicControlPoints(position3, controlPoint, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position3.x = endPoint.x;
      position3.y = endPoint.y;
    }
  }
};
function toLineParamaters(parameters, isVertical, value) {
  var insertPosition = isVertical ? 0 : 1;
  for (var i = 0; i < parameters.length; i += 2) {
    parameters.splice(i + insertPosition, 0, value);
  }
}
function reflectionPoint(point2, center) {
  if (point2 && center) {
    return center.scaleCopy(2).translate(-point2.x, -point2.y);
  }
}
var third = 1 / 3;
function quadraticToCubicControlPoints(position3, controlPoint, endPoint) {
  var scaledPoint = controlPoint.clone().scale(2 / 3);
  return {
    controlOut: scaledPoint.clone().translateWith(position3.scaleCopy(third)),
    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))
  };
}
var shape_map_default = ShapeMap;

// node_modules/@progress/kendo-drawing/dist/es/parsing/parse-path.js
var SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;
var SPLIT_REGEX = /[,\s]?([+\-]?(?:\d*\.\d+|\d+)(?:[eE][+\-]?\d+)?)/g;
var MOVE = "m";
var CLOSE = "z";
function parseParameters(str) {
  var parameters = [];
  str.replace(SPLIT_REGEX, function(match, number2) {
    parameters.push(parseFloat(number2));
  });
  return parameters;
}
function parsePath(pathInstance, str) {
  var position3 = new point_default();
  var previousCommand;
  str.replace(SEGMENT_REGEX, function(match, element2, params, closePath) {
    var command = element2.toLowerCase();
    var isRelative = command === element2;
    var parameters = parseParameters(params.trim());
    if (command === MOVE) {
      if (isRelative) {
        position3.x += parameters[0];
        position3.y += parameters[1];
      } else {
        position3.x = parameters[0];
        position3.y = parameters[1];
      }
      pathInstance.moveTo(position3.x, position3.y);
      if (parameters.length > 2) {
        command = "l";
        parameters.splice(0, 2);
      }
    }
    if (shape_map_default[command]) {
      shape_map_default[command](
        pathInstance,
        {
          parameters,
          position: position3,
          isRelative,
          previousCommand
        }
      );
      if (closePath && closePath.toLowerCase() === CLOSE) {
        pathInstance.close();
      }
    } else if (command !== MOVE) {
      throw new Error("Error while parsing SVG path. Unsupported command: " + command);
    }
    previousCommand = command;
  });
  return pathInstance;
}
var parse_path_default = parsePath;

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/elements-bounding-box.js
function elementsBoundingBox(elements, applyTransform, transformation) {
  var boundingBox;
  for (var i = 0; i < elements.length; i++) {
    var element2 = elements[i];
    if (element2.visible()) {
      var elementBoundingBox = applyTransform ? element2.bbox(transformation) : element2.rawBBox();
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/elements-clippend-bounding-box.js
function elementsClippedBoundingBox(elements, transformation) {
  var boundingBox;
  for (var i = 0; i < elements.length; i++) {
    var element2 = elements[i];
    if (element2.visible()) {
      var elementBoundingBox = element2.clippedBBox(transformation);
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/path.js
var SPACE2 = " ";
var printPoints = function(precision) {
  return function() {
    var points3 = [], len = arguments.length;
    while (len--)
      points3[len] = arguments[len];
    return points3.map(function(p) {
      return p.toString(precision);
    }).join(SPACE2);
    ;
  };
};
var segmentType = function(segmentStart, segmentEnd) {
  return segmentStart.controlOut() && segmentEnd.controlIn() ? "C" : "L";
};
var Path = function(superclass) {
  function Path9(options2) {
    superclass.call(this, options2);
    this.segments = new geometry_elements_array_default();
    this.segments.addObserver(this);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
      if (!defined(this.options.stroke.lineJoin)) {
        this.options.set("stroke.lineJoin", "miter");
      }
    }
  }
  if (superclass)
    Path9.__proto__ = superclass;
  Path9.prototype = Object.create(superclass && superclass.prototype);
  Path9.prototype.constructor = Path9;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Path";
  };
  Path9.prototype.moveTo = function moveTo(x, y) {
    this.suspend();
    this.segments.elements([]);
    this.resume();
    this.lineTo(x, y);
    return this;
  };
  Path9.prototype.lineTo = function lineTo(x, y) {
    var point2 = defined(y) ? new point_default(x, y) : x;
    var segment = new segment_default(point2);
    this.segments.push(segment);
    return this;
  };
  Path9.prototype.curveTo = function curveTo(controlOut, controlIn, point2) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var segment = new segment_default(point2, controlIn);
      this.suspend();
      lastSegment.controlOut(controlOut);
      this.resume();
      this.segments.push(segment);
    }
    return this;
  };
  Path9.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var anchor = lastSegment.anchor();
      var start = rad(startAngle);
      var center = new point_default(
        anchor.x - radiusX * Math.cos(start),
        anchor.y - radiusY * Math.sin(start)
      );
      var arc2 = new arc_default(center, {
        startAngle,
        endAngle,
        radiusX,
        radiusY,
        anticlockwise
      });
      this._addArcSegments(arc2);
    }
    return this;
  };
  Path9.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var anchor = lastSegment.anchor();
      var arc = arc_default.fromPoints(anchor, point_default.create(end), rx, ry, largeArc, swipe, rotation);
      this._addArcSegments(arc);
    }
    return this;
  };
  Path9.prototype._addArcSegments = function _addArcSegments(arc) {
    var this$1 = this;
    this.suspend();
    var curvePoints = arc.curvePoints();
    for (var i = 1; i < curvePoints.length; i += 3) {
      this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
    }
    this.resume();
    this.geometryChange();
  };
  Path9.prototype.close = function close2() {
    this.options.closed = true;
    this.geometryChange();
    return this;
  };
  Path9.prototype.rawBBox = function rawBBox() {
    return this._bbox();
  };
  Path9.prototype.toString = function toString3(digits) {
    var output = "";
    var segments = this.segments;
    var length = segments.length;
    if (length > 0) {
      var parts = [];
      var print = printPoints(digits);
      var currentType;
      for (var i = 1; i < length; i++) {
        var type = segmentType(segments[i - 1], segments[i]);
        if (type !== currentType) {
          currentType = type;
          parts.push(type);
        }
        if (type === "L") {
          parts.push(print(segments[i].anchor()));
        } else {
          parts.push(print(
            segments[i - 1].controlOut(),
            segments[i].controlIn(),
            segments[i].anchor()
          ));
        }
      }
      output = "M" + print(segments[0].anchor()) + SPACE2 + parts.join(SPACE2);
      if (this.options.closed) {
        output += "Z";
      }
    }
    return output;
  };
  Path9.prototype._containsPoint = function _containsPoint(point2) {
    var segments = this.segments;
    var length = segments.length;
    var intersectionsCount = 0;
    var previous, current4;
    for (var idx = 1; idx < length; idx++) {
      previous = segments[idx - 1];
      current4 = segments[idx];
      intersectionsCount += previous._intersectionsTo(current4, point2);
    }
    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {
      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point2);
    }
    return intersectionsCount % 2 !== 0;
  };
  Path9.prototype._isOnPath = function _isOnPath(point2, width) {
    var segments = this.segments;
    var length = segments.length;
    var pathWidth = width || this.options.stroke.width;
    if (length > 1) {
      if (segments[0]._isOnPathTo(segments[1], point2, pathWidth, "start")) {
        return true;
      }
      for (var idx = 2; idx <= length - 2; idx++) {
        if (segments[idx - 1]._isOnPathTo(segments[idx], point2, pathWidth)) {
          return true;
        }
      }
      if (segments[length - 2]._isOnPathTo(segments[length - 1], point2, pathWidth, "end")) {
        return true;
      }
    }
    return false;
  };
  Path9.prototype._bbox = function _bbox(matrix) {
    var segments = this.segments;
    var length = segments.length;
    var boundingBox;
    if (length === 1) {
      var anchor = segments[0].anchor().transformCopy(matrix);
      boundingBox = new rect_default(anchor, size_default.ZERO);
    } else if (length > 0) {
      for (var i = 1; i < length; i++) {
        var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, segmentBox);
        } else {
          boundingBox = segmentBox;
        }
      }
    }
    return boundingBox;
  };
  Path9.parse = function parse(str, options2) {
    return MultiPath.parse(str, options2);
  };
  Path9.fromRect = function fromRect(rect, options2) {
    var path = new Path9(options2);
    var ref2 = rect.cornerRadius;
    var rx = ref2[0];
    var ry = ref2[1];
    if (rx === 0 && ry === 0) {
      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();
    } else {
      var origin = rect.origin;
      var x = origin.x;
      var y = origin.y;
      var width = rect.width();
      var height = rect.height();
      rx = limitValue(rx, 0, width / 2);
      ry = limitValue(ry, 0, height / 2);
      path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);
    }
    return path;
  };
  Path9.fromPoints = function fromPoints(points3, options2) {
    if (points3) {
      var path = new Path9(options2);
      for (var i = 0; i < points3.length; i++) {
        var point2 = point_default.create(points3[i]);
        if (point2) {
          if (i === 0) {
            path.moveTo(point2);
          } else {
            path.lineTo(point2);
          }
        }
      }
      return path;
    }
  };
  Path9.curveFromPoints = function curveFromPoints(points3, options2) {
    if (points3) {
      var segments = pointsToCurve(points3);
      var path = new Path9(options2);
      path.segments.push.apply(path.segments, segments);
      return path;
    }
  };
  Path9.fromArc = function fromArc(arc, options2) {
    var path = new Path9(options2);
    var startAngle = arc.startAngle;
    var start = arc.pointAt(startAngle);
    path.moveTo(start.x, start.y);
    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);
    return path;
  };
  Object.defineProperties(Path9.prototype, prototypeAccessors4);
  return Path9;
}(paintable_default(measurable_default(element_default)));
var MultiPath = function(superclass) {
  function MultiPath2(options2) {
    superclass.call(this, options2);
    this.paths = new geometry_elements_array_default();
    this.paths.addObserver(this);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
    }
  }
  if (superclass)
    MultiPath2.__proto__ = superclass;
  MultiPath2.prototype = Object.create(superclass && superclass.prototype);
  MultiPath2.prototype.constructor = MultiPath2;
  var prototypeAccessors$12 = { nodeType: { configurable: true } };
  MultiPath2.parse = function parse(str, options2) {
    var instance4 = new MultiPath2(options2);
    return parse_path_default(instance4, str);
  };
  MultiPath2.prototype.toString = function toString3(digits) {
    var paths = this.paths;
    var output = "";
    if (paths.length > 0) {
      var result = [];
      for (var i = 0; i < paths.length; i++) {
        result.push(paths[i].toString(digits));
      }
      output = result.join(SPACE2);
    }
    return output;
  };
  prototypeAccessors$12.nodeType.get = function() {
    return "MultiPath";
  };
  MultiPath2.prototype.moveTo = function moveTo(x, y) {
    var path = new Path();
    path.moveTo(x, y);
    this.paths.push(path);
    return this;
  };
  MultiPath2.prototype.lineTo = function lineTo(x, y) {
    if (this.paths.length > 0) {
      last(this.paths).lineTo(x, y);
    }
    return this;
  };
  MultiPath2.prototype.curveTo = function curveTo(controlOut, controlIn, point2) {
    if (this.paths.length > 0) {
      last(this.paths).curveTo(controlOut, controlIn, point2);
    }
    return this;
  };
  MultiPath2.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.paths.length > 0) {
      last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);
    }
    return this;
  };
  MultiPath2.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.paths.length > 0) {
      last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);
    }
    return this;
  };
  MultiPath2.prototype.close = function close2() {
    if (this.paths.length > 0) {
      last(this.paths).close();
    }
    return this;
  };
  MultiPath2.prototype._bbox = function _bbox(matrix) {
    return elementsBoundingBox(this.paths, true, matrix);
  };
  MultiPath2.prototype.rawBBox = function rawBBox() {
    return elementsBoundingBox(this.paths, false);
  };
  MultiPath2.prototype._containsPoint = function _containsPoint(point2) {
    var paths = this.paths;
    for (var idx = 0; idx < paths.length; idx++) {
      if (paths[idx]._containsPoint(point2)) {
        return true;
      }
    }
    return false;
  };
  MultiPath2.prototype._isOnPath = function _isOnPath(point2) {
    var paths = this.paths;
    var width = this.options.stroke.width;
    for (var idx = 0; idx < paths.length; idx++) {
      if (paths[idx]._isOnPath(point2, width)) {
        return true;
      }
    }
    return false;
  };
  MultiPath2.prototype._clippedBBox = function _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));
  };
  Object.defineProperties(MultiPath2.prototype, prototypeAccessors$12);
  return MultiPath2;
}(paintable_default(measurable_default(element_default)));

// node_modules/@progress/kendo-drawing/dist/es/shapes/arc.js
var DEFAULT_STROKE2 = "#000";
var Arc2 = function(superclass) {
  function Arc4(geometry, options2) {
    if (geometry === void 0)
      geometry = new arc_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke(DEFAULT_STROKE2);
    }
  }
  if (superclass)
    Arc4.__proto__ = superclass;
  Arc4.prototype = Object.create(superclass && superclass.prototype);
  Arc4.prototype.constructor = Arc4;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Arc";
  };
  Arc4.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Arc4.prototype.rawBBox = function rawBBox() {
    return this.geometry().bbox();
  };
  Arc4.prototype.toPath = function toPath() {
    var path = new Path();
    var curvePoints = this.geometry().curvePoints();
    if (curvePoints.length > 0) {
      path.moveTo(curvePoints[0].x, curvePoints[0].y);
      for (var i = 1; i < curvePoints.length; i += 3) {
        path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
      }
    }
    return path;
  };
  Arc4.prototype._containsPoint = function _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  };
  Arc4.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Arc4.prototype, prototypeAccessors4);
  return Arc4;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var arc_default2 = Arc2;

// node_modules/@progress/kendo-drawing/dist/es/shapes/text.js
var DEFAULT_FONT2 = "12px sans-serif";
var DEFAULT_FILL = "#000";
var Text = function(superclass) {
  function Text4(content, position3, options2) {
    if (position3 === void 0)
      position3 = new point_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.content(content);
    this.position(position3);
    if (!this.options.font) {
      this.options.font = DEFAULT_FONT2;
    }
    if (!defined(this.options.fill)) {
      this.fill(DEFAULT_FILL);
    }
  }
  if (superclass)
    Text4.__proto__ = superclass;
  Text4.prototype = Object.create(superclass && superclass.prototype);
  Text4.prototype.constructor = Text4;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Text";
  };
  Text4.prototype.content = function content(value) {
    if (defined(value)) {
      this.options.set("content", value);
      return this;
    }
    return this.options.get("content");
  };
  Text4.prototype.measure = function measure() {
    var metrics = measureText(this.content(), {
      font: this.options.get("font")
    });
    return metrics;
  };
  Text4.prototype.rect = function rect() {
    var size = this.measure();
    var pos = this.position().clone();
    return new rect_default(pos, [size.width, size.height]);
  };
  Text4.prototype.bbox = function bbox(transformation) {
    var combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this.rect().bbox(combinedMatrix);
  };
  Text4.prototype.rawBBox = function rawBBox() {
    return this.rect().bbox();
  };
  Text4.prototype._containsPoint = function _containsPoint(point2) {
    return this.rect().containsPoint(point2);
  };
  Object.defineProperties(Text4.prototype, prototypeAccessors4);
  return Text4;
}(paintable_default(with_points_default(element_default, ["position"])));
var text_default = Text;

// node_modules/@progress/kendo-drawing/dist/es/shapes/image.js
var Image2 = function(superclass) {
  function Image3(src, rect, options2) {
    if (rect === void 0)
      rect = new rect_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.src(src);
    this.rect(rect);
  }
  if (superclass)
    Image3.__proto__ = superclass;
  Image3.prototype = Object.create(superclass && superclass.prototype);
  Image3.prototype.constructor = Image3;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Image";
  };
  Image3.prototype.src = function src(value) {
    if (defined(value)) {
      this.options.set("src", value);
      return this;
    }
    return this.options.get("src");
  };
  Image3.prototype.bbox = function bbox(transformation) {
    var combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this._rect.bbox(combinedMatrix);
  };
  Image3.prototype.rawBBox = function rawBBox() {
    return this._rect.bbox();
  };
  Image3.prototype._containsPoint = function _containsPoint(point2) {
    return this._rect.containsPoint(point2);
  };
  Image3.prototype._hasFill = function _hasFill() {
    return this.src();
  };
  Object.defineProperties(Image3.prototype, prototypeAccessors4);
  return Image3;
}(with_geometry_default(element_default, ["rect"]));
var image_default = Image2;

// node_modules/@progress/kendo-drawing/dist/es/mixins/traversable.js
var traversable = function(TBase, childrenField) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.traverse = function traverse(callback) {
      var children = this[childrenField];
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.traverse) {
          child.traverse(callback);
        } else {
          callback(child);
        }
      }
      return this;
    };
    return anonymous;
  }(TBase);
};
var traversable_default = traversable;

// node_modules/@progress/kendo-drawing/dist/es/shapes/group.js
var Group = function(superclass) {
  function Group10(options2) {
    superclass.call(this, options2);
    this.children = [];
  }
  if (superclass)
    Group10.__proto__ = superclass;
  Group10.prototype = Object.create(superclass && superclass.prototype);
  Group10.prototype.constructor = Group10;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Group";
  };
  Group10.prototype.childrenChange = function childrenChange(action, items, index) {
    this.trigger("childrenChange", {
      action,
      items,
      index
    });
  };
  Group10.prototype.append = function append$1() {
    append(this.children, arguments);
    this._reparent(arguments, this);
    this.childrenChange("add", arguments);
    return this;
  };
  Group10.prototype.insert = function insert(index, element2) {
    this.children.splice(index, 0, element2);
    element2.parent = this;
    this.childrenChange("add", [element2], index);
    return this;
  };
  Group10.prototype.insertAt = function insertAt(element2, index) {
    return this.insert(index, element2);
  };
  Group10.prototype.remove = function remove(element2) {
    var index = this.children.indexOf(element2);
    if (index >= 0) {
      this.children.splice(index, 1);
      element2.parent = null;
      this.childrenChange("remove", [element2], index);
    }
    return this;
  };
  Group10.prototype.removeAt = function removeAt(index) {
    if (0 <= index && index < this.children.length) {
      var element2 = this.children[index];
      this.children.splice(index, 1);
      element2.parent = null;
      this.childrenChange("remove", [element2], index);
    }
    return this;
  };
  Group10.prototype.clear = function clear4() {
    var items = this.children;
    this.children = [];
    this._reparent(items, null);
    this.childrenChange("remove", items, 0);
    return this;
  };
  Group10.prototype.bbox = function bbox(transformation) {
    return elementsBoundingBox(this.children, true, this.currentTransform(transformation));
  };
  Group10.prototype.rawBBox = function rawBBox() {
    return elementsBoundingBox(this.children, false);
  };
  Group10.prototype._clippedBBox = function _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));
  };
  Group10.prototype.currentTransform = function currentTransform(transformation) {
    return element_default.prototype.currentTransform.call(this, transformation) || null;
  };
  Group10.prototype.containsPoint = function containsPoint(point2, parentTransform) {
    if (this.visible()) {
      var children = this.children;
      var transform2 = this.currentTransform(parentTransform);
      for (var idx = 0; idx < children.length; idx++) {
        if (children[idx].containsPoint(point2, transform2)) {
          return true;
        }
      }
    }
    return false;
  };
  Group10.prototype._reparent = function _reparent(elements, newParent) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var child = elements[i];
      var parent = child.parent;
      if (parent && parent !== this$1 && parent.remove) {
        parent.remove(child);
      }
      child.parent = newParent;
    }
  };
  Object.defineProperties(Group10.prototype, prototypeAccessors4);
  return Group10;
}(traversable_default(element_default, "children"));
var group_default = Group;

// node_modules/@progress/kendo-drawing/dist/es/alignment/translate-to-point.js
function translateToPoint(point2, bbox, element2) {
  var transofrm = element2.transform() || transform();
  var matrix = transofrm.matrix();
  matrix.e += point2.x - bbox.origin.x;
  matrix.f += point2.y - bbox.origin.y;
  transofrm.matrix(matrix);
  element2.transform(transofrm);
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-start.js
function alignStart(size, rect, align3, axis, sizeField) {
  var start;
  if (align3 === "start") {
    start = rect.origin[axis];
  } else if (align3 === "end") {
    start = rect.origin[axis] + rect.size[sizeField] - size;
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
  }
  return start;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-start-reverse.js
function alignStartReverse(size, rect, align3, axis, sizeField) {
  var start;
  if (align3 === "start") {
    start = rect.origin[axis] + rect.size[sizeField] - size;
  } else if (align3 === "end") {
    start = rect.origin[axis];
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
  }
  return start;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/layout.js
var DEFAULT_OPTIONS2 = {
  alignContent: "start",
  justifyContent: "start",
  alignItems: "start",
  spacing: 0,
  orientation: "horizontal",
  lineSpacing: 0,
  wrap: true,
  revers: false
};
var forEach = function(elements, callback) {
  elements.forEach(callback);
};
var forEachReverse = function(elements, callback) {
  var length = elements.length;
  for (var idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx);
  }
};
var Layout = function(Group10) {
  function Layout2(rect, options2) {
    Group10.call(this, Object.assign({}, DEFAULT_OPTIONS2, options2));
    this._rect = rect;
    this._fieldMap = {};
  }
  if (Group10)
    Layout2.__proto__ = Group10;
  Layout2.prototype = Object.create(Group10 && Group10.prototype);
  Layout2.prototype.constructor = Layout2;
  Layout2.prototype.rect = function rect(value) {
    if (value) {
      this._rect = value;
      return this;
    }
    return this._rect;
  };
  Layout2.prototype._initMap = function _initMap() {
    var options2 = this.options;
    var fieldMap = this._fieldMap;
    if (options2.orientation === "horizontal") {
      fieldMap.sizeField = "width";
      fieldMap.groupsSizeField = "height";
      fieldMap.groupAxis = "x";
      fieldMap.groupsAxis = "y";
    } else {
      fieldMap.sizeField = "height";
      fieldMap.groupsSizeField = "width";
      fieldMap.groupAxis = "y";
      fieldMap.groupsAxis = "x";
    }
    if (options2.reverse) {
      this.forEach = forEachReverse;
      this.justifyAlign = alignStartReverse;
    } else {
      this.forEach = forEach;
      this.justifyAlign = alignStart;
    }
  };
  Layout2.prototype.reflow = function reflow() {
    var this$1 = this;
    if (!this._rect || this.children.length === 0) {
      return;
    }
    this._initMap();
    if (this.options.transform) {
      this.transform(null);
    }
    var options2 = this.options;
    var rect = this._rect;
    var ref2 = this._initGroups();
    var groups = ref2.groups;
    var groupsSize = ref2.groupsSize;
    var ref$1 = this._fieldMap;
    var sizeField = ref$1.sizeField;
    var groupsSizeField = ref$1.groupsSizeField;
    var groupAxis = ref$1.groupAxis;
    var groupsAxis = ref$1.groupsAxis;
    var groupOrigin = new point_default();
    var elementOrigin = new point_default();
    var size = new size_default();
    var groupStart = alignStart(groupsSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
    var elementStart, group, groupBox;
    var arrangeElements = function(bbox, idx) {
      var element2 = group.elements[idx];
      elementOrigin[groupAxis] = elementStart;
      elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options2.alignItems, groupsAxis, groupsSizeField);
      translateToPoint(elementOrigin, bbox, element2);
      elementStart += bbox.size[sizeField] + options2.spacing;
    };
    for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {
      group = groups[groupIdx];
      groupOrigin[groupAxis] = elementStart = this$1.justifyAlign(group.size, rect, options2.justifyContent, groupAxis, sizeField);
      groupOrigin[groupsAxis] = groupStart;
      size[sizeField] = group.size;
      size[groupsSizeField] = group.lineSize;
      groupBox = new rect_default(groupOrigin, size);
      this$1.forEach(group.bboxes, arrangeElements);
      groupStart += group.lineSize + options2.lineSpacing;
    }
    if (!options2.wrap && group.size > rect.size[sizeField]) {
      var scale = rect.size[sizeField] / groupBox.size[sizeField];
      var scaledStart = groupBox.topLeft().scale(scale, scale);
      var scaledSize = groupBox.size[groupsSizeField] * scale;
      var newStart = alignStart(scaledSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
      var transform2 = transform();
      if (groupAxis === "x") {
        transform2.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);
      } else {
        transform2.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);
      }
      transform2.scale(scale, scale);
      this.transform(transform2);
    }
  };
  Layout2.prototype._initGroups = function _initGroups() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var lineSpacing = options2.lineSpacing;
    var wrap2 = options2.wrap;
    var spacing = options2.spacing;
    var sizeField = this._fieldMap.sizeField;
    var group = this._newGroup();
    var groups = [];
    var addGroup = function() {
      groups.push(group);
      groupsSize += group.lineSize + lineSpacing;
    };
    var groupsSize = -lineSpacing;
    for (var idx = 0; idx < children.length; idx++) {
      var element2 = children[idx];
      var bbox = children[idx].clippedBBox();
      if (element2.visible() && bbox) {
        if (wrap2 && group.size + bbox.size[sizeField] + spacing > this$1._rect.size[sizeField]) {
          if (group.bboxes.length === 0) {
            this$1._addToGroup(group, bbox, element2);
            addGroup();
            group = this$1._newGroup();
          } else {
            addGroup();
            group = this$1._newGroup();
            this$1._addToGroup(group, bbox, element2);
          }
        } else {
          this$1._addToGroup(group, bbox, element2);
        }
      }
    }
    if (group.bboxes.length) {
      addGroup();
    }
    return {
      groups,
      groupsSize
    };
  };
  Layout2.prototype._addToGroup = function _addToGroup(group, bbox, element2) {
    group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;
    group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);
    group.bboxes.push(bbox);
    group.elements.push(element2);
  };
  Layout2.prototype._newGroup = function _newGroup() {
    return {
      lineSize: 0,
      size: -this.options.spacing,
      bboxes: [],
      elements: []
    };
  };
  return Layout2;
}(group_default);
var layout_default = Layout;

// node_modules/@progress/kendo-drawing/dist/es/shapes/rect.js
var Rect2 = function(superclass) {
  function Rect3(geometry, options2) {
    if (geometry === void 0)
      geometry = new rect_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
    }
  }
  if (superclass)
    Rect3.__proto__ = superclass;
  Rect3.prototype = Object.create(superclass && superclass.prototype);
  Rect3.prototype.constructor = Rect3;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Rect";
  };
  Rect3.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Rect3.prototype.rawBBox = function rawBBox() {
    return this._geometry.bbox();
  };
  Rect3.prototype._containsPoint = function _containsPoint(point2) {
    return this._geometry.containsPoint(point2);
  };
  Rect3.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Rect3.prototype, prototypeAccessors4);
  return Rect3;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var rect_default2 = Rect2;

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-elements.js
function alignElements(elements, rect, alignment, axis, sizeField) {
  for (var idx = 0; idx < elements.length; idx++) {
    var bbox = elements[idx].clippedBBox();
    if (bbox) {
      var point2 = bbox.origin.clone();
      point2[axis] = alignStart(bbox.size[sizeField], rect, alignment || "start", axis, sizeField);
      translateToPoint(point2, bbox, elements[idx]);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align.js
function align(elements, rect, alignment) {
  alignElements(elements, rect, alignment, "x", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-align.js
function vAlign(elements, rect, alignment) {
  alignElements(elements, rect, alignment, "y", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/stack-elements.js
function stackElements(elements, stackAxis, otherAxis, sizeField) {
  if (elements.length > 1) {
    var origin = new point_default();
    var previousBBox = elements[0].bbox;
    for (var idx = 1; idx < elements.length; idx++) {
      var element2 = elements[idx].element;
      var bbox = elements[idx].bbox;
      origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];
      origin[otherAxis] = bbox.origin[otherAxis];
      translateToPoint(origin, bbox, element2);
      bbox.origin[stackAxis] = origin[stackAxis];
      previousBBox = bbox;
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/create-stack-elements.js
function createStackElements(elements) {
  var stackElements2 = [];
  for (var idx = 0; idx < elements.length; idx++) {
    var element2 = elements[idx];
    var bbox = element2.clippedBBox();
    if (bbox) {
      stackElements2.push({
        element: element2,
        bbox
      });
    }
  }
  return stackElements2;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/stack.js
function stack(elements) {
  stackElements(createStackElements(elements), "x", "y", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-stack.js
function vStack(elements) {
  stackElements(createStackElements(elements), "y", "x", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/wrap-elements.js
function getStacks(elements, rect, sizeField) {
  var maxSize = rect.size[sizeField];
  var stacks = [];
  var stack2 = [];
  var stackSize = 0;
  var element2, bbox;
  var addElementToStack = function() {
    stack2.push({
      element: element2,
      bbox
    });
  };
  for (var idx = 0; idx < elements.length; idx++) {
    element2 = elements[idx];
    bbox = element2.clippedBBox();
    if (bbox) {
      var size = bbox.size[sizeField];
      if (stackSize + size > maxSize) {
        if (stack2.length) {
          stacks.push(stack2);
          stack2 = [];
          addElementToStack();
          stackSize = size;
        } else {
          addElementToStack();
          stacks.push(stack2);
          stack2 = [];
          stackSize = 0;
        }
      } else {
        addElementToStack();
        stackSize += size;
      }
    }
  }
  if (stack2.length) {
    stacks.push(stack2);
  }
  return stacks;
}
function wrapElements(elements, rect, axis, otherAxis, sizeField) {
  var stacks = getStacks(elements, rect, sizeField);
  var origin = rect.origin.clone();
  var result = [];
  for (var idx = 0; idx < stacks.length; idx++) {
    var stack2 = stacks[idx];
    var startElement = stack2[0];
    origin[otherAxis] = startElement.bbox.origin[otherAxis];
    translateToPoint(origin, startElement.bbox, startElement.element);
    startElement.bbox.origin[axis] = origin[axis];
    stackElements(stack2, axis, otherAxis, sizeField);
    result.push([]);
    for (var elementIdx = 0; elementIdx < stack2.length; elementIdx++) {
      result[idx].push(stack2[elementIdx].element);
    }
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/wrap.js
function wrap(elements, rect) {
  return wrapElements(elements, rect, "x", "y", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-wrap.js
function vWrap(elements, rect) {
  return wrapElements(elements, rect, "y", "x", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/fit.js
function fit(element2, rect) {
  var bbox = element2.clippedBBox();
  if (bbox) {
    var elementSize3 = bbox.size;
    var rectSize = rect.size;
    if (rectSize.width < elementSize3.width || rectSize.height < elementSize3.height) {
      var scale = Math.min(rectSize.width / elementSize3.width, rectSize.height / elementSize3.height);
      var transform2 = element2.transform() || transform();
      transform2.scale(scale, scale);
      element2.transform(transform2);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/gradients/stops-array.js
var StopsArray = function(ElementsArray2) {
  function StopsArray2() {
    ElementsArray2.apply(this, arguments);
  }
  if (ElementsArray2)
    StopsArray2.__proto__ = ElementsArray2;
  StopsArray2.prototype = Object.create(ElementsArray2 && ElementsArray2.prototype);
  StopsArray2.prototype.constructor = StopsArray2;
  StopsArray2.prototype._change = function _change() {
    this.optionsChange({
      field: "stops"
    });
  };
  return StopsArray2;
}(elements_array_default);
var stops_array_default = StopsArray;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-options.js
function optionsAccessor(name2) {
  return function(value) {
    if (defined(value)) {
      this.options.set(name2, value);
      return this;
    }
    return this.options.get(name2);
  };
}
function defineOptionsAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = optionsAccessor(names[i]);
  }
}
var withOptions = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineOptionsAccessors(result.prototype, names);
  return result;
};
var with_options_default = withOptions;

// node_modules/@progress/kendo-drawing/dist/es/gradients/gradient-stop.js
var options = ["offset", "color", "opacity"];
var GradientStop = function(superclass) {
  function GradientStop2(offset3, color, opacity) {
    superclass.call(this);
    this.options = new options_store_default({
      offset: offset3,
      color,
      opacity: defined(opacity) ? opacity : 1
    });
    this.options.addObserver(this);
  }
  if (superclass)
    GradientStop2.__proto__ = superclass;
  GradientStop2.prototype = Object.create(superclass && superclass.prototype);
  GradientStop2.prototype.constructor = GradientStop2;
  GradientStop2.create = function create3(arg) {
    if (defined(arg)) {
      var stop;
      if (arg instanceof GradientStop2) {
        stop = arg;
      } else if (arg.length > 1) {
        stop = new GradientStop2(arg[0], arg[1], arg[2]);
      } else {
        stop = new GradientStop2(arg.offset, arg.color, arg.opacity);
      }
      return stop;
    }
  };
  return GradientStop2;
}(with_options_default(has_observers_default, options));
var gradient_stop_default = GradientStop;

// node_modules/@progress/kendo-drawing/dist/es/gradients/gradient.js
var Gradient = function(HasObservers2) {
  function Gradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    HasObservers2.call(this);
    this.stops = new stops_array_default(this._createStops(options2.stops));
    this.stops.addObserver(this);
    this._userSpace = options2.userSpace;
    this.id = definitionId();
  }
  if (HasObservers2)
    Gradient2.__proto__ = HasObservers2;
  Gradient2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Gradient2.prototype.constructor = Gradient2;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Gradient";
  };
  Gradient2.prototype.userSpace = function userSpace(value) {
    if (defined(value)) {
      this._userSpace = value;
      this.optionsChange();
      return this;
    }
    return this._userSpace;
  };
  Gradient2.prototype._createStops = function _createStops(stops) {
    if (stops === void 0)
      stops = [];
    var result = [];
    for (var idx = 0; idx < stops.length; idx++) {
      result.push(gradient_stop_default.create(stops[idx]));
    }
    return result;
  };
  Gradient2.prototype.addStop = function addStop(offset3, color, opacity) {
    this.stops.push(new gradient_stop_default(offset3, color, opacity));
  };
  Gradient2.prototype.removeStop = function removeStop(stop) {
    var index = this.stops.indexOf(stop);
    if (index >= 0) {
      this.stops.splice(index, 1);
    }
  };
  Gradient2.prototype.optionsChange = function optionsChange(e) {
    this.trigger("optionsChange", {
      field: "gradient" + (e ? "." + e.field : ""),
      value: this
    });
  };
  Gradient2.prototype.geometryChange = function geometryChange() {
    this.optionsChange();
  };
  Object.defineProperties(Gradient2.prototype, prototypeAccessors4);
  return Gradient2;
}(has_observers_default);
var gradient_default = Gradient;

// node_modules/@progress/kendo-drawing/dist/es/gradients/linear-gradient.js
var points2 = ["start", "end"];
var LinearGradient = function(superclass) {
  function LinearGradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.start(options2.start || new point_default());
    this.end(options2.end || new point_default(1, 0));
  }
  if (superclass)
    LinearGradient2.__proto__ = superclass;
  LinearGradient2.prototype = Object.create(superclass && superclass.prototype);
  LinearGradient2.prototype.constructor = LinearGradient2;
  return LinearGradient2;
}(with_points_default(gradient_default, points2));
var linear_gradient_default = LinearGradient;

// node_modules/@progress/kendo-drawing/dist/es/gradients/radial-gradient.js
var RadialGradient = function(superclass) {
  function RadialGradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.center(options2.center || new point_default());
    this._radius = defined(options2.radius) ? options2.radius : 1;
    this._fallbackFill = options2.fallbackFill;
  }
  if (superclass)
    RadialGradient2.__proto__ = superclass;
  RadialGradient2.prototype = Object.create(superclass && superclass.prototype);
  RadialGradient2.prototype.constructor = RadialGradient2;
  RadialGradient2.prototype.radius = function radius(value) {
    if (defined(value)) {
      this._radius = value;
      this.geometryChange();
      return this;
    }
    return this._radius;
  };
  RadialGradient2.prototype.fallbackFill = function fallbackFill(value) {
    if (defined(value)) {
      this._fallbackFill = value;
      this.optionsChange();
      return this;
    }
    return this._fallbackFill;
  };
  return RadialGradient2;
}(with_points_default(gradient_default, ["center"]));
var radial_gradient_default = RadialGradient;

// node_modules/@progress/kendo-drawing/dist/es/animations/easing-functions.js
var easing_functions_exports = {};
__export(easing_functions_exports, {
  easeOutElastic: () => easeOutElastic,
  linear: () => linear,
  swing: () => swing
});
function swing(position3) {
  return 0.5 - Math.cos(position3 * Math.PI) / 2;
}
function linear(position3) {
  return position3;
}
function easeOutElastic(position3, time, start, diff) {
  var s = 1.70158, p = 0, a = diff;
  if (position3 === 0) {
    return start;
  }
  if (position3 === 1) {
    return start + diff;
  }
  if (!p) {
    p = 0.5;
  }
  if (a < Math.abs(diff)) {
    a = diff;
    s = p / 4;
  } else {
    s = p / (2 * Math.PI) * Math.asin(diff / a);
  }
  return a * Math.pow(2, -10 * position3) * Math.sin((Number(position3) - s) * (1.1 * Math.PI) / p) + diff + start;
}

// node_modules/@progress/kendo-drawing/dist/es/animations/animation-factory.js
var instance;
var AnimationFactory = function(Class3) {
  function AnimationFactory2() {
    Class3.call(this);
    this._items = [];
  }
  if (Class3)
    AnimationFactory2.__proto__ = Class3;
  AnimationFactory2.prototype = Object.create(Class3 && Class3.prototype);
  AnimationFactory2.prototype.constructor = AnimationFactory2;
  var staticAccessors2 = { current: { configurable: true } };
  staticAccessors2.current.get = function() {
    if (!instance) {
      instance = new AnimationFactory2();
    }
    return instance;
  };
  AnimationFactory2.prototype.register = function register4(name2, type) {
    this._items.push({
      name: name2,
      type
    });
  };
  AnimationFactory2.prototype.create = function create3(element2, options2) {
    var items = this._items;
    var match;
    if (options2 && options2.type) {
      var type = options2.type.toLowerCase();
      for (var i = 0; i < items.length; i++) {
        if (items[i].name.toLowerCase() === type) {
          match = items[i];
          break;
        }
      }
    }
    if (match) {
      return new match.type(element2, options2);
    }
  };
  Object.defineProperties(AnimationFactory2, staticAccessors2);
  return AnimationFactory2;
}(class_default);
var animation_factory_default = AnimationFactory;

// node_modules/@progress/kendo-drawing/dist/es/animations/animation.js
var Animation = function(Class3) {
  function Animation3(element2, options2) {
    Class3.call(this);
    this.options = Object.assign({}, this.options, options2);
    this.element = element2;
  }
  if (Class3)
    Animation3.__proto__ = Class3;
  Animation3.prototype = Object.create(Class3 && Class3.prototype);
  Animation3.prototype.constructor = Animation3;
  var prototypeAccessors4 = { options: { configurable: true } };
  Animation3.create = function create3(type, element2, options2) {
    return animation_factory_default.current.create(type, element2, options2);
  };
  prototypeAccessors4.options.get = function() {
    return this._options || {
      duration: 500,
      easing: "swing"
    };
  };
  prototypeAccessors4.options.set = function(value) {
    this._options = value;
  };
  Animation3.prototype.setup = function setup() {
  };
  Animation3.prototype.step = function step() {
  };
  Animation3.prototype.play = function play() {
    var this$1 = this;
    var options2 = this.options;
    var duration2 = options2.duration;
    var delay = options2.delay;
    if (delay === void 0)
      delay = 0;
    var easing = easing_functions_exports[options2.easing];
    var start = now_default() + delay;
    var finish = start + duration2;
    if (duration2 === 0) {
      this.step(1);
      this.abort();
    } else {
      setTimeout(function() {
        var loop = function() {
          if (this$1._stopped) {
            return;
          }
          var wallTime = now_default();
          var time = limitValue(wallTime - start, 0, duration2);
          var position3 = time / duration2;
          var easingPosition = easing(position3, time, 0, 1, duration2);
          this$1.step(easingPosition);
          if (wallTime < finish) {
            animation_frame_default(loop);
          } else {
            this$1.abort();
          }
        };
        loop();
      }, delay);
    }
  };
  Animation3.prototype.abort = function abort() {
    this._stopped = true;
  };
  Animation3.prototype.destroy = function destroy2() {
    this.abort();
  };
  Object.defineProperties(Animation3.prototype, prototypeAccessors4);
  return Animation3;
}(class_default);
var animation_default = Animation;

// node_modules/@progress/kendo-drawing/dist/es/parsing/path-parser.js
var instance2;
var PathParser = function(Class3) {
  function PathParser2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    PathParser2.__proto__ = Class3;
  PathParser2.prototype = Object.create(Class3 && Class3.prototype);
  PathParser2.prototype.constructor = PathParser2;
  var staticAccessors2 = { current: { configurable: true } };
  staticAccessors2.current.get = function() {
    if (!instance2) {
      instance2 = new PathParser2();
    }
    return instance2;
  };
  PathParser2.prototype.parse = function parse(str, options2) {
    var multiPath = new MultiPath(options2);
    return parse_path_default(multiPath, str);
  };
  Object.defineProperties(PathParser2, staticAccessors2);
  return PathParser2;
}(class_default);
var path_parser_default = PathParser;

// node_modules/@progress/kendo-drawing/dist/es/core/base-node.js
var BaseNode = function(Class3) {
  function BaseNode2(srcElement) {
    Class3.call(this);
    this.childNodes = [];
    this.parent = null;
    if (srcElement) {
      this.srcElement = srcElement;
      this.observe();
    }
  }
  if (Class3)
    BaseNode2.__proto__ = Class3;
  BaseNode2.prototype = Object.create(Class3 && Class3.prototype);
  BaseNode2.prototype.constructor = BaseNode2;
  BaseNode2.prototype.destroy = function destroy2() {
    var this$1 = this;
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    var children = this.childNodes;
    for (var i = 0; i < children.length; i++) {
      this$1.childNodes[i].destroy();
    }
    this.parent = null;
  };
  BaseNode2.prototype.load = function load2() {
  };
  BaseNode2.prototype.observe = function observe() {
    if (this.srcElement) {
      this.srcElement.addObserver(this);
    }
  };
  BaseNode2.prototype.append = function append3(node2) {
    this.childNodes.push(node2);
    node2.parent = this;
  };
  BaseNode2.prototype.insertAt = function insertAt(node2, pos) {
    this.childNodes.splice(pos, 0, node2);
    node2.parent = this;
  };
  BaseNode2.prototype.remove = function remove(index, count) {
    var this$1 = this;
    var end = index + count;
    for (var i = index; i < end; i++) {
      this$1.childNodes[i].removeSelf();
    }
    this.childNodes.splice(index, count);
  };
  BaseNode2.prototype.removeSelf = function removeSelf() {
    this.clear();
    this.destroy();
  };
  BaseNode2.prototype.clear = function clear4() {
    this.remove(0, this.childNodes.length);
  };
  BaseNode2.prototype.invalidate = function invalidate() {
    if (this.parent) {
      this.parent.invalidate();
    }
  };
  BaseNode2.prototype.geometryChange = function geometryChange() {
    this.invalidate();
  };
  BaseNode2.prototype.optionsChange = function optionsChange() {
    this.invalidate();
  };
  BaseNode2.prototype.childrenChange = function childrenChange(e) {
    if (e.action === "add") {
      this.load(e.items, e.index);
    } else if (e.action === "remove") {
      this.remove(e.index, e.items.length);
    }
    this.invalidate();
  };
  return BaseNode2;
}(class_default);
var base_node_default = BaseNode;

// node_modules/@progress/kendo-drawing/dist/es/core/surface.js
var events = [
  "click",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "resize"
];
var Surface = function(Observable3) {
  function Surface6(element2, options2) {
    Observable3.call(this);
    this.options = Object.assign({}, options2);
    this.element = element2;
    this.element._kendoExportVisual = this.exportVisual.bind(this);
    this._click = this._handler("click");
    this._mouseenter = this._handler("mouseenter");
    this._mouseleave = this._handler("mouseleave");
    this._mousemove = this._handler("mousemove");
    this._visual = new group_default();
    elementSize(element2, this.options);
    this.bind(events, this.options);
    this._enableTracking();
  }
  if (Observable3)
    Surface6.__proto__ = Observable3;
  Surface6.prototype = Object.create(Observable3 && Observable3.prototype);
  Surface6.prototype.constructor = Surface6;
  Surface6.prototype.draw = function draw(element2) {
    this._visual.children.push(element2);
  };
  Surface6.prototype.clear = function clear4() {
    this._visual.children = [];
  };
  Surface6.prototype.destroy = function destroy2() {
    this._visual = null;
    this.element._kendoExportVisual = null;
    this.unbind();
  };
  Surface6.prototype.eventTarget = function eventTarget(e) {
    var this$1 = this;
    var domNode = eventElement(e);
    var node2;
    while (!node2 && domNode) {
      node2 = domNode._kendoNode;
      if (domNode === this$1.element) {
        break;
      }
      domNode = domNode.parentElement;
    }
    if (node2) {
      return node2.srcElement;
    }
  };
  Surface6.prototype.exportVisual = function exportVisual() {
    return this._visual;
  };
  Surface6.prototype.getSize = function getSize() {
    return elementSize(this.element);
  };
  Surface6.prototype.currentSize = function currentSize(size) {
    if (size) {
      this._size = size;
    } else {
      return this._size;
    }
  };
  Surface6.prototype.setSize = function setSize(size) {
    elementSize(this.element, size);
    this.currentSize(size);
    this._resize();
  };
  Surface6.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this.currentSize();
    if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this.currentSize(size);
      this._resize(size, force);
      this.trigger("resize", size);
    }
  };
  Surface6.prototype.size = function size(value) {
    if (!value) {
      return this.getSize();
    }
    this.setSize(value);
  };
  Surface6.prototype.suspendTracking = function suspendTracking() {
    this._suspendedTracking = true;
  };
  Surface6.prototype.resumeTracking = function resumeTracking() {
    this._suspendedTracking = false;
  };
  Surface6.prototype._enableTracking = function _enableTracking() {
  };
  Surface6.prototype._resize = function _resize() {
  };
  Surface6.prototype._handler = function _handler(eventName) {
    var this$1 = this;
    return function(e) {
      var node2 = this$1.eventTarget(e);
      if (node2 && !this$1._suspendedTracking) {
        this$1.trigger(eventName, {
          element: node2,
          originalEvent: e,
          type: eventName
        });
      }
    };
  };
  Surface6.prototype._elementOffset = function _elementOffset() {
    var element2 = this.element;
    var padding = elementPadding(element2);
    var ref2 = elementOffset(element2);
    var left = ref2.left;
    var top = ref2.top;
    return {
      left: left + padding.left,
      top: top + padding.top
    };
  };
  Surface6.prototype._surfacePoint = function _surfacePoint(e) {
    var offset3 = this._elementOffset();
    var coord = eventCoordinates(e);
    var x = coord.x - offset3.left;
    var y = coord.y - offset3.top;
    var inverseTransform = elementScale(this.element).invert();
    var point2 = new point_default(
      x,
      y
    ).transform(inverseTransform);
    return point2;
  };
  return Surface6;
}(observable_default);
var surface_default = Surface;

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-attribute.js
function renderAttr(name2, value) {
  return defined(value) && value !== null ? " " + name2 + '="' + value + '" ' : "";
}

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-all-attributes.js
function renderAllAttr(attrs) {
  var output = "";
  for (var i = 0; i < attrs.length; i++) {
    output += renderAttr(attrs[i][0], attrs[i][1]);
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-style.js
function renderStyle(attrs) {
  var output = "";
  for (var i = 0; i < attrs.length; i++) {
    var value = attrs[i][1];
    if (defined(value)) {
      output += attrs[i][0] + ":" + value + ";";
    }
  }
  if (output !== "") {
    return output;
  }
}

// node_modules/@progress/kendo-drawing/dist/es/svg/node-map.js
var NODE_MAP = {};
var node_map_default = NODE_MAP;

// node_modules/@progress/kendo-drawing/dist/es/svg/constants.js
var SVG_NS = "http://www.w3.org/2000/svg";
var NONE2 = "none";
var POINT_DIGITS = 3;

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-svg.js
var applyStyle = function(styleString, element2) {
  return styleString.split(";").filter(function(s) {
    return s !== "";
  }).forEach(function(s) {
    var parts = s.split(":");
    element2.style[parts[0].trim()] = parts[1].trim();
  });
};
var styleAttr = "data-style";
var replaceStyleAttr = function(html) {
  return html.replace(/\sstyle=/g, " " + styleAttr + "=");
};
var restoreStyleAttr = function(container) {
  Array.from(container.querySelectorAll("[" + styleAttr + "]")).forEach(function(element2) {
    var styleString = element2.getAttribute(styleAttr);
    element2.removeAttribute(styleAttr);
    applyStyle(styleString, element2);
  });
};
var renderSVG = function(container, svg) {
  container.innerHTML = replaceStyleAttr(svg);
  restoreStyleAttr(container);
};
if (typeof document !== "undefined") {
  testFragment = "<svg xmlns='" + SVG_NS + "'></svg>";
  testContainer = document.createElement("div");
  hasParser = typeof DOMParser !== "undefined";
  testContainer.innerHTML = testFragment;
  if (hasParser && testContainer.firstChild.namespaceURI !== SVG_NS) {
    renderSVG = function(container, svg) {
      var parser = new DOMParser();
      var chartDoc = parser.parseFromString(replaceStyleAttr(svg), "text/xml");
      restoreStyleAttr(chartDoc);
      var importedDoc = document.adoptNode(chartDoc.documentElement);
      container.innerHTML = "";
      container.appendChild(importedDoc);
    };
  }
}
var testFragment;
var testContainer;
var hasParser;
var render_svg_default = renderSVG;

// node_modules/@progress/kendo-drawing/dist/es/svg/node.js
var TRANSFORM = "transform";
var DefinitionMap = {
  clip: "clip-path",
  fill: "fill"
};
function isDefinition(type, value) {
  return type === "clip" || type === "fill" && (!value || value.nodeType === "Gradient");
}
function baseUrl() {
  var base = document.getElementsByTagName("base")[0];
  var href = document.location.href;
  var url = "";
  if (base && !(support_default.browser || {}).msie) {
    var hashIndex = href.indexOf("#");
    if (hashIndex !== -1) {
      href = href.substring(0, hashIndex);
    }
    url = href;
  }
  return url;
}
var Node = function(BaseNode2) {
  function Node3(srcElement, options2) {
    BaseNode2.call(this, srcElement);
    this.definitions = {};
    this.options = options2;
  }
  if (BaseNode2)
    Node3.__proto__ = BaseNode2;
  Node3.prototype = Object.create(BaseNode2 && BaseNode2.prototype);
  Node3.prototype.constructor = Node3;
  Node3.prototype.destroy = function destroy2() {
    if (this.element) {
      this.element._kendoNode = null;
      this.element = null;
    }
    this.clearDefinitions();
    BaseNode2.prototype.destroy.call(this);
  };
  Node3.prototype.load = function load2(elements, pos) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var srcElement = elements[i];
      var children = srcElement.children;
      var childNode = new node_map_default[srcElement.nodeType](srcElement, this$1.options);
      if (defined(pos)) {
        this$1.insertAt(childNode, pos);
      } else {
        this$1.append(childNode);
      }
      childNode.createDefinitions();
      if (children && children.length > 0) {
        childNode.load(children);
      }
      var element2 = this$1.element;
      if (element2) {
        childNode.attachTo(element2, pos);
      }
    }
  };
  Node3.prototype.root = function root() {
    var root2 = this;
    while (root2.parent) {
      root2 = root2.parent;
    }
    return root2;
  };
  Node3.prototype.attachTo = function attachTo(domElement, pos) {
    var container = document.createElement("div");
    render_svg_default(
      container,
      "<svg xmlns='" + SVG_NS + "' version='1.1'>" + this.render() + "</svg>"
    );
    var element2 = container.firstChild.firstChild;
    if (element2) {
      if (defined(pos)) {
        domElement.insertBefore(element2, domElement.childNodes[pos] || null);
      } else {
        domElement.appendChild(element2);
      }
      this.setElement(element2);
    }
  };
  Node3.prototype.setElement = function setElement(element2) {
    if (this.element) {
      this.element._kendoNode = null;
    }
    this.element = element2;
    this.element._kendoNode = this;
    var nodes = this.childNodes;
    for (var i = 0; i < nodes.length; i++) {
      var childElement = element2.childNodes[i];
      nodes[i].setElement(childElement);
    }
  };
  Node3.prototype.clear = function clear4() {
    this.clearDefinitions();
    if (this.element) {
      this.element.innerHTML = "";
    }
    var children = this.childNodes;
    for (var i = 0; i < children.length; i++) {
      children[i].destroy();
    }
    this.childNodes = [];
  };
  Node3.prototype.removeSelf = function removeSelf() {
    if (this.element) {
      var parentNode = this.element.parentNode;
      if (parentNode) {
        parentNode.removeChild(this.element);
      }
      this.element = null;
    }
    BaseNode2.prototype.removeSelf.call(this);
  };
  Node3.prototype.template = function template3() {
    return this.renderChildren();
  };
  Node3.prototype.render = function render() {
    return this.template();
  };
  Node3.prototype.renderChildren = function renderChildren() {
    var nodes = this.childNodes;
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
      output += nodes[i].render();
    }
    return output;
  };
  Node3.prototype.optionsChange = function optionsChange(e) {
    var field = e.field;
    var value = e.value;
    if (field === "visible") {
      this.css("display", value ? "" : NONE2);
    } else if (DefinitionMap[field] && isDefinition(field, value)) {
      this.updateDefinition(field, value);
    } else if (field === "opacity") {
      this.attr("opacity", value);
    } else if (field === "cursor") {
      this.css("cursor", value);
    } else if (field === "id") {
      if (value) {
        this.attr("id", value);
      } else {
        this.removeAttr("id");
      }
    }
    BaseNode2.prototype.optionsChange.call(this, e);
  };
  Node3.prototype.attr = function attr(name2, value) {
    if (this.element) {
      this.element.setAttribute(name2, value);
    }
  };
  Node3.prototype.allAttr = function allAttr(attrs) {
    var this$1 = this;
    for (var i = 0; i < attrs.length; i++) {
      this$1.attr(attrs[i][0], attrs[i][1]);
    }
  };
  Node3.prototype.css = function css(name2, value) {
    if (this.element) {
      this.element.style[name2] = value;
    }
  };
  Node3.prototype.allCss = function allCss(styles) {
    var this$1 = this;
    for (var i = 0; i < styles.length; i++) {
      this$1.css(styles[i][0], styles[i][1]);
    }
  };
  Node3.prototype.removeAttr = function removeAttr(name2) {
    if (this.element) {
      this.element.removeAttribute(name2);
    }
  };
  Node3.prototype.mapTransform = function mapTransform(transform2) {
    var attrs = [];
    if (transform2) {
      attrs.push(
        [
          TRANSFORM,
          "matrix(" + transform2.matrix().toString(6) + ")"
        ]
      );
    }
    return attrs;
  };
  Node3.prototype.renderTransform = function renderTransform() {
    return renderAllAttr(
      this.mapTransform(this.srcElement.transform())
    );
  };
  Node3.prototype.transformChange = function transformChange(value) {
    if (value) {
      this.allAttr(this.mapTransform(value));
    } else {
      this.removeAttr(TRANSFORM);
    }
  };
  Node3.prototype.mapStyle = function mapStyle() {
    var options2 = this.srcElement.options;
    var style = [["cursor", options2.cursor]];
    if (options2.visible === false) {
      style.push(["display", NONE2]);
    }
    return style;
  };
  Node3.prototype.renderStyle = function renderStyle$1() {
    return renderAttr("style", renderStyle(this.mapStyle(true)));
  };
  Node3.prototype.renderOpacity = function renderOpacity() {
    return renderAttr("opacity", this.srcElement.options.opacity);
  };
  Node3.prototype.renderId = function renderId() {
    return renderAttr("id", this.srcElement.options.id);
  };
  Node3.prototype.createDefinitions = function createDefinitions() {
    var srcElement = this.srcElement;
    var definitions = this.definitions;
    if (srcElement) {
      var options2 = srcElement.options;
      var hasDefinitions;
      for (var field in DefinitionMap) {
        var definition = options2.get(field);
        if (definition && isDefinition(field, definition)) {
          definitions[field] = definition;
          hasDefinitions = true;
        }
      }
      if (hasDefinitions) {
        this.definitionChange({
          action: "add",
          definitions
        });
      }
    }
  };
  Node3.prototype.definitionChange = function definitionChange(e) {
    if (this.parent) {
      this.parent.definitionChange(e);
    }
  };
  Node3.prototype.updateDefinition = function updateDefinition(type, value) {
    var definitions = this.definitions;
    var current4 = definitions[type];
    var attr = DefinitionMap[type];
    var definition = {};
    if (current4) {
      definition[type] = current4;
      this.definitionChange({
        action: "remove",
        definitions: definition
      });
      delete definitions[type];
    }
    if (!value) {
      if (current4) {
        this.removeAttr(attr);
      }
    } else {
      definition[type] = value;
      this.definitionChange({
        action: "add",
        definitions: definition
      });
      definitions[type] = value;
      this.attr(attr, this.refUrl(value.id));
    }
  };
  Node3.prototype.clearDefinitions = function clearDefinitions() {
    var definitions = this.definitions;
    this.definitionChange({
      action: "remove",
      definitions
    });
    this.definitions = {};
  };
  Node3.prototype.renderDefinitions = function renderDefinitions() {
    return renderAllAttr(this.mapDefinitions());
  };
  Node3.prototype.mapDefinitions = function mapDefinitions() {
    var this$1 = this;
    var definitions = this.definitions;
    var attrs = [];
    for (var field in definitions) {
      attrs.push([DefinitionMap[field], this$1.refUrl(definitions[field].id)]);
    }
    return attrs;
  };
  Node3.prototype.refUrl = function refUrl(id) {
    var skipBaseHref = (this.options || {}).skipBaseHref;
    var baseHref = this.baseUrl().replace(/'/g, "\\'");
    var base = skipBaseHref ? "" : baseHref;
    return "url(" + base + "#" + id + ")";
  };
  Node3.prototype.baseUrl = function baseUrl$1() {
    return baseUrl();
  };
  return Node3;
}(base_node_default);
var node_default = Node;

// node_modules/@progress/kendo-drawing/dist/es/svg/gradient-stop-node.js
var GradientStopNode = function(Node3) {
  function GradientStopNode2() {
    Node3.apply(this, arguments);
  }
  if (Node3)
    GradientStopNode2.__proto__ = Node3;
  GradientStopNode2.prototype = Object.create(Node3 && Node3.prototype);
  GradientStopNode2.prototype.constructor = GradientStopNode2;
  GradientStopNode2.prototype.template = function template3() {
    return "<stop " + this.renderOffset() + " " + this.renderStyle() + " />";
  };
  GradientStopNode2.prototype.renderOffset = function renderOffset() {
    return renderAttr("offset", this.srcElement.offset());
  };
  GradientStopNode2.prototype.mapStyle = function mapStyle() {
    var srcElement = this.srcElement;
    return [
      ["stop-color", srcElement.color()],
      ["stop-opacity", srcElement.opacity()]
    ];
  };
  GradientStopNode2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "offset") {
      this.attr(e.field, e.value);
    } else if (e.field === "color" || e.field === "opacity") {
      this.css("stop-" + e.field, e.value);
    }
  };
  return GradientStopNode2;
}(node_default);
var gradient_stop_node_default = GradientStopNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/gradient-node.js
var GradientNode = function(Node3) {
  function GradientNode2(srcElement) {
    Node3.call(this, srcElement);
    this.id = srcElement.id;
    this.loadStops();
  }
  if (Node3)
    GradientNode2.__proto__ = Node3;
  GradientNode2.prototype = Object.create(Node3 && Node3.prototype);
  GradientNode2.prototype.constructor = GradientNode2;
  GradientNode2.prototype.loadStops = function loadStops() {
    var this$1 = this;
    var stops = this.srcElement.stops;
    var element2 = this.element;
    for (var idx = 0; idx < stops.length; idx++) {
      var stopNode = new gradient_stop_node_default(stops[idx]);
      this$1.append(stopNode);
      if (element2) {
        stopNode.attachTo(element2);
      }
    }
  };
  GradientNode2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "gradient.stops") {
      base_node_default.prototype.clear.call(this);
      this.loadStops();
    } else if (e.field === "gradient") {
      this.allAttr(this.mapCoordinates());
    }
  };
  GradientNode2.prototype.renderCoordinates = function renderCoordinates() {
    return renderAllAttr(this.mapCoordinates());
  };
  GradientNode2.prototype.mapSpace = function mapSpace() {
    return ["gradientUnits", this.srcElement.userSpace() ? "userSpaceOnUse" : "objectBoundingBox"];
  };
  return GradientNode2;
}(node_default);
var gradient_node_default = GradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/linear-gradient-node.js
var LinearGradientNode = function(GradientNode2) {
  function LinearGradientNode2() {
    GradientNode2.apply(this, arguments);
  }
  if (GradientNode2)
    LinearGradientNode2.__proto__ = GradientNode2;
  LinearGradientNode2.prototype = Object.create(GradientNode2 && GradientNode2.prototype);
  LinearGradientNode2.prototype.constructor = LinearGradientNode2;
  LinearGradientNode2.prototype.template = function template3() {
    return "<linearGradient id='" + this.id + "' " + this.renderCoordinates() + ">" + this.renderChildren() + "</linearGradient>";
  };
  LinearGradientNode2.prototype.mapCoordinates = function mapCoordinates() {
    var srcElement = this.srcElement;
    var start = srcElement.start();
    var end = srcElement.end();
    var attrs = [
      ["x1", start.x],
      ["y1", start.y],
      ["x2", end.x],
      ["y2", end.y],
      this.mapSpace()
    ];
    return attrs;
  };
  return LinearGradientNode2;
}(gradient_node_default);
var linear_gradient_node_default = LinearGradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/radial-gradient-node.js
var RadialGradientNode = function(GradientNode2) {
  function RadialGradientNode2() {
    GradientNode2.apply(this, arguments);
  }
  if (GradientNode2)
    RadialGradientNode2.__proto__ = GradientNode2;
  RadialGradientNode2.prototype = Object.create(GradientNode2 && GradientNode2.prototype);
  RadialGradientNode2.prototype.constructor = RadialGradientNode2;
  RadialGradientNode2.prototype.template = function template3() {
    return "<radialGradient id='" + this.id + "' " + this.renderCoordinates() + ">" + this.renderChildren() + "</radialGradient>";
  };
  RadialGradientNode2.prototype.mapCoordinates = function mapCoordinates() {
    var srcElement = this.srcElement;
    var center = srcElement.center();
    var radius = srcElement.radius();
    var attrs = [
      ["cx", center.x],
      ["cy", center.y],
      ["r", radius],
      this.mapSpace()
    ];
    return attrs;
  };
  return RadialGradientNode2;
}(gradient_node_default);
var radial_gradient_node_default = RadialGradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/clip-node.js
var ClipNode = function(Node3) {
  function ClipNode2(srcElement) {
    Node3.call(this);
    this.srcElement = srcElement;
    this.id = srcElement.id;
    this.load([srcElement]);
  }
  if (Node3)
    ClipNode2.__proto__ = Node3;
  ClipNode2.prototype = Object.create(Node3 && Node3.prototype);
  ClipNode2.prototype.constructor = ClipNode2;
  ClipNode2.prototype.template = function template3() {
    return "<clipPath id='" + this.id + "'>" + this.renderChildren() + "</clipPath>";
  };
  return ClipNode2;
}(node_default);
var clip_node_default = ClipNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/definition-node.js
var DefinitionNode = function(Node3) {
  function DefinitionNode2() {
    Node3.call(this);
    this.definitionMap = {};
  }
  if (Node3)
    DefinitionNode2.__proto__ = Node3;
  DefinitionNode2.prototype = Object.create(Node3 && Node3.prototype);
  DefinitionNode2.prototype.constructor = DefinitionNode2;
  DefinitionNode2.prototype.attachTo = function attachTo(domElement) {
    this.element = domElement;
  };
  DefinitionNode2.prototype.template = function template3() {
    return "<defs>" + this.renderChildren() + "</defs>";
  };
  DefinitionNode2.prototype.definitionChange = function definitionChange(e) {
    var definitions = e.definitions;
    var action = e.action;
    if (action === "add") {
      this.addDefinitions(definitions);
    } else if (action === "remove") {
      this.removeDefinitions(definitions);
    }
  };
  DefinitionNode2.prototype.createDefinition = function createDefinition(type, item) {
    var nodeType;
    if (type === "clip") {
      nodeType = clip_node_default;
    } else if (type === "fill") {
      if (item instanceof linear_gradient_default) {
        nodeType = linear_gradient_node_default;
      } else if (item instanceof radial_gradient_default) {
        nodeType = radial_gradient_node_default;
      }
    }
    return new nodeType(item);
  };
  DefinitionNode2.prototype.addDefinitions = function addDefinitions(definitions) {
    var this$1 = this;
    for (var field in definitions) {
      this$1.addDefinition(field, definitions[field]);
    }
  };
  DefinitionNode2.prototype.addDefinition = function addDefinition(type, srcElement) {
    var ref2 = this;
    var element2 = ref2.element;
    var definitionMap = ref2.definitionMap;
    var id = srcElement.id;
    var mapItem = definitionMap[id];
    if (!mapItem) {
      var node2 = this.createDefinition(type, srcElement);
      definitionMap[id] = {
        element: node2,
        count: 1
      };
      this.append(node2);
      if (element2) {
        node2.attachTo(this.element);
      }
    } else {
      mapItem.count++;
    }
  };
  DefinitionNode2.prototype.removeDefinitions = function removeDefinitions(definitions) {
    var this$1 = this;
    for (var field in definitions) {
      this$1.removeDefinition(definitions[field]);
    }
  };
  DefinitionNode2.prototype.removeDefinition = function removeDefinition(srcElement) {
    var definitionMap = this.definitionMap;
    var id = srcElement.id;
    var mapItem = definitionMap[id];
    if (mapItem) {
      mapItem.count--;
      if (mapItem.count === 0) {
        this.remove(this.childNodes.indexOf(mapItem.element), 1);
        delete definitionMap[id];
      }
    }
  };
  return DefinitionNode2;
}(node_default);
var definition_node_default = DefinitionNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/root-node.js
var RootNode = function(Node3) {
  function RootNode3(options2) {
    Node3.call(this);
    this.options = options2;
    this.defs = new definition_node_default();
  }
  if (Node3)
    RootNode3.__proto__ = Node3;
  RootNode3.prototype = Object.create(Node3 && Node3.prototype);
  RootNode3.prototype.constructor = RootNode3;
  RootNode3.prototype.attachTo = function attachTo(domElement) {
    this.element = domElement;
    this.defs.attachTo(domElement.firstElementChild);
  };
  RootNode3.prototype.clear = function clear4() {
    base_node_default.prototype.clear.call(this);
  };
  RootNode3.prototype.template = function template3() {
    return this.defs.render() + this.renderChildren();
  };
  RootNode3.prototype.definitionChange = function definitionChange(e) {
    this.defs.definitionChange(e);
  };
  return RootNode3;
}(node_default);
var root_node_default = RootNode;

// node_modules/@progress/kendo-drawing/dist/es/core/constants.js
var DASH_ARRAYS = {
  dot: [1.5, 3.5],
  dash: [4, 3.5],
  longdash: [8, 3.5],
  dashdot: [3.5, 3.5, 1.5, 3.5],
  longdashdot: [8, 3.5, 1.5, 3.5],
  longdashdotdot: [8, 3.5, 1.5, 3.5, 1.5, 3.5]
};
var SOLID = "solid";
var BUTT = "butt";

// node_modules/@progress/kendo-drawing/dist/es/svg/path-node.js
var ATTRIBUTE_MAP = {
  "fill.opacity": "fill-opacity",
  "stroke.color": "stroke",
  "stroke.width": "stroke-width",
  "stroke.opacity": "stroke-opacity"
};
var PathNode = function(Node3) {
  function PathNode3() {
    Node3.apply(this, arguments);
  }
  if (Node3)
    PathNode3.__proto__ = Node3;
  PathNode3.prototype = Object.create(Node3 && Node3.prototype);
  PathNode3.prototype.constructor = PathNode3;
  PathNode3.prototype.geometryChange = function geometryChange() {
    this.attr("d", this.renderData());
    this.invalidate();
  };
  PathNode3.prototype.optionsChange = function optionsChange(e) {
    switch (e.field) {
      case "fill":
        if (e.value) {
          this.allAttr(this.mapFill(e.value));
        } else {
          this.removeAttr("fill");
        }
        break;
      case "fill.color":
        this.allAttr(this.mapFill({ color: e.value }));
        break;
      case "stroke":
        if (e.value) {
          this.allAttr(this.mapStroke(e.value));
        } else {
          this.removeAttr("stroke");
        }
        break;
      case "transform":
        this.transformChange(e.value);
        break;
      default:
        var name2 = ATTRIBUTE_MAP[e.field];
        if (name2) {
          this.attr(name2, e.value);
        }
        break;
    }
    Node3.prototype.optionsChange.call(this, e);
  };
  PathNode3.prototype.content = function content() {
    if (this.element) {
      this.element.textContent = this.srcElement.content();
    }
  };
  PathNode3.prototype.renderData = function renderData() {
    return this.srcElement.toString(POINT_DIGITS) || void 0;
  };
  PathNode3.prototype.mapStroke = function mapStroke(stroke) {
    var attrs = [];
    if (stroke && !isTransparent(stroke.color)) {
      attrs.push(["stroke", stroke.color]);
      attrs.push(["stroke-width", stroke.width]);
      attrs.push(["stroke-linecap", this.renderLinecap(stroke)]);
      attrs.push(["stroke-linejoin", stroke.lineJoin]);
      if (defined(stroke.opacity)) {
        attrs.push(["stroke-opacity", stroke.opacity]);
      }
      if (defined(stroke.dashType)) {
        attrs.push(["stroke-dasharray", this.renderDashType(stroke)]);
      }
    } else {
      attrs.push(["stroke", NONE2]);
    }
    return attrs;
  };
  PathNode3.prototype.renderStroke = function renderStroke() {
    return renderAllAttr(
      this.mapStroke(this.srcElement.options.stroke)
    );
  };
  PathNode3.prototype.renderDashType = function renderDashType(stroke) {
    var dashType = stroke.dashType;
    var width = stroke.width;
    if (width === void 0)
      width = 1;
    if (dashType && dashType !== SOLID) {
      var dashArray = DASH_ARRAYS[dashType.toLowerCase()];
      var result = [];
      for (var i = 0; i < dashArray.length; i++) {
        result.push(dashArray[i] * width);
      }
      return result.join(" ");
    }
  };
  PathNode3.prototype.renderLinecap = function renderLinecap(stroke) {
    var dashType = stroke.dashType;
    var lineCap = stroke.lineCap;
    return dashType && dashType !== "solid" ? BUTT : lineCap;
  };
  PathNode3.prototype.mapFill = function mapFill(fill) {
    var attrs = [];
    if (!(fill && fill.nodeType === "Gradient")) {
      if (fill && !isTransparent(fill.color)) {
        attrs.push(["fill", fill.color]);
        if (defined(fill.opacity)) {
          attrs.push(["fill-opacity", fill.opacity]);
        }
      } else {
        attrs.push(["fill", NONE2]);
      }
    }
    return attrs;
  };
  PathNode3.prototype.renderFill = function renderFill() {
    return renderAllAttr(
      this.mapFill(this.srcElement.options.fill)
    );
  };
  PathNode3.prototype.template = function template3() {
    return "<path " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + " " + renderAttr("d", this.renderData()) + this.renderStroke() + this.renderFill() + this.renderDefinitions() + this.renderTransform() + "></path>";
  };
  return PathNode3;
}(node_default);
var path_node_default = PathNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/arc-node.js
var ArcNode = function(PathNode3) {
  function ArcNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    ArcNode3.__proto__ = PathNode3;
  ArcNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ArcNode3.prototype.constructor = ArcNode3;
  ArcNode3.prototype.renderData = function renderData() {
    return this.srcElement.toPath().toString(POINT_DIGITS);
  };
  return ArcNode3;
}(path_node_default);
var arc_node_default = ArcNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/circle-node.js
var CircleNode = function(PathNode3) {
  function CircleNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    CircleNode3.__proto__ = PathNode3;
  CircleNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  CircleNode3.prototype.constructor = CircleNode3;
  CircleNode3.prototype.geometryChange = function geometryChange() {
    var center = this.center();
    this.attr("cx", center.x);
    this.attr("cy", center.y);
    this.attr("r", this.radius());
    this.invalidate();
  };
  CircleNode3.prototype.center = function center() {
    return this.srcElement.geometry().center;
  };
  CircleNode3.prototype.radius = function radius() {
    return this.srcElement.geometry().radius;
  };
  CircleNode3.prototype.template = function template3() {
    return "<circle " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + "cx='" + this.center().x + "' cy='" + this.center().y + "' r='" + this.radius() + "'" + this.renderStroke() + " " + this.renderFill() + " " + this.renderDefinitions() + this.renderTransform() + " ></circle>";
  };
  return CircleNode3;
}(path_node_default);
var circle_node_default = CircleNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/group-node.js
var GroupNode = function(Node3) {
  function GroupNode3() {
    Node3.apply(this, arguments);
  }
  if (Node3)
    GroupNode3.__proto__ = Node3;
  GroupNode3.prototype = Object.create(Node3 && Node3.prototype);
  GroupNode3.prototype.constructor = GroupNode3;
  GroupNode3.prototype.template = function template3() {
    return "<g" + (this.renderId() + this.renderTransform() + this.renderStyle() + this.renderOpacity() + this.renderDefinitions()) + ">" + this.renderChildren() + "</g>";
  };
  GroupNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "transform") {
      this.transformChange(e.value);
    }
    Node3.prototype.optionsChange.call(this, e);
  };
  return GroupNode3;
}(node_default);
var group_node_default = GroupNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/image-node.js
var ImageNode = function(PathNode3) {
  function ImageNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    ImageNode3.__proto__ = PathNode3;
  ImageNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ImageNode3.prototype.constructor = ImageNode3;
  ImageNode3.prototype.geometryChange = function geometryChange() {
    this.allAttr(this.mapPosition());
    this.invalidate();
  };
  ImageNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "src") {
      this.allAttr(this.mapSource());
    }
    PathNode3.prototype.optionsChange.call(this, e);
  };
  ImageNode3.prototype.mapPosition = function mapPosition() {
    var rect = this.srcElement.rect();
    var tl = rect.topLeft();
    return [
      ["x", tl.x],
      ["y", tl.y],
      ["width", rect.width() + "px"],
      ["height", rect.height() + "px"]
    ];
  };
  ImageNode3.prototype.renderPosition = function renderPosition() {
    return renderAllAttr(this.mapPosition());
  };
  ImageNode3.prototype.mapSource = function mapSource(encode) {
    var src = this.srcElement.src();
    if (encode) {
      src = htmlEncode(src);
    }
    return [["xlink:href", src]];
  };
  ImageNode3.prototype.renderSource = function renderSource() {
    return renderAllAttr(this.mapSource(true));
  };
  ImageNode3.prototype.template = function template3() {
    return "<image preserveAspectRatio='none' " + this.renderId() + " " + this.renderStyle() + " " + this.renderTransform() + " " + this.renderOpacity() + this.renderPosition() + " " + this.renderSource() + " " + this.renderDefinitions() + "></image>";
  };
  return ImageNode3;
}(path_node_default);
var image_node_default = ImageNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/multi-path-node.js
var MultiPathNode = function(PathNode3) {
  function MultiPathNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    MultiPathNode3.__proto__ = PathNode3;
  MultiPathNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  MultiPathNode3.prototype.constructor = MultiPathNode3;
  MultiPathNode3.prototype.renderData = function renderData() {
    return this.srcElement.toString(POINT_DIGITS) || "undefined";
  };
  return MultiPathNode3;
}(path_node_default);
var multi_path_node_default = MultiPathNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/rect-node.js
var RectNode = function(PathNode3) {
  function RectNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    RectNode3.__proto__ = PathNode3;
  RectNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  RectNode3.prototype.constructor = RectNode3;
  RectNode3.prototype.geometryChange = function geometryChange() {
    var geometry = this.srcElement.geometry();
    this.attr("x", geometry.origin.x);
    this.attr("y", geometry.origin.y);
    this.attr("width", geometry.size.width);
    this.attr("height", geometry.size.height);
    this.attr("rx", geometry.cornerRadius[0]);
    this.attr("ry", geometry.cornerRadius[1]);
    this.invalidate();
  };
  RectNode3.prototype.size = function size() {
    return this.srcElement.geometry().size;
  };
  RectNode3.prototype.origin = function origin() {
    return this.srcElement.geometry().origin;
  };
  RectNode3.prototype.rx = function rx() {
    return this.srcElement.geometry().cornerRadius[0];
  };
  RectNode3.prototype.ry = function ry() {
    return this.srcElement.geometry().cornerRadius[1];
  };
  RectNode3.prototype.template = function template3() {
    return "<rect " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + " x='" + this.origin().x + "' y='" + this.origin().y + "' rx='" + this.rx() + "' ry='" + this.ry() + "' width='" + this.size().width + "' height='" + this.size().height + "' " + this.renderStroke() + " " + this.renderFill() + " " + this.renderDefinitions() + " " + this.renderTransform() + " />";
  };
  return RectNode3;
}(path_node_default);
var rect_node_default = RectNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/text-node.js
var ENTITY_REGEX = /&(?:[a-zA-Z]+|#\d+);/g;
function decodeEntities(text) {
  if (!text || typeof text !== "string" || !ENTITY_REGEX.test(text)) {
    return text;
  }
  var element2 = decodeEntities._element;
  ENTITY_REGEX.lastIndex = 0;
  return text.replace(ENTITY_REGEX, function(match) {
    element2.innerHTML = match;
    return element2.textContent || element2.innerText;
  });
}
if (typeof document !== "undefined") {
  decodeEntities._element = document.createElement("span");
}
var TextNode = function(PathNode3) {
  function TextNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    TextNode3.__proto__ = PathNode3;
  TextNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  TextNode3.prototype.constructor = TextNode3;
  TextNode3.prototype.geometryChange = function geometryChange() {
    var pos = this.pos();
    this.attr("x", pos.x);
    this.attr("y", pos.y);
    this.invalidate();
  };
  TextNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "font") {
      this.attr("style", renderStyle(this.mapStyle()));
      this.geometryChange();
    } else if (e.field === "content") {
      PathNode3.prototype.content.call(this, this.srcElement.content());
    }
    PathNode3.prototype.optionsChange.call(this, e);
  };
  TextNode3.prototype.mapStyle = function mapStyle(encode) {
    var style = PathNode3.prototype.mapStyle.call(this, encode);
    var font2 = this.srcElement.options.font;
    if (encode) {
      font2 = htmlEncode(font2);
    }
    style.push(["font", font2], ["white-space", "pre"]);
    return style;
  };
  TextNode3.prototype.pos = function pos() {
    var pos2 = this.srcElement.position();
    var size = this.srcElement.measure();
    return pos2.clone().setY(pos2.y + size.baseline);
  };
  TextNode3.prototype.renderContent = function renderContent() {
    var content = this.srcElement.content();
    content = decodeEntities(content);
    content = htmlEncode(content);
    return normalizeText(content);
  };
  TextNode3.prototype.renderTextAnchor = function renderTextAnchor() {
    var anchor;
    if ((this.options || {}).rtl && !(support_default.browser.msie || support_default.browser.edge)) {
      anchor = "end";
    }
    return renderAttr("text-anchor", anchor);
  };
  TextNode3.prototype.template = function template3() {
    return "<text " + this.renderId() + " " + this.renderTextAnchor() + " " + this.renderStyle() + " " + this.renderOpacity() + "x='" + this.pos().x + "' y='" + this.pos().y + "' " + this.renderStroke() + " " + this.renderTransform() + " " + this.renderDefinitions() + this.renderFill() + ">" + this.renderContent() + "</text>";
  };
  return TextNode3;
}(path_node_default);
var text_node_default = TextNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/surface.js
node_map_default.Arc = arc_node_default;
node_map_default.Circle = circle_node_default;
node_map_default.Group = group_node_default;
node_map_default.Image = image_node_default;
node_map_default.MultiPath = multi_path_node_default;
node_map_default.Path = path_node_default;
node_map_default.Rect = rect_node_default;
node_map_default.Text = text_node_default;
var RTL = "rtl";
function alignToScreen(element2) {
  var ctm;
  try {
    ctm = element2.getScreenCTM ? element2.getScreenCTM() : null;
  } catch (e) {
  }
  if (ctm) {
    var left = -ctm.e % 1;
    var top = -ctm.f % 1;
    var style = element2.style;
    if (left !== 0 || top !== 0) {
      style.left = left + "px";
      style.top = top + "px";
    }
  }
}
var Surface2 = function(BaseSurface) {
  function Surface6(element2, options2) {
    BaseSurface.call(this, element2, options2);
    this._root = new root_node_default(Object.assign({
      rtl: elementStyles(element2, "direction").direction === RTL
    }, this.options));
    render_svg_default(this.element, this._template(""));
    this._rootElement = this.element.firstElementChild;
    this._rootElement.style.width = "100%";
    this._rootElement.style.height = "100%";
    this._rootElement.style.overflow = "hidden";
    alignToScreen(this._rootElement);
    this._root.attachTo(this._rootElement);
    bindEvents(this.element, {
      click: this._click,
      mouseover: this._mouseenter,
      mouseout: this._mouseleave,
      mousemove: this._mousemove
    });
    this.resize();
  }
  if (BaseSurface)
    Surface6.__proto__ = BaseSurface;
  Surface6.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface6.prototype.constructor = Surface6;
  var prototypeAccessors4 = { type: { configurable: true } };
  prototypeAccessors4.type.get = function() {
    return "svg";
  };
  Surface6.prototype.destroy = function destroy2() {
    if (this._root) {
      this._root.destroy();
      this._root = null;
      this._rootElement = null;
      unbindEvents(this.element, {
        click: this._click,
        mouseover: this._mouseenter,
        mouseout: this._mouseleave,
        mousemove: this._mousemove
      });
    }
    BaseSurface.prototype.destroy.call(this);
  };
  Surface6.prototype.translate = function translate2(offset3) {
    var viewBox = Math.round(offset3.x) + " " + Math.round(offset3.y) + " " + this._size.width + " " + this._size.height;
    this._offset = offset3;
    this._rootElement.setAttribute("viewBox", viewBox);
  };
  Surface6.prototype.draw = function draw(element2) {
    BaseSurface.prototype.draw.call(this, element2);
    this._root.load([element2]);
  };
  Surface6.prototype.clear = function clear4() {
    BaseSurface.prototype.clear.call(this);
    this._root.clear();
  };
  Surface6.prototype.svg = function svg() {
    return "<?xml version='1.0' ?>" + this._template();
  };
  Surface6.prototype.exportVisual = function exportVisual() {
    var ref2 = this;
    var visual = ref2._visual;
    var offset3 = ref2._offset;
    if (offset3) {
      var wrap2 = new group_default();
      wrap2.children.push(visual);
      wrap2.transform(
        transform().translate(-offset3.x, -offset3.y)
      );
      visual = wrap2;
    }
    return visual;
  };
  Surface6.prototype._resize = function _resize() {
    if (this._offset) {
      this.translate(this._offset);
    }
  };
  Surface6.prototype._template = function _template(svgStyles) {
    var styles = typeof svgStyles === "string" ? svgStyles : "style='width: 100%; height: 100%; overflow: hidden;' ";
    return "<svg " + styles + "xmlns='" + SVG_NS + "' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>" + this._root.render() + "</svg>";
  };
  Object.defineProperties(Surface6.prototype, prototypeAccessors4);
  return Surface6;
}(surface_default);
var surface_default2 = Surface2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/node-map.js
var NODE_MAP2 = {};
var node_map_default2 = NODE_MAP2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/utils/render-path.js
function renderPath(ctx, path) {
  var segments = path.segments;
  if (segments.length === 0) {
    return;
  }
  var segment = segments[0];
  var anchor = segment.anchor();
  ctx.moveTo(anchor.x, anchor.y);
  for (var i = 1; i < segments.length; i++) {
    segment = segments[i];
    anchor = segment.anchor();
    var prevSeg = segments[i - 1];
    var prevOut = prevSeg.controlOut();
    var controlIn = segment.controlIn();
    if (prevOut && controlIn) {
      ctx.bezierCurveTo(
        prevOut.x,
        prevOut.y,
        controlIn.x,
        controlIn.y,
        anchor.x,
        anchor.y
      );
    } else {
      ctx.lineTo(anchor.x, anchor.y);
    }
  }
  if (path.options.closed) {
    ctx.closePath();
  }
}

// node_modules/@progress/kendo-drawing/dist/es/canvas/node.js
var Node2 = function(BaseNode2) {
  function Node3(srcElement) {
    BaseNode2.call(this, srcElement);
    if (srcElement) {
      this.initClip();
    }
  }
  if (BaseNode2)
    Node3.__proto__ = BaseNode2;
  Node3.prototype = Object.create(BaseNode2 && BaseNode2.prototype);
  Node3.prototype.constructor = Node3;
  Node3.prototype.initClip = function initClip() {
    var clip = this.srcElement.clip();
    if (clip) {
      this.clip = clip;
      clip.addObserver(this);
    }
  };
  Node3.prototype.clear = function clear4() {
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    this.clearClip();
    BaseNode2.prototype.clear.call(this);
  };
  Node3.prototype.clearClip = function clearClip() {
    if (this.clip) {
      this.clip.removeObserver(this);
      delete this.clip;
    }
  };
  Node3.prototype.setClip = function setClip(ctx) {
    if (this.clip) {
      ctx.beginPath();
      renderPath(ctx, this.clip);
      ctx.clip();
    }
  };
  Node3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "clip") {
      this.clearClip();
      this.initClip();
    }
    BaseNode2.prototype.optionsChange.call(this, e);
  };
  Node3.prototype.setTransform = function setTransform(ctx) {
    if (this.srcElement) {
      var transform2 = this.srcElement.transform();
      if (transform2) {
        ctx.transform.apply(ctx, transform2.matrix().toArray(6));
      }
    }
  };
  Node3.prototype.loadElements = function loadElements(elements, pos, cors) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var srcElement = elements[i];
      var children = srcElement.children;
      var childNode = new node_map_default2[srcElement.nodeType](srcElement, cors);
      if (children && children.length > 0) {
        childNode.load(children, pos, cors);
      }
      if (defined(pos)) {
        this$1.insertAt(childNode, pos);
      } else {
        this$1.append(childNode);
      }
    }
  };
  Node3.prototype.load = function load2(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this.invalidate();
  };
  Node3.prototype.setOpacity = function setOpacity(ctx) {
    if (this.srcElement) {
      var opacity = this.srcElement.opacity();
      if (defined(opacity)) {
        this.globalAlpha(ctx, opacity);
      }
    }
  };
  Node3.prototype.globalAlpha = function globalAlpha(ctx, value) {
    var opactity = value;
    if (opactity && ctx.globalAlpha) {
      opactity *= ctx.globalAlpha;
    }
    ctx.globalAlpha = opactity;
  };
  Node3.prototype.visible = function visible() {
    var src = this.srcElement;
    return !src || src && src.options.visible !== false;
  };
  return Node3;
}(base_node_default);
var node_default2 = Node2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/group-node.js
var GroupNode2 = function(superclass) {
  function GroupNode3() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    GroupNode3.__proto__ = superclass;
  GroupNode3.prototype = Object.create(superclass && superclass.prototype);
  GroupNode3.prototype.constructor = GroupNode3;
  GroupNode3.prototype.renderTo = function renderTo(ctx) {
    if (!this.visible()) {
      return;
    }
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    var childNodes = this.childNodes;
    for (var i = 0; i < childNodes.length; i++) {
      var child = childNodes[i];
      if (child.visible()) {
        child.renderTo(ctx);
      }
    }
    ctx.restore();
  };
  return GroupNode3;
}(traversable_default(node_default2, "childNodes"));
var group_node_default2 = GroupNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/root-node.js
var FRAME_DELAY = 1e3 / 60;
var RootNode2 = function(superclass) {
  function RootNode3(canvas, size) {
    superclass.call(this);
    this.canvas = canvas;
    this.size = size;
    this.ctx = canvas.getContext("2d");
    var invalidateHandler = this._invalidate.bind(this);
    this.invalidate = throttle(function() {
      animation_frame_default(invalidateHandler);
    }, FRAME_DELAY);
  }
  if (superclass)
    RootNode3.__proto__ = superclass;
  RootNode3.prototype = Object.create(superclass && superclass.prototype);
  RootNode3.prototype.constructor = RootNode3;
  RootNode3.prototype.destroy = function destroy2() {
    superclass.prototype.destroy.call(this);
    this.canvas = null;
    this.ctx = null;
  };
  RootNode3.prototype.load = function load2(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this._invalidate();
  };
  RootNode3.prototype._rescale = function _rescale(scale) {
    var ref2 = this;
    var canvas = ref2.canvas;
    var size = ref2.size;
    canvas.width = size.width * scale;
    canvas.height = size.height * scale;
    this.ctx.scale(scale, scale);
  };
  RootNode3.prototype._devicePixelRatio = function _devicePixelRatio() {
    if (typeof window.devicePixelRatio === "number") {
      return window.devicePixelRatio;
    }
    return 1;
  };
  RootNode3.prototype._invalidate = function _invalidate(options2) {
    if (!this.ctx) {
      return;
    }
    var fixedScale = options2 && options2.fixedScale;
    var scale = fixedScale ? 1 : this._devicePixelRatio();
    this._rescale(scale);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.renderTo(this.ctx);
  };
  return RootNode3;
}(traversable_default(group_node_default2, "childNodes"));
var root_node_default2 = RootNode2;

// node_modules/@progress/kendo-drawing/dist/es/search/quad-root.js
var QuadRoot = function(Class3) {
  function QuadRoot2() {
    Class3.call(this);
    this.shapes = [];
  }
  if (Class3)
    QuadRoot2.__proto__ = Class3;
  QuadRoot2.prototype = Object.create(Class3 && Class3.prototype);
  QuadRoot2.prototype.constructor = QuadRoot2;
  QuadRoot2.prototype._add = function _add(shape2, bbox) {
    this.shapes.push({
      bbox,
      shape: shape2
    });
    shape2._quadNode = this;
  };
  QuadRoot2.prototype.pointShapes = function pointShapes(point2) {
    var shapes = this.shapes;
    var length = shapes.length;
    var result = [];
    for (var idx = 0; idx < length; idx++) {
      if (shapes[idx].bbox.containsPoint(point2)) {
        result.push(shapes[idx].shape);
      }
    }
    return result;
  };
  QuadRoot2.prototype.insert = function insert(shape2, bbox) {
    this._add(shape2, bbox);
  };
  QuadRoot2.prototype.remove = function remove(shape2) {
    var shapes = this.shapes;
    var length = shapes.length;
    for (var idx = 0; idx < length; idx++) {
      if (shapes[idx].shape === shape2) {
        shapes.splice(idx, 1);
        break;
      }
    }
  };
  return QuadRoot2;
}(class_default);
var quad_root_default = QuadRoot;

// node_modules/@progress/kendo-drawing/dist/es/search/quad-node.js
var QuadNode = function(QuadRoot2) {
  function QuadNode2(rect) {
    QuadRoot2.call(this);
    this.children = [];
    this.rect = rect;
  }
  if (QuadRoot2)
    QuadNode2.__proto__ = QuadRoot2;
  QuadNode2.prototype = Object.create(QuadRoot2 && QuadRoot2.prototype);
  QuadNode2.prototype.constructor = QuadNode2;
  QuadNode2.prototype.inBounds = function inBounds(rect) {
    var nodeRect = this.rect;
    var nodeBottomRight = nodeRect.bottomRight();
    var bottomRight = rect.bottomRight();
    var inBounds2 = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x && bottomRight.y <= nodeBottomRight.y;
    return inBounds2;
  };
  QuadNode2.prototype.pointShapes = function pointShapes(point2) {
    var children = this.children;
    var length = children.length;
    var result = QuadRoot2.prototype.pointShapes.call(this, point2);
    for (var idx = 0; idx < length; idx++) {
      append(result, children[idx].pointShapes(point2));
    }
    return result;
  };
  QuadNode2.prototype.insert = function insert(shape2, bbox) {
    var children = this.children;
    var inserted = false;
    if (this.inBounds(bbox)) {
      if (this.shapes.length < 4) {
        this._add(shape2, bbox);
      } else {
        if (!children.length) {
          this._initChildren();
        }
        for (var idx = 0; idx < children.length; idx++) {
          if (children[idx].insert(shape2, bbox)) {
            inserted = true;
            break;
          }
        }
        if (!inserted) {
          this._add(shape2, bbox);
        }
      }
      inserted = true;
    }
    return inserted;
  };
  QuadNode2.prototype._initChildren = function _initChildren() {
    var ref2 = this;
    var rect = ref2.rect;
    var children = ref2.children;
    var center = rect.center();
    var halfWidth = rect.width() / 2;
    var halfHeight = rect.height() / 2;
    children.push(
      new QuadNode2(new rect_default([rect.origin.x, rect.origin.y], [halfWidth, halfHeight])),
      new QuadNode2(new rect_default([center.x, rect.origin.y], [halfWidth, halfHeight])),
      new QuadNode2(new rect_default([rect.origin.x, center.y], [halfWidth, halfHeight])),
      new QuadNode2(new rect_default([center.x, center.y], [halfWidth, halfHeight]))
    );
  };
  return QuadNode2;
}(quad_root_default);
var quad_node_default = QuadNode;

// node_modules/@progress/kendo-drawing/dist/es/search/shapes-quad-tree.js
var ROOT_SIZE = 3e3;
var LEVEL_STEP = 1e4;
var MAX_LEVEL = 75;
var ShapesQuadTree = function(Class3) {
  function ShapesQuadTree2() {
    Class3.call(this);
    this.initRoots();
  }
  if (Class3)
    ShapesQuadTree2.__proto__ = Class3;
  ShapesQuadTree2.prototype = Object.create(Class3 && Class3.prototype);
  ShapesQuadTree2.prototype.constructor = ShapesQuadTree2;
  ShapesQuadTree2.prototype.initRoots = function initRoots() {
    this.rootMap = {};
    this.root = new quad_root_default();
    this.rootElements = [];
  };
  ShapesQuadTree2.prototype.clear = function clear4() {
    var this$1 = this;
    var rootElements = this.rootElements;
    for (var idx = 0; idx < rootElements.length; idx++) {
      this$1.remove(rootElements[idx]);
    }
    this.initRoots();
  };
  ShapesQuadTree2.prototype.pointShape = function pointShape(point2) {
    var sectorRoot = (this.rootMap[Math.floor(point2.x / ROOT_SIZE)] || {})[Math.floor(point2.y / ROOT_SIZE)];
    var result = this.root.pointShapes(point2);
    if (sectorRoot) {
      result = result.concat(sectorRoot.pointShapes(point2));
    }
    this.assignZindex(result);
    result.sort(zIndexComparer);
    for (var idx = 0; idx < result.length; idx++) {
      if (result[idx].containsPoint(point2)) {
        return result[idx];
      }
    }
  };
  ShapesQuadTree2.prototype.assignZindex = function assignZindex(elements) {
    var this$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      var element2 = elements[idx];
      var zIndex3 = 0;
      var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);
      var parents = [];
      while (element2) {
        parents.push(element2);
        element2 = element2.parent;
      }
      while (parents.length) {
        element2 = parents.pop();
        zIndex3 += ((element2.parent ? element2.parent.children : this$1.rootElements).indexOf(element2) + 1) * levelWeight;
        levelWeight /= LEVEL_STEP;
      }
      elements[idx]._zIndex = zIndex3;
    }
  };
  ShapesQuadTree2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "transform" || e.field === "stroke.width") {
      this.bboxChange(e.element);
    }
  };
  ShapesQuadTree2.prototype.geometryChange = function geometryChange(e) {
    this.bboxChange(e.element);
  };
  ShapesQuadTree2.prototype.bboxChange = function bboxChange(element2) {
    var this$1 = this;
    if (element2.nodeType === "Group") {
      for (var idx = 0; idx < element2.children.length; idx++) {
        this$1.bboxChange(element2.children[idx]);
      }
    } else {
      if (element2._quadNode) {
        element2._quadNode.remove(element2);
      }
      this._insertShape(element2);
    }
  };
  ShapesQuadTree2.prototype.add = function add3(elements) {
    var elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];
    append(this.rootElements, elementsArray);
    this._insert(elementsArray);
  };
  ShapesQuadTree2.prototype.childrenChange = function childrenChange(e) {
    var this$1 = this;
    if (e.action === "remove") {
      for (var idx = 0; idx < e.items.length; idx++) {
        this$1.remove(e.items[idx]);
      }
    } else {
      this._insert(Array.prototype.slice.call(e.items, 0));
    }
  };
  ShapesQuadTree2.prototype._insert = function _insert(elements) {
    var this$1 = this;
    var element2;
    while (elements.length > 0) {
      element2 = elements.pop();
      element2.addObserver(this$1);
      if (element2.nodeType === "Group") {
        append(elements, element2.children);
      } else {
        this$1._insertShape(element2);
      }
    }
  };
  ShapesQuadTree2.prototype._insertShape = function _insertShape(shape2) {
    var bbox = shape2.bbox();
    if (bbox) {
      var sectors = this.getSectors(bbox);
      var x = sectors[0][0];
      var y = sectors[1][0];
      if (this.inRoot(sectors)) {
        this.root.insert(shape2, bbox);
      } else {
        var rootMap = this.rootMap;
        if (!rootMap[x]) {
          rootMap[x] = {};
        }
        if (!rootMap[x][y]) {
          rootMap[x][y] = new quad_node_default(
            new rect_default([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE])
          );
        }
        rootMap[x][y].insert(shape2, bbox);
      }
    }
  };
  ShapesQuadTree2.prototype.remove = function remove(element2) {
    var this$1 = this;
    element2.removeObserver(this);
    if (element2.nodeType === "Group") {
      var children = element2.children;
      for (var idx = 0; idx < children.length; idx++) {
        this$1.remove(children[idx]);
      }
    } else if (element2._quadNode) {
      element2._quadNode.remove(element2);
      delete element2._quadNode;
    }
  };
  ShapesQuadTree2.prototype.inRoot = function inRoot(sectors) {
    return sectors[0].length > 1 || sectors[1].length > 1;
  };
  ShapesQuadTree2.prototype.getSectors = function getSectors(rect) {
    var bottomRight = rect.bottomRight();
    var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);
    var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);
    var sectors = [[], []];
    for (var x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {
      sectors[0].push(x);
    }
    for (var y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {
      sectors[1].push(y);
    }
    return sectors;
  };
  return ShapesQuadTree2;
}(class_default);
function zIndexComparer(x1, x2) {
  if (x1._zIndex < x2._zIndex) {
    return 1;
  }
  if (x1._zIndex > x2._zIndex) {
    return -1;
  }
  return 0;
}
var shapes_quad_tree_default = ShapesQuadTree;

// node_modules/@progress/kendo-drawing/dist/es/canvas/surface-cursor.js
var SurfaceCursor = function SurfaceCursor2(surface) {
  surface.bind("mouseenter", this._mouseenter.bind(this));
  surface.bind("mouseleave", this._mouseleave.bind(this));
  this.element = surface.element;
};
SurfaceCursor.prototype.clear = function clear() {
  this._resetCursor();
};
SurfaceCursor.prototype.destroy = function destroy() {
  this._resetCursor();
  delete this.element;
};
SurfaceCursor.prototype._mouseenter = function _mouseenter(e) {
  var cursor = this._shapeCursor(e);
  if (!cursor) {
    this._resetCursor();
  } else {
    if (!this._current) {
      this._defaultCursor = this._getCursor();
    }
    this._setCursor(cursor);
  }
};
SurfaceCursor.prototype._mouseleave = function _mouseleave() {
  this._resetCursor();
};
SurfaceCursor.prototype._shapeCursor = function _shapeCursor(e) {
  var shape2 = e.element;
  while (shape2 && !defined(shape2.options.cursor)) {
    shape2 = shape2.parent;
  }
  if (shape2) {
    return shape2.options.cursor;
  }
};
SurfaceCursor.prototype._getCursor = function _getCursor() {
  if (this.element) {
    return this.element.style.cursor;
  }
};
SurfaceCursor.prototype._setCursor = function _setCursor(cursor) {
  if (this.element) {
    this.element.style.cursor = cursor;
    this._current = cursor;
  }
};
SurfaceCursor.prototype._resetCursor = function _resetCursor() {
  if (this._current) {
    this._setCursor(this._defaultCursor || "");
    delete this._current;
  }
};
var surface_cursor_default = SurfaceCursor;

// node_modules/@progress/kendo-drawing/dist/es/canvas/path-node.js
function addGradientStops(gradient, stops) {
  for (var idx = 0; idx < stops.length; idx++) {
    var stop = stops[idx];
    var color = parseColor(stop.color());
    color.a *= stop.opacity();
    gradient.addColorStop(stop.offset(), color.toCssRgba());
  }
}
var PathNode2 = function(Node3) {
  function PathNode3() {
    Node3.apply(this, arguments);
  }
  if (Node3)
    PathNode3.__proto__ = Node3;
  PathNode3.prototype = Object.create(Node3 && Node3.prototype);
  PathNode3.prototype.constructor = PathNode3;
  PathNode3.prototype.renderTo = function renderTo(ctx) {
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    this.renderPoints(ctx, this.srcElement);
    this.setLineDash(ctx);
    this.setLineCap(ctx);
    this.setLineJoin(ctx);
    this.setFill(ctx);
    this.setStroke(ctx);
    ctx.restore();
  };
  PathNode3.prototype.setFill = function setFill(ctx) {
    var fill = this.srcElement.options.fill;
    var hasFill = false;
    if (fill) {
      if (fill.nodeType === "Gradient") {
        this.setGradientFill(ctx, fill);
        hasFill = true;
      } else if (!isTransparent(fill.color)) {
        ctx.fillStyle = fill.color;
        ctx.save();
        this.globalAlpha(ctx, fill.opacity);
        ctx.fill();
        ctx.restore();
        hasFill = true;
      }
    }
    return hasFill;
  };
  PathNode3.prototype.setGradientFill = function setGradientFill(ctx, fill) {
    var bbox = this.srcElement.rawBBox();
    var gradient;
    if (fill instanceof linear_gradient_default) {
      var start = fill.start();
      var end = fill.end();
      gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
    } else if (fill instanceof radial_gradient_default) {
      var center = fill.center();
      gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());
    }
    addGradientStops(gradient, fill.stops);
    ctx.save();
    if (!fill.userSpace()) {
      ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);
    }
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.restore();
  };
  PathNode3.prototype.setStroke = function setStroke(ctx) {
    var stroke = this.srcElement.options.stroke;
    if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = valueOrDefault(stroke.width, 1);
      ctx.save();
      this.globalAlpha(ctx, stroke.opacity);
      ctx.stroke();
      ctx.restore();
      return true;
    }
  };
  PathNode3.prototype.dashType = function dashType() {
    var stroke = this.srcElement.options.stroke;
    if (stroke && stroke.dashType) {
      return stroke.dashType.toLowerCase();
    }
  };
  PathNode3.prototype.setLineDash = function setLineDash(ctx) {
    var dashType = this.dashType();
    if (dashType && dashType !== SOLID) {
      var dashArray = DASH_ARRAYS[dashType];
      if (ctx.setLineDash) {
        ctx.setLineDash(dashArray);
      } else {
        ctx.mozDash = dashArray;
        ctx.webkitLineDash = dashArray;
      }
    }
  };
  PathNode3.prototype.setLineCap = function setLineCap(ctx) {
    var dashType = this.dashType();
    var stroke = this.srcElement.options.stroke;
    if (dashType && dashType !== SOLID) {
      ctx.lineCap = BUTT;
    } else if (stroke && stroke.lineCap) {
      ctx.lineCap = stroke.lineCap;
    }
  };
  PathNode3.prototype.setLineJoin = function setLineJoin(ctx) {
    var stroke = this.srcElement.options.stroke;
    if (stroke && stroke.lineJoin) {
      ctx.lineJoin = stroke.lineJoin;
    }
  };
  PathNode3.prototype.renderPoints = function renderPoints(ctx, path) {
    renderPath(ctx, path);
  };
  return PathNode3;
}(node_default2);
var path_node_default2 = PathNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/arc-node.js
var ArcNode2 = function(PathNode3) {
  function ArcNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    ArcNode3.__proto__ = PathNode3;
  ArcNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ArcNode3.prototype.constructor = ArcNode3;
  ArcNode3.prototype.renderPoints = function renderPoints(ctx) {
    var path = this.srcElement.toPath();
    renderPath(ctx, path);
  };
  return ArcNode3;
}(path_node_default2);
var arc_node_default2 = ArcNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/circle-node.js
var CircleNode2 = function(PathNode3) {
  function CircleNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    CircleNode3.__proto__ = PathNode3;
  CircleNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  CircleNode3.prototype.constructor = CircleNode3;
  CircleNode3.prototype.renderPoints = function renderPoints(ctx) {
    var ref2 = this.srcElement.geometry();
    var center = ref2.center;
    var radius = ref2.radius;
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
  };
  return CircleNode3;
}(path_node_default2);
var circle_node_default2 = CircleNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/image-node.js
var ImageNode2 = function(PathNode3) {
  function ImageNode3(srcElement, cors) {
    PathNode3.call(this, srcElement);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.loading = createPromise();
    var img = this.img = new Image();
    var src = srcElement.src();
    if (cors && !/^data:/i.test(src)) {
      img.crossOrigin = cors;
    }
    if (src) {
      img.src = src;
    }
    if (img.complete) {
      this.onLoad();
    } else {
      img.onload = this.onLoad;
      img.onerror = this.onError;
    }
  }
  if (PathNode3)
    ImageNode3.__proto__ = PathNode3;
  ImageNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ImageNode3.prototype.constructor = ImageNode3;
  ImageNode3.prototype.renderTo = function renderTo(ctx) {
    if (this.loading.state() === "resolved") {
      ctx.save();
      this.setTransform(ctx);
      this.setClip(ctx);
      this.drawImage(ctx);
      ctx.restore();
    }
  };
  ImageNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "src") {
      this.loading = createPromise();
      this.img.src = this.srcElement.src();
    } else {
      PathNode3.prototype.optionsChange.call(this, e);
    }
  };
  ImageNode3.prototype.onLoad = function onLoad() {
    this.loading.resolve();
    this.invalidate();
  };
  ImageNode3.prototype.onError = function onError() {
    this.loading.reject(new Error(
      "Unable to load image '" + this.img.src + "'. Check for connectivity and verify CORS headers."
    ));
  };
  ImageNode3.prototype.drawImage = function drawImage(ctx) {
    var rect = this.srcElement.rect();
    var topLeft = rect.topLeft();
    ctx.drawImage(
      this.img,
      topLeft.x,
      topLeft.y,
      rect.width(),
      rect.height()
    );
  };
  return ImageNode3;
}(path_node_default2);
var image_node_default2 = ImageNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/multi-path-node.js
var MultiPathNode2 = function(PathNode3) {
  function MultiPathNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    MultiPathNode3.__proto__ = PathNode3;
  MultiPathNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  MultiPathNode3.prototype.constructor = MultiPathNode3;
  MultiPathNode3.prototype.renderPoints = function renderPoints(ctx) {
    var paths = this.srcElement.paths;
    for (var i = 0; i < paths.length; i++) {
      renderPath(ctx, paths[i]);
    }
  };
  return MultiPathNode3;
}(path_node_default2);
var multi_path_node_default2 = MultiPathNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/rect-node.js
var RectNode2 = function(PathNode3) {
  function RectNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    RectNode3.__proto__ = PathNode3;
  RectNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  RectNode3.prototype.constructor = RectNode3;
  RectNode3.prototype.renderPoints = function renderPoints(ctx) {
    var geometry = this.srcElement.geometry();
    var ref2 = geometry.cornerRadius;
    var rx = ref2[0];
    var ry = ref2[1];
    if (rx === 0 && ry === 0) {
      var origin = geometry.origin;
      var size = geometry.size;
      ctx.rect(origin.x, origin.y, size.width, size.height);
    } else {
      PathNode3.prototype.renderPoints.call(this, ctx, Path.fromRect(geometry));
    }
  };
  return RectNode3;
}(path_node_default2);
var rect_node_default2 = RectNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/text-node.js
var TextNode2 = function(PathNode3) {
  function TextNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    TextNode3.__proto__ = PathNode3;
  TextNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  TextNode3.prototype.constructor = TextNode3;
  TextNode3.prototype.renderTo = function renderTo(ctx) {
    var text = this.srcElement;
    var pos = text.position();
    var size = text.measure();
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    ctx.font = text.options.font;
    ctx.textAlign = "left";
    if (this.setFill(ctx)) {
      ctx.fillText(text.content(), pos.x, pos.y + size.baseline);
    }
    if (this.setStroke(ctx)) {
      this.setLineDash(ctx);
      ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);
    }
    ctx.restore();
  };
  return TextNode3;
}(path_node_default2);
var text_node_default2 = TextNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/surface.js
node_map_default2.Arc = arc_node_default2;
node_map_default2.Circle = circle_node_default2;
node_map_default2.Group = group_node_default2;
node_map_default2.Image = image_node_default2;
node_map_default2.MultiPath = multi_path_node_default2;
node_map_default2.Path = path_node_default2;
node_map_default2.Rect = rect_node_default2;
node_map_default2.Text = text_node_default2;
var Surface3 = function(BaseSurface) {
  function Surface6(element2, options2) {
    BaseSurface.call(this, element2, options2);
    this.element.innerHTML = this._template(this);
    var canvas = this.element.firstElementChild;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    var size = elementSize(element2);
    canvas.width = size.width;
    canvas.height = size.height;
    this._rootElement = canvas;
    this._root = new root_node_default2(canvas, size);
    this._mouseTrackHandler = this._trackMouse.bind(this);
    bindEvents(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  }
  if (BaseSurface)
    Surface6.__proto__ = BaseSurface;
  Surface6.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface6.prototype.constructor = Surface6;
  var prototypeAccessors4 = { type: { configurable: true } };
  prototypeAccessors4.type.get = function() {
    return "canvas";
  };
  Surface6.prototype.destroy = function destroy2() {
    BaseSurface.prototype.destroy.call(this);
    if (this._root) {
      this._root.destroy();
      this._root = null;
    }
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
    if (this._cursor) {
      this._cursor.destroy();
      delete this._cursor;
    }
    unbindEvents(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  };
  Surface6.prototype.draw = function draw(element2) {
    BaseSurface.prototype.draw.call(this, element2);
    this._root.load([element2], void 0, this.options.cors);
    if (this._searchTree) {
      this._searchTree.add([element2]);
    }
  };
  Surface6.prototype.clear = function clear4() {
    BaseSurface.prototype.clear.call(this);
    this._root.clear();
    if (this._searchTree) {
      this._searchTree.clear();
    }
    if (this._cursor) {
      this._cursor.clear();
    }
  };
  Surface6.prototype.eventTarget = function eventTarget(e) {
    if (this._searchTree) {
      var point2 = this._surfacePoint(e);
      var shape2 = this._searchTree.pointShape(point2);
      return shape2;
    }
  };
  Surface6.prototype.image = function image() {
    var ref2 = this;
    var root = ref2._root;
    var rootElement = ref2._rootElement;
    var loadingStates = [];
    root.traverse(function(childNode) {
      if (childNode.loading) {
        loadingStates.push(childNode.loading);
      }
    });
    var promise = createPromise();
    var resolveDataURL = function() {
      root._invalidate({ fixedScale: true });
      try {
        var data = rootElement.toDataURL();
        promise.resolve(data);
      } catch (e) {
        promise.reject(e);
      }
    };
    promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);
    return promise;
  };
  Surface6.prototype.suspendTracking = function suspendTracking() {
    BaseSurface.prototype.suspendTracking.call(this);
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
  };
  Surface6.prototype.resumeTracking = function resumeTracking() {
    BaseSurface.prototype.resumeTracking.call(this);
    if (!this._searchTree) {
      this._searchTree = new shapes_quad_tree_default();
      var childNodes = this._root.childNodes;
      var rootElements = [];
      for (var idx = 0; idx < childNodes.length; idx++) {
        rootElements.push(childNodes[idx].srcElement);
      }
      this._searchTree.add(rootElements);
    }
  };
  Surface6.prototype._resize = function _resize() {
    this._rootElement.width = this._size.width;
    this._rootElement.height = this._size.height;
    this._root.size = this._size;
    this._root.invalidate();
  };
  Surface6.prototype._template = function _template() {
    return "<canvas></canvas>";
  };
  Surface6.prototype._enableTracking = function _enableTracking() {
    this._searchTree = new shapes_quad_tree_default();
    this._cursor = new surface_cursor_default(this);
    BaseSurface.prototype._enableTracking.call(this);
  };
  Surface6.prototype._trackMouse = function _trackMouse(e) {
    if (this._suspendedTracking) {
      return;
    }
    var shape2 = this.eventTarget(e);
    if (e.type !== "click") {
      var currentShape = this._currentShape;
      if (currentShape && currentShape !== shape2) {
        this.trigger("mouseleave", {
          element: currentShape,
          originalEvent: e,
          type: "mouseleave"
        });
      }
      if (shape2 && currentShape !== shape2) {
        this.trigger("mouseenter", {
          element: shape2,
          originalEvent: e,
          type: "mouseenter"
        });
      }
      this.trigger("mousemove", {
        element: shape2,
        originalEvent: e,
        type: "mousemove"
      });
      this._currentShape = shape2;
    } else if (shape2) {
      this.trigger("click", {
        element: shape2,
        originalEvent: e,
        type: "click"
      });
    }
  };
  Object.defineProperties(Surface6.prototype, prototypeAccessors4);
  return Surface6;
}(surface_default);
var surface_default3 = Surface3;

// node_modules/@progress/kendo-drawing/dist/es/surface-factory.js
var instance3;
var support2;
var hasDocument = function() {
  return typeof document !== "undefined";
};
var supportsCanvas = function() {
  return hasDocument() && document.createElement("canvas").getContext;
};
var supportsSVG = function() {
  return hasDocument() && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
};
var SurfaceFactory = function(Class3) {
  function SurfaceFactory2() {
    Class3.call(this);
    this._items = [{
      name: "svg",
      type: surface_default2
    }, {
      name: "canvas",
      type: surface_default3
    }];
  }
  if (Class3)
    SurfaceFactory2.__proto__ = Class3;
  SurfaceFactory2.prototype = Object.create(Class3 && Class3.prototype);
  SurfaceFactory2.prototype.constructor = SurfaceFactory2;
  var staticAccessors2 = { support: { configurable: true }, current: { configurable: true } };
  staticAccessors2.support.get = function() {
    if (!support2) {
      support2 = {
        canvas: supportsCanvas(),
        svg: supportsSVG()
      };
    }
    return support2;
  };
  staticAccessors2.current.get = function() {
    if (!instance3) {
      instance3 = new SurfaceFactory2();
    }
    return instance3;
  };
  SurfaceFactory2.prototype.create = function create3(element2, options2) {
    var items = this._items;
    var match = items[0];
    if (options2 && options2.type) {
      var preferred = options2.type.toLowerCase();
      for (var i = 0; i < items.length; i++) {
        if (items[i].name === preferred) {
          match = items[i];
          break;
        }
      }
    }
    if (match) {
      return new match.type(element2, options2);
    }
    logToConsole(
      "Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\n- The browser does not support SVG and Canvas. User agent: " + navigator.userAgent
    );
  };
  Object.defineProperties(SurfaceFactory2, staticAccessors2);
  return SurfaceFactory2;
}(class_default);
var surface_factory_default = SurfaceFactory;

// node_modules/@progress/kendo-drawing/dist/es/surface.js
var Surface4 = function(BaseSurface) {
  function Surface6() {
    BaseSurface.apply(this, arguments);
  }
  if (BaseSurface)
    Surface6.__proto__ = BaseSurface;
  Surface6.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface6.prototype.constructor = Surface6;
  var staticAccessors2 = { support: { configurable: true } };
  staticAccessors2.support.get = function() {
    return surface_factory_default.support;
  };
  Surface6.create = function create3(element2, options2) {
    return surface_factory_default.current.create(element2, options2);
  };
  Object.defineProperties(Surface6, staticAccessors2);
  return Surface6;
}(surface_default);
var surface_default4 = Surface4;

// node_modules/@progress/kendo-drawing/dist/es/svg.js
var svg_exports = {};
__export(svg_exports, {
  ArcNode: () => arc_node_default,
  CircleNode: () => circle_node_default,
  ClipNode: () => clip_node_default,
  DefinitionNode: () => definition_node_default,
  GradientStopNode: () => gradient_stop_node_default,
  GroupNode: () => group_node_default,
  ImageNode: () => image_node_default,
  LinearGradientNode: () => linear_gradient_node_default,
  MultiPathNode: () => multi_path_node_default,
  Node: () => node_default,
  PathNode: () => path_node_default,
  RadialGradientNode: () => radial_gradient_node_default,
  RectNode: () => rect_node_default,
  RootNode: () => root_node_default,
  Surface: () => surface_default2,
  TextNode: () => text_node_default,
  exportGroup: () => exportGroup
});

// node_modules/@progress/kendo-drawing/dist/es/svg/export-group.js
function exportGroup(group) {
  var root = new root_node_default({
    skipBaseHref: true
  });
  var bbox = group.clippedBBox();
  var rootGroup = group;
  if (bbox) {
    var origin = bbox.getOrigin();
    var exportRoot = new group_default();
    exportRoot.transform(transform().translate(-origin.x, -origin.y));
    exportRoot.children.push(group);
    rootGroup = exportRoot;
  }
  root.load([rootGroup]);
  var svg = "<?xml version='1.0' ?><svg xmlns='" + SVG_NS + "' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>" + root.render() + "</svg>";
  root.destroy();
  return svg;
}

// node_modules/@progress/kendo-drawing/dist/es/canvas.js
var canvas_exports = {};
__export(canvas_exports, {
  ArcNode: () => arc_node_default2,
  CircleNode: () => circle_node_default2,
  GroupNode: () => group_node_default2,
  ImageNode: () => image_node_default2,
  MultiPathNode: () => multi_path_node_default2,
  Node: () => node_default2,
  PathNode: () => path_node_default2,
  RectNode: () => rect_node_default2,
  RootNode: () => root_node_default2,
  Surface: () => surface_default3,
  TextNode: () => text_node_default2
});

// node_modules/@progress/kendo-drawing/dist/es/canvas/export-image.js
function exportImage(group, options2) {
  var defaults = {
    width: "800px",
    height: "600px",
    cors: "Anonymous"
  };
  var exportRoot = group;
  var bbox = group.clippedBBox();
  if (bbox) {
    var origin = bbox.getOrigin();
    exportRoot = new group_default();
    exportRoot.transform(transform().translate(-origin.x, -origin.y));
    exportRoot.children.push(group);
    var size = bbox.getSize();
    defaults.width = size.width + "px";
    defaults.height = size.height + "px";
  }
  var surfaceOptions = Object.assign(defaults, options2);
  var container = document.createElement("div");
  var style = container.style;
  style.display = "none";
  style.width = surfaceOptions.width;
  style.height = surfaceOptions.height;
  document.body.appendChild(container);
  var surface = new surface_default3(container, surfaceOptions);
  surface.suspendTracking();
  surface.draw(exportRoot);
  var promise = surface.image();
  var destroy2 = function() {
    surface.destroy();
    document.body.removeChild(container);
  };
  promise.then(destroy2, destroy2);
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/svg/export-svg.js
function exportSVG(group, options2) {
  var svg = exportGroup(group);
  if (!options2 || !options2.raw) {
    svg = "data:image/svg+xml;base64," + encodeBase64(svg);
  }
  return createPromise().resolve(svg);
}

// node_modules/@progress/kendo-charts/dist/es/common/align-path-to-pixel.js
function alignPathToPixel(path) {
  var offset3 = 0.5;
  if (path.options.stroke && drawing_exports.util.defined(path.options.stroke.width)) {
    if (path.options.stroke.width % 2 === 0) {
      offset3 = 0;
    }
  }
  for (var i = 0; i < path.segments.length; i++) {
    path.segments[i].anchor().round(0).translate(offset3, offset3);
  }
  return path;
}

// node_modules/@progress/kendo-charts/dist/es/common/clockwise.js
function clockwise(angle1, angle2) {
  return -angle1.x * angle2.y + angle1.y * angle2.x < 0;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-number.js
function isNumber2(value) {
  return typeof value === "number" && !isNaN(value);
}

// node_modules/@progress/kendo-charts/dist/es/common/is-string.js
function isString2(value) {
  return typeof value === STRING;
}

// node_modules/@progress/kendo-charts/dist/es/common/convertable-to-number.js
function convertableToNumber(value) {
  return isNumber2(value) || isString2(value) && isFinite(value);
}

// node_modules/@progress/kendo-charts/dist/es/common/is-function.js
function isFunction3(fn) {
  return typeof fn === "function";
}

// node_modules/@progress/kendo-charts/dist/es/common/deep-extend.js
var OBJECT2 = "object";
var UNDEFINED2 = "undefined";
function deepExtendOne(destination, source) {
  for (var property in source) {
    var propValue = source[property];
    var propType = typeof propValue;
    var propInit = void 0;
    if (propType === OBJECT2 && propValue !== null) {
      propInit = propValue.constructor;
    } else {
      propInit = null;
    }
    if (propInit && propInit !== Array) {
      if (propValue instanceof Date) {
        destination[property] = new Date(propValue.getTime());
      } else if (isFunction3(propValue.clone)) {
        destination[property] = propValue.clone();
      } else {
        var destProp = destination[property];
        if (typeof destProp === OBJECT2) {
          destination[property] = destProp || {};
        } else {
          destination[property] = {};
        }
        deepExtendOne(destination[property], propValue);
      }
    } else if (propType !== UNDEFINED2) {
      destination[property] = propValue;
    }
  }
  return destination;
}
function deepExtend(destination) {
  var arguments$1 = arguments;
  var length = arguments.length;
  for (var i = 1; i < length; i++) {
    deepExtendOne(destination, arguments$1[i]);
  }
  return destination;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-object.js
function isObject(value) {
  return typeof value === "object";
}

// node_modules/@progress/kendo-charts/dist/es/common/style-value.js
function styleValue(value) {
  if (isNumber2(value)) {
    return value + "px";
  }
  return value;
}

// node_modules/@progress/kendo-charts/dist/es/common/element-styles.js
var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;
function isSizeField(field) {
  return SIZE_STYLES_REGEX.test(field);
}
function elementStyles2(element2, styles) {
  var stylesArray = isString2(styles) ? [styles] : styles;
  if (isArray(stylesArray)) {
    var result = {};
    var style = window.getComputedStyle(element2);
    for (var idx = 0; idx < stylesArray.length; idx++) {
      var field = stylesArray[idx];
      result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];
    }
    return result;
  } else if (isObject(styles)) {
    for (var field$1 in styles) {
      element2.style[field$1] = styleValue(styles[field$1]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-spacing.js
function getSpacing(value, defaultSpacing) {
  if (defaultSpacing === void 0)
    defaultSpacing = 0;
  var spacing = { top: 0, right: 0, bottom: 0, left: 0 };
  if (typeof value === "number") {
    spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;
  } else {
    spacing[TOP] = value[TOP] || defaultSpacing;
    spacing[RIGHT] = value[RIGHT] || defaultSpacing;
    spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;
    spacing[LEFT] = value[LEFT] || defaultSpacing;
  }
  return spacing;
}

// node_modules/@progress/kendo-charts/dist/es/services/template-service.js
var current = {
  compile: function(template3) {
    return template3;
  }
};
var TemplateService = function TemplateService2() {
};
TemplateService.register = function register(userImplementation) {
  current = userImplementation;
};
TemplateService.compile = function compile(template3, options2) {
  return current.compile(template3, options2);
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-charts/dist/es/common/get-template.js
function getTemplate(options2) {
  if (options2 === void 0)
    options2 = {};
  var template3;
  if (options2.template) {
    options2.template = template3 = template_service_default.compile(options2.template);
  } else if (isFunction3(options2.content)) {
    template3 = options2.content;
  }
  return template3;
}

// node_modules/@progress/kendo-charts/dist/es/common/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
getterCache["undefined"] = function(obj) {
  return obj;
};
function getter(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(drawing_exports.util.defined(index) ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-charts/dist/es/common/grep.js
function grep(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    if (callback(array[idx])) {
      result.push(array[idx]);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/has-classes.js
function hasClasses(element2, classNames2) {
  if (element2.className) {
    var names = classNames2.split(" ");
    for (var idx = 0; idx < names.length; idx++) {
      if (element2.className.indexOf && element2.className.indexOf(names[idx]) !== -1) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/hash-map.js
var HashMap = function HashMap2() {
  this._map = {};
};
HashMap.prototype.get = function get(name2) {
  return this._map[this._key(name2)];
};
HashMap.prototype.set = function set(name2, value) {
  this._map[this._key(name2)] = value;
};
HashMap.prototype._key = function _key(name2) {
  return name2 instanceof Date ? name2.getTime() : name2;
};
var hash_map_default = HashMap;

// node_modules/@progress/kendo-charts/dist/es/common/in-array.js
function inArray(value, array) {
  if (array) {
    return array.indexOf(value) !== -1;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/interpolate-value.js
function interpolateValue(start, end, progress) {
  return drawing_exports.util.round(start + (end - start) * progress, COORD_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/common/instance-observer.js
var TRIGGER = "trigger";
var InstanceObserver = function InstanceObserver2(observer, handlers) {
  this.observer = observer;
  this.handlerMap = deepExtend({}, this.handlerMap, handlers);
};
InstanceObserver.prototype.trigger = function trigger(name2, args) {
  var ref2 = this;
  var observer = ref2.observer;
  var handlerMap = ref2.handlerMap;
  var isDefaultPrevented3;
  if (handlerMap[name2]) {
    isDefaultPrevented3 = this.callObserver(handlerMap[name2], args);
  } else if (observer[TRIGGER]) {
    isDefaultPrevented3 = this.callObserver(TRIGGER, name2, args);
  }
  return isDefaultPrevented3;
};
InstanceObserver.prototype.callObserver = function callObserver(fnName) {
  var args = [], len = arguments.length - 1;
  while (len-- > 0)
    args[len] = arguments[len + 1];
  return this.observer[fnName].apply(this.observer, args);
};
InstanceObserver.prototype.requiresHandlers = function requiresHandlers(names) {
  var this$1 = this;
  if (this.observer.requiresHandlers) {
    return this.observer.requiresHandlers(names);
  }
  for (var idx = 0; idx < names.length; idx++) {
    if (this$1.handlerMap[names[idx]]) {
      return true;
    }
  }
};
var instance_observer_default = InstanceObserver;

// node_modules/@progress/kendo-charts/dist/es/common/map.js
function map(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    var value = callback(array[idx]);
    if (drawing_exports.util.defined(value)) {
      result.push(value);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/mousewheel-delta.js
var browser3 = support_default.browser || {};
function mousewheelDelta(e) {
  var delta = 0;
  if (e.wheelDelta) {
    delta = -e.wheelDelta / 120;
    if (browser3.webkit) {
      delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));
    }
  } else if (e.detail) {
    delta = e.detail / 3;
  }
  delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  return delta;
}

// node_modules/@progress/kendo-charts/dist/es/drawing-utils.js
var ref = drawing_exports.util;
var append2 = ref.append;
var bindEvents2 = ref.bindEvents;
var defined2 = ref.defined;
var deg2 = ref.deg;
var elementOffset2 = ref.elementOffset;
var elementSize2 = ref.elementSize;
var eventCoordinates2 = ref.eventCoordinates;
var eventElement2 = ref.eventElement;
var hashKey2 = ref.hashKey;
var last2 = ref.last;
var limitValue2 = ref.limitValue;
var objectKey2 = ref.objectKey;
var rad2 = ref.rad;
var round3 = ref.round;
var unbindEvents2 = ref.unbindEvents;
var valueOrDefault2 = ref.valueOrDefault;

// node_modules/@progress/kendo-charts/dist/es/common/font-loader.js
var FontLoader = function FontLoader2() {
};
FontLoader.fetchFonts = function fetchFonts(options2, fonts, state) {
  if (state === void 0)
    state = { depth: 0 };
  var MAX_DEPTH = 5;
  if (!options2 || state.depth > MAX_DEPTH || !document.fonts) {
    return;
  }
  Object.keys(options2).forEach(function(key) {
    var value = options2[key];
    if (key === "dataSource" || key[0] === "$" || !value) {
      return;
    }
    if (key === "font") {
      fonts.push(value);
    } else if (typeof value === "object") {
      state.depth++;
      FontLoader.fetchFonts(value, fonts, state);
      state.depth--;
    }
  });
};
FontLoader.loadFonts = function loadFonts(fonts, callback) {
  var promises = [];
  if (fonts.length > 0 && document.fonts) {
    try {
      promises = fonts.map(function(font2) {
        return document.fonts.load(font2);
      });
    } catch (e) {
      logToConsole(e);
    }
    Promise.all(promises).then(callback, callback);
  } else {
    callback();
  }
};
FontLoader.preloadFonts = function preloadFonts(options2, callback) {
  var fonts = [];
  FontLoader.fetchFonts(options2, fonts);
  FontLoader.loadFonts(fonts, callback);
};
var font_loader_default = FontLoader;

// node_modules/@progress/kendo-charts/dist/es/common/set-default-options.js
function setDefaultOptions(type, options2) {
  var proto = type.prototype;
  if (proto.options) {
    proto.options = deepExtend({}, proto.options, options2);
  } else {
    proto.options = options2;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/sparse-array-limits.js
function sparseArrayLimits(arr) {
  var min3 = MAX_VALUE;
  var max2 = MIN_VALUE;
  for (var idx = 0, length = arr.length; idx < length; idx++) {
    var value = arr[idx];
    if (value !== null && isFinite(value)) {
      min3 = Math.min(min3, value);
      max2 = Math.max(max2, value);
    }
  }
  return {
    min: min3 === MAX_VALUE ? void 0 : min3,
    max: max2 === MIN_VALUE ? void 0 : max2
  };
}

// node_modules/@progress/kendo-charts/dist/es/common/find.js
function find(array, predicate) {
  for (var i = 0; i < array.length; i++) {
    var item = array[i];
    if (predicate(item, i, array)) {
      return item;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/element-scale.js
var Matrix2 = geometry_exports.Matrix;
var matrixRegexp2 = /matrix\((.*)\)/;
function parseMatrix2(matrixString) {
  var match = matrixString.match(matrixRegexp2);
  if (match === null || match.length !== 2) {
    return Matrix2.unit();
  }
  var members = match[1].split(",").map(function(x) {
    return parseFloat(x);
  });
  return new (Function.prototype.bind.apply(Matrix2, [null].concat(members)))();
}
function transformMatrix2(element2) {
  var transform2 = getComputedStyle(element2).transform;
  if (transform2 === "none") {
    return Matrix2.unit();
  }
  return parseMatrix2(transform2);
}
function elementScale2(element2) {
  if (!element2) {
    return Matrix2.unit();
  }
  var matrix = transformMatrix2(element2);
  var parent = element2.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix2(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-charts/dist/es/common/auto-text-color.js
function autoTextColor(color) {
  var isDark = new color_default(color).isDark();
  if (isDark) {
    return WHITE;
  }
  return BLACK;
}
var auto_text_color_default = autoTextColor;

// node_modules/@progress/kendo-charts/dist/es/common/create-hash-set.js
var DELETED = {};
var LegacySet = function LegacySet2(values5) {
  var this$1 = this;
  this._index = {};
  this._values = values5 ? values5.slice(0) : [];
  for (var i = 0; i < this._values.length; i++) {
    this$1._index[this$1._values[i]] = i;
  }
};
var prototypeAccessors = { size: { configurable: true } };
LegacySet.prototype.values = function values() {
  return this._values.filter(function(item) {
    return item !== DELETED;
  });
};
LegacySet.prototype.has = function has(value) {
  return this._index[value] !== void 0;
};
LegacySet.prototype.add = function add(value) {
  if (!this.has(value)) {
    this._index[value] = this._values.length;
    this._values.push(value);
  }
};
LegacySet.prototype.delete = function delete$1(value) {
  var index = this._index[value];
  if (index !== void 0) {
    this._values[index] = DELETED;
    delete this._index[value];
  }
};
LegacySet.prototype.clear = function clear2() {
  this._index = {};
  this._values = [];
};
prototypeAccessors.size.get = function() {
  return this._values.length;
};
Object.defineProperties(LegacySet.prototype, prototypeAccessors);
var SetWrapper = function SetWrapper2(values5) {
  this._set = new Set(values5);
};
var prototypeAccessors$1 = { size: { configurable: true } };
SetWrapper.prototype.values = function values2() {
  return Array.from(this._set);
};
SetWrapper.prototype.has = function has2(value) {
  return this._set.has(value);
};
SetWrapper.prototype.add = function add2(value) {
  this._set.add(value);
};
SetWrapper.prototype.delete = function delete$2(value) {
  this._set.delete(value);
};
SetWrapper.prototype.clear = function clear3() {
  this._set.clear();
};
prototypeAccessors$1.size.get = function() {
  return this._set.size;
};
Object.defineProperties(SetWrapper.prototype, prototypeAccessors$1);
var supportsSet = function() {
  var supported = false;
  if (typeof Set === "function") {
    var set2 = /* @__PURE__ */ new Set([1]);
    supported = set2.has(1);
  }
  return supported;
};
function createHashSet(values5) {
  if (supportsSet()) {
    return new SetWrapper(values5);
  }
  return new LegacySet(values5);
}

// node_modules/@progress/kendo-charts/dist/es/common/default-error-handler.js
function defaultErrorHandler(error2) {
  throw error2;
}

// node_modules/@progress/kendo-charts/dist/es/common/keys.js
var keys = {
  INSERT: 45,
  DELETE: 46,
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  END: 35,
  HOME: 36,
  SPACEBAR: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  F2: 113,
  F10: 121,
  F12: 123,
  NUMPAD_PLUS: 107,
  NUMPAD_MINUS: 109,
  NUMPAD_DOT: 110
};
var keys_default = keys;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-major-unit.js
function autoMajorUnit(min3, max2) {
  var diff = round3(max2 - min3, DEFAULT_PRECISION - 1);
  if (diff === 0) {
    if (max2 === 0) {
      return 0.1;
    }
    diff = Math.abs(max2);
  }
  var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));
  var relativeValue = round3(diff / scale, DEFAULT_PRECISION);
  var scaleMultiplier = 1;
  if (relativeValue < 1.904762) {
    scaleMultiplier = 0.2;
  } else if (relativeValue < 4.761904) {
    scaleMultiplier = 0.5;
  } else if (relativeValue < 9.523809) {
    scaleMultiplier = 1;
  } else {
    scaleMultiplier = 2;
  }
  return round3(scale * scaleMultiplier, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/point.js
var Point2 = function(Class3) {
  function Point8(x, y) {
    Class3.call(this);
    this.x = x || 0;
    this.y = y || 0;
  }
  if (Class3)
    Point8.__proto__ = Class3;
  Point8.prototype = Object.create(Class3 && Class3.prototype);
  Point8.prototype.constructor = Point8;
  Point8.prototype.clone = function clone2() {
    return new Point8(this.x, this.y);
  };
  Point8.prototype.equals = function equals(point2) {
    return point2 && this.x === point2.x && this.y === point2.y;
  };
  Point8.prototype.rotate = function rotate(center, degrees) {
    var theta = rad2(degrees);
    var cosT = Math.cos(theta);
    var sinT = Math.sin(theta);
    var cx = center.x;
    var cy = center.y;
    var ref2 = this;
    var x = ref2.x;
    var y = ref2.y;
    this.x = round3(
      cx + (x - cx) * cosT + (y - cy) * sinT,
      COORD_PRECISION
    );
    this.y = round3(
      cy + (y - cy) * cosT - (x - cx) * sinT,
      COORD_PRECISION
    );
    return this;
  };
  Point8.prototype.multiply = function multiply(a) {
    this.x *= a;
    this.y *= a;
    return this;
  };
  Point8.prototype.distanceTo = function distanceTo(point2) {
    var dx = this.x - point2.x;
    var dy = this.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point8.onCircle = function onCircle(center, angle, radius) {
    var radians = rad2(angle);
    return new Point8(
      center.x - radius * Math.cos(radians),
      center.y - radius * Math.sin(radians)
    );
  };
  return Point8;
}(class_default);
var point_default2 = Point2;

// node_modules/@progress/kendo-charts/dist/es/core/box.js
var Box = function(Class3) {
  function Box2(x1, y1, x2, y2) {
    Class3.call(this);
    this.x1 = x1 || 0;
    this.y1 = y1 || 0;
    this.x2 = x2 || 0;
    this.y2 = y2 || 0;
  }
  if (Class3)
    Box2.__proto__ = Class3;
  Box2.prototype = Object.create(Class3 && Class3.prototype);
  Box2.prototype.constructor = Box2;
  Box2.prototype.equals = function equals(box) {
    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;
  };
  Box2.prototype.width = function width() {
    return this.x2 - this.x1;
  };
  Box2.prototype.height = function height() {
    return this.y2 - this.y1;
  };
  Box2.prototype.translate = function translate2(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  };
  Box2.prototype.move = function move(x, y) {
    var height = this.height();
    var width = this.width();
    if (defined2(x)) {
      this.x1 = x;
      this.x2 = this.x1 + width;
    }
    if (defined2(y)) {
      this.y1 = y;
      this.y2 = this.y1 + height;
    }
    return this;
  };
  Box2.prototype.wrap = function wrap2(targetBox) {
    this.x1 = Math.min(this.x1, targetBox.x1);
    this.y1 = Math.min(this.y1, targetBox.y1);
    this.x2 = Math.max(this.x2, targetBox.x2);
    this.y2 = Math.max(this.y2, targetBox.y2);
    return this;
  };
  Box2.prototype.wrapPoint = function wrapPoint(point2) {
    var arrayPoint = isArray(point2);
    var x = arrayPoint ? point2[0] : point2.x;
    var y = arrayPoint ? point2[1] : point2.y;
    this.wrap(new Box2(x, y, x, y));
    return this;
  };
  Box2.prototype.snapTo = function snapTo(targetBox, axis) {
    if (axis === X || !axis) {
      this.x1 = targetBox.x1;
      this.x2 = targetBox.x2;
    }
    if (axis === Y || !axis) {
      this.y1 = targetBox.y1;
      this.y2 = targetBox.y2;
    }
    return this;
  };
  Box2.prototype.alignTo = function alignTo(targetBox, anchor) {
    var height = this.height();
    var width = this.width();
    var axis = anchor === TOP || anchor === BOTTOM ? Y : X;
    var offset3 = axis === Y ? height : width;
    if (anchor === CENTER) {
      var targetCenter = targetBox.center();
      var center = this.center();
      this.x1 += targetCenter.x - center.x;
      this.y1 += targetCenter.y - center.y;
    } else if (anchor === TOP || anchor === LEFT) {
      this[axis + 1] = targetBox[axis + 1] - offset3;
    } else {
      this[axis + 1] = targetBox[axis + 2];
    }
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.shrink = function shrink(dw, dh) {
    this.x2 -= dw;
    this.y2 -= dh;
    return this;
  };
  Box2.prototype.expand = function expand(dw, dh) {
    this.shrink(-dw, -dh);
    return this;
  };
  Box2.prototype.pad = function pad3(padding) {
    var spacing = getSpacing(padding);
    this.x1 -= spacing.left;
    this.x2 += spacing.right;
    this.y1 -= spacing.top;
    this.y2 += spacing.bottom;
    return this;
  };
  Box2.prototype.unpad = function unpad2(padding) {
    var spacing = getSpacing(padding);
    spacing.left = -spacing.left;
    spacing.top = -spacing.top;
    spacing.right = -spacing.right;
    spacing.bottom = -spacing.bottom;
    return this.pad(spacing);
  };
  Box2.prototype.clone = function clone2() {
    return new Box2(this.x1, this.y1, this.x2, this.y2);
  };
  Box2.prototype.center = function center() {
    return new point_default2(
      this.x1 + this.width() / 2,
      this.y1 + this.height() / 2
    );
  };
  Box2.prototype.containsPoint = function containsPoint(point2) {
    return point2.x >= this.x1 && point2.x <= this.x2 && point2.y >= this.y1 && point2.y <= this.y2;
  };
  Box2.prototype.points = function points3() {
    return [
      new point_default2(this.x1, this.y1),
      new point_default2(this.x2, this.y1),
      new point_default2(this.x2, this.y2),
      new point_default2(this.x1, this.y2)
    ];
  };
  Box2.prototype.getHash = function getHash() {
    return [this.x1, this.y1, this.x2, this.y2].join(",");
  };
  Box2.prototype.overlaps = function overlaps(box) {
    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);
  };
  Box2.prototype.rotate = function rotate(rotation) {
    var width = this.width();
    var height = this.height();
    var ref2 = this.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var r1 = rotatePoint(0, 0, cx, cy, rotation);
    var r2 = rotatePoint(width, 0, cx, cy, rotation);
    var r3 = rotatePoint(width, height, cx, cy, rotation);
    var r4 = rotatePoint(0, height, cx, cy, rotation);
    width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);
    height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.toRect = function toRect() {
    return new geometry_exports.Rect([this.x1, this.y1], [this.width(), this.height()]);
  };
  Box2.prototype.hasSize = function hasSize() {
    return this.width() !== 0 && this.height() !== 0;
  };
  Box2.prototype.align = function align3(targetBox, axis, alignment) {
    var c1 = axis + 1;
    var c2 = axis + 2;
    var sizeFunc = axis === X ? WIDTH : HEIGHT;
    var size = this[sizeFunc]();
    if (inArray(alignment, [LEFT, TOP])) {
      this[c1] = targetBox[c1];
      this[c2] = this[c1] + size;
    } else if (inArray(alignment, [RIGHT, BOTTOM])) {
      this[c2] = targetBox[c2];
      this[c1] = this[c2] - size;
    } else if (alignment === CENTER) {
      this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;
      this[c2] = this[c1] + size;
    }
  };
  return Box2;
}(class_default);
function rotatePoint(x, y, cx, cy, angle) {
  var theta = rad2(angle);
  return new point_default2(
    cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),
    cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)
  );
}
var box_default = Box;

// node_modules/@progress/kendo-charts/dist/es/core/ring.js
var Ring = function(Class3) {
  function Ring2(center, innerRadius, radius, startAngle, angle) {
    Class3.call(this);
    this.center = center;
    this.innerRadius = innerRadius;
    this.radius = radius;
    this.startAngle = startAngle;
    this.angle = angle;
  }
  if (Class3)
    Ring2.__proto__ = Class3;
  Ring2.prototype = Object.create(Class3 && Class3.prototype);
  Ring2.prototype.constructor = Ring2;
  Ring2.prototype.clone = function clone2() {
    return new Ring2(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);
  };
  Ring2.prototype.middle = function middle() {
    return this.startAngle + this.angle / 2;
  };
  Ring2.prototype.setRadius = function setRadius(newRadius, innerRadius) {
    if (innerRadius) {
      this.innerRadius = newRadius;
    } else {
      this.radius = newRadius;
    }
    return this;
  };
  Ring2.prototype.point = function point2(angle, innerRadius) {
    var radianAngle = rad2(angle);
    var ax = Math.cos(radianAngle);
    var ay = Math.sin(radianAngle);
    var radius = innerRadius ? this.innerRadius : this.radius;
    var x = round3(this.center.x - ax * radius, COORD_PRECISION);
    var y = round3(this.center.y - ay * radius, COORD_PRECISION);
    return new point_default2(x, y);
  };
  Ring2.prototype.adjacentBox = function adjacentBox(distance, width, height) {
    var sector = this.clone().expand(distance);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    var hw = width / 2;
    var hh = height / 2;
    var sa = Math.sin(rad2(midAndle));
    var ca = Math.cos(rad2(midAndle));
    var x = midPoint.x - hw;
    var y = midPoint.y - hh;
    if (Math.abs(sa) < 0.9) {
      x += hw * -ca / Math.abs(ca);
    }
    if (Math.abs(ca) < 0.9) {
      y += hh * -sa / Math.abs(sa);
    }
    return new box_default(x, y, x + width, y + height);
  };
  Ring2.prototype.containsPoint = function containsPoint(p) {
    var center = this.center;
    var innerRadius = this.innerRadius;
    var radius = this.radius;
    var startAngle = this.startAngle;
    var endAngle = this.startAngle + this.angle;
    var dx = p.x - center.x;
    var dy = p.y - center.y;
    var vector = new point_default2(dx, dy);
    var startPoint = this.point(startAngle);
    var startVector = new point_default2(startPoint.x - center.x, startPoint.y - center.y);
    var endPoint = this.point(endAngle);
    var endVector = new point_default2(endPoint.x - center.x, endPoint.y - center.y);
    var dist = round3(dx * dx + dy * dy, COORD_PRECISION);
    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;
  };
  Ring2.prototype.getBBox = function getBBox() {
    var this$1 = this;
    var box = new box_default(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);
    var startAngle = round3(this.startAngle % 360);
    var endAngle = round3((startAngle + this.angle) % 360);
    var innerRadius = this.innerRadius;
    var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);
    var startAngleIndex = allAngles.indexOf(startAngle);
    var endAngleIndex = allAngles.indexOf(endAngle);
    var angles;
    if (startAngle === endAngle) {
      angles = allAngles;
    } else {
      if (startAngleIndex < endAngleIndex) {
        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);
      } else {
        angles = [].concat(
          allAngles.slice(0, endAngleIndex + 1),
          allAngles.slice(startAngleIndex, allAngles.length)
        );
      }
    }
    for (var i = 0; i < angles.length; i++) {
      var point2 = this$1.point(angles[i]);
      box.wrapPoint(point2);
      box.wrapPoint(point2, innerRadius);
    }
    if (!innerRadius) {
      box.wrapPoint(this.center);
    }
    return box;
  };
  Ring2.prototype.expand = function expand(value) {
    this.radius += value;
    return this;
  };
  return Ring2;
}(class_default);
function numericComparer(a, b) {
  return a - b;
}
var ring_default = Ring;

// node_modules/@progress/kendo-charts/dist/es/core/sector.js
var Sector = function(Ring2) {
  function Sector2(center, radius, startAngle, angle) {
    Ring2.call(this, center, 0, radius, startAngle, angle);
  }
  if (Ring2)
    Sector2.__proto__ = Ring2;
  Sector2.prototype = Object.create(Ring2 && Ring2.prototype);
  Sector2.prototype.constructor = Sector2;
  Sector2.prototype.expand = function expand(value) {
    return Ring2.prototype.expand.call(this, value);
  };
  Sector2.prototype.clone = function clone2() {
    return new Sector2(this.center, this.radius, this.startAngle, this.angle);
  };
  Sector2.prototype.setRadius = function setRadius(newRadius) {
    this.radius = newRadius;
    return this;
  };
  return Sector2;
}(ring_default);

// node_modules/@progress/kendo-charts/dist/es/core/shape-builder.js
var DIRECTION_ANGLE = 1e-3;
var ShapeBuilder = function(Class3) {
  function ShapeBuilder2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    ShapeBuilder2.__proto__ = Class3;
  ShapeBuilder2.prototype = Object.create(Class3 && Class3.prototype);
  ShapeBuilder2.prototype.constructor = ShapeBuilder2;
  ShapeBuilder2.prototype.createRing = function createRing(sector, options2) {
    var startAngle = sector.startAngle + 180;
    var endAngle = sector.angle + startAngle;
    if (sector.angle > 0 && startAngle === endAngle) {
      endAngle += DIRECTION_ANGLE;
    }
    var center = new geometry_exports.Point(sector.center.x, sector.center.y);
    var radius = Math.max(sector.radius, 0);
    var innerRadius = Math.max(sector.innerRadius, 0);
    var arc = new geometry_exports.Arc(center, {
      startAngle,
      endAngle,
      radiusX: radius,
      radiusY: radius
    });
    var path = drawing_exports.Path.fromArc(arc, options2).close();
    if (innerRadius) {
      arc.radiusX = arc.radiusY = innerRadius;
      var innerEnd = arc.pointAt(endAngle);
      path.lineTo(innerEnd.x, innerEnd.y);
      path.arc(endAngle, startAngle, innerRadius, innerRadius, true);
    } else {
      path.lineTo(center.x, center.y);
    }
    return path;
  };
  return ShapeBuilder2;
}(class_default);
ShapeBuilder.current = new ShapeBuilder();
var shape_builder_default = ShapeBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/chart-element.js
var ChartElement = function(Class3) {
  function ChartElement2(options2) {
    Class3.call(this);
    this.children = [];
    this.options = deepExtend({}, this.options, this.initUserOptions(options2));
  }
  if (Class3)
    ChartElement2.__proto__ = Class3;
  ChartElement2.prototype = Object.create(Class3 && Class3.prototype);
  ChartElement2.prototype.constructor = ChartElement2;
  ChartElement2.prototype.initUserOptions = function initUserOptions(options2) {
    return options2;
  };
  ChartElement2.prototype.reflow = function reflow(targetBox) {
    var children = this.children;
    var box;
    for (var i = 0; i < children.length; i++) {
      var currentChild = children[i];
      currentChild.reflow(targetBox);
      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();
    }
    this.box = box || targetBox;
  };
  ChartElement2.prototype.destroy = function destroy2() {
    var children = this.children;
    if (this.animation) {
      this.animation.destroy();
    }
    for (var i = 0; i < children.length; i++) {
      children[i].destroy();
    }
  };
  ChartElement2.prototype.getRoot = function getRoot() {
    var parent = this.parent;
    return parent ? parent.getRoot() : null;
  };
  ChartElement2.prototype.getSender = function getSender() {
    var service = this.getService();
    if (service) {
      return service.sender;
    }
  };
  ChartElement2.prototype.getService = function getService() {
    var element2 = this;
    while (element2) {
      if (element2.chartService) {
        return element2.chartService;
      }
      element2 = element2.parent;
    }
  };
  ChartElement2.prototype.translateChildren = function translateChildren(dx, dy) {
    var children = this.children;
    var childrenCount = children.length;
    for (var i = 0; i < childrenCount; i++) {
      children[i].box.translate(dx, dy);
    }
  };
  ChartElement2.prototype.append = function append3() {
    var arguments$1 = arguments;
    var this$1 = this;
    for (var i = 0; i < arguments.length; i++) {
      var item = arguments$1[i];
      this$1.children.push(item);
      item.parent = this$1;
    }
  };
  ChartElement2.prototype.renderVisual = function renderVisual() {
    if (this.options.visible === false) {
      return;
    }
    this.createVisual();
    this.addVisual();
    this.renderChildren();
    this.createAnimation();
    this.renderComplete();
  };
  ChartElement2.prototype.addVisual = function addVisual() {
    if (this.visual) {
      this.visual.chartElement = this;
      if (this.parent) {
        this.parent.appendVisual(this.visual);
      }
    }
  };
  ChartElement2.prototype.renderChildren = function renderChildren() {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      children[i].renderVisual();
    }
  };
  ChartElement2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: this.options.zIndex,
      visible: valueOrDefault2(this.options.visible, true)
    });
  };
  ChartElement2.prototype.createAnimation = function createAnimation() {
    if (this.visual && this.options.animation) {
      this.animation = drawing_exports.Animation.create(
        this.visual,
        this.options.animation
      );
    }
  };
  ChartElement2.prototype.appendVisual = function appendVisual(childVisual) {
    if (!childVisual.chartElement) {
      childVisual.chartElement = this;
    }
    if (childVisual.options.noclip) {
      this.clipRoot().visual.append(childVisual);
    } else if (defined2(childVisual.options.zIndex)) {
      this.stackRoot().stackVisual(childVisual);
    } else if (this.isStackRoot) {
      this.stackVisual(childVisual);
    } else if (this.visual) {
      this.visual.append(childVisual);
    } else {
      this.parent.appendVisual(childVisual);
    }
  };
  ChartElement2.prototype.clipRoot = function clipRoot() {
    if (this.parent) {
      return this.parent.clipRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackRoot = function stackRoot() {
    if (this.parent) {
      return this.parent.stackRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackVisual = function stackVisual(childVisual) {
    var zIndex3 = childVisual.options.zIndex || 0;
    var visuals = this.visual.children;
    var length = visuals.length;
    var pos;
    for (pos = 0; pos < length; pos++) {
      var sibling = visuals[pos];
      var here = valueOrDefault2(sibling.options.zIndex, 0);
      if (here > zIndex3) {
        break;
      }
    }
    this.visual.insert(pos, childVisual);
  };
  ChartElement2.prototype.traverse = function traverse(callback) {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      var child = children[i];
      callback(child);
      if (child.traverse) {
        child.traverse(callback);
      }
    }
  };
  ChartElement2.prototype.closest = function closest(match) {
    var element2 = this;
    var matched = false;
    while (element2 && !matched) {
      matched = match(element2);
      if (!matched) {
        element2 = element2.parent;
      }
    }
    if (matched) {
      return element2;
    }
  };
  ChartElement2.prototype.renderComplete = function renderComplete() {
  };
  ChartElement2.prototype.hasHighlight = function hasHighlight() {
    var options2 = (this.options || {}).highlight;
    return !(!this.createHighlight || options2 && options2.visible === false);
  };
  ChartElement2.prototype.toggleHighlight = function toggleHighlight(show2, opacity) {
    var this$1 = this;
    var options2 = (this.options || {}).highlight || {};
    var customVisual = options2.visual;
    var highlight = this._highlight;
    if (!highlight) {
      var highlightOptions = {
        fill: {
          color: WHITE,
          opacity: opacity || 0.2
        },
        stroke: {
          color: WHITE,
          width: 1,
          opacity: opacity || 0.2
        }
      };
      if (customVisual) {
        highlight = this._highlight = customVisual(
          Object.assign(
            this.highlightVisualArgs(),
            {
              createVisual: function() {
                return this$1.createHighlight(highlightOptions);
              },
              sender: this.getSender(),
              series: this.series,
              dataItem: this.dataItem,
              category: this.category,
              value: this.value,
              percentage: this.percentage,
              runningTotal: this.runningTotal,
              total: this.total
            }
          )
        );
        if (!highlight) {
          return;
        }
      } else {
        highlight = this._highlight = this.createHighlight(highlightOptions);
      }
      if (!defined2(highlight.options.zIndex)) {
        highlight.options.zIndex = valueOrDefault2(options2.zIndex, this.options.zIndex);
      }
      this.appendVisual(highlight);
    }
    highlight.visible(show2);
  };
  ChartElement2.prototype.createGradientOverlay = function createGradientOverlay(element2, options2, gradientOptions) {
    var overlay = new drawing_exports.Path(Object.assign({
      stroke: {
        color: "none"
      },
      fill: this.createGradient(gradientOptions),
      closed: element2.options.closed
    }, options2));
    overlay.segments.elements(element2.segments.elements());
    return overlay;
  };
  ChartElement2.prototype.createGradient = function createGradient(options2) {
    if (this.parent) {
      return this.parent.createGradient(options2);
    }
  };
  ChartElement2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return true;
  };
  return ChartElement2;
}(class_default);
ChartElement.prototype.options = {};
var chart_element_default = ChartElement;

// node_modules/@progress/kendo-charts/dist/es/core/box-element.js
var BoxElement = function(ChartElement2) {
  function BoxElement2(options2) {
    ChartElement2.call(this, options2);
    this.options.margin = getSpacing(this.options.margin);
    this.options.padding = getSpacing(this.options.padding);
  }
  if (ChartElement2)
    BoxElement2.__proto__ = ChartElement2;
  BoxElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BoxElement2.prototype.constructor = BoxElement2;
  BoxElement2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var options2 = this.options;
    var width = options2.width;
    var height = options2.height;
    var shrinkToFit = options2.shrinkToFit;
    var hasSetSize = width && height;
    var margin = options2.margin;
    var padding = options2.padding;
    var borderWidth = options2.border.width;
    var box;
    var reflowPaddingBox = function() {
      this$1.align(targetBox, X, options2.align);
      this$1.align(targetBox, Y, options2.vAlign);
      this$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);
    };
    var contentBox = targetBox.clone();
    if (hasSetSize) {
      contentBox.x2 = contentBox.x1 + width;
      contentBox.y2 = contentBox.y1 + height;
    }
    if (shrinkToFit) {
      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);
    }
    ChartElement2.prototype.reflow.call(this, contentBox);
    if (hasSetSize) {
      box = this.box = new box_default(0, 0, width, height);
    } else {
      box = this.box;
    }
    if (shrinkToFit && hasSetSize) {
      reflowPaddingBox();
      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);
    } else {
      contentBox = this.contentBox = box.clone();
      box.pad(padding).pad(borderWidth).pad(margin);
      reflowPaddingBox();
    }
    this.translateChildren(
      box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,
      box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top
    );
    var children = this.children;
    for (var i = 0; i < children.length; i++) {
      var item = children[i];
      item.reflow(item.box);
    }
  };
  BoxElement2.prototype.align = function align3(targetBox, axis, alignment) {
    this.box.align(targetBox, axis, alignment);
  };
  BoxElement2.prototype.hasBox = function hasBox() {
    var options2 = this.options;
    return options2.border.width || options2.background;
  };
  BoxElement2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    if (options2.visible && this.hasBox()) {
      this.visual.append(drawing_exports.Path.fromRect(
        this.paddingBox.toRect(),
        this.visualStyle()
      ));
    }
  };
  BoxElement2.prototype.visualStyle = function visualStyle() {
    var options2 = this.options;
    var border = options2.border || {};
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault2(border.opacity, options2.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options2.background,
        opacity: options2.opacity
      },
      cursor: options2.cursor
    };
  };
  return BoxElement2;
}(chart_element_default);
setDefaultOptions(BoxElement, {
  align: LEFT,
  vAlign: TOP,
  margin: {},
  padding: {},
  border: {
    color: BLACK,
    width: 0
  },
  background: "",
  shrinkToFit: false,
  width: 0,
  height: 0,
  visible: true
});
var box_element_default = BoxElement;

// node_modules/@progress/kendo-charts/dist/es/core/shape-element.js
var ShapeElement = function(BoxElement2) {
  function ShapeElement2(options2, pointData) {
    BoxElement2.call(this, options2);
    this.pointData = pointData;
  }
  if (BoxElement2)
    ShapeElement2.__proto__ = BoxElement2;
  ShapeElement2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  ShapeElement2.prototype.constructor = ShapeElement2;
  ShapeElement2.prototype.getElement = function getElement() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.paddingBox;
    var type = options2.type;
    var rotation = options2.rotation;
    var center = box.center();
    var halfWidth = box.width() / 2;
    var halfHeight = box.height() / 2;
    if (!options2.visible || !this.hasBox()) {
      return null;
    }
    var style = this.visualStyle();
    var element2;
    if (type === CIRCLE) {
      element2 = new drawing_exports.Circle(
        new geometry_exports.Circle([
          round3(box.x1 + halfWidth, COORD_PRECISION),
          round3(box.y1 + halfHeight, COORD_PRECISION)
        ], Math.min(halfWidth, halfHeight)),
        style
      );
    } else if (type === TRIANGLE) {
      element2 = drawing_exports.Path.fromPoints([
        [box.x1 + halfWidth, box.y1],
        [box.x1, box.y2],
        [box.x2, box.y2]
      ], style).close();
    } else if (type === CROSS) {
      element2 = new drawing_exports.MultiPath(style);
      element2.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);
      element2.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);
    } else {
      var rect = box.toRect();
      if (type === ROUNDED_RECT) {
        var borderRadius = valueOrDefault2(options2.borderRadius, rect.width() / 5);
        rect.setCornerRadius(borderRadius);
      }
      element2 = drawing_exports.Path.fromRect(rect, style);
    }
    if (rotation) {
      element2.transform(
        geometry_exports.transform().rotate(-rotation, [center.x, center.y])
      );
    }
    element2.options.zIndex = options2.zIndex;
    return element2;
  };
  ShapeElement2.prototype.createElement = function createElement17() {
    var this$1 = this;
    var customVisual = this.options.visual;
    var pointData = this.pointData || {};
    var visual;
    if (customVisual) {
      visual = customVisual({
        value: pointData.value,
        dataItem: pointData.dataItem,
        sender: this.getSender(),
        series: pointData.series,
        category: pointData.category,
        rect: this.paddingBox.toRect(),
        options: this.visualOptions(),
        createVisual: function() {
          return this$1.getElement();
        }
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  };
  ShapeElement2.prototype.visualOptions = function visualOptions() {
    var options2 = this.options;
    return {
      background: options2.background,
      border: options2.border,
      margin: options2.margin,
      padding: options2.padding,
      type: options2.type,
      size: options2.width,
      visible: options2.visible
    };
  };
  ShapeElement2.prototype.createVisual = function createVisual() {
    this.visual = this.createElement();
  };
  return ShapeElement2;
}(box_element_default);
setDefaultOptions(ShapeElement, {
  type: CIRCLE,
  align: CENTER,
  vAlign: CENTER
});
var shape_element_default = ShapeElement;

// node_modules/@progress/kendo-charts/dist/es/core/gradients.js
var LINEAR = "linear";
var RADIAL = "radial";
var GRADIENTS = {
  glass: {
    type: LINEAR,
    rotation: 0,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.25,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 1,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpBevel: {
    type: RADIAL,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.55
    }, {
      offset: 0.65,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0.25
    }]
  },
  roundedBevel: {
    type: RADIAL,
    stops: [{
      offset: 0.33,
      color: WHITE,
      opacity: 0.06
    }, {
      offset: 0.83,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0
    }]
  },
  roundedGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.5,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.15,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.17,
      color: WHITE,
      opacity: 0.35
    }, {
      offset: 0.85,
      color: WHITE,
      opacity: 0.05
    }, {
      offset: 0.87,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  bubbleShadow: {
    type: RADIAL,
    center: [0.5, 0.5],
    radius: 0.5
  }
};
var gradients_default = GRADIENTS;

// node_modules/@progress/kendo-charts/dist/es/core/utils/box-diff.js
function boxDiff(r, s) {
  if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {
    return s;
  }
  var a = Math.min(r.x1, s.x1);
  var b = Math.max(r.x1, s.x1);
  var c = Math.min(r.x2, s.x2);
  var d = Math.max(r.x2, s.x2);
  var e = Math.min(r.y1, s.y1);
  var f = Math.max(r.y1, s.y1);
  var g = Math.min(r.y2, s.y2);
  var h = Math.max(r.y2, s.y2);
  var boxes = [];
  boxes[0] = new box_default(b, e, c, f);
  boxes[1] = new box_default(a, f, b, g);
  boxes[2] = new box_default(c, f, d, g);
  boxes[3] = new box_default(b, g, c, h);
  if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) {
    boxes[4] = new box_default(a, e, b, f);
    boxes[5] = new box_default(c, g, d, h);
  } else {
    boxes[4] = new box_default(c, e, d, f);
    boxes[5] = new box_default(a, g, b, h);
  }
  return grep(boxes, function(box) {
    return box.height() > 0 && box.width() > 0;
  })[0];
}

// node_modules/@progress/kendo-charts/dist/es/core/root-element.js
var RootElement = function(ChartElement2) {
  function RootElement2(options2) {
    ChartElement2.call(this, options2);
    var rootOptions = this.options;
    rootOptions.width = parseInt(rootOptions.width, 10);
    rootOptions.height = parseInt(rootOptions.height, 10);
    this.gradients = {};
  }
  if (ChartElement2)
    RootElement2.__proto__ = ChartElement2;
  RootElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RootElement2.prototype.constructor = RootElement2;
  RootElement2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var currentBox = new box_default(0, 0, options2.width, options2.height);
    this.box = currentBox.unpad(options2.margin);
    for (var i = 0; i < children.length; i++) {
      children[i].reflow(currentBox);
      currentBox = boxDiff(currentBox, children[i].box) || new box_default();
    }
  };
  RootElement2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group();
    this.createBackground();
  };
  RootElement2.prototype.createBackground = function createBackground() {
    var options2 = this.options;
    var border = options2.border || {};
    var box = this.box.clone().pad(options2.margin).unpad(border.width);
    var background = drawing_exports.Path.fromRect(box.toRect(), {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      fill: {
        color: options2.background,
        opacity: options2.opacity
      },
      zIndex: -10
    });
    this.visual.append(background);
  };
  RootElement2.prototype.getRoot = function getRoot() {
    return this;
  };
  RootElement2.prototype.createGradient = function createGradient(options2) {
    var gradients = this.gradients;
    var hashCode = objectKey2(options2);
    var gradient = gradients_default[options2.gradient];
    var drawingGradient;
    if (gradients[hashCode]) {
      drawingGradient = gradients[hashCode];
    } else {
      var gradientOptions = Object.assign({}, gradient, options2);
      if (gradient.type === "linear") {
        drawingGradient = new drawing_exports.LinearGradient(gradientOptions);
      } else {
        if (options2.innerRadius) {
          gradientOptions.stops = innerRadialStops(gradientOptions);
        }
        drawingGradient = new drawing_exports.RadialGradient(gradientOptions);
        drawingGradient.supportVML = gradient.supportVML !== false;
      }
      gradients[hashCode] = drawingGradient;
    }
    return drawingGradient;
  };
  RootElement2.prototype.cleanGradients = function cleanGradients() {
    var gradients = this.gradients;
    for (var hashCode in gradients) {
      gradients[hashCode]._observers = [];
    }
  };
  RootElement2.prototype.size = function size() {
    var options2 = this.options;
    return new box_default(0, 0, options2.width, options2.height);
  };
  return RootElement2;
}(chart_element_default);
setDefaultOptions(RootElement, {
  width: DEFAULT_WIDTH,
  height: DEFAULT_HEIGHT,
  background: WHITE,
  border: {
    color: BLACK,
    width: 0
  },
  margin: getSpacing(5),
  zIndex: -2
});
function innerRadialStops(options2) {
  var stops = options2.stops;
  var usedSpace = options2.innerRadius / options2.radius * 100;
  var length = stops.length;
  var currentStops = [];
  for (var i = 0; i < length; i++) {
    var currentStop = Object.assign({}, stops[i]);
    currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;
    currentStops.push(currentStop);
  }
  return currentStops;
}
var root_element_default = RootElement;

// node_modules/@progress/kendo-charts/dist/es/core/float-element.js
var FloatElement = function(ChartElement2) {
  function FloatElement2(options2) {
    ChartElement2.call(this, options2);
    this._initDirection();
  }
  if (ChartElement2)
    FloatElement2.__proto__ = ChartElement2;
  FloatElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FloatElement2.prototype.constructor = FloatElement2;
  FloatElement2.prototype._initDirection = function _initDirection() {
    var options2 = this.options;
    if (options2.vertical) {
      this.groupAxis = X;
      this.elementAxis = Y;
      this.groupSizeField = WIDTH;
      this.elementSizeField = HEIGHT;
      this.groupSpacing = options2.spacing;
      this.elementSpacing = options2.vSpacing;
    } else {
      this.groupAxis = Y;
      this.elementAxis = X;
      this.groupSizeField = HEIGHT;
      this.elementSizeField = WIDTH;
      this.groupSpacing = options2.vSpacing;
      this.elementSpacing = options2.spacing;
    }
  };
  FloatElement2.prototype.reflow = function reflow(targetBox) {
    this.box = targetBox.clone();
    this.reflowChildren();
  };
  FloatElement2.prototype.reflowChildren = function reflowChildren() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var elementAxis = ref2.elementAxis;
    var groupAxis = ref2.groupAxis;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var ref$1 = this.groupOptions();
    var groups = ref$1.groups;
    var groupsSize = ref$1.groupsSize;
    var maxGroupElementsSize = ref$1.maxGroupElementsSize;
    var groupsCount = groups.length;
    var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());
    if (groupsCount) {
      var groupStart = groupsStart;
      for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {
        var group = groups[groupIdx];
        var groupElements = group.groupElements;
        var elementStart = box[elementAxis + 1];
        var groupElementsCount = groupElements.length;
        for (var idx = 0; idx < groupElementsCount; idx++) {
          var element2 = groupElements[idx];
          var elementSize3 = this$1.elementSize(element2);
          var groupElementStart = groupStart + this$1.alignStart(elementSize3[groupSizeField], group.groupSize);
          var elementBox = new box_default();
          elementBox[groupAxis + 1] = groupElementStart;
          elementBox[groupAxis + 2] = groupElementStart + elementSize3[groupSizeField];
          elementBox[elementAxis + 1] = elementStart;
          elementBox[elementAxis + 2] = elementStart + elementSize3[elementSizeField];
          element2.reflow(elementBox);
          elementStart += elementSize3[elementSizeField] + this$1.elementSpacing;
        }
        groupStart += group.groupSize + this$1.groupSpacing;
      }
      box[groupAxis + 1] = groupsStart;
      box[groupAxis + 2] = groupsStart + groupsSize;
      box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;
    }
  };
  FloatElement2.prototype.alignStart = function alignStart2(size, maxSize) {
    var start = 0;
    var align3 = this.options.align;
    if (align3 === RIGHT || align3 === BOTTOM) {
      start = maxSize - size;
    } else if (align3 === CENTER) {
      start = (maxSize - size) / 2;
    }
    return start;
  };
  FloatElement2.prototype.groupOptions = function groupOptions() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var children = ref2.children;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var elementSpacing = ref2.elementSpacing;
    var groupSpacing = ref2.groupSpacing;
    var maxSize = round3(box[elementSizeField]());
    var childrenCount = children.length;
    var groups = [];
    var groupSize = 0;
    var groupElementsSize = 0;
    var groupsSize = 0;
    var maxGroupElementsSize = 0;
    var groupElements = [];
    for (var idx = 0; idx < childrenCount; idx++) {
      var element2 = children[idx];
      if (!element2.box) {
        element2.reflow(box);
      }
      var elementSize3 = this$1.elementSize(element2);
      if (this$1.options.wrap && round3(groupElementsSize + elementSpacing + elementSize3[elementSizeField]) > maxSize) {
        groups.push({
          groupElements,
          groupSize,
          groupElementsSize
        });
        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
        groupsSize += groupSpacing + groupSize;
        groupSize = 0;
        groupElementsSize = 0;
        groupElements = [];
      }
      groupSize = Math.max(groupSize, elementSize3[groupSizeField]);
      if (groupElementsSize > 0) {
        groupElementsSize += elementSpacing;
      }
      groupElementsSize += elementSize3[elementSizeField];
      groupElements.push(element2);
    }
    groups.push({
      groupElements,
      groupSize,
      groupElementsSize
    });
    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
    groupsSize += groupSize;
    return {
      groups,
      groupsSize,
      maxGroupElementsSize
    };
  };
  FloatElement2.prototype.elementSize = function elementSize3(element2) {
    return {
      width: element2.box.width(),
      height: element2.box.height()
    };
  };
  FloatElement2.prototype.createVisual = function createVisual() {
  };
  return FloatElement2;
}(chart_element_default);
setDefaultOptions(FloatElement, {
  vertical: true,
  wrap: true,
  vSpacing: 0,
  spacing: 0
});
var float_element_default = FloatElement;

// node_modules/@progress/kendo-charts/dist/es/core/text.js
var DrawingText = drawing_exports.Text;
var Text2 = function(ChartElement2) {
  function Text4(content, options2) {
    ChartElement2.call(this, options2);
    this.content = content;
    this.reflow(new box_default());
  }
  if (ChartElement2)
    Text4.__proto__ = ChartElement2;
  Text4.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Text4.prototype.constructor = Text4;
  Text4.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var size = options2.size = drawing_exports.util.measureText(this.content, { font: options2.font });
    this.baseline = size.baseline;
    this.box = new box_default(
      targetBox.x1,
      targetBox.y1,
      targetBox.x1 + size.width,
      targetBox.y1 + size.height
    );
  };
  Text4.prototype.createVisual = function createVisual() {
    var ref2 = this.options;
    var font2 = ref2.font;
    var color = ref2.color;
    var opacity = ref2.opacity;
    var cursor = ref2.cursor;
    this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {
      font: font2,
      fill: { color, opacity },
      cursor
    });
  };
  return Text4;
}(chart_element_default);
setDefaultOptions(Text2, {
  font: DEFAULT_FONT,
  color: BLACK
});
var text_default2 = Text2;

// node_modules/@progress/kendo-charts/dist/es/core/utils/rect-to-box.js
function rectToBox(rect) {
  var origin = rect.origin;
  var bottomRight = rect.bottomRight();
  return new box_default(origin.x, origin.y, bottomRight.x, bottomRight.y);
}

// node_modules/@progress/kendo-charts/dist/es/core/text-box.js
var ROWS_SPLIT_REGEX = /\n/m;
var TextBox = function(BoxElement2) {
  function TextBox2(content, options2, data) {
    BoxElement2.call(this, options2);
    this.content = content;
    this.data = data;
    this._initContainer();
    if (this.options._autoReflow !== false) {
      this.reflow(new box_default());
    }
  }
  if (BoxElement2)
    TextBox2.__proto__ = BoxElement2;
  TextBox2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  TextBox2.prototype.constructor = TextBox2;
  TextBox2.prototype._initContainer = function _initContainer() {
    var options2 = this.options;
    var rows = String(this.content).split(ROWS_SPLIT_REGEX);
    var floatElement = new float_element_default({ vertical: true, align: options2.align, wrap: false });
    var textOptions = deepExtend({}, options2, { opacity: 1, animation: null });
    this.container = floatElement;
    this.append(floatElement);
    for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
      var text = new text_default2(rows[rowIdx].trim(), textOptions);
      floatElement.append(text);
    }
  };
  TextBox2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var visualFn = options2.visual;
    this.container.options.align = options2.align;
    if (visualFn && !this._boxReflow) {
      var visualBox = targetBox;
      if (!visualBox.hasSize()) {
        this._boxReflow = true;
        this.reflow(visualBox);
        this._boxReflow = false;
        visualBox = this.box;
      }
      var visual = this.visual = visualFn(this.visualContext(visualBox));
      if (visual) {
        visualBox = rectToBox(visual.clippedBBox() || new geometry_exports.Rect());
        visual.options.zIndex = options2.zIndex;
      }
      this.box = this.contentBox = this.paddingBox = visualBox;
    } else {
      BoxElement2.prototype.reflow.call(this, targetBox);
      if (options2.rotation) {
        var margin = getSpacing(options2.margin);
        var box = this.box.unpad(margin);
        this.targetBox = targetBox;
        this.normalBox = box.clone();
        box = this.rotate();
        box.translate(margin.left - margin.right, margin.top - margin.bottom);
        this.rotatedBox = box.clone();
        box.pad(margin);
      }
    }
  };
  TextBox2.prototype.createVisual = function createVisual() {
    var options2 = this.options;
    this.visual = new drawing_exports.Group({
      transform: this.rotationTransform(),
      zIndex: options2.zIndex,
      noclip: options2.noclip
    });
    if (this.hasBox()) {
      var box = drawing_exports.Path.fromRect(this.paddingBox.toRect(), this.visualStyle());
      this.visual.append(box);
    }
  };
  TextBox2.prototype.renderVisual = function renderVisual() {
    if (!this.options.visible) {
      return;
    }
    if (this.options.visual) {
      var visual = this.visual;
      if (visual && !defined2(visual.options.noclip)) {
        visual.options.noclip = this.options.noclip;
      }
      this.addVisual();
      this.createAnimation();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  TextBox2.prototype.visualContext = function visualContext(targetBox) {
    var this$1 = this;
    var context2 = {
      text: this.content,
      rect: targetBox.toRect(),
      sender: this.getSender(),
      options: this.options,
      createVisual: function() {
        this$1._boxReflow = true;
        this$1.reflow(targetBox);
        this$1._boxReflow = false;
        return this$1.getDefaultVisual();
      }
    };
    if (this.data) {
      Object.assign(context2, this.data);
    }
    return context2;
  };
  TextBox2.prototype.getDefaultVisual = function getDefaultVisual() {
    this.createVisual();
    this.renderChildren();
    var visual = this.visual;
    delete this.visual;
    return visual;
  };
  TextBox2.prototype.rotate = function rotate() {
    var options2 = this.options;
    this.box.rotate(options2.rotation);
    this.align(this.targetBox, X, options2.align);
    this.align(this.targetBox, Y, options2.vAlign);
    return this.box;
  };
  TextBox2.prototype.rotationTransform = function rotationTransform() {
    var rotation = this.options.rotation;
    if (!rotation) {
      return null;
    }
    var ref2 = this.normalBox.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var boxCenter = this.rotatedBox.center();
    return geometry_exports.transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);
  };
  return TextBox2;
}(box_element_default);
var text_box_default = TextBox;

// node_modules/@progress/kendo-charts/dist/es/core/title.js
var Title = function(ChartElement2) {
  function Title2(options2) {
    ChartElement2.call(this, options2);
    this._textBox = new text_box_default(this.options.text, Object.assign({}, this.options, {
      vAlign: this.options.position
    }));
    this.append(this._textBox);
  }
  if (ChartElement2)
    Title2.__proto__ = ChartElement2;
  Title2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Title2.prototype.constructor = Title2;
  Title2.prototype.reflow = function reflow(targetBox) {
    ChartElement2.prototype.reflow.call(this, targetBox);
    this.box.snapTo(targetBox, X);
  };
  Title2.buildTitle = function buildTitle(options2, defaultOptions) {
    var titleOptions = options2;
    if (typeof options2 === "string") {
      titleOptions = { text: options2 };
    }
    titleOptions = Object.assign({ visible: true }, defaultOptions, titleOptions);
    var title2;
    if (titleOptions && titleOptions.visible && titleOptions.text) {
      title2 = new Title2(titleOptions);
    }
    return title2;
  };
  Title2.orderTitles = function orderTitles(titles) {
    var items = [].concat(titles);
    var top = items.filter(function(item) {
      return item && item.options.position !== BOTTOM;
    });
    var bottom = items.filter(function(item) {
      return item && item.options.position === BOTTOM;
    });
    collapseVerticalMargins(top);
    collapseVerticalMargins(bottom);
    bottom.reverse();
    return top.concat(bottom);
  };
  return Title2;
}(chart_element_default);
function collapseVerticalMargins(items) {
  for (var i = 1; i < items.length; i++) {
    var box = items[i]._textBox;
    var prevBox = items[i - 1]._textBox;
    prevBox.options.margin = Object.assign(getSpacing(prevBox.options.margin), { bottom: 0 });
    box.options.margin = Object.assign(getSpacing(box.options.margin), { top: 0 });
  }
}
setDefaultOptions(Title, {
  color: BLACK,
  position: TOP,
  align: CENTER,
  margin: getSpacing(5),
  padding: getSpacing(5)
});
var title_default = Title;

// node_modules/@progress/kendo-charts/dist/es/core/axis-label.js
var AxisLabel = function(TextBox2) {
  function AxisLabel2(value, text, index, dataItem, options2) {
    TextBox2.call(this, text, options2);
    this.text = text;
    this.value = value;
    this.index = index;
    this.dataItem = dataItem;
    this.reflow(new box_default());
  }
  if (TextBox2)
    AxisLabel2.__proto__ = TextBox2;
  AxisLabel2.prototype = Object.create(TextBox2 && TextBox2.prototype);
  AxisLabel2.prototype.constructor = AxisLabel2;
  AxisLabel2.prototype.visualContext = function visualContext(targetBox) {
    var context2 = TextBox2.prototype.visualContext.call(this, targetBox);
    context2.value = this.value;
    context2.dataItem = this.dataItem;
    context2.format = this.options.format;
    context2.culture = this.options.culture;
    return context2;
  };
  AxisLabel2.prototype.click = function click(widget, e) {
    widget.trigger(AXIS_LABEL_CLICK, {
      element: eventElement2(e),
      value: this.value,
      text: this.text,
      index: this.index,
      dataItem: this.dataItem,
      axis: this.parent.options
    });
  };
  AxisLabel2.prototype.rotate = function rotate() {
    if (this.options.alignRotation !== CENTER) {
      var box = this.normalBox.toRect();
      var transform2 = this.rotationTransform();
      this.box = rectToBox(box.bbox(transform2.matrix()));
    } else {
      TextBox2.prototype.rotate.call(this);
    }
    return this.box;
  };
  AxisLabel2.prototype.rotationTransform = function rotationTransform() {
    var options2 = this.options;
    var rotation = options2.rotation;
    if (!rotation) {
      return null;
    }
    if (options2.alignRotation === CENTER) {
      return TextBox2.prototype.rotationTransform.call(this);
    }
    var rotationMatrix = geometry_exports.transform().rotate(rotation).matrix();
    var box = this.normalBox.toRect();
    var rect = this.targetBox.toRect();
    var rotationOrigin = options2.rotationOrigin || TOP;
    var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;
    var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;
    var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();
    var topLeft = box.topLeft().transformCopy(rotationMatrix);
    var topRight = box.topRight().transformCopy(rotationMatrix);
    var bottomRight = box.bottomRight().transformCopy(rotationMatrix);
    var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);
    var rotatedBox = geometry_exports.Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);
    var translate2 = {};
    translate2[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];
    var distanceLeft = Math.abs(topLeft[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var distanceRight = Math.abs(topRight[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var alignStart2, alignEnd;
    if (round3(distanceLeft, DEFAULT_PRECISION) === round3(distanceRight, DEFAULT_PRECISION)) {
      alignStart2 = topLeft;
      alignEnd = topRight;
    } else if (distanceRight < distanceLeft) {
      alignStart2 = topRight;
      alignEnd = bottomRight;
    } else {
      alignStart2 = topLeft;
      alignEnd = bottomLeft;
    }
    var alignCenter = alignStart2[alignAxis] + (alignEnd[alignAxis] - alignStart2[alignAxis]) / 2;
    translate2[alignAxis] = rect.center()[alignAxis] - alignCenter;
    return geometry_exports.transform().translate(translate2.x, translate2.y).rotate(rotation);
  };
  return AxisLabel2;
}(text_box_default);
setDefaultOptions(AxisLabel, {
  _autoReflow: false
});
var axis_label_default = AxisLabel;

// node_modules/@progress/kendo-charts/dist/es/core/note.js
var DEFAULT_ICON_SIZE = 7;
var DEFAULT_LABEL_COLOR = "#fff";
var Note = function(BoxElement2) {
  function Note2(fields, options2, chartService) {
    BoxElement2.call(this, options2);
    this.fields = fields;
    this.chartService = chartService;
    this.render();
  }
  if (BoxElement2)
    Note2.__proto__ = BoxElement2;
  Note2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Note2.prototype.constructor = Note2;
  Note2.prototype.hide = function hide2() {
    this.options.visible = false;
  };
  Note2.prototype.show = function show2() {
    this.options.visible = true;
  };
  Note2.prototype.render = function render() {
    var this$1 = this;
    var options2 = this.options;
    if (options2.visible) {
      var label = options2.label;
      var icon = options2.icon;
      var box = new box_default();
      var childAlias = function() {
        return this$1;
      };
      var size = icon.size;
      var text = this.fields.text;
      var width, height;
      if (defined2(label) && label.visible) {
        var noteTemplate = getTemplate(label);
        if (noteTemplate) {
          text = noteTemplate(this.fields);
        } else if (label.format) {
          text = this.chartService.format.auto(label.format, text);
        }
        if (!label.color) {
          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;
        }
        this.label = new text_box_default(text, deepExtend({}, label));
        this.label.aliasFor = childAlias;
        if (label.position === INSIDE && !defined2(size)) {
          if (icon.type === CIRCLE) {
            size = Math.max(this.label.box.width(), this.label.box.height());
          } else {
            width = this.label.box.width();
            height = this.label.box.height();
          }
          box.wrap(this.label.box);
        }
      }
      icon.width = width || size || DEFAULT_ICON_SIZE;
      icon.height = height || size || DEFAULT_ICON_SIZE;
      var marker = new shape_element_default(deepExtend({}, icon));
      marker.aliasFor = childAlias;
      this.marker = marker;
      this.append(marker);
      if (this.label) {
        this.append(this.label);
      }
      marker.reflow(new box_default());
      this.wrapperBox = box.wrap(marker.box);
    }
  };
  Note2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var label = ref2.label;
    var marker = ref2.marker;
    var wrapperBox = ref2.wrapperBox;
    var center = targetBox.center();
    var length = options2.line.length;
    var position3 = options2.position;
    if (options2.visible) {
      var lineStart, box, contentBox;
      if (inArray(position3, [LEFT, RIGHT])) {
        if (position3 === LEFT) {
          contentBox = wrapperBox.alignTo(targetBox, position3).translate(-length, targetBox.center().y - wrapperBox.center().y);
          if (options2.line.visible) {
            lineStart = [targetBox.x1, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x2, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position3).translate(length, targetBox.center().y - wrapperBox.center().y);
          if (options2.line.visible) {
            lineStart = [targetBox.x2, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x1, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      } else {
        if (position3 === BOTTOM) {
          contentBox = wrapperBox.alignTo(targetBox, position3).translate(targetBox.center().x - wrapperBox.center().x, length);
          if (options2.line.visible) {
            lineStart = [center.x, targetBox.y2];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y1]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position3).translate(targetBox.center().x - wrapperBox.center().x, -length);
          if (options2.line.visible) {
            lineStart = [center.x, targetBox.y1];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y2]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      }
      if (marker) {
        marker.reflow(contentBox);
      }
      if (label) {
        label.reflow(contentBox);
        if (marker) {
          if (options2.label.position === OUTSIDE) {
            label.box.alignTo(marker.box, position3);
          }
          label.reflow(label.box);
        }
      }
      this.contentBox = contentBox;
      this.targetBox = targetBox;
      this.box = box || contentBox;
    }
  };
  Note2.prototype.createVisual = function createVisual() {
    BoxElement2.prototype.createVisual.call(this);
    this.visual.options.noclip = this.options.noclip;
    if (this.options.visible) {
      this.createLine();
    }
  };
  Note2.prototype.renderVisual = function renderVisual() {
    var this$1 = this;
    var options2 = this.options;
    var customVisual = options2.visual;
    if (options2.visible && customVisual) {
      this.visual = customVisual(Object.assign(this.fields, {
        sender: this.getSender(),
        rect: this.targetBox.toRect(),
        options: {
          background: options2.background,
          border: options2.background,
          icon: options2.icon,
          label: options2.label,
          line: options2.line,
          position: options2.position,
          visible: options2.visible
        },
        createVisual: function() {
          this$1.createVisual();
          this$1.renderChildren();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      }));
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  Note2.prototype.createLine = function createLine() {
    var options2 = this.options.line;
    if (this.linePoints) {
      var path = drawing_exports.Path.fromPoints(this.linePoints, {
        stroke: {
          color: options2.color,
          width: options2.width,
          dashType: options2.dashType
        }
      });
      alignPathToPixel(path);
      this.visual.append(path);
    }
  };
  Note2.prototype.click = function click(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(NOTE_CLICK, args)) {
      e.preventDefault();
    }
  };
  Note2.prototype.over = function over(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(NOTE_HOVER, args)) {
      e.preventDefault();
    }
  };
  Note2.prototype.out = function out(widget, e) {
    var args = this.eventArgs(e);
    widget.trigger(NOTE_LEAVE, args);
  };
  Note2.prototype.eventArgs = function eventArgs2(e) {
    var options2 = this.options;
    return Object.assign(this.fields, {
      element: eventElement2(e),
      text: defined2(options2.label) ? options2.label.text : "",
      visual: this.visual
    });
  };
  return Note2;
}(box_element_default);
setDefaultOptions(Note, {
  icon: {
    visible: true,
    type: CIRCLE
  },
  label: {
    position: INSIDE,
    visible: true,
    align: CENTER,
    vAlign: CENTER
  },
  line: {
    visible: true
  },
  visible: true,
  position: TOP,
  zIndex: 2
});
var note_default = Note;

// node_modules/@progress/kendo-charts/dist/es/services/intl-service.js
var defaultImplementation = {
  format: function(format2, value) {
    return value;
  },
  toString: function(value) {
    return value;
  },
  parseDate: function(value) {
    return new Date(value);
  },
  firstDay: function() {
    return 0;
  }
};
var current2 = defaultImplementation;
var IntlService2 = function IntlService3() {
};
var staticAccessors = { implementation: { configurable: true } };
IntlService2.register = function register2(userImplementation) {
  current2 = userImplementation;
};
staticAccessors.implementation.get = function() {
  return current2;
};
Object.defineProperties(IntlService2, staticAccessors);
var intl_service_default = IntlService2;

// node_modules/@progress/kendo-charts/dist/es/services/format-service.js
var FORMAT_REPLACE_REGEX = /\{(\d+)(:[^\}]+)?\}/g;
var FormatService = function FormatService2(intlService) {
  this._intlService = intlService;
};
var prototypeAccessors2 = { intl: { configurable: true } };
prototypeAccessors2.intl.get = function() {
  return this._intlService || intl_service_default.implementation;
};
prototypeAccessors2.intl.set = function(value) {
  this._intlService = value;
};
FormatService.prototype.auto = function auto(formatString2) {
  var values5 = [], len = arguments.length - 1;
  while (len-- > 0)
    values5[len] = arguments[len + 1];
  var intl = this.intl;
  if (isString2(formatString2) && formatString2.match(FORMAT_REGEX)) {
    return intl.format.apply(intl, [formatString2].concat(values5));
  }
  return intl.toString(values5[0], formatString2);
};
FormatService.prototype.localeAuto = function localeAuto(formatString2, values5, locale) {
  var intl = this.intl;
  var result;
  if (isString2(formatString2) && formatString2.match(FORMAT_REGEX)) {
    result = formatString2.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {
      var value = values5[parseInt(index, 10)];
      return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : "", locale);
    });
  } else {
    result = intl.toString(values5[0], formatString2, locale);
  }
  return result;
};
Object.defineProperties(FormatService.prototype, prototypeAccessors2);
var format_service_default = FormatService;

// node_modules/@progress/kendo-charts/dist/es/services/chart-service.js
var ChartService = function ChartService2(chart, context2) {
  if (context2 === void 0)
    context2 = {};
  this._intlService = context2.intlService;
  this.sender = context2.sender || chart;
  this.format = new format_service_default(context2.intlService);
  this.chart = chart;
  this.rtl = Boolean(context2.rtl);
};
var prototypeAccessors3 = { intl: { configurable: true } };
prototypeAccessors3.intl.get = function() {
  return this._intlService || intl_service_default.implementation;
};
prototypeAccessors3.intl.set = function(value) {
  this._intlService = value;
  this.format.intl = value;
};
ChartService.prototype.notify = function notify(name2, args) {
  if (this.chart) {
    this.chart.trigger(name2, args);
  }
};
ChartService.prototype.isPannable = function isPannable(axis) {
  var pannable = ((this.chart || {}).options || {}).pannable;
  return pannable && pannable.lock !== axis;
};
Object.defineProperties(ChartService.prototype, prototypeAccessors3);
var chart_service_default = ChartService;

// node_modules/@progress/kendo-charts/dist/es/services/dom-events-builder.js
var current3;
var DomEventsBuilder = function DomEventsBuilder2() {
};
DomEventsBuilder.register = function register3(userImplementation) {
  current3 = userImplementation;
};
DomEventsBuilder.create = function create(element2, events2) {
  if (current3) {
    return current3.create(element2, events2);
  }
};
var dom_events_builder_default = DomEventsBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-tick.js
function createAxisTick(options2, tickOptions) {
  var tickX = options2.tickX;
  var tickY = options2.tickY;
  var position3 = options2.position;
  var tick = new drawing_exports.Path({
    stroke: {
      width: tickOptions.width,
      color: tickOptions.color
    }
  });
  if (options2.vertical) {
    tick.moveTo(tickX, position3).lineTo(tickX + tickOptions.size, position3);
  } else {
    tick.moveTo(position3, tickY).lineTo(position3, tickY + tickOptions.size);
  }
  alignPathToPixel(tick);
  return tick;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-grid-line.js
function createAxisGridLine(options2, gridLine) {
  var lineStart = options2.lineStart;
  var lineEnd = options2.lineEnd;
  var position3 = options2.position;
  var line = new drawing_exports.Path({
    stroke: {
      width: gridLine.width,
      color: gridLine.color,
      dashType: gridLine.dashType
    }
  });
  if (options2.vertical) {
    line.moveTo(lineStart, position3).lineTo(lineEnd, position3);
  } else {
    line.moveTo(position3, lineStart).lineTo(position3, lineEnd);
  }
  alignPathToPixel(line);
  return line;
}

// node_modules/@progress/kendo-charts/dist/es/core/axis.js
var Axis = function(ChartElement2) {
  function Axis2(options2, chartService) {
    if (chartService === void 0)
      chartService = new chart_service_default();
    ChartElement2.call(this, options2);
    this.chartService = chartService;
    if (!this.options.visible) {
      this.options = deepExtend({}, this.options, {
        labels: {
          visible: false
        },
        line: {
          visible: false
        },
        margin: 0,
        majorTickSize: 0,
        minorTickSize: 0
      });
    }
    this.options.minorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.minorTickType !== NONE
    }, this.options.minorTicks, {
      size: this.options.minorTickSize,
      align: this.options.minorTickType
    });
    this.options.majorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.majorTickType !== NONE
    }, this.options.majorTicks, {
      size: this.options.majorTickSize,
      align: this.options.majorTickType
    });
    this.initFields();
    if (!this.options._deferLabels) {
      this.createLabels();
    }
    this.createTitle();
    this.createNotes();
  }
  if (ChartElement2)
    Axis2.__proto__ = ChartElement2;
  Axis2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Axis2.prototype.constructor = Axis2;
  Axis2.prototype.initFields = function initFields() {
  };
  Axis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.labelsCount()
    };
  };
  Axis2.prototype.normalizeLabelRotation = function normalizeLabelRotation(labelOptions) {
    var rotation = labelOptions.rotation;
    if (isObject(rotation)) {
      labelOptions.alignRotation = rotation.align;
      labelOptions.rotation = rotation.angle;
    }
  };
  Axis2.prototype.createLabels = function createLabels() {
    var this$1 = this;
    var options2 = this.options;
    var align3 = options2.vertical ? RIGHT : CENTER;
    var labelOptions = deepExtend({}, options2.labels, {
      align: align3,
      zIndex: options2.zIndex
    });
    var step = Math.max(1, labelOptions.step);
    this.clearLabels();
    if (labelOptions.visible) {
      this.normalizeLabelRotation(labelOptions);
      if (labelOptions.rotation === "auto") {
        labelOptions.rotation = 0;
        options2.autoRotateLabels = true;
      }
      var range = this.labelsRange();
      for (var idx = range.min; idx < range.max; idx += step) {
        var labelContext = { index: idx, count: range.max };
        var label = this$1.createAxisLabel(idx, labelOptions, labelContext);
        if (label) {
          this$1.append(label);
          this$1.labels.push(label);
        }
      }
    }
  };
  Axis2.prototype.clearLabels = function clearLabels() {
    this.children = grep(this.children, function(child) {
      return !(child instanceof axis_label_default);
    });
    this.labels = [];
  };
  Axis2.prototype.clearTitle = function clearTitle() {
    var this$1 = this;
    if (this.title) {
      this.children = grep(this.children, function(child) {
        return child !== this$1.title;
      });
      this.title = void 0;
    }
  };
  Axis2.prototype.clear = function clear4() {
    this.clearLabels();
    this.clearTitle();
  };
  Axis2.prototype.lineBox = function lineBox() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var axisX = mirror ? box.x1 : box.x2;
    var axisY = mirror ? box.y2 : box.y1;
    var lineWidth = options2.line.width || 0;
    return vertical ? new box_default(axisX, box.y1, axisX, box.y2 - lineWidth) : new box_default(box.x1, axisY, box.x2 - lineWidth, axisY);
  };
  Axis2.prototype.createTitle = function createTitle() {
    var options2 = this.options;
    var titleOptions = deepExtend({
      rotation: options2.vertical ? -90 : 0,
      text: "",
      zIndex: 1,
      visualSize: true
    }, options2.title);
    if (titleOptions.visible && titleOptions.text) {
      var title2 = new text_box_default(titleOptions.text, titleOptions);
      this.append(title2);
      this.title = title2;
    }
  };
  Axis2.prototype.createNotes = function createNotes() {
    var this$1 = this;
    var options2 = this.options;
    var notes2 = options2.notes;
    var items = notes2.data || [];
    this.notes = [];
    for (var i = 0; i < items.length; i++) {
      var item = deepExtend({}, notes2, items[i]);
      item.value = this$1.parseNoteValue(item.value);
      var note = new note_default({
        value: item.value,
        text: item.label.text,
        dataItem: item
      }, item, this$1.chartService);
      if (note.options.visible) {
        if (defined2(note.options.position)) {
          if (options2.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {
            note.options.position = options2.reverse ? LEFT : RIGHT;
          } else if (!options2.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {
            note.options.position = options2.reverse ? BOTTOM : TOP;
          }
        } else {
          if (options2.vertical) {
            note.options.position = options2.reverse ? LEFT : RIGHT;
          } else {
            note.options.position = options2.reverse ? BOTTOM : TOP;
          }
        }
        this$1.append(note);
        this$1.notes.push(note);
      }
    }
  };
  Axis2.prototype.parseNoteValue = function parseNoteValue(value) {
    return value;
  };
  Axis2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    this.createPlotBands();
  };
  Axis2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.createBackground();
    this.createLine();
  };
  Axis2.prototype.gridLinesVisual = function gridLinesVisual() {
    var gridLines = this._gridLines;
    if (!gridLines) {
      gridLines = this._gridLines = new drawing_exports.Group({
        zIndex: -2
      });
      this.appendVisual(this._gridLines);
    }
    return gridLines;
  };
  Axis2.prototype.createTicks = function createTicks(lineGroup) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var mirror = options2.labels.mirror;
    var majorUnit = options2.majorTicks.visible ? options2.majorUnit : 0;
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical: options2.vertical
    };
    function render(tickPositions, tickOptions, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, tickOptions.step);
      if (tickOptions.visible) {
        for (var i = tickOptions.skip; i < count; i += step) {
          if (defined2(skipUnit) && i % skipUnit === 0) {
            continue;
          }
          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
          tickLineOptions.position = tickPositions[i];
          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
        }
      }
    }
    render(this.getMajorTickPositions(), options2.majorTicks);
    render(this.getMinorTickPositions(), options2.minorTicks, majorUnit / options2.minorUnit);
  };
  Axis2.prototype.createLine = function createLine() {
    var options2 = this.options;
    var line = options2.line;
    var lineBox = this.lineBox();
    if (line.width > 0 && line.visible) {
      var path = new drawing_exports.Path({
        stroke: {
          width: line.width,
          color: line.color,
          dashType: line.dashType
        }
        /* TODO
        zIndex: line.zIndex,
        */
      });
      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      if (options2._alignLines) {
        alignPathToPixel(path);
      }
      var group = this._lineGroup = new drawing_exports.Group();
      group.append(path);
      this.visual.append(group);
      this.createTicks(group);
    }
  };
  Axis2.prototype.getActualTickSize = function getActualTickSize() {
    var options2 = this.options;
    var tickSize = 0;
    if (options2.majorTicks.visible && options2.minorTicks.visible) {
      tickSize = Math.max(options2.majorTicks.size, options2.minorTicks.size);
    } else if (options2.majorTicks.visible) {
      tickSize = options2.majorTicks.size;
    } else if (options2.minorTicks.visible) {
      tickSize = options2.minorTicks.size;
    }
    return tickSize;
  };
  Axis2.prototype.createBackground = function createBackground() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var background = options2.background;
    if (background) {
      this._backgroundPath = drawing_exports.Path.fromRect(box.toRect(), {
        fill: {
          color: background
        },
        stroke: null
      });
      this.visual.append(this._backgroundPath);
    }
  };
  Axis2.prototype.createPlotBands = function createPlotBands() {
    var this$1 = this;
    var options2 = this.options;
    var plotBands = options2.plotBands || [];
    var vertical = options2.vertical;
    var plotArea = this.plotArea;
    if (plotBands.length === 0) {
      return;
    }
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    var altAxis = grep(this.pane.axes, function(axis) {
      return axis.options.vertical !== this$1.options.vertical;
    })[0];
    for (var idx = 0; idx < plotBands.length; idx++) {
      var item = plotBands[idx];
      var slotX = void 0, slotY = void 0;
      var labelOptions = item.label;
      var label = void 0;
      if (vertical) {
        slotX = (altAxis || plotArea.axisX).lineBox();
        slotY = this$1.getSlot(item.from, item.to, true);
      } else {
        slotX = this$1.getSlot(item.from, item.to, true);
        slotY = (altAxis || plotArea.axisY).lineBox();
      }
      if (labelOptions) {
        labelOptions.vAlign = labelOptions.position || LEFT;
        label = this$1.createPlotBandLabel(
          labelOptions,
          item,
          new box_default(
            slotX.x1,
            slotY.y1,
            slotX.x2,
            slotY.y2
          )
        );
      }
      if (slotX.width() !== 0 && slotY.height() !== 0) {
        var bandRect = new geometry_exports.Rect(
          [slotX.x1, slotY.y1],
          [slotX.width(), slotY.height()]
        );
        var path = drawing_exports.Path.fromRect(bandRect, {
          fill: {
            color: item.color,
            opacity: item.opacity
          },
          stroke: null
        });
        group.append(path);
        if (label) {
          group.append(label);
        }
      }
    }
    this.appendVisual(group);
  };
  Axis2.prototype.createPlotBandLabel = function createPlotBandLabel(label, item, box) {
    if (label.visible === false) {
      return null;
    }
    var text = label.text;
    var textbox;
    if (defined2(label) && label.visible) {
      var labelTemplate = getTemplate(label);
      if (labelTemplate) {
        text = labelTemplate({ text, item });
      } else if (label.format) {
        text = this.chartService.format.auto(label.format, text);
      }
      if (!label.color) {
        label.color = this.options.labels.color;
      }
    }
    textbox = new text_box_default(text, label);
    textbox.reflow(box);
    textbox.renderVisual();
    return textbox.visual;
  };
  Axis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var minorUnit = options2.minorUnit;
    var vertical = options2.vertical;
    var axisLineVisible = altAxis.options.line.visible;
    var majorUnit = majorGridLines.visible ? options2.majorUnit : 0;
    var lineBox = altAxis.lineBox();
    var linePos = lineBox[vertical ? "y1" : "x1"];
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render(tickPositions, gridLine, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, gridLine.step);
      if (gridLine.visible) {
        for (var i = gridLine.skip; i < count; i += step) {
          var pos = round3(tickPositions[i]);
          if (!inArray(pos, majorTicks)) {
            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {
              lineOptions.position = pos;
              container.append(createAxisGridLine(lineOptions, gridLine));
              majorTicks.push(pos);
            }
          }
        }
      }
    }
    render(this.getMajorTickPositions(), majorGridLines);
    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);
    return container.children;
  };
  Axis2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var title2 = ref2.title;
    var vertical = options2.vertical;
    var count = labels.length;
    var sizeFn = vertical ? WIDTH : HEIGHT;
    var titleSize = title2 ? title2.box[sizeFn]() : 0;
    var space = this.getActualTickSize() + options2.margin + titleSize;
    var rootBox = (this.getRoot() || {}).box || box;
    var boxSize = rootBox[sizeFn]();
    var maxLabelSize = 0;
    for (var i = 0; i < count; i++) {
      var labelSize = labels[i].box[sizeFn]();
      if (labelSize + space <= boxSize) {
        maxLabelSize = Math.max(maxLabelSize, labelSize);
      }
    }
    if (vertical) {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x1 + maxLabelSize + space,
        box.y2
      );
    } else {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x2,
        box.y1 + maxLabelSize + space
      );
    }
    this.arrangeTitle();
    this.arrangeLabels();
    this.arrangeNotes();
  };
  Axis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getMajorTickPositions();
  };
  Axis2.prototype.labelTickIndex = function labelTickIndex(label) {
    return label.index;
  };
  Axis2.prototype.arrangeLabels = function arrangeLabels() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var tickPositions = this.getLabelsTickPositions();
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1.labelTickIndex(label);
      var labelSize = vertical ? label.box.height() : label.box.width();
      var firstTickPosition = tickPositions[tickIx];
      var nextTickPosition = tickPositions[tickIx + 1];
      var positionStart = void 0, positionEnd = void 0;
      if (vertical) {
        if (labelsBetweenTicks) {
          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
          positionStart = middle - labelSize / 2;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
        }
        positionEnd = positionStart;
      } else {
        if (labelsBetweenTicks) {
          positionStart = firstTickPosition;
          positionEnd = nextTickPosition;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
          positionEnd = positionStart + labelSize;
        }
      }
      this$1.positionLabel(label, mirror, positionStart, positionEnd);
    }
  };
  Axis2.prototype.positionLabel = function positionLabel(label, mirror, positionStart, positionEnd) {
    if (positionEnd === void 0)
      positionEnd = positionStart;
    var options2 = this.options;
    var vertical = options2.vertical;
    var lineBox = this.lineBox();
    var labelOffset = this.getActualTickSize() + options2.margin;
    var labelBox;
    if (vertical) {
      var labelX = lineBox.x2;
      if (mirror) {
        labelX += labelOffset;
        label.options.rotationOrigin = LEFT;
      } else {
        labelX -= labelOffset + label.box.width();
        label.options.rotationOrigin = RIGHT;
      }
      labelBox = label.box.move(labelX, positionStart);
    } else {
      var labelY = lineBox.y1;
      if (mirror) {
        labelY -= labelOffset + label.box.height();
        label.options.rotationOrigin = BOTTOM;
      } else {
        labelY += labelOffset;
        label.options.rotationOrigin = TOP;
      }
      labelBox = new box_default(
        positionStart,
        labelY,
        positionEnd,
        labelY + label.box.height()
      );
    }
    label.reflow(labelBox);
  };
  Axis2.prototype.autoRotateLabelAngle = function autoRotateLabelAngle(labelBox, slotWidth) {
    if (labelBox.width() < slotWidth) {
      return 0;
    }
    if (labelBox.height() > slotWidth) {
      return -90;
    }
    return -45;
  };
  Axis2.prototype.autoRotateLabels = function autoRotateLabels() {
    var this$1 = this;
    if (!this.options.autoRotateLabels || this.options.vertical) {
      return false;
    }
    var tickPositions = this.getMajorTickPositions();
    var labels = this.labels;
    var limit = Math.min(labels.length, tickPositions.length - 1);
    var angle = 0;
    for (var idx = 0; idx < limit; idx++) {
      var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);
      var labelBox = labels[idx].box;
      var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);
      if (labelAngle !== 0) {
        angle = labelAngle;
      }
      if (angle === -90) {
        break;
      }
    }
    if (angle !== 0) {
      for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {
        labels[idx$1].options.rotation = angle;
        labels[idx$1].reflow(new box_default());
      }
      return true;
    }
  };
  Axis2.prototype.arrangeTitle = function arrangeTitle() {
    var ref2 = this;
    var options2 = ref2.options;
    var title2 = ref2.title;
    var mirror = options2.labels.mirror;
    var vertical = options2.vertical;
    if (title2) {
      if (vertical) {
        title2.options.align = mirror ? RIGHT : LEFT;
        title2.options.vAlign = title2.options.position;
      } else {
        title2.options.align = title2.options.position;
        title2.options.vAlign = mirror ? TOP : BOTTOM;
      }
      title2.reflow(this.box);
    }
  };
  Axis2.prototype.arrangeNotes = function arrangeNotes() {
    var this$1 = this;
    for (var idx = 0; idx < this.notes.length; idx++) {
      var item = this$1.notes[idx];
      var value = item.options.value;
      var slot = void 0;
      if (defined2(value)) {
        if (this$1.shouldRenderNote(value)) {
          item.show();
        } else {
          item.hide();
        }
        slot = this$1.noteSlot(value);
      } else {
        item.hide();
      }
      item.reflow(slot || this$1.lineBox());
    }
  };
  Axis2.prototype.noteSlot = function noteSlot(value) {
    return this.getSlot(value);
  };
  Axis2.prototype.alignTo = function alignTo(secondAxis) {
    var lineBox = secondAxis.lineBox();
    var vertical = this.options.vertical;
    var pos = vertical ? Y : X;
    this.box.snapTo(lineBox, pos);
    if (vertical) {
      this.box.shrink(0, this.lineBox().height() - lineBox.height());
    } else {
      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);
    }
    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];
    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];
  };
  Axis2.prototype.axisLabelText = function axisLabelText(value, options2, context2) {
    var this$1 = this;
    var text;
    var tmpl = getTemplate(options2);
    var defaultText = function() {
      if (!options2.format) {
        return value;
      }
      return this$1.chartService.format.localeAuto(
        options2.format,
        [value],
        options2.culture
      );
    };
    if (tmpl) {
      var templateContext = Object.assign({}, context2, {
        get text() {
          return defaultText();
        },
        value,
        format: options2.format,
        culture: options2.culture
      });
      text = tmpl(templateContext);
    } else {
      text = defaultText();
    }
    return text;
  };
  Axis2.prototype.slot = function slot(from, to, limit) {
    var slot2 = this.getSlot(from, to, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  Axis2.prototype.contentBox = function contentBox() {
    var box = this.box.clone();
    var labels = this.labels;
    if (labels.length) {
      var axis = this.options.vertical ? Y : X;
      if (this.chartService.isPannable(axis)) {
        var offset3 = this.maxLabelOffset();
        box[axis + 1] -= offset3.start;
        box[axis + 2] += offset3.end;
      } else {
        if (labels[0].options.visible) {
          box.wrap(labels[0].box);
        }
        var lastLabel = labels[labels.length - 1];
        if (lastLabel.options.visible) {
          box.wrap(lastLabel.box);
        }
      }
    }
    return box;
  };
  Axis2.prototype.maxLabelOffset = function maxLabelOffset() {
    var this$1 = this;
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var tickPositions = this.getLabelsTickPositions();
    var offsetField = vertical ? Y : X;
    var labels = this.labels;
    var startPosition = reverse ? 1 : 0;
    var endPosition = reverse ? 0 : 1;
    var maxStartOffset = 0;
    var maxEndOffset = 0;
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1.labelTickIndex(label);
      var startTick = void 0, endTick = void 0;
      if (labelsBetweenTicks) {
        startTick = tickPositions[tickIx + startPosition];
        endTick = tickPositions[tickIx + endPosition];
      } else {
        startTick = endTick = tickPositions[tickIx];
      }
      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);
      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);
    }
    return {
      start: maxStartOffset,
      end: maxEndOffset
    };
  };
  Axis2.prototype.limitRange = function limitRange(from, to, min3, max2, offset3) {
    var options2 = this.options;
    if (from < min3 && offset3 < 0 && (!defined2(options2.min) || options2.min <= min3) || max2 < to && offset3 > 0 && (!defined2(options2.max) || max2 <= options2.max)) {
      return null;
    }
    if (to < min3 && offset3 > 0 || max2 < from && offset3 < 0) {
      return {
        min: from,
        max: to
      };
    }
    var rangeSize = to - from;
    var minValue = from;
    var maxValue = to;
    if (from < min3 && offset3 < 0) {
      minValue = limitValue2(from, min3, max2);
      maxValue = limitValue2(from + rangeSize, min3 + rangeSize, max2);
    } else if (to > max2 && offset3 > 0) {
      maxValue = limitValue2(to, min3, max2);
      minValue = limitValue2(to - rangeSize, min3, max2 - rangeSize);
    }
    return {
      min: minValue,
      max: maxValue
    };
  };
  Axis2.prototype.valueRange = function valueRange3() {
    return {
      min: this.seriesMin,
      max: this.seriesMax
    };
  };
  Axis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    return (vertical ? -1 : 1) * (reverse ? -1 : 1);
  };
  Axis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y : X;
    var axisDir = this.lineDir();
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  Axis2.prototype.pointOffset = function pointOffset(point2) {
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var relative = axisDir > 0 ? point2[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point2[axis];
    var offset3 = relative / lineSize;
    return offset3;
  };
  Axis2.prototype.scaleToDelta = function scaleToDelta(rawScale, range) {
    var MAX_SCALE = 0.999;
    var scale = limitValue2(rawScale, -MAX_SCALE, MAX_SCALE);
    var delta;
    if (scale > 0) {
      delta = range * Math.min(1, scale);
    } else {
      delta = range - range / (1 + scale);
    }
    return delta;
  };
  Axis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.options.justified;
  };
  Axis2.prototype.prepareUserOptions = function prepareUserOptions() {
  };
  return Axis2;
}(chart_element_default);
setDefaultOptions(Axis, {
  labels: {
    visible: true,
    rotation: 0,
    mirror: false,
    step: 1,
    skip: 0
  },
  line: {
    width: 1,
    color: BLACK,
    visible: true
  },
  title: {
    visible: true,
    position: CENTER
  },
  majorTicks: {
    align: OUTSIDE,
    size: 4,
    skip: 0,
    step: 1
  },
  minorTicks: {
    align: OUTSIDE,
    size: 3,
    skip: 0,
    step: 1
  },
  axisCrossingValue: 0,
  majorTickType: OUTSIDE,
  minorTickType: NONE,
  majorGridLines: {
    skip: 0,
    step: 1
  },
  minorGridLines: {
    visible: false,
    width: 1,
    color: BLACK,
    skip: 0,
    step: 1
  },
  // TODO: Move to line or labels options
  margin: 5,
  visible: true,
  reverse: false,
  justified: true,
  notes: {
    label: {
      text: ""
    }
  },
  _alignLines: true,
  _deferLabels: false
});
var axis_default = Axis;

// node_modules/@progress/kendo-charts/dist/es/date-utils/constants.js
var MILLISECONDS = "milliseconds";
var SECONDS = "seconds";
var MINUTES = "minutes";
var HOURS = "hours";
var DAYS = "days";
var WEEKS = "weeks";
var MONTHS = "months";
var YEARS = "years";
var TIME_PER_MILLISECOND = 1;
var TIME_PER_SECOND = 1e3;
var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;
var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;
var TIME_PER_DAY = 24 * TIME_PER_HOUR;
var TIME_PER_WEEK = 7 * TIME_PER_DAY;
var TIME_PER_MONTH = 31 * TIME_PER_DAY;
var TIME_PER_YEAR = 365 * TIME_PER_DAY;
var TIME_PER_UNIT = {
  "years": TIME_PER_YEAR,
  "months": TIME_PER_MONTH,
  "weeks": TIME_PER_WEEK,
  "days": TIME_PER_DAY,
  "hours": TIME_PER_HOUR,
  "minutes": TIME_PER_MINUTE,
  "seconds": TIME_PER_SECOND,
  "milliseconds": TIME_PER_MILLISECOND
};

// node_modules/@progress/kendo-charts/dist/es/date-utils/absolute-date-diff.js
function absoluteDateDiff(a, b) {
  var diff = a.getTime() - b;
  var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();
  return diff - offsetDiff * TIME_PER_MINUTE;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-ticks.js
function addTicks(date, ticks) {
  return new Date(date.getTime() + ticks);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-date.js
function toDate(value) {
  var result;
  if (value instanceof Date) {
    result = value;
  } else if (value) {
    result = new Date(value);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/start-of-week.js
function startOfWeek(date, weekStartDay) {
  if (weekStartDay === void 0)
    weekStartDay = 0;
  var daysToSubtract = 0;
  var day = date.getDay();
  if (!isNaN(day)) {
    while (day !== weekStartDay) {
      if (day === 0) {
        day = 6;
      } else {
        day--;
      }
      daysToSubtract++;
    }
  }
  return addTicks(date, -daysToSubtract * TIME_PER_DAY);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-duration.js
function adjustDST2(date, hours) {
  if (hours === 0 && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
    return true;
  }
  return false;
}
function addHours(date, hours) {
  var roundedDate = new Date(date);
  roundedDate.setMinutes(0, 0, 0);
  var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;
  return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);
}
function addDuration(dateValue, value, unit, weekStartDay) {
  var result = dateValue;
  if (dateValue) {
    var date = toDate(dateValue);
    var hours = date.getHours();
    if (unit === YEARS) {
      result = new Date(date.getFullYear() + value, 0, 1);
      adjustDST2(result, 0);
    } else if (unit === MONTHS) {
      result = new Date(date.getFullYear(), date.getMonth() + value, 1);
      adjustDST2(result, hours);
    } else if (unit === WEEKS) {
      result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);
      adjustDST2(result, hours);
    } else if (unit === DAYS) {
      result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);
      adjustDST2(result, hours);
    } else if (unit === HOURS) {
      result = addHours(date, value);
    } else if (unit === MINUTES) {
      result = addTicks(date, value * TIME_PER_MINUTE);
      if (result.getSeconds() > 0) {
        result.setSeconds(0);
      }
    } else if (unit === SECONDS) {
      result = addTicks(date, value * TIME_PER_SECOND);
    } else if (unit === MILLISECONDS) {
      result = addTicks(date, value);
    }
    if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {
      result.setMilliseconds(0);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/floor-date.js
function floorDate(date, unit, weekStartDay) {
  return addDuration(toDate(date), 0, unit, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/ceil-date.js
function ceilDate(dateValue, unit, weekStartDay) {
  var date = toDate(dateValue);
  if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {
    return date;
  }
  return addDuration(date, 1, unit, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-comparer.js
function dateComparer(a, b) {
  if (a && b) {
    return a.getTime() - b.getTime();
  }
  return -1;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-diff.js
function dateDiff(a, b) {
  return a.getTime() - b;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-time.js
function toTime(value) {
  if (isArray(value)) {
    var result = [];
    for (var idx = 0; idx < value.length; idx++) {
      result.push(toTime(value[idx]));
    }
    return result;
  } else if (value) {
    return toDate(value).getTime();
  }
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-equals.js
function dateEquals(a, b) {
  if (a && b) {
    return toTime(a) === toTime(b);
  }
  return a === b;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-index.js
function timeIndex(date, start, baseUnit) {
  return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];
}
function dateIndex(value, start, baseUnit, baseUnitStep) {
  var date = toDate(value);
  var startDate = toDate(start);
  var index;
  if (baseUnit === MONTHS) {
    index = date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12 + timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  } else if (baseUnit === YEARS) {
    index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;
  } else if (baseUnit === DAYS || baseUnit === WEEKS) {
    index = timeIndex(date, startDate, baseUnit);
  } else {
    index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];
  }
  return index / baseUnitStep;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/duration.js
function duration(a, b, unit) {
  var diff;
  if (unit === YEARS) {
    diff = b.getFullYear() - a.getFullYear();
  } else if (unit === MONTHS) {
    diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();
  } else if (unit === DAYS) {
    diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);
  } else {
    diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);
  }
  return diff;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-date.js
function parseDate3(intlService, date) {
  var result;
  if (isString2(date)) {
    result = intlService.parseDate(date) || toDate(date);
  } else {
    result = toDate(date);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-dates.js
function parseDates(intlService, dates) {
  if (isArray(dates)) {
    var result = [];
    for (var idx = 0; idx < dates.length; idx++) {
      result.push(parseDate3(intlService, dates[idx]));
    }
    return result;
  }
  return parseDate3(intlService, dates);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/first-day.js
function firstDay2(options2, intlService) {
  if (isNumber2(options2.weekStartDay)) {
    return options2.weekStartDay;
  }
  if (intlService && intlService.firstDay) {
    return intlService.firstDay();
  }
  return 0;
}

// node_modules/@progress/kendo-charts/dist/es/core/category-axis.js
var MIN_CATEGORY_POINTS_RANGE = 0.01;
var MIN_CATEGORY_RANGE = 0.1;
function indexOf(value, arr) {
  if (value instanceof Date) {
    var length = arr.length;
    for (var idx = 0; idx < length; idx++) {
      if (dateEquals(arr[idx], value)) {
        return idx;
      }
    }
    return -1;
  }
  return arr.indexOf(value);
}
var CategoryAxis = function(Axis2) {
  function CategoryAxis2() {
    Axis2.apply(this, arguments);
  }
  if (Axis2)
    CategoryAxis2.__proto__ = Axis2;
  CategoryAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  CategoryAxis2.prototype.constructor = CategoryAxis2;
  CategoryAxis2.prototype.initFields = function initFields() {
    this._ticks = {};
  };
  CategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    return "";
  };
  CategoryAxis2.prototype.clone = function clone2() {
    var copy = new CategoryAxis2(Object.assign({}, this.options, {
      categories: this.options.srcCategories
    }), this.chartService);
    copy.createLabels();
    return copy;
  };
  CategoryAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    var categories = options2.categories || [];
    var definedMin = defined2(options2.min);
    var definedMax = defined2(options2.max);
    options2.srcCategories = options2.categories = categories;
    if ((definedMin || definedMax) && categories.length) {
      var min3 = definedMin ? Math.floor(options2.min) : 0;
      var max2;
      if (definedMax) {
        max2 = options2.justified ? Math.floor(options2.max) + 1 : Math.ceil(options2.max);
      } else {
        max2 = categories.length;
      }
      options2.categories = options2.categories.slice(min3, max2);
    }
    return options2;
  };
  CategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    var options2 = this.options;
    var length = options2.categories.length || 1;
    var min3 = isNumber2(options2.min) ? options2.min % 1 : 0;
    var max2;
    if (isNumber2(options2.max) && options2.max % 1 !== 0 && options2.max < this.totalRange().max) {
      max2 = length - (1 - options2.max % 1);
    } else {
      max2 = length - (options2.justified ? 1 : 0);
    }
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.totalRangeIndices = function totalRangeIndices(limit) {
    var options2 = this.options;
    var min3 = isNumber2(options2.min) ? options2.min : 0;
    var max2;
    if (isNumber2(options2.max)) {
      max2 = options2.max;
    } else if (isNumber2(options2.min)) {
      max2 = min3 + options2.categories.length;
    } else {
      max2 = this.totalRange().max || 1;
    }
    if (limit) {
      var totalRange = this.totalRange();
      min3 = limitValue2(min3, 0, totalRange.max);
      max2 = limitValue2(max2, 0, totalRange.max);
    }
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.range = function range() {
    var options2 = this.options;
    var min3 = isNumber2(options2.min) ? options2.min : 0;
    var max2 = isNumber2(options2.max) ? options2.max : this.totalRange().max;
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.roundedRange = function roundedRange() {
    return this.range();
  };
  CategoryAxis2.prototype.totalRange = function totalRange() {
    var options2 = this.options;
    return { min: 0, max: Math.max(this._seriesMax || 0, options2.srcCategories.length) - (options2.justified ? 1 : 0) };
  };
  CategoryAxis2.prototype.scaleOptions = function scaleOptions() {
    var ref2 = this.rangeIndices();
    var min3 = ref2.min;
    var max2 = ref2.max;
    var lineBox = this.lineBox();
    var size = this.options.vertical ? lineBox.height() : lineBox.width();
    var scale = size / (max2 - min3 || 1);
    return {
      scale: scale * (this.options.reverse ? -1 : 1),
      box: lineBox,
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    Axis2.prototype.arrangeLabels.call(this);
    this.hideOutOfRangeLabels();
  };
  CategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    var ref2 = this;
    var box = ref2.box;
    var labels = ref2.labels;
    if (labels.length > 0) {
      var valueAxis = this.options.vertical ? Y : X;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      var firstLabel = labels[0];
      var lastLabel = last2(labels);
      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {
        firstLabel.options.visible = false;
      }
      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {
        lastLabel.options.visible = false;
      }
    }
  };
  CategoryAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTicks().majorTicks;
  };
  CategoryAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTicks().minorTicks;
  };
  CategoryAxis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getTicks().labelTicks;
  };
  CategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this.rangeIndices();
    var min3 = ref2.min;
    var max2 = ref2.max;
    var limit = Math.ceil(max2);
    var current4 = Math.floor(min3);
    var indices = [];
    while (current4 <= limit) {
      indices.push(current4);
      current4 += stepSize;
    }
    return indices;
  };
  CategoryAxis2.prototype.getTickPositions = function getTickPositions(stepSize) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min3 = ref$1.min;
    var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];
    var indices = this.tickIndices(stepSize);
    var positions = [];
    for (var idx = 0; idx < indices.length; idx++) {
      positions.push(pos + round3(scale * (indices[idx] - min3), COORD_PRECISION));
    }
    return positions;
  };
  CategoryAxis2.prototype.getTicks = function getTicks() {
    var options2 = this.options;
    var cache2 = this._ticks;
    var range = this.rangeIndices();
    var lineBox = this.lineBox();
    var hash = lineBox.getHash() + range.min + "," + range.max + options2.reverse + options2.justified;
    if (cache2._hash !== hash) {
      var hasMinor = options2.minorTicks.visible || options2.minorGridLines.visible;
      cache2._hash = hash;
      cache2.labelTicks = this.getTickPositions(1);
      cache2.majorTicks = this.filterOutOfRangePositions(cache2.labelTicks, lineBox);
      cache2.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];
    }
    return cache2;
  };
  CategoryAxis2.prototype.filterOutOfRangePositions = function filterOutOfRangePositions(positions, lineBox) {
    if (!positions.length) {
      return positions;
    }
    var axis = this.options.vertical ? Y : X;
    var inRange = function(position3) {
      return lineBox[axis + 1] <= position3 && position3 <= lineBox[axis + 2];
    };
    var end = positions.length - 1;
    var startIndex = 0;
    while (!inRange(positions[startIndex]) && startIndex <= end) {
      startIndex++;
    }
    var endIndex = end;
    while (!inRange(positions[endIndex]) && endIndex >= 0) {
      endIndex--;
    }
    return positions.slice(startIndex, endIndex + 1);
  };
  CategoryAxis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y : X;
    var axisDir = reverse ? -1 : 1;
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  CategoryAxis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    return reverse ? -1 : 1;
  };
  CategoryAxis2.prototype.getSlot = function getSlot(from, to, limit) {
    var options2 = this.options;
    var reverse = options2.reverse;
    var justified = options2.justified;
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var box = ref2.box;
    var min3 = ref2.min;
    var ref$1 = this.lineInfo();
    var valueAxis = ref$1.axis;
    var lineStart = ref$1.lineStart;
    var slotBox = box.clone();
    var singleSlot = !defined2(to);
    var start = valueOrDefault2(from, 0);
    var end = valueOrDefault2(to, start);
    end = Math.max(end - 1, start);
    end = Math.max(start, end);
    var p1 = lineStart + (start - min3) * scale;
    var p2 = lineStart + (end + 1 - min3) * scale;
    if (singleSlot && justified) {
      p2 = p1;
    }
    if (limit) {
      p1 = limitValue2(p1, box[valueAxis + 1], box[valueAxis + 2]);
      p2 = limitValue2(p2, box[valueAxis + 1], box[valueAxis + 2]);
    }
    slotBox[valueAxis + 1] = reverse ? p2 : p1;
    slotBox[valueAxis + 2] = reverse ? p1 : p2;
    return slotBox;
  };
  CategoryAxis2.prototype.limitSlot = function limitSlot(slot) {
    var vertical = this.options.vertical;
    var valueAxis = vertical ? Y : X;
    var lineBox = this.lineBox();
    var limittedSlot = slot.clone();
    limittedSlot[valueAxis + 1] = limitValue2(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    limittedSlot[valueAxis + 2] = limitValue2(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    return limittedSlot;
  };
  CategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var min3 = Math.floor(this.options.min || 0);
    var start = from;
    var end = to;
    if (typeof start === "string") {
      start = this.categoryIndex(start);
    } else if (isNumber2(start)) {
      start -= min3;
    }
    if (typeof end === "string") {
      end = this.categoryIndex(end);
    } else if (isNumber2(end)) {
      end -= min3;
    }
    return Axis2.prototype.slot.call(this, start, end, limit);
  };
  CategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point2) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y : X;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min3 = ref$1.min;
    var max2 = ref$1.max;
    var startValue = reverse ? max2 : min3;
    var lineStart = box[valueAxis + 1];
    var lineEnd = box[valueAxis + 2];
    var pos = point2[valueAxis];
    if (pos < lineStart || pos > lineEnd) {
      return null;
    }
    var value = startValue + (pos - lineStart) / scale;
    var diff = value % 1;
    if (justified) {
      value = Math.round(value);
    } else if (diff === 0 && value > 0) {
      value--;
    }
    return Math.floor(value);
  };
  CategoryAxis2.prototype.getCategory = function getCategory(point2) {
    var index = this.pointCategoryIndex(point2);
    if (index === null) {
      return null;
    }
    return this.options.categories[index];
  };
  CategoryAxis2.prototype.categoryIndex = function categoryIndex(value) {
    return this.totalIndex(value) - Math.floor(this.options.min || 0);
  };
  CategoryAxis2.prototype.categoryAt = function categoryAt(index, total3) {
    var options2 = this.options;
    return (total3 ? options2.srcCategories : options2.categories)[index];
  };
  CategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return (this.options.categories || []).length;
  };
  CategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var size = options2.vertical ? lineBox.height() : lineBox.width();
    var range = options2.categories.length;
    var scale = size / range;
    var offset3 = round3(delta / scale, DEFAULT_PRECISION);
    return {
      min: offset3,
      max: range + offset3
    };
  };
  CategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position3 = Math.abs(this.pointOffset(cursor));
    var rangeIndices = this.totalRangeIndices();
    var range = rangeIndices.max - rangeIndices.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position3 * delta;
    var maxDelta = (1 - position3) * delta;
    var min3 = rangeIndices.min + minDelta;
    var max2 = rangeIndices.max - maxDelta;
    if (max2 - min3 < MIN_CATEGORY_RANGE) {
      max2 = min3 + MIN_CATEGORY_RANGE;
    }
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this.totalRange();
    var totalMin = ref2.min;
    var totalMax = ref2.max;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue2(range.min, totalMin, totalMax),
      max: limitValue2(range.max, totalMin, totalMax)
    };
  };
  CategoryAxis2.prototype.labelsCount = function labelsCount() {
    var labelsRange = this.labelsRange();
    return labelsRange.max - labelsRange.min;
  };
  CategoryAxis2.prototype.labelsRange = function labelsRange() {
    var options2 = this.options;
    var justified = options2.justified;
    var labelOptions = options2.labels;
    var ref2 = this.totalRangeIndices(true);
    var min3 = ref2.min;
    var max2 = ref2.max;
    var start = Math.floor(min3);
    if (!justified) {
      min3 = Math.floor(min3);
      max2 = Math.ceil(max2);
    } else {
      min3 = Math.ceil(min3);
      max2 = Math.floor(max2);
    }
    var skip;
    if (min3 > labelOptions.skip) {
      skip = labelOptions.skip + labelOptions.step * Math.ceil((min3 - labelOptions.skip) / labelOptions.step);
    } else {
      skip = labelOptions.skip;
    }
    return {
      min: skip - start,
      max: (options2.categories.length ? max2 + (justified ? 1 : 0) : 0) - start
    };
  };
  CategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options2 = this.options;
    var dataItem = options2.dataItems ? options2.dataItems[index] : null;
    var category = valueOrDefault2(options2.categories[index], "");
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(category, labelOptions, labelContext);
    return new axis_label_default(category, text, index, dataItem, labelOptions);
  };
  CategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.totalRangeIndices();
    return Math.floor(range.min) <= value && value <= Math.ceil(range.max);
  };
  CategoryAxis2.prototype.noteSlot = function noteSlot(value) {
    var options2 = this.options;
    var index = value - Math.floor(options2.min || 0);
    return this.getSlot(index);
  };
  CategoryAxis2.prototype.arrangeNotes = function arrangeNotes() {
    Axis2.prototype.arrangeNotes.call(this);
    this.hideOutOfRangeNotes();
  };
  CategoryAxis2.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes() {
    var ref2 = this;
    var notes2 = ref2.notes;
    var box = ref2.box;
    if (notes2 && notes2.length) {
      var valueAxis = this.options.vertical ? Y : X;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      for (var idx = 0; idx < notes2.length; idx++) {
        var note = notes2[idx];
        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {
          note.hide();
        }
      }
    }
  };
  CategoryAxis2.prototype.pan = function pan(delta) {
    var range = this.totalRangeIndices(true);
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var offset3 = round3(delta / scale, DEFAULT_PRECISION);
    var totalRange = this.totalRange();
    var min3 = range.min + offset3;
    var max2 = range.max + offset3;
    return this.limitRange(min3, max2, 0, totalRange.max, offset3);
  };
  CategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y : X;
    var range = this.totalRangeIndices(true);
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var lineStart = box[valueAxis + (reverse ? 2 : 1)];
    var diffStart = start[valueAxis] - lineStart;
    var diffEnd = end[valueAxis] - lineStart;
    var min3 = range.min + diffStart / scale;
    var max2 = range.min + diffEnd / scale;
    var rangeMin = Math.min(min3, max2);
    var rangeMax = Math.max(min3, max2);
    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {
      return {
        min: rangeMin,
        max: rangeMax
      };
    }
  };
  CategoryAxis2.prototype.valueRange = function valueRange3() {
    return this.range();
  };
  CategoryAxis2.prototype.totalIndex = function totalIndex3(value) {
    var options2 = this.options;
    var index = this._categoriesMap ? this._categoriesMap.get(value) : indexOf(value, options2.srcCategories);
    return index;
  };
  CategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var options2 = this.options;
    var min3 = 0;
    if (isNumber2(options2.min)) {
      min3 = Math.floor(options2.min);
    }
    var max2;
    if (isNumber2(options2.max)) {
      max2 = options2.justified ? Math.floor(options2.max) : Math.ceil(options2.max) - 1;
    } else {
      max2 = this.totalCount() - 1;
    }
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.mapCategories = function mapCategories() {
    if (!this._categoriesMap) {
      var map2 = this._categoriesMap = new hash_map_default();
      var srcCategories = this.options.srcCategories;
      for (var idx = 0; idx < srcCategories.length; idx++) {
        map2.set(srcCategories[idx], idx);
      }
    }
  };
  CategoryAxis2.prototype.totalCount = function totalCount3() {
    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);
  };
  return CategoryAxis2;
}(axis_default);
setDefaultOptions(CategoryAxis, {
  type: "category",
  vertical: false,
  majorGridLines: {
    visible: false,
    width: 1,
    color: BLACK
  },
  labels: {
    zIndex: 1
  },
  justified: false,
  _deferLabels: true
});
var category_axis_default = CategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/constants.js
var COORDINATE_LIMIT = 3e5;
var DateLabelFormats = {
  milliseconds: "HH:mm:ss.fff",
  seconds: "HH:mm:ss",
  minutes: "HH:mm",
  hours: "HH:mm",
  days: "M/d",
  weeks: "M/d",
  months: "MMM 'yy",
  years: "yyyy"
};
var ZERO_THRESHOLD = 0.2;

// node_modules/@progress/kendo-charts/dist/es/core/date-category-axis.js
var AUTO = "auto";
var BASE_UNITS = [
  MILLISECONDS,
  SECONDS,
  MINUTES,
  HOURS,
  DAYS,
  WEEKS,
  MONTHS,
  YEARS
];
var FIT = "fit";
function categoryRange(categories) {
  var range = categories._range;
  if (!range) {
    range = categories._range = sparseArrayLimits(categories);
    range.min = toDate(range.min);
    range.max = toDate(range.max);
  }
  return range;
}
var EmptyDateRange = function EmptyDateRange2(options2) {
  this.options = options2;
};
EmptyDateRange.prototype.displayIndices = function displayIndices() {
  return {
    min: 0,
    max: 1
  };
};
EmptyDateRange.prototype.displayRange = function displayRange() {
  return {};
};
EmptyDateRange.prototype.total = function total() {
  return {};
};
EmptyDateRange.prototype.valueRange = function valueRange() {
  return {};
};
EmptyDateRange.prototype.valueIndex = function valueIndex() {
  return -1;
};
EmptyDateRange.prototype.values = function values3() {
  return [];
};
EmptyDateRange.prototype.totalIndex = function totalIndex() {
  return -1;
};
EmptyDateRange.prototype.valuesCount = function valuesCount() {
  return 0;
};
EmptyDateRange.prototype.totalCount = function totalCount() {
  return 0;
};
EmptyDateRange.prototype.dateAt = function dateAt() {
  return null;
};
var DateRange = function DateRange2(start, end, options2) {
  this.options = options2;
  options2.baseUnitStep = options2.baseUnitStep || 1;
  var roundToBaseUnit = options2.roundToBaseUnit;
  var justified = options2.justified;
  this.start = addDuration(start, 0, options2.baseUnit, options2.weekStartDay);
  var lowerEnd = this.roundToTotalStep(end);
  var expandEnd = !justified && dateEquals(end, lowerEnd) && !options2.justifyEnd;
  this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);
  var min3 = options2.min || start;
  this.valueStart = this.roundToTotalStep(min3);
  this.displayStart = roundToBaseUnit ? this.valueStart : min3;
  var max2 = options2.max;
  if (!max2) {
    this.valueEnd = lowerEnd;
    this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;
  } else {
    var next = !justified && dateEquals(max2, this.roundToTotalStep(max2)) ? -1 : 0;
    this.valueEnd = this.roundToTotalStep(max2, false, next);
    this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max2, !justified) : options2.max;
  }
  if (this.valueEnd < this.valueStart) {
    this.valueEnd = this.valueStart;
  }
  if (this.displayEnd <= this.displayStart) {
    this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);
  }
};
DateRange.prototype.displayRange = function displayRange2() {
  return {
    min: this.displayStart,
    max: this.displayEnd
  };
};
DateRange.prototype.displayIndices = function displayIndices2() {
  if (!this._indices) {
    var options2 = this.options;
    var baseUnit = options2.baseUnit;
    var baseUnitStep = options2.baseUnitStep;
    var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);
    var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);
    this._indices = { min: minIdx, max: maxIdx };
  }
  return this._indices;
};
DateRange.prototype.total = function total2() {
  return {
    min: this.start,
    max: this.end
  };
};
DateRange.prototype.totalCount = function totalCount2() {
  var last3 = this.totalIndex(this.end);
  return last3 + (this.options.justified ? 1 : 0);
};
DateRange.prototype.valueRange = function valueRange2() {
  return {
    min: this.valueStart,
    max: this.valueEnd
  };
};
DateRange.prototype.valueIndex = function valueIndex2(value) {
  var options2 = this.options;
  return Math.floor(dateIndex(value, this.valueStart, options2.baseUnit, options2.baseUnitStep));
};
DateRange.prototype.totalIndex = function totalIndex2(value) {
  var options2 = this.options;
  return Math.floor(dateIndex(value, this.start, options2.baseUnit, options2.baseUnitStep));
};
DateRange.prototype.dateIndex = function dateIndex$1(value) {
  var options2 = this.options;
  return dateIndex(value, this.valueStart, options2.baseUnit, options2.baseUnitStep);
};
DateRange.prototype.valuesCount = function valuesCount2() {
  var maxIdx = this.valueIndex(this.valueEnd);
  return maxIdx + 1;
};
DateRange.prototype.values = function values4() {
  var values5 = this._values;
  if (!values5) {
    var options2 = this.options;
    var range = this.valueRange();
    this._values = values5 = [];
    for (var date = range.min; date <= range.max; ) {
      values5.push(date);
      date = addDuration(date, options2.baseUnitStep, options2.baseUnit, options2.weekStartDay);
    }
  }
  return values5;
};
DateRange.prototype.dateAt = function dateAt2(index, total3) {
  var options2 = this.options;
  return addDuration(total3 ? this.start : this.valueStart, options2.baseUnitStep * index, options2.baseUnit, options2.weekStartDay);
};
DateRange.prototype.roundToTotalStep = function roundToTotalStep(value, upper, next) {
  var ref2 = this.options;
  var baseUnit = ref2.baseUnit;
  var baseUnitStep = ref2.baseUnitStep;
  var weekStartDay = ref2.weekStartDay;
  var start = this.start;
  var step = dateIndex(value, start, baseUnit, baseUnitStep);
  var roundedStep = upper ? Math.ceil(step) : Math.floor(step);
  if (next) {
    roundedStep += next;
  }
  return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);
};
function autoBaseUnit(options2, startUnit, startStep) {
  var categoryLimits = categoryRange(options2.categories);
  var span = (options2.max || categoryLimits.max) - (options2.min || categoryLimits.min);
  var autoBaseUnitSteps = options2.autoBaseUnitSteps;
  var maxDateGroups = options2.maxDateGroups;
  var autoUnit = options2.baseUnit === FIT;
  var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;
  var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options2.baseUnit;
  var units = span / TIME_PER_UNIT[baseUnit];
  var totalUnits = units;
  var unitSteps, step, nextStep;
  while (!step || units >= maxDateGroups) {
    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);
    do {
      nextStep = unitSteps.shift();
    } while (nextStep && startUnit === baseUnit && nextStep < startStep);
    if (nextStep) {
      step = nextStep;
      units = totalUnits / step;
    } else if (baseUnit === last2(BASE_UNITS)) {
      step = Math.ceil(totalUnits / maxDateGroups);
      break;
    } else if (autoUnit) {
      baseUnit = BASE_UNITS[autoUnitIx++] || last2(BASE_UNITS);
      totalUnits = span / TIME_PER_UNIT[baseUnit];
      unitSteps = null;
    } else {
      if (units > maxDateGroups) {
        step = Math.ceil(totalUnits / maxDateGroups);
      }
      break;
    }
  }
  options2.baseUnitStep = step;
  options2.baseUnit = baseUnit;
}
function defaultBaseUnit(options2) {
  var categories = options2.categories;
  var count = defined2(categories) ? categories.length : 0;
  var minDiff = MAX_VALUE;
  var lastCategory, unit;
  for (var categoryIx = 0; categoryIx < count; categoryIx++) {
    var category = categories[categoryIx];
    if (category && lastCategory) {
      var diff = absoluteDateDiff(category, lastCategory);
      if (diff > 0) {
        minDiff = Math.min(minDiff, diff);
        if (minDiff >= TIME_PER_YEAR) {
          unit = YEARS;
        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {
          unit = MONTHS;
        } else if (minDiff >= TIME_PER_WEEK) {
          unit = WEEKS;
        } else if (minDiff >= TIME_PER_DAY) {
          unit = DAYS;
        } else if (minDiff >= TIME_PER_HOUR) {
          unit = HOURS;
        } else if (minDiff >= TIME_PER_MINUTE) {
          unit = MINUTES;
        } else {
          unit = SECONDS;
        }
      }
    }
    lastCategory = category;
  }
  options2.baseUnit = unit || DAYS;
}
function initUnit(options2) {
  var baseUnit = (options2.baseUnit || "").toLowerCase();
  var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);
  if (useDefault) {
    defaultBaseUnit(options2);
  }
  if (baseUnit === FIT || options2.baseUnitStep === AUTO) {
    autoBaseUnit(options2);
  }
  return options2;
}
var DateCategoryAxis = function(CategoryAxis2) {
  function DateCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2)
    DateCategoryAxis2.__proto__ = CategoryAxis2;
  DateCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  DateCategoryAxis2.prototype.constructor = DateCategoryAxis2;
  DateCategoryAxis2.prototype.clone = function clone2() {
    var copy = new DateCategoryAxis2(Object.assign({}, this.options), this.chartService);
    copy.createLabels();
    return copy;
  };
  DateCategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    var start = this.dataRange.total().min;
    return this.options.baseUnit + this.options.baseUnitStep + start;
  };
  DateCategoryAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    return options2;
  };
  DateCategoryAxis2.prototype.initFields = function initFields() {
    CategoryAxis2.prototype.initFields.call(this);
    var chartService = this.chartService;
    var intlService = chartService.intl;
    var options2 = this.options;
    var categories = options2.categories || [];
    if (!categories._parsed) {
      categories = parseDates(intlService, categories);
      categories._parsed = true;
    }
    options2 = deepExtend({
      roundToBaseUnit: true
    }, options2, {
      categories,
      min: parseDate3(intlService, options2.min),
      max: parseDate3(intlService, options2.max),
      weekStartDay: firstDay2(options2, intlService)
    });
    if (chartService.panning && chartService.isPannable(options2.vertical ? Y : X)) {
      options2.roundToBaseUnit = false;
    }
    options2.userSetBaseUnit = options2.userSetBaseUnit || options2.baseUnit;
    options2.userSetBaseUnitStep = options2.userSetBaseUnitStep || options2.baseUnitStep;
    this.options = options2;
    options2.srcCategories = categories;
    if (categories.length > 0) {
      var range = categoryRange(categories);
      var maxDivisions = options2.maxDivisions;
      this.dataRange = new DateRange(range.min, range.max, initUnit(options2));
      if (maxDivisions) {
        var dataRange = this.dataRange.displayRange();
        var divisionOptions = Object.assign({}, options2, {
          justified: true,
          roundToBaseUnit: false,
          baseUnit: "fit",
          min: dataRange.min,
          max: dataRange.max,
          maxDateGroups: maxDivisions
        });
        var dataRangeOptions = this.dataRange.options;
        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);
        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);
      } else {
        this.divisionRange = this.dataRange;
      }
    } else {
      options2.baseUnit = options2.baseUnit || DAYS;
      this.dataRange = this.divisionRange = new EmptyDateRange(options2);
    }
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this;
    var dataRange = ref2.dataRange;
    var divisionRange = ref2.divisionRange;
    var valuesCount3 = divisionRange.valuesCount();
    if (!this.options.maxDivisions || !valuesCount3) {
      return CategoryAxis2.prototype.tickIndices.call(this, stepSize);
    }
    var indices = [];
    var values5 = divisionRange.values();
    var offset3 = 0;
    if (!this.options.justified) {
      values5 = values5.concat(divisionRange.dateAt(valuesCount3));
      offset3 = 0.5;
    }
    for (var idx = 0; idx < values5.length; idx++) {
      indices.push(dataRange.dateIndex(values5[idx]) + offset3);
      if (stepSize !== 1 && idx >= 1) {
        var last3 = indices.length - 1;
        indices.splice(idx, 0, indices[last3 - 1] + (indices[last3] - indices[last3 - 1]) * stepSize);
      }
    }
    return indices;
  };
  DateCategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.range();
    var categories = this.options.categories || [];
    return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;
  };
  DateCategoryAxis2.prototype.parseNoteValue = function parseNoteValue(value) {
    return parseDate3(this.chartService.intl, value);
  };
  DateCategoryAxis2.prototype.noteSlot = function noteSlot(value) {
    return this.getSlot(value);
  };
  DateCategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var baseUnit = options2.baseUnit;
    var weekStartDay = options2.weekStartDay;
    var vertical = options2.vertical;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / (range.max - range.min);
    var offset3 = round3(delta / scale, DEFAULT_PRECISION);
    if (range.min && range.max) {
      var from = addTicks(options2.min || range.min, offset3);
      var to = addTicks(options2.max || range.max, offset3);
      range = {
        min: addDuration(from, 0, baseUnit, weekStartDay),
        max: addDuration(to, 0, baseUnit, weekStartDay)
      };
    }
    return range;
  };
  DateCategoryAxis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.divisionRange.valuesCount()
    };
  };
  DateCategoryAxis2.prototype.pan = function pan(delta) {
    if (this.isEmpty()) {
      return null;
    }
    var options2 = this.options;
    var lineBox = this.lineBox();
    var size = options2.vertical ? lineBox.height() : lineBox.width();
    var ref2 = this.dataRange.displayRange();
    var min3 = ref2.min;
    var max2 = ref2.max;
    var totalLimits = this.dataRange.total();
    var scale = size / (max2 - min3);
    var offset3 = round3(delta / scale, DEFAULT_PRECISION) * (options2.reverse ? -1 : 1);
    var from = addTicks(min3, offset3);
    var to = addTicks(max2, offset3);
    var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset3);
    if (panRange) {
      panRange.min = toDate(panRange.min);
      panRange.max = toDate(panRange.max);
      panRange.baseUnit = options2.baseUnit;
      panRange.baseUnitStep = options2.baseUnitStep || 1;
      panRange.userSetBaseUnit = options2.userSetBaseUnit;
      panRange.userSetBaseUnitStep = options2.userSetBaseUnitStep;
      return panRange;
    }
  };
  DateCategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    if (this.isEmpty()) {
      return null;
    }
    var pointsRange2 = CategoryAxis2.prototype.pointsRange.call(this, start, end);
    var datesRange = this.dataRange.displayRange();
    var indicesRange = this.dataRange.displayIndices();
    var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);
    var options2 = this.options;
    var min3 = addTicks(datesRange.min, pointsRange2.min * scale);
    var max2 = addTicks(datesRange.min, pointsRange2.max * scale);
    return {
      min: min3,
      max: max2,
      baseUnit: options2.userSetBaseUnit || options2.baseUnit,
      baseUnitStep: options2.userSetBaseUnitStep || options2.baseUnitStep
    };
  };
  DateCategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    if (this.isEmpty()) {
      return {};
    }
    var options2 = this.options;
    var fit3 = options2.userSetBaseUnit === FIT;
    var totalLimits = this.dataRange.total();
    var ref2 = this.dataRange.displayRange();
    var rangeMin = ref2.min;
    var rangeMax = ref2.max;
    var position3 = Math.abs(this.pointOffset(cursor));
    var range = rangeMax - rangeMin;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = Math.round(position3 * delta);
    var maxDelta = Math.round((1 - position3) * delta);
    var ref$1 = this.dataRange.options;
    var baseUnit = ref$1.baseUnit;
    var min3 = new Date(rangeMin.getTime() + minDelta);
    var max2 = new Date(rangeMax.getTime() - maxDelta);
    if (fit3) {
      var autoBaseUnitSteps = options2.autoBaseUnitSteps;
      var maxDateGroups = options2.maxDateGroups;
      var maxDiff = last2(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];
      var rangeDiff = dateDiff(rangeMax, rangeMin);
      var diff = dateDiff(max2, min3);
      var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);
      var autoBaseUnitStep, ticks;
      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {
        baseUnit = BASE_UNITS[baseUnitIndex - 1];
        autoBaseUnitStep = last2(autoBaseUnitSteps[baseUnit]);
        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;
        min3 = addTicks(rangeMin, ticks);
        max2 = addTicks(rangeMax, -ticks);
      } else if (diff > maxDiff && baseUnit !== YEARS) {
        var stepIndex = 0;
        do {
          baseUnitIndex++;
          baseUnit = BASE_UNITS[baseUnitIndex];
          stepIndex = 0;
          ticks = 2 * TIME_PER_UNIT[baseUnit];
          do {
            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];
            stepIndex++;
          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);
        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);
        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;
        if (ticks > 0) {
          min3 = addTicks(rangeMin, -ticks);
          max2 = addTicks(rangeMax, ticks);
          min3 = addTicks(min3, limitValue2(max2, totalLimits.min, totalLimits.max) - max2);
          max2 = addTicks(max2, limitValue2(min3, totalLimits.min, totalLimits.max) - min3);
        }
      }
    }
    if (min3 && max2 && dateDiff(max2, min3) > 0) {
      return {
        min: min3,
        max: max2,
        baseUnit: options2.userSetBaseUnit || options2.baseUnit,
        baseUnitStep: options2.userSetBaseUnitStep || options2.baseUnitStep
      };
    }
  };
  DateCategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var totalLimits = this.dataRange.total();
    var range = this.scaleRange(scale, cursor);
    if (range) {
      if (range.min < totalLimits.min) {
        range.min = totalLimits.min;
      }
      if (range.max > totalLimits.max) {
        range.max = totalLimits.max;
      }
    }
    return range;
  };
  DateCategoryAxis2.prototype.range = function range() {
    return this.dataRange.displayRange();
  };
  DateCategoryAxis2.prototype.createLabels = function createLabels() {
    CategoryAxis2.prototype.createLabels.call(this);
    this.createRangeLabels();
  };
  DateCategoryAxis2.prototype.clearLabels = function clearLabels() {
    CategoryAxis2.prototype.clearLabels.call(this);
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    this.arrangeRangeLabels();
    CategoryAxis2.prototype.arrangeLabels.call(this);
  };
  DateCategoryAxis2.prototype.arrangeRangeLabels = function arrangeRangeLabels() {
    var ref2 = this;
    var options2 = ref2.options;
    var rangeLabels = ref2.rangeLabels;
    if (rangeLabels.length === 0) {
      return;
    }
    var lineBox = this.lineBox();
    var vertical = options2.vertical;
    var mirror = options2.rangeLabels.mirror || options2.labels.mirror;
    var firstLabel = rangeLabels[0];
    if (firstLabel) {
      var position3 = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;
      this.positionLabel(firstLabel, mirror, position3);
    }
    var lastLabel = rangeLabels[1];
    if (lastLabel) {
      var position$1 = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;
      this.positionLabel(lastLabel, mirror, position$1);
    }
  };
  DateCategoryAxis2.prototype.autoRotateLabels = function autoRotateLabels() {
    CategoryAxis2.prototype.autoRotateLabels.call(this);
    this.autoRotateRangeLabels();
  };
  DateCategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    CategoryAxis2.prototype.hideOutOfRangeLabels.call(this);
    this.hideOverlappingLabels();
  };
  DateCategoryAxis2.prototype.hideOverlappingLabels = function hideOverlappingLabels() {
    var ref2 = this;
    var rangeLabels = ref2.rangeLabels;
    var labels = ref2.labels;
    if (rangeLabels.length === 0) {
      return;
    }
    function clip(rangeLabel, label) {
      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {
        label.options.visible = false;
        return true;
      }
      return false;
    }
    var firstRangeLabel = rangeLabels[0];
    if (firstRangeLabel && firstRangeLabel.options.visible) {
      for (var i = 0; i < labels.length; i++) {
        var overlaps = clip(firstRangeLabel, labels[i]);
        if (!overlaps) {
          break;
        }
      }
    }
    var lastRangeLabel = rangeLabels[1];
    if (lastRangeLabel && lastRangeLabel.options.visible) {
      for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {
        var overlaps$1 = clip(lastRangeLabel, labels[i$1]);
        if (!overlaps$1) {
          break;
        }
      }
    }
  };
  DateCategoryAxis2.prototype.contentBox = function contentBox() {
    var box = CategoryAxis2.prototype.contentBox.call(this);
    var rangeLabels = this.rangeLabels;
    for (var i = 0; i < rangeLabels.length; i++) {
      var label = rangeLabels[i];
      if (label.options.visible) {
        box.wrap(label.box);
      }
    }
    return box;
  };
  DateCategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    if (labelContext === void 0)
      labelContext = {};
    var options2 = this.options;
    var dataItem = options2.dataItems && !options2.maxDivisions ? options2.dataItems[index] : null;
    var date = this.divisionRange.dateAt(index);
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    if (text) {
      return new axis_label_default(date, text, index, dataItem, labelOptions);
    }
  };
  DateCategoryAxis2.prototype.createRangeLabels = function createRangeLabels() {
    var this$1 = this;
    var ref2 = this.divisionRange;
    var displayStart = ref2.displayStart;
    var displayEnd = ref2.displayEnd;
    var options2 = this.options;
    var labelOptions = Object.assign({}, options2.labels, options2.rangeLabels, {
      align: CENTER,
      zIndex: options2.zIndex
    });
    if (labelOptions.visible !== true) {
      return;
    }
    this.normalizeLabelRotation(labelOptions);
    labelOptions.alignRotation = CENTER;
    if (labelOptions.rotation === "auto") {
      labelOptions.rotation = 0;
      options2.autoRotateRangeLabels = true;
    }
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var createLabel = function(index, date, text) {
      if (text) {
        var label = new axis_label_default(date, text, index, null, labelOptions);
        this$1.append(label);
        this$1.rangeLabels.push(label);
      }
    };
    var startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });
    createLabel(0, displayStart, startText);
    var endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });
    createLabel(1, displayEnd, endText);
  };
  DateCategoryAxis2.prototype.autoRotateRangeLabels = function autoRotateRangeLabels() {
    var this$1 = this;
    var labels = this.rangeLabels;
    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {
      return;
    }
    var rotateLabel = function(label, tickPositions2, index) {
      var width = Math.abs(tickPositions2[index + 1] - tickPositions2[index]) * 2;
      var angle = this$1.autoRotateLabelAngle(label.box, width);
      if (angle !== 0) {
        label.options.rotation = angle;
        label.reflow(new box_default());
      }
    };
    var tickPositions = this.getMajorTickPositions();
    rotateLabel(labels[0], tickPositions, 0);
    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);
  };
  DateCategoryAxis2.prototype.categoryIndex = function categoryIndex(value) {
    return this.dataRange.valueIndex(value);
  };
  DateCategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var dateRange = this.dataRange;
    var start = from;
    var end = to;
    if (start instanceof Date) {
      start = dateRange.dateIndex(start);
    }
    if (end instanceof Date) {
      end = dateRange.dateIndex(end);
    }
    var slot2 = this.getSlot(start, end, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  DateCategoryAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    var start = a;
    var end = b;
    if (typeof start === OBJECT) {
      start = this.categoryIndex(start);
    }
    if (typeof end === OBJECT) {
      end = this.categoryIndex(end);
    }
    return CategoryAxis2.prototype.getSlot.call(this, start, end, limit);
  };
  DateCategoryAxis2.prototype.valueRange = function valueRange3() {
    var options2 = this.options;
    var range = categoryRange(options2.srcCategories);
    return {
      min: toDate(range.min),
      max: toDate(range.max)
    };
  };
  DateCategoryAxis2.prototype.categoryAt = function categoryAt(index, total3) {
    return this.dataRange.dateAt(index, total3);
  };
  DateCategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return this.dataRange.valuesCount();
  };
  DateCategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    return this.dataRange.displayIndices();
  };
  DateCategoryAxis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.divisionRange.options.justified;
  };
  DateCategoryAxis2.prototype.prepareUserOptions = function prepareUserOptions() {
    if (this.isEmpty()) {
      return;
    }
    this.options.categories = this.dataRange.values();
  };
  DateCategoryAxis2.prototype.getCategory = function getCategory(point2) {
    var index = this.pointCategoryIndex(point2);
    if (index === null) {
      return null;
    }
    return this.dataRange.dateAt(index);
  };
  DateCategoryAxis2.prototype.totalIndex = function totalIndex3(value) {
    return this.dataRange.totalIndex(value);
  };
  DateCategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var range = this.dataRange.valueRange();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  };
  DateCategoryAxis2.prototype.totalRange = function totalRange() {
    return this.dataRange.total();
  };
  DateCategoryAxis2.prototype.totalCount = function totalCount3() {
    return this.dataRange.totalCount();
  };
  DateCategoryAxis2.prototype.isEmpty = function isEmpty() {
    return !this.options.srcCategories.length;
  };
  DateCategoryAxis2.prototype.roundedRange = function roundedRange() {
    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {
      return this.range();
    }
    var options2 = this.options;
    var datesRange = categoryRange(options2.srcCategories);
    var dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options2, {
      justified: false,
      roundToBaseUnit: true,
      justifyEnd: false
    }));
    return dateRange.displayRange();
  };
  return DateCategoryAxis2;
}(category_axis_default);
setDefaultOptions(DateCategoryAxis, {
  type: DATE,
  labels: {
    dateFormats: DateLabelFormats
  },
  rangeLabels: {
    visible: false
  },
  autoBaseUnitSteps: {
    milliseconds: [1, 10, 100],
    seconds: [1, 2, 5, 15, 30],
    minutes: [1, 2, 5, 15, 30],
    hours: [1, 2, 3],
    days: [1, 2, 3],
    weeks: [1, 2],
    months: [1, 2, 3, 6],
    years: [1, 2, 3, 5, 10, 25, 50]
  },
  maxDateGroups: 10
});
var date_category_axis_default = DateCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-min.js
function autoAxisMin(min3, max2, narrow) {
  if (!min3 && !max2) {
    return 0;
  }
  var axisMin;
  if (min3 >= 0 && max2 >= 0) {
    var minValue = min3 === max2 ? 0 : min3;
    var diff = (max2 - minValue) / max2;
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMin = Math.max(0, minValue - (max2 - minValue) / 2);
  } else {
    axisMin = min3;
  }
  return axisMin;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-max.js
function autoAxisMax(min3, max2, narrow) {
  if (!min3 && !max2) {
    return 1;
  }
  var axisMax;
  if (min3 <= 0 && max2 <= 0) {
    var maxValue = min3 === max2 ? 0 : max2;
    var diff = Math.abs((maxValue - min3) / maxValue);
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMax = Math.min(0, maxValue - (min3 - maxValue) / 2);
  } else {
    axisMax = max2;
  }
  return axisMax;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/floor.js
function floor(value, step) {
  return round3(Math.floor(value / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/ceil.js
function ceil(value, step) {
  return round3(Math.ceil(value / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/limit-coordinate.js
function limitCoordinate(value) {
  return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);
}

// node_modules/@progress/kendo-charts/dist/es/core/numeric-axis.js
var MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);
var NumericAxis = function(Axis2) {
  function NumericAxis2(seriesMin, seriesMax, options2, chartService) {
    Axis2.call(this, Object.assign({}, options2, {
      seriesMin,
      seriesMax
    }), chartService);
  }
  if (Axis2)
    NumericAxis2.__proto__ = Axis2;
  NumericAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  NumericAxis2.prototype.constructor = NumericAxis2;
  NumericAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    var autoOptions = autoAxisOptions(options2.seriesMin, options2.seriesMax, options2);
    this.totalOptions = totalAxisOptions(autoOptions, options2);
    return axisOptions(autoOptions, options2);
  };
  NumericAxis2.prototype.initFields = function initFields() {
    this.totalMin = this.totalOptions.min;
    this.totalMax = this.totalOptions.max;
    this.totalMajorUnit = this.totalOptions.majorUnit;
    this.seriesMin = this.options.seriesMin;
    this.seriesMax = this.options.seriesMax;
  };
  NumericAxis2.prototype.clone = function clone2() {
    return new NumericAxis2(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  };
  NumericAxis2.prototype.startValue = function startValue() {
    return 0;
  };
  NumericAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  NumericAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    if (stepValue === 0) {
      return 1;
    }
    var options2 = this.options;
    var range = options2.max - options2.min;
    return Math.floor(round3(range / stepValue, COORD_PRECISION)) + 1;
  };
  NumericAxis2.prototype.getTickPositions = function getTickPositions(unit, skipUnit) {
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var range = options2.max - options2.min;
    var scale = lineSize / range;
    var step = unit * scale;
    var divisions = this.getDivisions(unit);
    var positions = [];
    var pos = lineBox[axisOrigin];
    var skipStep = 0;
    if (skipUnit) {
      skipStep = skipUnit / unit;
    }
    for (var idx = 0; idx < divisions; idx++) {
      if (idx % skipStep !== 0) {
        positions.push(round3(pos, COORD_PRECISION));
      }
      pos = pos + step * axisDir;
    }
    return positions;
  };
  NumericAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  NumericAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  NumericAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    if (limit === void 0)
      limit = false;
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var lineStart = ref2.lineStart;
    var step = axisDir * (lineSize / (options2.max - options2.min));
    var start = valueOrDefault2(a, b || 0);
    var end = valueOrDefault2(b, a || 0);
    if (limit) {
      start = limitValue2(start, options2.min, options2.max);
      end = limitValue2(end, options2.min, options2.max);
    }
    var p1 = Math.min(start, end) - options2.min;
    var p2 = Math.max(start, end) - options2.min;
    var slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));
    return slotBox;
  };
  NumericAxis2.prototype.getValue = function getValue(point2) {
    var options2 = this.options;
    var max2 = Number(options2.max);
    var min3 = Number(options2.min);
    var offset3 = this.pointOffset(point2);
    var valueOffset = offset3 * (max2 - min3);
    if (offset3 < 0 || offset3 > 1) {
      return null;
    }
    var value = min3 + valueOffset;
    return round3(value, DEFAULT_PRECISION);
  };
  NumericAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var vertical = options2.vertical;
    var reverse = options2.reverse;
    var max2 = options2.max;
    var min3 = options2.min;
    var ref2 = this.lineInfo();
    var lineSize = ref2.lineSize;
    var range = max2 - min3;
    var scale = lineSize / range;
    var offset3 = round3(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset3 = -offset3;
    }
    return {
      min: min3 + offset3,
      max: max2 + offset3,
      offset: offset3
    };
  };
  NumericAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  NumericAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options2 = this.options;
    var value = round3(options2.min + index * options2.majorUnit, DEFAULT_PRECISION);
    var text = this.axisLabelText(value, labelOptions, labelContext);
    return new axis_label_default(value, text, index, null, labelOptions);
  };
  NumericAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.range();
    return range.min <= value && value <= range.max;
  };
  NumericAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  NumericAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min3 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    if (this.isValidRange(min3, max2)) {
      return {
        min: min3,
        max: max2
      };
    }
  };
  NumericAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position3 = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position3 * delta;
    var maxDelta = (1 - position3) * delta;
    var min3 = round3(this.options.min + minDelta, DEFAULT_PRECISION);
    var max2 = round3(this.options.max - maxDelta, DEFAULT_PRECISION);
    if (max2 - min3 < MIN_VALUE_RANGE) {
      max2 = min3 + MIN_VALUE_RANGE;
    }
    return {
      min: min3,
      max: max2
    };
  };
  NumericAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue2(range.min, totalMin, totalMax),
      max: limitValue2(range.max, totalMin, totalMax),
      narrowRange: false
    };
  };
  NumericAxis2.prototype.isValidRange = function isValidRange(min3, max2) {
    return max2 - min3 > MIN_VALUE_RANGE;
  };
  return NumericAxis2;
}(axis_default);
function autoAxisOptions(seriesMin, seriesMax, options2) {
  var narrowRange = options2.narrowRange;
  var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);
  var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);
  var majorUnit = autoMajorUnit(autoMin, autoMax);
  var autoOptions = {
    majorUnit
  };
  if (options2.roundToMajorUnit !== false) {
    if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {
      autoMin -= majorUnit;
    }
    if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {
      autoMax += majorUnit;
    }
  }
  autoOptions.min = floor(autoMin, majorUnit);
  autoOptions.max = ceil(autoMax, majorUnit);
  return autoOptions;
}
function totalAxisOptions(autoOptions, options2) {
  return {
    min: defined2(options2.min) ? Math.min(autoOptions.min, options2.min) : autoOptions.min,
    max: defined2(options2.max) ? Math.max(autoOptions.max, options2.max) : autoOptions.max,
    majorUnit: autoOptions.majorUnit
  };
}
function clearNullValues(options2, fields) {
  for (var idx = 0; idx < fields.length; idx++) {
    var field = fields[idx];
    if (options2[field] === null) {
      options2[field] = void 0;
    }
  }
}
function axisOptions(autoOptions, userOptions) {
  var options2 = userOptions;
  var userSetMin, userSetMax;
  if (userOptions) {
    clearNullValues(userOptions, ["min", "max"]);
    userSetMin = defined2(userOptions.min);
    userSetMax = defined2(userOptions.max);
    var userSetLimits = userSetMin || userSetMax;
    if (userSetLimits) {
      if (userOptions.min === userOptions.max) {
        if (userOptions.min > 0) {
          userOptions.min = 0;
        } else {
          userOptions.max = 1;
        }
      }
    }
    if (userOptions.majorUnit) {
      autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);
      autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);
    } else if (userSetLimits) {
      options2 = deepExtend(autoOptions, userOptions);
      autoOptions.majorUnit = autoMajorUnit(options2.min, options2.max);
    }
  }
  autoOptions.minorUnit = (options2.majorUnit || autoOptions.majorUnit) / 5;
  var result = deepExtend(autoOptions, options2);
  if (result.min >= result.max) {
    if (userSetMin && !userSetMax) {
      result.max = result.min + result.majorUnit;
    } else if (!userSetMin && userSetMax) {
      result.min = result.max - result.majorUnit;
    }
  }
  return result;
}
function remainderClose(value, divisor, ratio) {
  var remainder = round3(Math.abs(value % divisor), DEFAULT_PRECISION);
  var threshold = divisor * (1 - ratio);
  return remainder === 0 || remainder > threshold;
}
setDefaultOptions(NumericAxis, {
  type: "numeric",
  min: 0,
  max: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    format: "#.####################"
  },
  zIndex: 1
});
var numeric_axis_default = NumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/date-value-axis.js
var MIN_VALUE_RANGE2 = 1e3;
var DateValueAxis = function(Axis2) {
  function DateValueAxis2(seriesMin, seriesMax, axisOptions2, chartService) {
    var min3 = toDate(seriesMin);
    var max2 = toDate(seriesMax);
    var intlService = chartService.intl;
    var options2 = axisOptions2 || {};
    options2 = deepExtend(options2 || {}, {
      min: parseDate3(intlService, options2.min),
      max: parseDate3(intlService, options2.max),
      axisCrossingValue: parseDates(intlService, options2.axisCrossingValues || options2.axisCrossingValue),
      weekStartDay: firstDay2(options2, intlService)
    });
    options2 = applyDefaults(min3, max2, options2);
    Axis2.call(this, options2, chartService);
    this.intlService = intlService;
    this.seriesMin = min3;
    this.seriesMax = max2;
    var weekStartDay = options2.weekStartDay || 0;
    this.totalMin = toTime(floorDate(toTime(min3) - 1, options2.baseUnit, weekStartDay));
    this.totalMax = toTime(ceilDate(toTime(max2) + 1, options2.baseUnit, weekStartDay));
  }
  if (Axis2)
    DateValueAxis2.__proto__ = Axis2;
  DateValueAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  DateValueAxis2.prototype.constructor = DateValueAxis2;
  DateValueAxis2.prototype.clone = function clone2() {
    return new DateValueAxis2(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  };
  DateValueAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  DateValueAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    var options2 = this.options;
    return Math.floor(
      duration(options2.min, options2.max, options2.baseUnit) / stepValue + 1
    );
  };
  DateValueAxis2.prototype.getTickPositions = function getTickPositions(step) {
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var dir = ref2.axisDir;
    var lineSize = ref2.lineSize;
    var start = ref2.lineStart;
    var divisions = this.getDivisions(step);
    var timeRange = dateDiff(options2.max, options2.min);
    var scale = lineSize / timeRange;
    var weekStartDay = options2.weekStartDay || 0;
    var positions = [start];
    for (var i = 1; i < divisions; i++) {
      var date = addDuration(options2.min, i * step, options2.baseUnit, weekStartDay);
      var pos = start + dateDiff(date, options2.min) * scale * dir;
      positions.push(round3(pos, COORD_PRECISION));
    }
    return positions;
  };
  DateValueAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  DateValueAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    return numeric_axis_default.prototype.getSlot.call(
      this,
      parseDate3(this.intlService, a),
      parseDate3(this.intlService, b),
      limit
    );
  };
  DateValueAxis2.prototype.getValue = function getValue(point2) {
    var value = numeric_axis_default.prototype.getValue.call(this, point2);
    return value !== null ? toDate(value) : null;
  };
  DateValueAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options2 = this.options;
    var offset3 = index * options2.majorUnit;
    var weekStartDay = options2.weekStartDay || 0;
    var date = options2.min;
    if (offset3 > 0) {
      date = addDuration(date, offset3, options2.baseUnit, weekStartDay);
    }
    var unitFormat = labelOptions.dateFormats[options2.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    return new axis_label_default(date, text, index, null, labelOptions);
  };
  DateValueAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var vertical = options2.vertical;
    var reverse = options2.reverse;
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / dateDiff(range.max, range.min);
    var offset3 = round3(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset3 = -offset3;
    }
    var from = addTicks(options2.min, offset3);
    var to = addTicks(options2.max, offset3);
    return {
      min: from,
      max: to,
      offset: offset3
    };
  };
  DateValueAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.range();
    return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;
  };
  DateValueAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta, true);
    var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);
    if (limittedRange) {
      return {
        min: toDate(limittedRange.min),
        max: toDate(limittedRange.max)
      };
    }
  };
  DateValueAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min3 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    return {
      min: toDate(min3),
      max: toDate(max2)
    };
  };
  DateValueAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position3 = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position3 * delta;
    var maxDelta = (1 - position3) * delta;
    var min3 = toDate(toTime(this.options.min) + minDelta);
    var max2 = toDate(toTime(this.options.max) - maxDelta);
    if (max2 - min3 < MIN_VALUE_RANGE2) {
      max2 = toDate(toTime(min3) + MIN_VALUE_RANGE2);
    }
    return {
      min: min3,
      max: max2
    };
  };
  DateValueAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var min3 = toDate(limitValue2(toTime(range.min), this.totalMin, this.totalMax));
    var max2 = toDate(limitValue2(toTime(range.max), this.totalMin, this.totalMax));
    return {
      min: min3,
      max: max2
    };
  };
  return DateValueAxis2;
}(axis_default);
function timeUnits(delta) {
  var unit = HOURS;
  if (delta >= TIME_PER_YEAR) {
    unit = YEARS;
  } else if (delta >= TIME_PER_MONTH) {
    unit = MONTHS;
  } else if (delta >= TIME_PER_WEEK) {
    unit = WEEKS;
  } else if (delta >= TIME_PER_DAY) {
    unit = DAYS;
  }
  return unit;
}
function applyDefaults(seriesMin, seriesMax, options2) {
  var min3 = options2.min || seriesMin;
  var max2 = options2.max || seriesMax;
  var baseUnit = options2.baseUnit || (max2 && min3 ? timeUnits(absoluteDateDiff(max2, min3)) : HOURS);
  var baseUnitTime = TIME_PER_UNIT[baseUnit];
  var weekStartDay = options2.weekStartDay || 0;
  var autoMin = floorDate(toTime(min3) - 1, baseUnit, weekStartDay) || toDate(max2);
  var autoMax = ceilDate(toTime(max2) + 1, baseUnit, weekStartDay);
  var userMajorUnit = options2.majorUnit ? options2.majorUnit : void 0;
  var majorUnit = userMajorUnit || ceil(
    autoMajorUnit(autoMin.getTime(), autoMax.getTime()),
    baseUnitTime
  ) / baseUnitTime;
  var actualUnits = duration(autoMin, autoMax, baseUnit);
  var totalUnits = ceil(actualUnits, majorUnit);
  var unitsToAdd = totalUnits - actualUnits;
  var head = Math.floor(unitsToAdd / 2);
  var tail = unitsToAdd - head;
  if (!options2.baseUnit) {
    delete options2.baseUnit;
  }
  options2.baseUnit = options2.baseUnit || baseUnit;
  options2.min = options2.min || addDuration(autoMin, -head, baseUnit, weekStartDay);
  options2.max = options2.max || addDuration(autoMax, tail, baseUnit, weekStartDay);
  options2.minorUnit = options2.minorUnit || majorUnit / 5;
  options2.majorUnit = majorUnit;
  return options2;
}
setDefaultOptions(DateValueAxis, {
  type: DATE,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    dateFormats: DateLabelFormats
  }
});
var date_value_axis_default = DateValueAxis;

// node_modules/@progress/kendo-charts/dist/es/core/logarithmic-axis.js
var DEFAULT_MAJOR_UNIT = 10;
var MIN_VALUE_RANGE3 = 1e-6;
var LogarithmicAxis = function(Axis2) {
  function LogarithmicAxis2(seriesMin, seriesMax, options2, chartService) {
    var axisOptions2 = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options2);
    var base = axisOptions2.majorUnit;
    var autoMax = autoAxisMax2(seriesMax, base);
    var autoMin = autoAxisMin2(seriesMin, seriesMax, axisOptions2);
    var range = initRange(autoMin, autoMax, axisOptions2, options2);
    axisOptions2.max = range.max;
    axisOptions2.min = range.min;
    axisOptions2.minorUnit = options2.minorUnit || round3(base - 1, DEFAULT_PRECISION);
    Axis2.call(this, axisOptions2, chartService);
    this.totalMin = defined2(options2.min) ? Math.min(autoMin, options2.min) : autoMin;
    this.totalMax = defined2(options2.max) ? Math.max(autoMax, options2.max) : autoMax;
    this.logMin = round3(log(range.min, base), DEFAULT_PRECISION);
    this.logMax = round3(log(range.max, base), DEFAULT_PRECISION);
    this.seriesMin = seriesMin;
    this.seriesMax = seriesMax;
    this.createLabels();
  }
  if (Axis2)
    LogarithmicAxis2.__proto__ = Axis2;
  LogarithmicAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  LogarithmicAxis2.prototype.constructor = LogarithmicAxis2;
  LogarithmicAxis2.prototype.clone = function clone2() {
    return new LogarithmicAxis2(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  };
  LogarithmicAxis2.prototype.startValue = function startValue() {
    return this.options.min;
  };
  LogarithmicAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options2.majorUnit;
    var min3 = options2.min;
    var max2 = options2.max;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineBox = ref$1.lineBox;
    var lineSize = ref$1.lineSize;
    var lineStart = ref$1.lineStart;
    var step = axisDir * (lineSize / (logMax - logMin));
    var start = valueOrDefault2(a, b || 1);
    var end = valueOrDefault2(b, a || 1);
    if (start <= 0 || end <= 0) {
      return null;
    }
    if (limit) {
      start = limitValue2(start, min3, max2);
      end = limitValue2(end, min3, max2);
    }
    start = log(start, base);
    end = log(end, base);
    var p1 = Math.min(start, end) - logMin;
    var p2 = Math.max(start, end) - logMin;
    var slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));
    return slotBox;
  };
  LogarithmicAxis2.prototype.getValue = function getValue(point2) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options2.majorUnit;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineStart = ref$1.lineStart;
    var lineSize = ref$1.lineSize;
    var step = (logMax - logMin) / lineSize;
    var offset3 = axisDir * (point2[axis] - lineStart);
    var valueOffset = offset3 * step;
    if (offset3 < 0 || offset3 > lineSize) {
      return null;
    }
    var value = logMin + valueOffset;
    return round3(Math.pow(base, value), DEFAULT_PRECISION);
  };
  LogarithmicAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  LogarithmicAxis2.prototype.translateRange = function translateRange(delta) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var reverse = options2.reverse;
    var vertical = options2.vertical;
    var base = options2.majorUnit;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var scale = size / (logMax - logMin);
    var offset3 = round3(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset3 = -offset3;
    }
    return {
      min: Math.pow(base, logMin + offset3),
      max: Math.pow(base, logMax + offset3),
      offset: offset3
    };
  };
  LogarithmicAxis2.prototype.labelsCount = function labelsCount() {
    var floorMax = Math.floor(this.logMax);
    var count = Math.floor(floorMax - this.logMin) + 1;
    return count;
  };
  LogarithmicAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    var ticks = [];
    this.traverseMajorTicksPositions(function(position3) {
      ticks.push(position3);
    }, { step: 1, skip: 0 });
    return ticks;
  };
  LogarithmicAxis2.prototype.createTicks = function createTicks(lineGroup) {
    var options2 = this.options;
    var majorTicks = options2.majorTicks;
    var minorTicks = options2.minorTicks;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var lineBox = this.lineBox();
    var ticks = [];
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical
    };
    function render(tickPosition, tickOptions) {
      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickLineOptions.position = tickPosition;
      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
    }
    if (majorTicks.visible) {
      this.traverseMajorTicksPositions(render, majorTicks);
    }
    if (minorTicks.visible) {
      this.traverseMinorTicksPositions(render, minorTicks);
    }
    return ticks;
  };
  LogarithmicAxis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var vertical = options2.vertical;
    var lineBox = altAxis.lineBox();
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render(tickPosition, gridLine) {
      if (!inArray(tickPosition, majorTicks)) {
        lineOptions.position = tickPosition;
        container.append(createAxisGridLine(lineOptions, gridLine));
        majorTicks.push(tickPosition);
      }
    }
    if (majorGridLines.visible) {
      this.traverseMajorTicksPositions(render, majorGridLines);
    }
    if (minorGridLines.visible) {
      this.traverseMinorTicksPositions(render, minorGridLines);
    }
    return container.children;
  };
  LogarithmicAxis2.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {
    var ref2 = this.lineInfo();
    var lineStart = ref2.lineStart;
    var step = ref2.step;
    var ref$1 = this;
    var logMin = ref$1.logMin;
    var logMax = ref$1.logMax;
    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {
      var position3 = round3(lineStart + step * (power - logMin), DEFAULT_PRECISION);
      callback(position3, tickOptions);
    }
  };
  LogarithmicAxis2.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {
    var this$1 = this;
    var ref2 = this.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var ref$1 = this.lineInfo();
    var lineStart = ref$1.lineStart;
    var step = ref$1.step;
    var ref$2 = this;
    var logMin = ref$2.logMin;
    var logMax = ref$2.logMax;
    var start = Math.floor(logMin);
    for (var power = start; power < logMax; power++) {
      var minorOptions = this$1._minorIntervalOptions(power);
      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {
        var value = minorOptions.value + idx * minorOptions.minorStep;
        if (value > max2) {
          break;
        }
        if (value >= min3) {
          var position3 = round3(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);
          callback(position3, tickOptions);
        }
      }
    }
  };
  LogarithmicAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var power = Math.ceil(this.logMin + index);
    var value = Math.pow(this.options.majorUnit, power);
    var text = this.axisLabelText(value, labelOptions, labelContext);
    return new axis_label_default(value, text, index, null, labelOptions);
  };
  LogarithmicAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.range();
    return range.min <= value && value <= range.max;
  };
  LogarithmicAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  LogarithmicAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min3 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    return {
      min: min3,
      max: max2
    };
  };
  LogarithmicAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var ref2 = this.options;
    var base = ref2.majorUnit;
    var logMin = log(this.options.min, base);
    var logMax = log(this.options.max, base);
    var position3 = Math.abs(this.pointOffset(cursor));
    var range = logMax - logMin;
    var delta = this.scaleToDelta(scale, range);
    var min3 = Math.pow(base, logMin + position3 * delta);
    var max2 = Math.pow(base, logMax - (1 - position3) * delta);
    if (max2 - min3 < MIN_VALUE_RANGE3) {
      max2 = min3 + MIN_VALUE_RANGE3;
    }
    return {
      min: min3,
      max: max2
    };
  };
  LogarithmicAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    return {
      min: limitValue2(range.min, totalMin, totalMax),
      max: limitValue2(range.max, totalMin, totalMax)
    };
  };
  LogarithmicAxis2.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {
    var ref2 = this.options;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var value = Math.pow(base, power);
    var nextValue = Math.pow(base, power + 1);
    var difference = nextValue - value;
    var minorStep = difference / minorUnit;
    return {
      value,
      minorStep
    };
  };
  LogarithmicAxis2.prototype.lineInfo = function lineInfo() {
    var info = Axis2.prototype.lineInfo.call(this);
    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));
    return info;
  };
  return LogarithmicAxis2;
}(axis_default);
function initRange(autoMin, autoMax, axisOptions2, options2) {
  var min3 = axisOptions2.min;
  var max2 = axisOptions2.max;
  if (defined2(axisOptions2.axisCrossingValue) && axisOptions2.axisCrossingValue <= 0) {
    throwNegativeValuesError();
  }
  if (!defined2(options2.max)) {
    max2 = autoMax;
  } else if (options2.max <= 0) {
    throwNegativeValuesError();
  }
  if (!defined2(options2.min)) {
    min3 = autoMin;
  } else if (options2.min <= 0) {
    throwNegativeValuesError();
  }
  return {
    min: min3,
    max: max2
  };
}
function autoAxisMin2(min3, max2, options2) {
  var base = options2.majorUnit;
  var autoMin = min3;
  if (min3 <= 0) {
    autoMin = max2 <= 1 ? Math.pow(base, -2) : 1;
  } else if (!options2.narrowRange) {
    autoMin = Math.pow(base, Math.floor(log(min3, base)));
  }
  return autoMin;
}
function autoAxisMax2(max2, base) {
  var logMaxRemainder = round3(log(max2, base), DEFAULT_PRECISION) % 1;
  var autoMax;
  if (max2 <= 0) {
    autoMax = base;
  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {
    autoMax = Math.pow(base, log(max2, base) + 0.2);
  } else {
    autoMax = Math.pow(base, Math.ceil(log(max2, base)));
  }
  return autoMax;
}
function throwNegativeValuesError() {
  throw new Error("Non positive values cannot be used for a logarithmic axis");
}
function log(x, base) {
  return Math.log(x) / Math.log(base);
}
setDefaultOptions(LogarithmicAxis, {
  type: "log",
  majorUnit: DEFAULT_MAJOR_UNIT,
  minorUnit: 1,
  axisCrossingValue: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  zIndex: 1,
  _deferLabels: true
});
var logarithmic_axis_default = LogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/grid-lines-mixin.js
var GridLinesMixin = {
  createGridLines: function(altAxis) {
    var options2 = this.options;
    var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);
    var gridLines = [];
    var skipMajor = false;
    var majorAngles, minorAngles;
    if (options2.majorGridLines.visible) {
      majorAngles = this.majorGridLineAngles(altAxis);
      skipMajor = true;
      gridLines = this.renderMajorGridLines(
        majorAngles,
        radius,
        options2.majorGridLines
      );
    }
    if (options2.minorGridLines.visible) {
      minorAngles = this.minorGridLineAngles(altAxis, skipMajor);
      append2(gridLines, this.renderMinorGridLines(
        minorAngles,
        radius,
        options2.minorGridLines,
        altAxis,
        skipMajor
      ));
    }
    return gridLines;
  },
  renderMajorGridLines: function(angles, radius, options2) {
    return this.renderGridLines(angles, radius, options2);
  },
  renderMinorGridLines: function(angles, radius, options2, altAxis, skipMajor) {
    var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);
    return this.renderGridLines(angles, radius, options2, radiusCallback);
  },
  renderGridLines: function(angles, radius, options2, radiusCallback) {
    var style = {
      stroke: {
        width: options2.width,
        color: options2.color,
        dashType: options2.dashType
      }
    };
    var center = this.box.center();
    var circle = new geometry_exports.Circle([center.x, center.y], radius);
    var container = this.gridLinesVisual();
    for (var i = 0; i < angles.length; i++) {
      var line = new drawing_exports.Path(style);
      if (radiusCallback) {
        circle.radius = radiusCallback(angles[i]);
      }
      line.moveTo(circle.center).lineTo(circle.pointAt(angles[i] + 180));
      container.append(line);
    }
    return container.children;
  },
  gridLineAngles: function(altAxis, size, skip, step, skipAngles) {
    var this$1 = this;
    var divs = this.intervals(size, skip, step, skipAngles);
    var options2 = altAxis.options;
    var altAxisVisible = options2.visible && (options2.line || {}).visible !== false;
    return map(divs, function(d) {
      var alpha = this$1.intervalAngle(d);
      if (!altAxisVisible || alpha !== 90) {
        return alpha;
      }
    });
  }
};
var grid_lines_mixin_default = GridLinesMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-category-axis.js
var RadarCategoryAxis = function(CategoryAxis2) {
  function RadarCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2)
    RadarCategoryAxis2.__proto__ = CategoryAxis2;
  RadarCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  RadarCategoryAxis2.prototype.constructor = RadarCategoryAxis2;
  RadarCategoryAxis2.prototype.range = function range() {
    return { min: 0, max: this.options.categories.length };
  };
  RadarCategoryAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  RadarCategoryAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  RadarCategoryAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1 = this;
    var ref2 = this;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new box_default();
    for (var i = 0; i < labels.length; i++) {
      labels[i].reflow(measureBox);
      var labelBox = labels[i].box;
      labels[i].reflow(this$1.getSlot(skip + i * step).adjacentBox(
        0,
        labelBox.width(),
        labelBox.height()
      ));
    }
  };
  RadarCategoryAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0)
      skipAngles = false;
    var options2 = this.options;
    var categories = options2.categories.length;
    var divCount = categories / size || 1;
    var divAngle = 360 / divCount;
    var skip = skipOption || 0;
    var step = stepOption || 1;
    var divs = [];
    var angle = 0;
    for (var i = skip; i < divCount; i += step) {
      if (options2.reverse) {
        angle = 360 - i * divAngle;
      } else {
        angle = i * divAngle;
      }
      angle = round3(angle, COORD_PRECISION) % 360;
      if (!(skipAngles && inArray(angle, skipAngles))) {
        divs.push(angle);
      }
    }
    return divs;
  };
  RadarCategoryAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(1);
  };
  RadarCategoryAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(0.5);
  };
  RadarCategoryAxis2.prototype.intervalAngle = function intervalAngle(interval) {
    return (360 + interval + this.options.startAngle) % 360;
  };
  RadarCategoryAxis2.prototype.majorAngles = function majorAngles() {
    var this$1 = this;
    return map(this.majorIntervals(), function(interval) {
      return this$1.intervalAngle(interval);
    });
  };
  RadarCategoryAxis2.prototype.createLine = function createLine() {
    return [];
  };
  RadarCategoryAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);
  };
  RadarCategoryAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var ref2 = this.options;
    var minorGridLines = ref2.minorGridLines;
    var majorGridLines = ref2.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  RadarCategoryAxis2.prototype.radiusCallback = function radiusCallback(radius, altAxis, skipMajor) {
    if (altAxis.options.type !== ARC) {
      var minorAngle = rad2(360 / (this.options.categories.length * 2));
      var minorRadius = Math.cos(minorAngle) * radius;
      var majorAngles = this.majorAngles();
      var radiusCallback2 = function(angle) {
        if (!skipMajor && inArray(angle, majorAngles)) {
          return radius;
        }
        return minorRadius;
      };
      return radiusCallback2;
    }
  };
  RadarCategoryAxis2.prototype.createPlotBands = function createPlotBands() {
    var this$1 = this;
    var plotBands = this.options.plotBands || [];
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (var i = 0; i < plotBands.length; i++) {
      var band = plotBands[i];
      var slot = this$1.plotBandSlot(band);
      var singleSlot = this$1.getSlot(band.from);
      var head = band.from - Math.floor(band.from);
      slot.startAngle += head * singleSlot.angle;
      var tail = Math.ceil(band.to) - band.to;
      slot.angle -= (tail + head) * singleSlot.angle;
      var ring = shape_builder_default.current.createRing(slot, {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      });
      group.append(ring);
    }
    this.appendVisual(group);
  };
  RadarCategoryAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to - 1);
  };
  RadarCategoryAxis2.prototype.getSlot = function getSlot(from, to) {
    var options2 = this.options;
    var justified = options2.justified;
    var box = this.box;
    var divs = this.majorAngles();
    var totalDivs = divs.length;
    var slotAngle = 360 / totalDivs;
    var fromValue = from;
    if (options2.reverse && !justified) {
      fromValue = (fromValue + 1) % totalDivs;
    }
    fromValue = limitValue2(Math.floor(fromValue), 0, totalDivs - 1);
    var slotStart = divs[fromValue];
    if (justified) {
      slotStart = slotStart - slotAngle / 2;
      if (slotStart < 0) {
        slotStart += 360;
      }
    }
    var toValue = limitValue2(Math.ceil(to || fromValue), fromValue, totalDivs - 1);
    var slots = toValue - fromValue + 1;
    var angle = slotAngle * slots;
    return new ring_default(box.center(), 0, box.height() / 2, slotStart, angle);
  };
  RadarCategoryAxis2.prototype.slot = function slot(from, to) {
    var slot2 = this.getSlot(from, to);
    var startAngle = slot2.startAngle + 180;
    var endAngle = startAngle + slot2.angle;
    return new geometry_exports.Arc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  RadarCategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point2) {
    var this$1 = this;
    var length = this.options.categories.length;
    var index = null;
    for (var i = 0; i < length; i++) {
      var slot = this$1.getSlot(i);
      if (slot.containsPoint(point2)) {
        index = i;
        break;
      }
    }
    return index;
  };
  return RadarCategoryAxis2;
}(category_axis_default);
setDefaultOptions(RadarCategoryAxis, {
  startAngle: 90,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    visible: true
  },
  justified: true
});
deepExtend(RadarCategoryAxis.prototype, grid_lines_mixin_default);
var radar_category_axis_default = RadarCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/polar-axis.js
var PolarAxis = function(Axis2) {
  function PolarAxis2(options2, chartService) {
    Axis2.call(this, options2, chartService);
    var instanceOptions = this.options;
    instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;
  }
  if (Axis2)
    PolarAxis2.__proto__ = Axis2;
  PolarAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  PolarAxis2.prototype.constructor = PolarAxis2;
  PolarAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    return numeric_axis_default.prototype.getDivisions.call(this, stepValue) - 1;
  };
  PolarAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  PolarAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new box_default();
    var divs = this.intervals(options2.majorUnit, skip, step);
    for (var i = 0; i < labels.length; i++) {
      labels[i].reflow(measureBox);
      var labelBox = labels[i].box;
      labels[i].reflow(this$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));
    }
  };
  PolarAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  PolarAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0)
      skipAngles = false;
    var min3 = this.options.min;
    var divisions = this.getDivisions(size);
    var divs = [];
    var skip = skipOption || 0;
    var step = stepOption || 1;
    for (var i = skip; i < divisions; i += step) {
      var current4 = (360 + min3 + i * size) % 360;
      if (!(skipAngles && inArray(current4, skipAngles))) {
        divs.push(current4);
      }
    }
    return divs;
  };
  PolarAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(this.options.majorUnit);
  };
  PolarAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(this.options.minorUnit);
  };
  PolarAxis2.prototype.intervalAngle = function intervalAngle(i) {
    return (540 - i - this.options.startAngle) % 360;
  };
  PolarAxis2.prototype.createLine = function createLine() {
    return [];
  };
  PolarAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);
  };
  PolarAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(options2.majorUnit, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, options2.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  PolarAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to);
  };
  PolarAxis2.prototype.getSlot = function getSlot(a, b) {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var startAngle = options2.startAngle;
    var start = limitValue2(a, options2.min, options2.max);
    var end = limitValue2(b || start, start, options2.max);
    if (options2.reverse) {
      start *= -1;
      end *= -1;
    }
    start = (540 - start - startAngle) % 360;
    end = (540 - end - startAngle) % 360;
    if (end < start) {
      var tmp = start;
      start = end;
      end = tmp;
    }
    return new ring_default(box.center(), 0, box.height() / 2, start, end - start);
  };
  PolarAxis2.prototype.slot = function slot(from, to) {
    if (to === void 0)
      to = from;
    var options2 = this.options;
    var start = 360 - options2.startAngle;
    var slot2 = this.getSlot(from, to);
    var min3 = Math.min(from, to);
    var max2 = Math.max(from, to);
    var startAngle, endAngle;
    if (options2.reverse) {
      startAngle = min3;
      endAngle = max2;
    } else {
      startAngle = 360 - max2;
      endAngle = 360 - min3;
    }
    startAngle = (startAngle + start) % 360;
    endAngle = (endAngle + start) % 360;
    return new geometry_exports.Arc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  PolarAxis2.prototype.getValue = function getValue(point2) {
    var options2 = this.options;
    var center = this.box.center();
    var dx = point2.x - center.x;
    var dy = point2.y - center.y;
    var theta = Math.round(deg2(Math.atan2(dy, dx)));
    var start = options2.startAngle;
    if (!options2.reverse) {
      theta *= -1;
      start *= -1;
    }
    return (theta + start + 360) % 360;
  };
  PolarAxis2.prototype.valueRange = function valueRange3() {
    return {
      min: 0,
      max: Math.PI * 2
    };
  };
  return PolarAxis2;
}(axis_default);
setDefaultOptions(PolarAxis, {
  type: "polar",
  startAngle: 0,
  reverse: false,
  majorUnit: 60,
  min: 0,
  max: 360,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    color: BLACK,
    visible: true,
    width: 1
  },
  minorGridLines: {
    color: "#aaa"
  }
});
deepExtend(PolarAxis.prototype, grid_lines_mixin_default, {
  createPlotBands: radar_category_axis_default.prototype.createPlotBands,
  majorAngles: radar_category_axis_default.prototype.majorAngles,
  range: numeric_axis_default.prototype.range,
  labelsCount: numeric_axis_default.prototype.labelsCount,
  createAxisLabel: numeric_axis_default.prototype.createAxisLabel
});
var polar_axis_default = PolarAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/radar-numeric-axis-mixin.js
var RadarNumericAxisMixin = {
  options: {
    majorGridLines: {
      visible: true
    }
  },
  createPlotBands: function() {
    var this$1 = this;
    var ref2 = this.options;
    var type = ref2.majorGridLines.type;
    var plotBands = ref2.plotBands;
    if (plotBands === void 0)
      plotBands = [];
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (var i = 0; i < plotBands.length; i++) {
      var band = plotBands[i];
      var bandStyle = {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      };
      var slot = this$1.getSlot(band.from, band.to, true);
      var ring = new ring_default(center, center.y - slot.y2, center.y - slot.y1, 0, 360);
      var shape2 = void 0;
      if (type === ARC) {
        shape2 = shape_builder_default.current.createRing(ring, bandStyle);
      } else {
        shape2 = drawing_exports.Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();
      }
      group.append(shape2);
    }
    this.appendVisual(group);
  },
  plotBandPoints: function(ring, angles) {
    var innerPoints = [];
    var outerPoints = [];
    var center = [ring.center.x, ring.center.y];
    var innerCircle = new geometry_exports.Circle(center, ring.innerRadius);
    var outerCircle = new geometry_exports.Circle(center, ring.radius);
    for (var i = 0; i < angles.length; i++) {
      innerPoints.push(innerCircle.pointAt(angles[i] + 180));
      outerPoints.push(outerCircle.pointAt(angles[i] + 180));
    }
    innerPoints.reverse();
    innerPoints.push(innerPoints[0]);
    outerPoints.push(outerPoints[0]);
    return outerPoints.concat(innerPoints);
  },
  createGridLines: function(altAxis) {
    var options2 = this.options;
    var majorTicks = this.radarMajorGridLinePositions();
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var gridLines = [];
    if (options2.majorGridLines.visible) {
      gridLines = this.renderGridLines(
        center,
        majorTicks,
        majorAngles,
        options2.majorGridLines
      );
    }
    if (options2.minorGridLines.visible) {
      var minorTicks = this.radarMinorGridLinePositions();
      append2(gridLines, this.renderGridLines(
        center,
        minorTicks,
        majorAngles,
        options2.minorGridLines
      ));
    }
    return gridLines;
  },
  renderGridLines: function(center, ticks, angles, options2) {
    var style = {
      stroke: {
        width: options2.width,
        color: options2.color,
        dashType: options2.dashType
      }
    };
    var skip = options2.skip;
    if (skip === void 0)
      skip = 0;
    var step = options2.step;
    if (step === void 0)
      step = 0;
    var container = this.gridLinesVisual();
    for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {
      var tickRadius = center.y - ticks[tickIx];
      if (tickRadius > 0) {
        var circle = new geometry_exports.Circle([center.x, center.y], tickRadius);
        if (options2.type === ARC) {
          container.append(new drawing_exports.Circle(circle, style));
        } else {
          var line = new drawing_exports.Path(style);
          for (var angleIx = 0; angleIx < angles.length; angleIx++) {
            line.lineTo(circle.pointAt(angles[angleIx] + 180));
          }
          line.close();
          container.append(line);
        }
      }
    }
    return container.children;
  },
  getValue: function(point2) {
    var lineBox = this.lineBox();
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var radius = point2.distanceTo(center);
    var distance = radius;
    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {
      var dx = point2.x - center.x;
      var dy = point2.y - center.y;
      var theta = (deg2(Math.atan2(dy, dx)) + 540) % 360;
      majorAngles.sort(function(a, b) {
        return angularDistance(a, theta) - angularDistance(b, theta);
      });
      var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;
      var alpha = angularDistance(theta, majorAngles[0]);
      var gamma = 90 - midAngle;
      var beta = 180 - alpha - gamma;
      distance = radius * (Math.sin(rad2(beta)) / Math.sin(rad2(gamma)));
    }
    return this.axisType().prototype.getValue.call(
      this,
      new point_default2(lineBox.x1, lineBox.y2 - distance)
    );
  }
};
function angularDistance(a, b) {
  return 180 - Math.abs(Math.abs(a - b) - 180);
}
var radar_numeric_axis_mixin_default = RadarNumericAxisMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-numeric-axis.js
var RadarNumericAxis = function(NumericAxis2) {
  function RadarNumericAxis2() {
    NumericAxis2.apply(this, arguments);
  }
  if (NumericAxis2)
    RadarNumericAxis2.__proto__ = NumericAxis2;
  RadarNumericAxis2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadarNumericAxis2.prototype.constructor = RadarNumericAxis2;
  RadarNumericAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  RadarNumericAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var options2 = this.options;
    var minorSkipStep = 0;
    if (options2.majorGridLines.visible) {
      minorSkipStep = options2.majorUnit;
    }
    return this.getTickPositions(options2.minorUnit, minorSkipStep);
  };
  RadarNumericAxis2.prototype.axisType = function axisType() {
    return NumericAxis2;
  };
  return RadarNumericAxis2;
}(numeric_axis_default);
deepExtend(RadarNumericAxis.prototype, radar_numeric_axis_mixin_default);
var radar_numeric_axis_default = RadarNumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/radar-logarithmic-axis.js
var RadarLogarithmicAxis = function(LogarithmicAxis2) {
  function RadarLogarithmicAxis2() {
    LogarithmicAxis2.apply(this, arguments);
  }
  if (LogarithmicAxis2)
    RadarLogarithmicAxis2.__proto__ = LogarithmicAxis2;
  RadarLogarithmicAxis2.prototype = Object.create(LogarithmicAxis2 && LogarithmicAxis2.prototype);
  RadarLogarithmicAxis2.prototype.constructor = RadarLogarithmicAxis2;
  RadarLogarithmicAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    var positions = [];
    this.traverseMajorTicksPositions(function(position3) {
      positions.push(position3);
    }, this.options.majorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var positions = [];
    this.traverseMinorTicksPositions(function(position3) {
      positions.push(position3);
    }, this.options.minorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.axisType = function axisType() {
    return LogarithmicAxis2;
  };
  return RadarLogarithmicAxis2;
}(logarithmic_axis_default);
deepExtend(RadarLogarithmicAxis.prototype, radar_numeric_axis_mixin_default);
var radar_logarithmic_axis_default = RadarLogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/curve-processor.js
var WEIGHT2 = 0.333;
var EXTREMUM_ALLOWED_DEVIATION2 = 0.01;
var CurveProcessor = function(Class3) {
  function CurveProcessor2(closed) {
    Class3.call(this);
    this.closed = closed;
  }
  if (Class3)
    CurveProcessor2.__proto__ = Class3;
  CurveProcessor2.prototype = Object.create(Class3 && Class3.prototype);
  CurveProcessor2.prototype.constructor = CurveProcessor2;
  CurveProcessor2.prototype.process = function process2(dataPoints) {
    var this$1 = this;
    var points3 = dataPoints.slice(0);
    var segments = [];
    var closed = this.closed;
    var length = points3.length;
    if (length > 2) {
      this.removeDuplicates(0, points3);
      length = points3.length;
    }
    if (length < 2 || length === 2 && points3[0].equals(points3[1])) {
      return segments;
    }
    var p0 = points3[0];
    var p1 = points3[1];
    var p2 = points3[2];
    segments.push(new geometry_exports.Segment(p0));
    while (p0.equals(points3[length - 1])) {
      closed = true;
      points3.pop();
      length--;
    }
    if (length === 2) {
      var tangent = this.tangent(p0, p1, X, Y);
      last2(segments).controlOut(
        this.firstControlPoint(tangent, p0, p1, X, Y)
      );
      segments.push(new geometry_exports.Segment(
        p1,
        this.secondControlPoint(tangent, p0, p1, X, Y)
      ));
      return segments;
    }
    var initialControlPoint, lastControlPoint;
    if (closed) {
      p0 = points3[length - 1];
      p1 = points3[0];
      p2 = points3[1];
      var controlPoints = this.controlPoints(p0, p1, p2);
      initialControlPoint = controlPoints[1];
      lastControlPoint = controlPoints[0];
    } else {
      var tangent$1 = this.tangent(p0, p1, X, Y);
      initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);
    }
    var cp0 = initialControlPoint;
    for (var idx = 0; idx <= length - 3; idx++) {
      this$1.removeDuplicates(idx, points3);
      length = points3.length;
      if (idx + 3 <= length) {
        p0 = points3[idx];
        p1 = points3[idx + 1];
        p2 = points3[idx + 2];
        var controlPoints$1 = this$1.controlPoints(p0, p1, p2);
        last2(segments).controlOut(cp0);
        cp0 = controlPoints$1[1];
        var cp1 = controlPoints$1[0];
        segments.push(new geometry_exports.Segment(p1, cp1));
      }
    }
    if (closed) {
      p0 = points3[length - 2];
      p1 = points3[length - 1];
      p2 = points3[0];
      var controlPoints$2 = this.controlPoints(p0, p1, p2);
      last2(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p1,
        controlPoints$2[0]
      ));
      last2(segments).controlOut(controlPoints$2[1]);
      segments.push(new geometry_exports.Segment(
        p2,
        lastControlPoint
      ));
    } else {
      var tangent$2 = this.tangent(p1, p2, X, Y);
      last2(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p2,
        this.secondControlPoint(tangent$2, p1, p2, X, Y)
      ));
    }
    return segments;
  };
  CurveProcessor2.prototype.removeDuplicates = function removeDuplicates2(idx, points3) {
    while (points3[idx + 1] && (points3[idx].equals(points3[idx + 1]) || points3[idx + 1].equals(points3[idx + 2]))) {
      points3.splice(idx + 1, 1);
    }
  };
  CurveProcessor2.prototype.invertAxis = function invertAxis2(p0, p1, p2) {
    var invertAxis3 = false;
    if (p0.x === p1.x) {
      invertAxis3 = true;
    } else if (p1.x === p2.x) {
      if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
        invertAxis3 = true;
      }
    } else {
      var fn = this.lineFunction(p0, p1);
      var y2 = this.calculateFunction(fn, p2.x);
      if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
        invertAxis3 = true;
      }
    }
    return invertAxis3;
  };
  CurveProcessor2.prototype.isLine = function isLine2(p0, p1, p2) {
    var fn = this.lineFunction(p0, p1);
    var y2 = this.calculateFunction(fn, p2.x);
    return p0.x === p1.x && p1.x === p2.x || round3(y2, 1) === round3(p2.y, 1);
  };
  CurveProcessor2.prototype.lineFunction = function lineFunction2(p1, p2) {
    var a = (p2.y - p1.y) / (p2.x - p1.x);
    var b = p1.y - a * p1.x;
    return [b, a];
  };
  CurveProcessor2.prototype.controlPoints = function controlPoints(p0, p1, p2) {
    var xField = X;
    var yField = Y;
    var restrict = false;
    var switchOrientation = false;
    var tangent;
    if (this.isLine(p0, p1, p2)) {
      tangent = this.tangent(p0, p1, X, Y);
    } else {
      var monotonic = {
        x: this.isMonotonicByField(p0, p1, p2, X),
        y: this.isMonotonicByField(p0, p1, p2, Y)
      };
      if (monotonic.x && monotonic.y) {
        tangent = this.tangent(p0, p2, X, Y);
        restrict = true;
      } else {
        if (this.invertAxis(p0, p1, p2)) {
          xField = Y;
          yField = X;
        }
        if (monotonic[xField]) {
          tangent = 0;
        } else {
          var sign;
          if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
            sign = numberSign3((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
          } else {
            sign = -numberSign3((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
          }
          tangent = EXTREMUM_ALLOWED_DEVIATION2 * sign;
          switchOrientation = true;
        }
      }
    }
    var secondControlPoint2 = this.secondControlPoint(tangent, p0, p1, xField, yField);
    if (switchOrientation) {
      var oldXField = xField;
      xField = yField;
      yField = oldXField;
    }
    var firstControlPoint2 = this.firstControlPoint(tangent, p1, p2, xField, yField);
    if (restrict) {
      this.restrictControlPoint(p0, p1, secondControlPoint2, tangent);
      this.restrictControlPoint(p1, p2, firstControlPoint2, tangent);
    }
    return [secondControlPoint2, firstControlPoint2];
  };
  CurveProcessor2.prototype.restrictControlPoint = function restrictControlPoint2(p1, p2, cp, tangent) {
    if (p1.y < p2.y) {
      if (p2.y < cp.y) {
        cp.x = p1.x + (p2.y - p1.y) / tangent;
        cp.y = p2.y;
      } else if (cp.y < p1.y) {
        cp.x = p2.x - (p2.y - p1.y) / tangent;
        cp.y = p1.y;
      }
    } else {
      if (cp.y < p2.y) {
        cp.x = p1.x - (p1.y - p2.y) / tangent;
        cp.y = p2.y;
      } else if (p1.y < cp.y) {
        cp.x = p2.x + (p1.y - p2.y) / tangent;
        cp.y = p1.y;
      }
    }
  };
  CurveProcessor2.prototype.tangent = function tangent(p0, p1, xField, yField) {
    var x = p1[xField] - p0[xField];
    var y = p1[yField] - p0[yField];
    var tangent2;
    if (x === 0) {
      tangent2 = 0;
    } else {
      tangent2 = y / x;
    }
    return tangent2;
  };
  CurveProcessor2.prototype.isMonotonicByField = function isMonotonicByField2(p0, p1, p2, field) {
    return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
  };
  CurveProcessor2.prototype.firstControlPoint = function firstControlPoint2(tangent, p0, p3, xField, yField) {
    var t1 = p0[xField];
    var t2 = p3[xField];
    var distance = (t2 - t1) * WEIGHT2;
    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.secondControlPoint = function secondControlPoint2(tangent, p0, p3, xField, yField) {
    var t1 = p0[xField];
    var t2 = p3[xField];
    var distance = (t2 - t1) * WEIGHT2;
    return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.point = function point2(xValue, yValue, xField, yField) {
    var controlPoint = new geometry_exports.Point();
    controlPoint[xField] = xValue;
    controlPoint[yField] = yValue;
    return controlPoint;
  };
  CurveProcessor2.prototype.calculateFunction = function calculateFunction2(fn, x) {
    var length = fn.length;
    var result = 0;
    for (var i = 0; i < length; i++) {
      result += Math.pow(x, i) * fn[i];
    }
    return result;
  };
  return CurveProcessor2;
}(class_default);
function numberSign3(value) {
  return value <= 0 ? -1 : 1;
}
var curve_processor_default = CurveProcessor;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-axis.js
var ChartAxis = function(Class3) {
  function ChartAxis2(axis) {
    Class3.call(this);
    this._axis = axis;
    this.options = axis.options;
  }
  if (Class3)
    ChartAxis2.__proto__ = Class3;
  ChartAxis2.prototype = Object.create(Class3 && Class3.prototype);
  ChartAxis2.prototype.constructor = ChartAxis2;
  ChartAxis2.prototype.value = function value(point2) {
    var axis = this._axis;
    var value2 = axis.getCategory ? axis.getCategory(point2) : axis.getValue(point2);
    return value2;
  };
  ChartAxis2.prototype.slot = function slot(from, to, limit) {
    if (limit === void 0)
      limit = true;
    return this._axis.slot(from, to, limit);
  };
  ChartAxis2.prototype.range = function range() {
    return this._axis.range();
  };
  ChartAxis2.prototype.valueRange = function valueRange3() {
    return this._axis.valueRange();
  };
  return ChartAxis2;
}(class_default);
var chart_axis_default = ChartAxis;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/find-axis-by-name.js
function findAxisByName(name2, axes) {
  for (var idx = 0; idx < axes.length; idx++) {
    if (axes[idx].options.name === name2) {
      axes[idx].prepareUserOptions();
      return new chart_axis_default(axes[idx]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-pane.js
var ChartPane = function ChartPane2(pane) {
  this.visual = pane.visual;
  this.chartsVisual = pane.chartContainer.visual;
  this._pane = pane;
};
ChartPane.prototype.findAxisByName = function findAxisByName$1(name2) {
  return findAxisByName(name2, this._pane.axes);
};
var chart_pane_default = ChartPane;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-plotarea.js
var ChartPlotArea = function(Class3) {
  function ChartPlotArea2(plotArea) {
    Class3.call(this);
    this._plotArea = plotArea;
    this.visual = plotArea.visual;
    this.backgroundVisual = plotArea._bgVisual;
  }
  if (Class3)
    ChartPlotArea2.__proto__ = Class3;
  ChartPlotArea2.prototype = Object.create(Class3 && Class3.prototype);
  ChartPlotArea2.prototype.constructor = ChartPlotArea2;
  return ChartPlotArea2;
}(class_default);
var chart_plotarea_default = ChartPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/count-numbers.js
function countNumbers(values5) {
  var length = values5.length;
  var count = 0;
  for (var i = 0; i < length; i++) {
    var num = values5[i];
    if (isNumber2(num)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/aggregates.js
var Aggregates = {
  min: function(values5) {
    var length = values5.length;
    var min3 = MAX_VALUE;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (isNumber2(value)) {
        min3 = Math.min(min3, value);
      }
    }
    return min3 === MAX_VALUE ? values5[0] : min3;
  },
  max: function(values5) {
    var length = values5.length;
    var max2 = MIN_VALUE;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (isNumber2(value)) {
        max2 = Math.max(max2, value);
      }
    }
    return max2 === MIN_VALUE ? values5[0] : max2;
  },
  sum: function(values5) {
    var length = values5.length;
    var sum = 0;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (isNumber2(value)) {
        sum += value;
      }
    }
    return sum;
  },
  sumOrNull: function(values5) {
    var result = null;
    if (countNumbers(values5)) {
      result = Aggregates.sum(values5);
    }
    return result;
  },
  count: function(values5) {
    var length = values5.length;
    var count = 0;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (value !== null && defined2(value)) {
        count++;
      }
    }
    return count;
  },
  avg: function(values5) {
    var count = countNumbers(values5);
    var result = values5[0];
    if (count > 0) {
      result = Aggregates.sum(values5) / count;
    }
    return result;
  },
  first: function(values5) {
    var length = values5.length;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (value !== null && defined2(value)) {
        return value;
      }
    }
    return values5[0];
  }
};
var aggregates_default = Aggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/get-field.js
function getField(field, row) {
  if (row === null) {
    return row;
  }
  var get2 = getter(field, true);
  return get2(row);
}

// node_modules/@progress/kendo-charts/dist/es/chart/series-binder.js
var SeriesBinder = function(Class3) {
  function SeriesBinder2() {
    Class3.call(this);
    this._valueFields = {};
    this._otherFields = {};
    this._nullValue = {};
    this._undefinedValue = {};
  }
  if (Class3)
    SeriesBinder2.__proto__ = Class3;
  SeriesBinder2.prototype = Object.create(Class3 && Class3.prototype);
  SeriesBinder2.prototype.constructor = SeriesBinder2;
  SeriesBinder2.prototype.register = function register4(seriesTypes, valueFields, otherFields) {
    var this$1 = this;
    if (valueFields === void 0)
      valueFields = [VALUE];
    if (otherFields === void 0)
      otherFields = {};
    for (var i = 0; i < seriesTypes.length; i++) {
      var type = seriesTypes[i];
      this$1._valueFields[type] = valueFields;
      this$1._otherFields[type] = otherFields;
      this$1._nullValue[type] = this$1._makeValue(valueFields, null);
      this$1._undefinedValue[type] = this$1._makeValue(valueFields, void 0);
    }
  };
  SeriesBinder2.prototype.canonicalFields = function canonicalFields(series) {
    return this.valueFields(series).concat(this.otherFields(series));
  };
  SeriesBinder2.prototype.valueFields = function valueFields(series) {
    return this._valueFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.otherFields = function otherFields(series) {
    return this._otherFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.bindPoint = function bindPoint(series, pointIx, item) {
    var data = series.data;
    var pointData = defined2(item) ? item : data[pointIx];
    var result = { valueFields: { value: pointData } };
    var valueFields = this.valueFields(series);
    var otherFields = this._otherFields[series.type];
    var fields, value;
    if (pointData === null) {
      value = this._nullValue[series.type];
    } else if (!defined2(pointData)) {
      value = this._undefinedValue[series.type];
    } else if (Array.isArray(pointData)) {
      var fieldData = pointData.slice(valueFields.length);
      value = this._bindFromArray(pointData, valueFields);
      fields = this._bindFromArray(fieldData, otherFields);
    } else if (typeof pointData === "object") {
      var srcValueFields = this.sourceFields(series, valueFields);
      var srcPointFields = this.sourceFields(series, otherFields);
      value = this._bindFromObject(pointData, valueFields, srcValueFields);
      fields = this._bindFromObject(pointData, otherFields, srcPointFields);
    }
    if (defined2(value)) {
      if (valueFields.length === 1) {
        result.valueFields.value = value[valueFields[0]];
      } else {
        result.valueFields = value;
      }
    }
    result.fields = fields || {};
    return result;
  };
  SeriesBinder2.prototype._makeValue = function _makeValue(fields, initialValue) {
    var value = {};
    var length = fields.length;
    for (var i = 0; i < length; i++) {
      var fieldName = fields[i];
      value[fieldName] = initialValue;
    }
    return value;
  };
  SeriesBinder2.prototype._bindFromArray = function _bindFromArray(array, fields) {
    var value = {};
    if (fields) {
      var length = Math.min(fields.length, array.length);
      for (var i = 0; i < length; i++) {
        value[fields[i]] = array[i];
      }
    }
    return value;
  };
  SeriesBinder2.prototype._bindFromObject = function _bindFromObject(object2, fields, srcFields) {
    if (srcFields === void 0)
      srcFields = fields;
    var value = {};
    if (fields) {
      var length = fields.length;
      for (var i = 0; i < length; i++) {
        var fieldName = fields[i];
        var srcFieldName = srcFields[i];
        if (srcFieldName !== null) {
          value[fieldName] = getField(srcFieldName, object2);
        }
      }
    }
    return value;
  };
  SeriesBinder2.prototype.sourceFields = function sourceFields(series, canonicalFields) {
    var sourceFields2 = [];
    if (canonicalFields) {
      var length = canonicalFields.length;
      for (var i = 0; i < length; i++) {
        var fieldName = canonicalFields[i];
        var sourceFieldName = fieldName === VALUE ? "field" : fieldName + "Field";
        sourceFields2.push(series[sourceFieldName] !== null ? series[sourceFieldName] || fieldName : null);
      }
    }
    return sourceFields2;
  };
  return SeriesBinder2;
}(class_default);
SeriesBinder.current = new SeriesBinder();
var series_binder_default = SeriesBinder;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-range-calculator.js
var STD_ERR = "stderr";
var STD_DEV = "stddev";
var percentRegex = /percent(?:\w*)\((\d+)\)/;
var standardDeviationRegex = new RegExp("^" + STD_DEV + "(?:\\((\\d+(?:\\.\\d+)?)\\))?$");
var ErrorRangeCalculator = function(Class3) {
  function ErrorRangeCalculator2(errorValue, series, field) {
    Class3.call(this);
    this.initGlobalRanges(errorValue, series, field);
  }
  if (Class3)
    ErrorRangeCalculator2.__proto__ = Class3;
  ErrorRangeCalculator2.prototype = Object.create(Class3 && Class3.prototype);
  ErrorRangeCalculator2.prototype.constructor = ErrorRangeCalculator2;
  ErrorRangeCalculator2.prototype.initGlobalRanges = function initGlobalRanges(errorValue, series, field) {
    var data = series.data;
    var deviationMatch = standardDeviationRegex.exec(errorValue);
    if (deviationMatch) {
      this.valueGetter = this.createValueGetter(series, field);
      var average = this.getAverage(data);
      var deviation = this.getStandardDeviation(data, average, false);
      var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;
      var errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };
      this.globalRange = function() {
        return errorRange;
      };
    } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {
      this.valueGetter = this.createValueGetter(series, field);
      var standardError = this.getStandardError(data, this.getAverage(data));
      this.globalRange = function(value) {
        return { low: value - standardError, high: value + standardError };
      };
    }
  };
  ErrorRangeCalculator2.prototype.createValueGetter = function createValueGetter(series, field) {
    var data = series.data;
    var binder = series_binder_default.current;
    var valueFields = binder.valueFields(series);
    var item = defined2(data[0]) ? data[0] : {};
    var valueGetter;
    if (isArray(item)) {
      var index = field ? valueFields.indexOf(field) : 0;
      valueGetter = getter("[" + index + "]");
    } else if (isNumber2(item)) {
      valueGetter = getter();
    } else if (typeof item === OBJECT) {
      var srcValueFields = binder.sourceFields(series, valueFields);
      valueGetter = getter(srcValueFields[valueFields.indexOf(field)]);
    }
    return valueGetter;
  };
  ErrorRangeCalculator2.prototype.getErrorRange = function getErrorRange(pointValue, errorValue) {
    var low, high, value;
    if (!defined2(errorValue)) {
      return null;
    }
    if (this.globalRange) {
      return this.globalRange(pointValue);
    }
    if (isArray(errorValue)) {
      low = pointValue - errorValue[0];
      high = pointValue + errorValue[1];
    } else if (isNumber2(value = parseFloat(errorValue))) {
      low = pointValue - value;
      high = pointValue + value;
    } else if (value = percentRegex.exec(errorValue)) {
      var percentValue = pointValue * (parseFloat(value[1]) / 100);
      low = pointValue - Math.abs(percentValue);
      high = pointValue + Math.abs(percentValue);
    } else {
      throw new Error("Invalid ErrorBar value: " + errorValue);
    }
    return { low, high };
  };
  ErrorRangeCalculator2.prototype.getStandardError = function getStandardError(data, average) {
    return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);
  };
  ErrorRangeCalculator2.prototype.getStandardDeviation = function getStandardDeviation(data, average, isSample) {
    var this$1 = this;
    var length = data.length;
    var total3 = isSample ? average.count - 1 : average.count;
    var squareDifferenceSum = 0;
    for (var idx = 0; idx < length; idx++) {
      var value = this$1.valueGetter(data[idx]);
      if (isNumber2(value)) {
        squareDifferenceSum += Math.pow(value - average.value, 2);
      }
    }
    return Math.sqrt(squareDifferenceSum / total3);
  };
  ErrorRangeCalculator2.prototype.getAverage = function getAverage(data) {
    var this$1 = this;
    var length = data.length;
    var sum = 0;
    var count = 0;
    for (var idx = 0; idx < length; idx++) {
      var value = this$1.valueGetter(data[idx]);
      if (isNumber2(value)) {
        sum += value;
        count++;
      }
    }
    return {
      value: sum / count,
      count
    };
  };
  return ErrorRangeCalculator2;
}(class_default);
var error_range_calculator_default = ErrorRangeCalculator;

// node_modules/@progress/kendo-charts/dist/es/chart/constants.js
var browser4 = support_default.browser || {};
var INITIAL_ANIMATION_DURATION = 600;
var FADEIN = "fadeIn";
var BORDER_BRIGHTNESS = 0.8;
var TOOLTIP_OFFSET = 5;
var START_SCALE = browser4.msie ? 1e-3 : 0;
var ERROR_LOW_FIELD = "errorLow";
var ERROR_HIGH_FIELD = "errorHigh";
var X_ERROR_LOW_FIELD = "xErrorLow";
var X_ERROR_HIGH_FIELD = "xErrorHigh";
var Y_ERROR_LOW_FIELD = "yErrorLow";
var Y_ERROR_HIGH_FIELD = "yErrorHigh";
var LINE_MARKER_SIZE = 8;
var ZERO2 = "zero";
var INTERPOLATE = "interpolate";
var GAP = "gap";
var ABOVE = "above";
var BELOW = "below";
var SMOOTH = "smooth";
var STEP = "step";
var AREA = "area";
var BAR = "bar";
var BOX_PLOT = "boxPlot";
var BUBBLE = "bubble";
var BULLET = "bullet";
var CANDLESTICK = "candlestick";
var COLUMN = "column";
var DONUT = "donut";
var FUNNEL = "funnel";
var HEATMAP = "heatmap";
var HORIZONTAL_WATERFALL = "horizontalWaterfall";
var LINE = "line";
var OHLC = "ohlc";
var PIE = "pie";
var POLAR_AREA = "polarArea";
var POLAR_LINE = "polarLine";
var POLAR_SCATTER = "polarScatter";
var RADAR_AREA = "radarArea";
var RADAR_COLUMN = "radarColumn";
var RADAR_LINE = "radarLine";
var RANGE_AREA = "rangeArea";
var RANGE_BAR = "rangeBar";
var RANGE_COLUMN = "rangeColumn";
var SCATTER = "scatter";
var SCATTER_LINE = "scatterLine";
var VERTICAL_AREA = "verticalArea";
var VERTICAL_BOX_PLOT = "verticalBoxPlot";
var VERTICAL_BULLET = "verticalBullet";
var VERTICAL_LINE = "verticalLine";
var VERTICAL_RANGE_AREA = "verticalRangeArea";
var WATERFALL = "waterfall";
var EQUALLY_SPACED_SERIES = [
  BAR,
  COLUMN,
  OHLC,
  CANDLESTICK,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  BULLET,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL
];
var LEGEND_ITEM_CLICK = "legendItemClick";
var LEGEND_ITEM_HOVER = "legendItemHover";
var LEGEND_ITEM_LEAVE = "legendItemLeave";
var SERIES_CLICK = "seriesClick";
var SERIES_HOVER = "seriesHover";
var SERIES_OVER = "seriesOver";
var SERIES_LEAVE = "seriesLeave";
var PLOT_AREA_CLICK = "plotAreaClick";
var PLOT_AREA_HOVER = "plotAreaHover";
var PLOT_AREA_LEAVE = "plotAreaLeave";
var DRAG = "drag";
var DRAG_END = "dragEnd";
var DRAG_START = "dragStart";
var ZOOM_START = "zoomStart";
var ZOOM = "zoom";
var ZOOM_END = "zoomEnd";
var SELECT_START = "selectStart";
var SELECT = "select";
var SELECT_END = "selectEnd";
var RENDER = "render";
var SHOW_TOOLTIP = "showTooltip";
var HIDE_TOOLTIP = "hideTooltip";
var PANE_RENDER = "paneRender";
var LOGARITHMIC = "log";
var CATEGORY = "category";
var INSIDE_END = "insideEnd";
var INSIDE_BASE = "insideBase";
var OUTSIDE_END = "outsideEnd";
var MOUSEWHEEL = "wheel";
var MOUSEWHEEL_DELAY = 150;
var MOUSEWHEEL_ZOOM_RATE = 0.3;
var DRILLDOWN = "drilldown";
var DRILLDOWN_FIELD = "drilldown";

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-bar-base.js
var DEFAULT_ERROR_BAR_WIDTH = 4;
var ErrorBarBase = function(ChartElement2) {
  function ErrorBarBase2(low, high, isVertical, chart, series, options2) {
    ChartElement2.call(this, options2);
    this.low = low;
    this.high = high;
    this.isVertical = isVertical;
    this.chart = chart;
    this.series = series;
  }
  if (ChartElement2)
    ErrorBarBase2.__proto__ = ChartElement2;
  ErrorBarBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ErrorBarBase2.prototype.constructor = ErrorBarBase2;
  ErrorBarBase2.prototype.reflow = function reflow(targetBox) {
    var endCaps = this.options.endCaps;
    var isVertical = this.isVertical;
    var axis = this.getAxis();
    var valueBox = axis.getSlot(this.low, this.high);
    var centerBox = targetBox.center();
    var capsWidth = this.getCapsWidth(targetBox, isVertical);
    var capValue = isVertical ? centerBox.x : centerBox.y;
    var capStart = capValue - capsWidth;
    var capEnd = capValue + capsWidth;
    var linePoints;
    if (isVertical) {
      linePoints = [
        new point_default2(centerBox.x, valueBox.y1),
        new point_default2(centerBox.x, valueBox.y2)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default2(capStart, valueBox.y1),
          new point_default2(capEnd, valueBox.y1),
          new point_default2(capStart, valueBox.y2),
          new point_default2(capEnd, valueBox.y2)
        );
      }
      this.box = new box_default(capStart, valueBox.y1, capEnd, valueBox.y2);
    } else {
      linePoints = [
        new point_default2(valueBox.x1, centerBox.y),
        new point_default2(valueBox.x2, centerBox.y)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default2(valueBox.x1, capStart),
          new point_default2(valueBox.x1, capEnd),
          new point_default2(valueBox.x2, capStart),
          new point_default2(valueBox.x2, capEnd)
        );
      }
      this.box = new box_default(valueBox.x1, capStart, valueBox.x2, capEnd);
    }
    this.linePoints = linePoints;
  };
  ErrorBarBase2.prototype.getCapsWidth = function getCapsWidth(box, isVertical) {
    var boxSize = isVertical ? box.width() : box.height();
    var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;
    return capsWidth;
  };
  ErrorBarBase2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var options2 = this.options;
    var visual = options2.visual;
    if (visual) {
      this.visual = visual({
        low: this.low,
        high: this.high,
        rect: this.box.toRect(),
        sender: this.getSender(),
        options: {
          endCaps: options2.endCaps,
          color: options2.color,
          line: options2.line
        },
        createVisual: function() {
          this$1.createDefaultVisual();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      });
    } else {
      this.createDefaultVisual();
    }
  };
  ErrorBarBase2.prototype.createDefaultVisual = function createDefaultVisual() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var linePoints = ref2.linePoints;
    var lineOptions = {
      stroke: {
        color: options2.color,
        width: options2.line.width,
        dashType: options2.line.dashType
      }
    };
    ChartElement2.prototype.createVisual.call(this);
    for (var idx = 0; idx < linePoints.length; idx += 2) {
      var line = new drawing_exports.Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);
      alignPathToPixel(line);
      this$1.visual.append(line);
    }
  };
  return ErrorBarBase2;
}(chart_element_default);
setDefaultOptions(ErrorBarBase, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  endCaps: true,
  line: {
    width: 2
  },
  zIndex: 1
});
var error_bar_base_default = ErrorBarBase;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/categorical-error-bar.js
var CategoricalErrorBar = function(ErrorBarBase2) {
  function CategoricalErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2)
    CategoricalErrorBar2.__proto__ = ErrorBarBase2;
  CategoricalErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  CategoricalErrorBar2.prototype.constructor = CategoricalErrorBar2;
  CategoricalErrorBar2.prototype.getAxis = function getAxis() {
    var axis = this.chart.seriesValueAxis(this.series);
    return axis;
  };
  return CategoricalErrorBar2;
}(error_bar_base_default);
var categorical_error_bar_default = CategoricalErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/eval-options.js
var MAX_EXPAND_DEPTH = 5;
function evalOptions(options2, context2, state, dryRun) {
  if (state === void 0)
    state = {};
  if (dryRun === void 0)
    dryRun = false;
  var defaults = state.defaults = state.defaults || {};
  var depth = state.depth = state.depth || 0;
  var needsEval = false;
  state.excluded = state.excluded || [];
  if (depth > MAX_EXPAND_DEPTH) {
    return null;
  }
  for (var property in options2) {
    if (!inArray(property, state.excluded) && options2.hasOwnProperty(property)) {
      var propValue = options2[property];
      if (isFunction3(propValue)) {
        needsEval = true;
        if (!dryRun) {
          options2[property] = valueOrDefault2(propValue(context2), defaults[property]);
        }
      } else if (isObject(propValue)) {
        if (!dryRun) {
          state.defaults = defaults[property];
        }
        state.depth++;
        needsEval = evalOptions(propValue, context2, state, dryRun) || needsEval;
        state.depth--;
      }
    }
  }
  return needsEval;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/categories-count.js
function categoriesCount(series) {
  var seriesCount = series.length;
  var categories = 0;
  for (var i = 0; i < seriesCount; i++) {
    categories = Math.max(categories, series[i].data.length);
  }
  return categories;
}

// node_modules/@progress/kendo-charts/dist/es/chart/categorical-chart.js
var CategoricalChart = function(ChartElement2) {
  function CategoricalChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.categoryAxis = plotArea.seriesCategoryAxis(options2.series[0]);
    this.valueAxisRanges = {};
    this.points = [];
    this.categoryPoints = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
    this.render();
  }
  if (ChartElement2)
    CategoricalChart2.__proto__ = ChartElement2;
  CategoricalChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  CategoricalChart2.prototype.constructor = CategoricalChart2;
  CategoricalChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  CategoricalChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        vertical: !this.options.invertAxes
      }, series);
    }
    return options2;
  };
  CategoricalChart2.prototype.plotValue = function plotValue(point2) {
    if (!point2) {
      return 0;
    }
    if (this.options.isStacked100 && isNumber2(point2.value)) {
      var categoryIx = point2.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      var otherValues = [];
      var categorySum = 0;
      for (var i = 0; i < categoryPoints.length; i++) {
        var other = categoryPoints[i];
        if (other) {
          var stack2 = point2.series.stack;
          var otherStack = other.series.stack;
          if (stack2 && otherStack && stack2.group !== otherStack.group) {
            continue;
          }
          if (isNumber2(other.value)) {
            categorySum += Math.abs(other.value);
            otherValues.push(Math.abs(other.value));
          }
        }
      }
      if (categorySum > 0) {
        return point2.value / categorySum;
      }
    }
    return point2.value;
  };
  CategoricalChart2.prototype.plotRange = function plotRange(point2, startValue) {
    var this$1 = this;
    if (startValue === void 0)
      startValue = 0;
    var categoryPoints = this.categoryPoints[point2.categoryIx];
    if (this.options.isStacked) {
      var plotValue = this.plotValue(point2);
      var positive = plotValue >= 0;
      var prevValue = startValue;
      var isStackedBar = false;
      for (var i = 0; i < categoryPoints.length; i++) {
        var other = categoryPoints[i];
        if (point2 === other) {
          break;
        }
        var stack2 = point2.series.stack;
        var otherStack = other.series.stack;
        if (stack2 && otherStack) {
          if (typeof stack2 === STRING && stack2 !== otherStack) {
            continue;
          }
          if (stack2.group && stack2.group !== otherStack.group) {
            continue;
          }
        }
        var otherValue = this$1.plotValue(other);
        if (otherValue >= 0 && positive || otherValue < 0 && !positive) {
          prevValue += otherValue;
          plotValue += otherValue;
          isStackedBar = true;
          if (this$1.options.isStacked100) {
            plotValue = Math.min(plotValue, 1);
          }
        }
      }
      if (isStackedBar) {
        prevValue -= startValue;
      }
      return [prevValue, plotValue];
    }
    var series = point2.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, convertableToNumber(point2.value) ? point2.value : axisCrossingValue];
  };
  CategoricalChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var this$1 = this;
    var min3 = MAX_VALUE;
    var max2 = MIN_VALUE;
    for (var i = 0; i < this.categoryPoints.length; i++) {
      var categoryPoints = this$1.categoryPoints[i];
      if (!categoryPoints) {
        continue;
      }
      for (var pIx = 0; pIx < categoryPoints.length; pIx++) {
        var point2 = categoryPoints[pIx];
        if (point2) {
          if (point2.series.stack === stackName || point2.series.axis === axisName) {
            var to = this$1.plotRange(point2, 0)[1];
            if (defined2(to) && isFinite(to)) {
              max2 = Math.max(max2, to);
              min3 = Math.min(min3, to);
            }
          }
        }
      }
    }
    return { min: min3, max: max2 };
  };
  CategoricalChart2.prototype.updateStackRange = function updateStackRange() {
    var this$1 = this;
    var ref2 = this.options;
    var isStacked = ref2.isStacked;
    var chartSeries = ref2.series;
    var limitsCache = {};
    if (isStacked) {
      for (var i = 0; i < chartSeries.length; i++) {
        var series = chartSeries[i];
        var axisName = series.axis;
        var key = axisName + series.stack;
        var limits = limitsCache[key];
        if (!limits) {
          limits = this$1.stackLimits(axisName, series.stack);
          var errorTotals = this$1.errorTotals;
          if (errorTotals) {
            if (errorTotals.negative.length) {
              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);
            }
            if (errorTotals.positive.length) {
              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);
            }
          }
          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {
            limitsCache[key] = limits;
          } else {
            limits = null;
          }
        }
        if (limits) {
          this$1.valueAxisRanges[axisName] = limits;
        }
      }
    }
  };
  CategoricalChart2.prototype.addErrorBar = function addErrorBar(point2, data, categoryIx) {
    var value = point2.value;
    var series = point2.series;
    var seriesIx = point2.seriesIx;
    var errorBars = point2.options.errorBars;
    var lowValue = data.fields[ERROR_LOW_FIELD];
    var highValue = data.fields[ERROR_HIGH_FIELD];
    var errorRange;
    if (isNumber2(lowValue) && isNumber2(highValue)) {
      errorRange = { low: lowValue, high: highValue };
    } else if (errorBars && defined2(errorBars.value)) {
      this.seriesErrorRanges = this.seriesErrorRanges || [];
      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new error_range_calculator_default(errorBars.value, series, VALUE);
      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);
    }
    if (errorRange) {
      point2.low = errorRange.low;
      point2.high = errorRange.high;
      this.addPointErrorBar(point2, categoryIx);
    }
  };
  CategoricalChart2.prototype.addPointErrorBar = function addPointErrorBar(point2, categoryIx) {
    var isVertical = !this.options.invertAxes;
    var options2 = point2.options.errorBars;
    var series = point2.series;
    var low = point2.low;
    var high = point2.high;
    if (this.options.isStacked) {
      var stackedErrorRange = this.stackedErrorRange(point2, categoryIx);
      low = stackedErrorRange.low;
      high = stackedErrorRange.high;
    } else {
      var fields = { categoryIx, series };
      this.updateRange({ value: low }, fields);
      this.updateRange({ value: high }, fields);
    }
    var errorBar = new categorical_error_bar_default(low, high, isVertical, this, series, options2);
    point2.errorBars = [errorBar];
    point2.append(errorBar);
  };
  CategoricalChart2.prototype.stackedErrorRange = function stackedErrorRange(point2, categoryIx) {
    var plotValue = this.plotRange(point2, 0)[1] - point2.value;
    var low = point2.low + plotValue;
    var high = point2.high + plotValue;
    this.errorTotals = this.errorTotals || { positive: [], negative: [] };
    if (low < 0) {
      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);
    }
    if (high > 0) {
      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);
    }
    return { low, high };
  };
  CategoricalChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var categoryPoints = this.categoryPoints[categoryIx];
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    var seriesPoints = this.seriesPoints[seriesIx];
    if (!seriesPoints) {
      this.seriesPoints[seriesIx] = seriesPoints = [];
    }
    var point2 = this.createPoint(data, fields);
    if (point2) {
      Object.assign(point2, fields);
      point2.owner = this;
      point2.noteText = data.fields.noteText;
      if (!defined2(point2.dataItem)) {
        point2.dataItem = series.data[categoryIx];
      }
      this.addErrorBar(point2, data, categoryIx);
    }
    this.points.push(point2);
    seriesPoints.push(point2);
    categoryPoints.push(point2);
    this.updateRange(data.valueFields, fields);
  };
  CategoricalChart2.prototype.evalPointOptions = function evalPointOptions(options2, value, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "aggregate",
        "_events",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined2(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, pointOptions);
      evalOptions(pointOptions, {
        value,
        category,
        index: categoryIx,
        series,
        dataItem: series.data[categoryIx]
      }, state);
    }
    return pointOptions;
  };
  CategoricalChart2.prototype.updateRange = function updateRange(data, fields) {
    var axisName = fields.series.axis;
    var value = data.value;
    var axisRange = this.valueAxisRanges[axisName];
    if (isFinite(value) && value !== null) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, value);
      axisRange.max = Math.max(axisRange.max, value);
    }
  };
  CategoricalChart2.prototype.seriesValueAxis = function seriesValueAxis(series) {
    var plotArea = this.plotArea;
    var axisName = series.axis;
    var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;
    if (!axis) {
      throw new Error("Unable to locate value axis with name " + axisName);
    }
    return axis;
  };
  CategoricalChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var categorySlots = this.categorySlots = [];
    var chartPoints = this.points;
    var categoryAxis = this.categoryAxis;
    var pointIx = 0;
    this.traverseDataPoints(function(data, fields) {
      var categoryIx = fields.categoryIx;
      var currentSeries = fields.series;
      var valueAxis = this$1.seriesValueAxis(currentSeries);
      var point2 = chartPoints[pointIx++];
      var categorySlot = categorySlots[categoryIx];
      if (!categorySlot) {
        categorySlots[categoryIx] = categorySlot = this$1.categorySlot(categoryAxis, categoryIx, valueAxis);
      }
      if (point2) {
        var plotRange = this$1.plotRange(point2, valueAxis.startValue());
        var valueSlot = this$1.valueSlot(valueAxis, plotRange);
        if (valueSlot) {
          var pointSlot = this$1.pointSlot(categorySlot, valueSlot);
          point2.aboveAxis = this$1.aboveAxis(point2, valueAxis);
          point2.stackValue = plotRange[1];
          if (this$1.options.isStacked100) {
            point2.percentage = this$1.plotValue(point2);
          }
          this$1.reflowPoint(point2, pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.reflowCategories(categorySlots);
    if (!this.options.clip && this.options.limitPoints && this.points.length) {
      this.limitPoints();
    }
    this.box = targetBox;
  };
  CategoricalChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);
  };
  CategoricalChart2.prototype.limitPoints = function limitPoints() {
    var this$1 = this;
    var categoryPoints = this.categoryPoints;
    var points3 = categoryPoints[0].concat(last2(categoryPoints));
    for (var idx = 0; idx < points3.length; idx++) {
      if (points3[idx]) {
        this$1.limitPoint(points3[idx]);
      }
    }
  };
  CategoricalChart2.prototype.limitPoint = function limitPoint(point2) {
    var limittedSlot = this.categoryAxis.limitSlot(point2.box);
    if (!limittedSlot.equals(point2.box)) {
      point2.reflow(limittedSlot);
    }
  };
  CategoricalChart2.prototype.aboveAxis = function aboveAxis(point2, valueAxis) {
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    var value = point2.value;
    return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;
  };
  CategoricalChart2.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue(valueAxis) {
    var categoryAxis = this.categoryAxis;
    var options2 = valueAxis.options;
    var crossingValues = [].concat(
      options2.axisCrossingValues || options2.axisCrossingValue
    );
    return crossingValues[categoryAxis.axisIndex || 0] || 0;
  };
  CategoricalChart2.prototype.reflowPoint = function reflowPoint(point2, pointSlot) {
    point2.reflow(pointSlot);
  };
  CategoricalChart2.prototype.reflowCategories = function reflowCategories() {
  };
  CategoricalChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var options2 = this.options;
    var invertAxes = options2.invertAxes;
    var slotX = invertAxes ? valueSlot : categorySlot;
    var slotY = invertAxes ? categorySlot : valueSlot;
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  CategoricalChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  CategoricalChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var series = this.options.series;
    var count = categoriesCount(series);
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this$1._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);
    }
    for (var categoryIx = 0; categoryIx < count; categoryIx++) {
      for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {
        var currentSeries = series[seriesIx$1];
        var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);
        var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);
        callback(pointData, {
          category: currentCategory,
          categoryIx,
          categoriesCount: count,
          series: currentSeries,
          seriesIx: seriesIx$1
        });
      }
    }
    for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {
      this$1._outOfRangeCallback(series[seriesIx$2], "_outOfRangeMaxPoint", seriesIx$2, callback);
    }
  };
  CategoricalChart2.prototype._outOfRangeCallback = function _outOfRangeCallback(series, field, seriesIx, callback) {
    var outOfRangePoint = series[field];
    if (outOfRangePoint) {
      var categoryIx = outOfRangePoint.categoryIx;
      var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);
      callback(pointData, {
        category: outOfRangePoint.category,
        categoryIx,
        series,
        seriesIx,
        dataItem: outOfRangePoint.item
      });
    }
  };
  CategoricalChart2.prototype._bindPoint = function _bindPoint(series, seriesIx, categoryIx, item) {
    if (!this._bindCache) {
      this._bindCache = [];
    }
    var bindCache = this._bindCache[seriesIx];
    if (!bindCache) {
      bindCache = this._bindCache[seriesIx] = [];
    }
    var data = bindCache[categoryIx];
    if (!data) {
      data = bindCache[categoryIx] = series_binder_default.current.bindPoint(series, categoryIx, item);
    }
    return data;
  };
  CategoricalChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    if (point2.value === null) {
      return "";
    }
    return this.chartService.format.auto(format2, point2.value);
  };
  CategoricalChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields.value;
  };
  return CategoricalChart2;
}(chart_element_default);
setDefaultOptions(CategoricalChart, {
  series: [],
  invertAxes: false,
  isStacked: false,
  clip: true,
  limitPoints: true
});
var categorical_chart_default = CategoricalChart;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/point-events-mixin.js
var PointEventsMixin = {
  click: function(chart, e) {
    return chart.trigger(
      SERIES_CLICK,
      this.eventArgs(e)
    );
  },
  hover: function(chart, e) {
    return chart.trigger(
      SERIES_HOVER,
      this.eventArgs(e)
    );
  },
  over: function(chart, e) {
    return chart.trigger(
      SERIES_OVER,
      this.eventArgs(e)
    );
  },
  out: function(chart, e) {
    return chart.trigger(
      SERIES_LEAVE,
      this.eventArgs(e)
    );
  },
  eventArgs: function(e) {
    return {
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      category: this.category,
      series: this.series,
      dataItem: this.dataItem,
      runningTotal: this.runningTotal,
      total: this.total,
      element: eventElement2(e),
      originalEvent: e,
      point: this
    };
  }
};
var point_events_mixin_default = PointEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/note-mixin.js
var NoteMixin = {
  createNote: function() {
    var options2 = this.options.notes;
    var text = this.noteText || options2.label.text;
    if (options2.visible !== false && defined2(text) && text !== null) {
      this.note = new note_default({
        value: this.value,
        text,
        dataItem: this.dataItem,
        category: this.category,
        series: this.series
      }, this.options.notes, this.owner.chartService);
      this.append(this.note);
    }
  }
};
var note_mixin_default = NoteMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-point.js
var LinePoint = function(ChartElement2) {
  function LinePoint2(value, options2) {
    ChartElement2.call(this);
    this.value = value;
    this.options = options2;
    this.aboveAxis = valueOrDefault2(this.options.aboveAxis, true);
    this.tooltipTracking = true;
  }
  if (ChartElement2)
    LinePoint2.__proto__ = ChartElement2;
  LinePoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LinePoint2.prototype.constructor = LinePoint2;
  LinePoint2.prototype.render = function render() {
    var ref2 = this.options;
    var markers = ref2.markers;
    var labels = ref2.labels;
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    if (markers.visible && markers.size) {
      this.marker = this.createMarker();
      this.append(this.marker);
    }
    if (labels.visible) {
      var labelTemplate = getTemplate(labels);
      var pointData = this.pointData();
      var labelText = this.value;
      if (labelTemplate) {
        labelText = labelTemplate(pointData);
      } else if (labels.format) {
        labelText = this.formatValue(labels.format);
      }
      this.label = new text_box_default(
        labelText,
        deepExtend({
          align: CENTER,
          vAlign: CENTER,
          margin: {
            left: 5,
            right: 5
          },
          zIndex: valueOrDefault2(labels.zIndex, this.series.zIndex)
        }, labels),
        pointData
      );
      this.append(this.label);
    }
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  LinePoint2.prototype.markerBorder = function markerBorder() {
    var options2 = this.options.markers;
    var background = options2.background;
    var border = deepExtend({ color: this.color }, options2.border);
    if (!defined2(border.color)) {
      border.color = new color_default(background).brightness(BORDER_BRIGHTNESS).toHex();
    }
    return border;
  };
  LinePoint2.prototype.createVisual = function createVisual() {
  };
  LinePoint2.prototype.createMarker = function createMarker() {
    var options2 = this.options.markers;
    var marker = new shape_element_default({
      type: options2.type,
      width: options2.size,
      height: options2.size,
      rotation: options2.rotation,
      background: options2.background,
      border: this.markerBorder(),
      opacity: this.series.opacity || options2.opacity,
      zIndex: valueOrDefault2(options2.zIndex, this.series.zIndex),
      animation: options2.animation,
      visual: options2.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    return marker;
  };
  LinePoint2.prototype.markerBox = function markerBox() {
    if (!this.marker) {
      this.marker = this.createMarker();
      this.marker.reflow(this._childBox);
    }
    return this.marker.box;
  };
  LinePoint2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var aboveAxis = ref2.aboveAxis;
    var vertical = options2.vertical;
    this.render();
    this.box = targetBox;
    var childBox = targetBox.clone();
    if (vertical) {
      if (aboveAxis) {
        childBox.y1 -= childBox.height();
      } else {
        childBox.y2 += childBox.height();
      }
    } else {
      if (aboveAxis) {
        childBox.x1 += childBox.width();
      } else {
        childBox.x2 -= childBox.width();
      }
    }
    this._childBox = childBox;
    if (this.marker) {
      this.marker.reflow(childBox);
    }
    this.reflowLabel(childBox);
    if (this.errorBars) {
      for (var i = 0; i < this.errorBars.length; i++) {
        this$1.errorBars[i].reflow(childBox);
      }
    }
    if (this.note) {
      var noteTargetBox = this.markerBox();
      if (!(options2.markers.visible && options2.markers.size)) {
        var center = noteTargetBox.center();
        noteTargetBox = new box_default(center.x, center.y, center.x, center.y);
      }
      this.note.reflow(noteTargetBox);
    }
  };
  LinePoint2.prototype.reflowLabel = function reflowLabel(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var label = ref2.label;
    var anchor = options2.labels.position;
    if (label) {
      anchor = anchor === ABOVE ? TOP : anchor;
      anchor = anchor === BELOW ? BOTTOM : anchor;
      label.reflow(box);
      label.box.alignTo(this.markerBox(), anchor);
      label.reflow(label.box);
    }
  };
  LinePoint2.prototype.createHighlight = function createHighlight() {
    var markers = this.options.highlight.markers;
    var defaultColor = this.markerBorder().color;
    var options2 = this.options.markers;
    var size = options2.size + (options2.border.width || 0) + (markers.border.width || 0);
    var shadow = new shape_element_default({
      type: options2.type,
      width: size,
      height: size,
      rotation: options2.rotation,
      background: markers.color || defaultColor,
      border: {
        color: markers.border.color,
        width: markers.border.width,
        opacity: valueOrDefault2(markers.border.opacity, 1)
      },
      opacity: valueOrDefault2(markers.opacity, 1)
    });
    shadow.reflow(this._childBox);
    return shadow.getElement();
  };
  LinePoint2.prototype.highlightVisual = function highlightVisual() {
    return (this.marker || {}).visual;
  };
  LinePoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var marker = this.marker;
    var visual, rect;
    if (marker) {
      rect = marker.paddingBox.toRect();
      visual = marker.visual;
    } else {
      var size = this.options.markers.size;
      var halfSize = size / 2;
      var center = this.box.center();
      rect = new geometry_exports.Rect([center.x - halfSize, center.y - halfSize], [size, size]);
    }
    return {
      options: this.options,
      rect,
      visual
    };
  };
  LinePoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var markerBox = this.markerBox();
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(markerBox);
    if (showTooltip) {
      var x = markerBox.x2 + TOOLTIP_OFFSET;
      var horizontalAlign = LEFT;
      var y, verticalAlign;
      if (this.aboveAxis) {
        y = markerBox.y1;
        verticalAlign = BOTTOM;
      } else {
        y = markerBox.y2;
        verticalAlign = TOP;
      }
      return {
        point: new point_default2(x, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  LinePoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  LinePoint2.prototype.overlapsBox = function overlapsBox(box) {
    var markerBox = this.markerBox();
    return markerBox.overlaps(box);
  };
  LinePoint2.prototype.unclipElements = function unclipElements() {
    if (this.label) {
      this.label.options.noclip = true;
    }
    if (this.note) {
      this.note.options.noclip = true;
    }
  };
  LinePoint2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      series: this.series
    };
  };
  return LinePoint2;
}(chart_element_default);
LinePoint.prototype.defaults = {
  vertical: true,
  markers: {
    visible: true,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    position: ABOVE,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    }
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: "#fff",
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  errorBars: {
    line: {
      width: 1
    }
  }
};
deepExtend(LinePoint.prototype, point_events_mixin_default);
deepExtend(LinePoint.prototype, note_mixin_default);
var line_point_default = LinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-segment.js
var LineSegment = function(ChartElement2) {
  function LineSegment2(linePoints, series, seriesIx) {
    ChartElement2.call(this);
    this.linePoints = linePoints;
    this.series = series;
    this.seriesIx = seriesIx;
  }
  if (ChartElement2)
    LineSegment2.__proto__ = ChartElement2;
  LineSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LineSegment2.prototype.constructor = LineSegment2;
  LineSegment2.prototype.points = function points3() {
    return this.toGeometryPoints(this.linePoints);
  };
  LineSegment2.prototype.toGeometryPoints = function toGeometryPoints(points3) {
    var result = [];
    for (var i = 0, length = points3.length; i < length; i++) {
      if (points3[i] && points3[i].visible !== false) {
        result.push(points3[i]._childBox.toRect().center());
      }
    }
    return result;
  };
  LineSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var customVisual = this.series.visual;
    if (customVisual) {
      this.visual = customVisual({
        points: this.toGeometryPoints(this.linePoints),
        series: this.series,
        sender: this.getSender(),
        createVisual: function() {
          this$1.segmentVisual();
          return this$1.visual;
        }
      });
      if (this.visual && !defined2(this.visual.options.zIndex)) {
        this.visual.options.zIndex = this.series.zIndex;
      }
    } else {
      this.segmentVisual();
    }
  };
  LineSegment2.prototype.segmentVisual = function segmentVisual() {
    var ref2 = this;
    var options2 = ref2.options;
    var series = ref2.series;
    var color = series.color;
    var defaults = series._defaults;
    if (isFunction3(color) && defaults) {
      color = defaults.color;
    }
    var line = drawing_exports.Path.fromPoints(this.points(), {
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    if (options2.closed) {
      line.close();
    }
    this.visual = line;
  };
  LineSegment2.prototype.aliasFor = function aliasFor(e, coords) {
    return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);
  };
  return LineSegment2;
}(chart_element_default);
setDefaultOptions(LineSegment, {
  closed: false
});
var line_segment_default = LineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-mixin.js
var StepLineMixin = {
  calculateStepPoints: function(points3) {
    var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);
    var ref2 = categoryAxis.options;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var stepAxis = vertical ? X : Y;
    var axis = vertical ? Y : X;
    var stepDir = reverse ? 2 : 1;
    var dir = stepDir;
    var previousPoint = toGeometryPoint(points3[0], stepAxis, stepDir, axis, dir);
    var result = [previousPoint];
    for (var idx = 1; idx < points3.length; idx++) {
      var point2 = toGeometryPoint(points3[idx], stepAxis, stepDir, axis, dir);
      if (previousPoint[stepAxis] !== point2[stepAxis]) {
        var stepPoint = new geometry_exports.Point();
        stepPoint[stepAxis] = previousPoint[stepAxis];
        stepPoint[axis] = point2[axis];
        result.push(stepPoint, point2);
      }
      previousPoint = point2;
    }
    if (!justified) {
      result.push(toGeometryPoint(last2(points3), stepAxis, stepDir, axis, reverse ? 1 : 2));
    } else if (previousPoint !== last2(result)) {
      result.push(previousPoint);
    }
    return result;
  }
};
function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {
  var box = lintPoint.box;
  var result = new geometry_exports.Point();
  result[stepAxis] = box[stepAxis + stepDir];
  result[axis] = box[axis + dir];
  return result;
}
var step_line_mixin_default = StepLineMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-segment.js
var StepLineSegment = function(LineSegment2) {
  function StepLineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2)
    StepLineSegment2.__proto__ = LineSegment2;
  StepLineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  StepLineSegment2.prototype.constructor = StepLineSegment2;
  StepLineSegment2.prototype.points = function points3() {
    return this.calculateStepPoints(this.linePoints);
  };
  return StepLineSegment2;
}(line_segment_default);
deepExtend(StepLineSegment.prototype, step_line_mixin_default);
var step_line_segment_default = StepLineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/spline-segment.js
var SplineSegment = function(LineSegment2) {
  function SplineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2)
    SplineSegment2.__proto__ = LineSegment2;
  SplineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  SplineSegment2.prototype.constructor = SplineSegment2;
  SplineSegment2.prototype.segmentVisual = function segmentVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var color = series.color;
    if (isFunction3(color) && defaults) {
      color = defaults.color;
    }
    var curveProcessor = new curve_processor_default(this.options.closed);
    var segments = curveProcessor.process(this.points());
    var curve = new drawing_exports.Path({
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    curve.segments.push.apply(curve.segments, segments);
    this.visual = curve;
  };
  return SplineSegment2;
}(line_segment_default);
var spline_segment_default = SplineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/line-chart-mixin.js
var LineChartMixin = {
  renderSegments: function() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesPoints = ref2.seriesPoints;
    var series = options2.series;
    var seriesCount = seriesPoints.length;
    var lastSegment;
    this._segments = [];
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var sortedPoints = this$1.sortPoints(seriesPoints[seriesIx]);
      var pointCount = sortedPoints.length;
      var linePoints = [];
      for (var pointIx = 0; pointIx < pointCount; pointIx++) {
        var point2 = sortedPoints[pointIx];
        if (point2) {
          linePoints.push(point2);
        } else if (this$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {
          if (linePoints.length > 1) {
            lastSegment = this$1.createSegment(
              linePoints,
              currentSeries,
              seriesIx,
              lastSegment
            );
            this$1._addSegment(lastSegment);
          }
          linePoints = [];
        }
      }
      if (linePoints.length > 1) {
        lastSegment = this$1.createSegment(
          linePoints,
          currentSeries,
          seriesIx,
          lastSegment
        );
        this$1._addSegment(lastSegment);
      }
    }
    this.children.unshift.apply(this.children, this._segments);
  },
  _addSegment: function(segment) {
    this._segments.push(segment);
    segment.parent = this;
  },
  sortPoints: function(points3) {
    return points3;
  },
  seriesMissingValues: function(series) {
    var missingValues = series.missingValues;
    var assumeZero = !missingValues && this.options.isStacked;
    return assumeZero ? ZERO2 : missingValues || INTERPOLATE;
  },
  getNearestPoint: function(x, y, seriesIx) {
    var target = new point_default2(x, y);
    var allPoints = this.seriesPoints[seriesIx];
    var nearestPointDistance = MAX_VALUE;
    var nearestPoint;
    for (var i = 0; i < allPoints.length; i++) {
      var point2 = allPoints[i];
      if (point2 && defined2(point2.value) && point2.value !== null && point2.visible !== false) {
        var pointBox = point2.box;
        var pointDistance = pointBox.center().distanceTo(target);
        if (pointDistance < nearestPointDistance) {
          nearestPoint = point2;
          nearestPointDistance = pointDistance;
        }
      }
    }
    return nearestPoint;
  }
};
var line_chart_mixin_default = LineChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/clip-animation.js
var ClipAnimation = function(superclass) {
  function ClipAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    ClipAnimation2.__proto__ = superclass;
  ClipAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ClipAnimation2.prototype.constructor = ClipAnimation2;
  ClipAnimation2.prototype.setup = function setup() {
    this._setEnd(this.options.box.x1);
  };
  ClipAnimation2.prototype.step = function step(pos) {
    var box = this.options.box;
    this._setEnd(interpolateValue(box.x1, box.x2, pos));
  };
  ClipAnimation2.prototype._setEnd = function _setEnd(x) {
    var element2 = this.element;
    var segments = element2.segments;
    var topRight = segments[1].anchor();
    var bottomRight = segments[2].anchor();
    element2.suspend();
    topRight.setX(x);
    element2.resume();
    bottomRight.setX(x);
  };
  return ClipAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(ClipAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register("clip", ClipAnimation);
var clip_animation_default = ClipAnimation;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/any-has-z-index.js
function anyHasZIndex(elements) {
  for (var idx = 0; idx < elements.length; idx++) {
    if (defined2(elements[idx].zIndex)) {
      return true;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/clip-animation-mixin.js
var ClipAnimationMixin = {
  createAnimation: function() {
    var root = this.getRoot();
    if (root && (root.options || {}).transitions !== false) {
      var box = root.size();
      var clipPath = drawing_exports.Path.fromRect(box.toRect());
      this.visual.clip(clipPath);
      this.animation = new clip_animation_default(clipPath, {
        box
      });
      if (anyHasZIndex(this.options.series)) {
        this._setChildrenAnimation(clipPath);
      }
    }
  },
  _setChildrenAnimation: function(clipPath) {
    var points3 = this.animationPoints();
    for (var idx = 0; idx < points3.length; idx++) {
      var point2 = points3[idx];
      if (point2 && point2.visual && defined2(point2.visual.options.zIndex)) {
        point2.visual.clip(clipPath);
      }
    }
  }
};
var clip_animation_mixin_default = ClipAnimationMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-chart.js
var LineChart = function(CategoricalChart2) {
  function LineChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    LineChart2.__proto__ = CategoricalChart2;
  LineChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  LineChart2.prototype.constructor = LineChart2;
  LineChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
    this.renderSegments();
  };
  LineChart2.prototype.pointType = function pointType() {
    return line_point_default;
  };
  LineChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var missingValues = this.seriesMissingValues(series);
    var value = data.valueFields.value;
    if (!defined2(value) || value === null) {
      if (missingValues === ZERO2) {
        value = 0;
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    var color = data.fields.color || series.color;
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new line_point_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  LineChart2.prototype.plotRange = function plotRange(point2) {
    var this$1 = this;
    var plotValue = this.plotValue(point2);
    if (this.options.isStacked) {
      var categoryIx = point2.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      for (var i = 0; i < categoryPoints.length; i++) {
        var other = categoryPoints[i];
        if (point2 === other) {
          break;
        }
        plotValue += this$1.plotValue(other);
        if (this$1.options.isStacked100) {
          plotValue = Math.min(plotValue, 1);
        }
      }
    }
    return [plotValue, plotValue];
  };
  LineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === STEP) {
      pointType = step_line_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  LineChart2.prototype.animationPoints = function animationPoints() {
    var points3 = this.points;
    var result = [];
    for (var idx = 0; idx < points3.length; idx++) {
      result.push((points3[idx] || {}).marker);
    }
    return result.concat(this._segments);
  };
  LineChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return LineChart2;
}(categorical_chart_default);
deepExtend(LineChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var line_chart_default = LineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-segment.js
var AreaSegment = function(LineSegment2) {
  function AreaSegment2(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {
    LineSegment2.call(this, linePoints, currentSeries, seriesIx);
    this.prevSegment = prevSegment;
    this.stackPoints = stackPoints;
  }
  if (LineSegment2)
    AreaSegment2.__proto__ = LineSegment2;
  AreaSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  AreaSegment2.prototype.constructor = AreaSegment2;
  AreaSegment2.prototype.createVisual = function createVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var lineOptions = series.line || {};
    var color = series.color;
    if (isFunction3(color) && defaults) {
      color = defaults.color;
    }
    this.visual = new drawing_exports.Group({
      zIndex: series.zIndex
    });
    this.createFill({
      fill: {
        color,
        opacity: series.opacity
      },
      stroke: null
    });
    if (lineOptions.width > 0 && lineOptions.visible !== false) {
      this.createStroke({
        stroke: deepExtend({
          color,
          opacity: series.opacity,
          lineCap: "butt"
        }, lineOptions)
      });
    }
  };
  AreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      segments = this._strokeSegments = this.createStrokeSegments();
    }
    return segments;
  };
  AreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.points());
  };
  AreaSegment2.prototype.stackSegments = function stackSegments() {
    if (this.prevSegment) {
      return this.prevSegment.createStackSegments(this.stackPoints);
    }
    return this.createStackSegments(this.stackPoints);
  };
  AreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();
  };
  AreaSegment2.prototype.segmentsFromPoints = function segmentsFromPoints(points3) {
    return points3.map(function(point2) {
      return new geometry_exports.Segment(point2);
    });
  };
  AreaSegment2.prototype.createStroke = function createStroke(style) {
    var stroke = new drawing_exports.Path(style);
    stroke.segments.push.apply(stroke.segments, this.strokeSegments());
    this.visual.append(stroke);
  };
  AreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return this.prevSegment || this.stackPoints && this.stackPoints.length;
  };
  AreaSegment2.prototype.createFill = function createFill(style) {
    var strokeSegments = this.strokeSegments();
    var fillSegments = strokeSegments.slice(0);
    var hasStackSegments = this.hasStackSegment();
    if (hasStackSegments) {
      var stackSegments = this.stackSegments();
      append2(fillSegments, stackSegments);
    }
    var fill = new drawing_exports.Path(style);
    fill.segments.push.apply(fill.segments, fillSegments);
    if (!hasStackSegments && strokeSegments.length > 1) {
      this.fillToAxes(fill);
    }
    this.visual.append(fill);
  };
  AreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var chart = this.parent;
    var invertAxes = chart.options.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.series);
    var crossingValue = chart.categoryAxisCrossingValue(valueAxis);
    var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);
    var segments = this.strokeSegments();
    var firstPoint = segments[0].anchor();
    var lastPoint = last2(segments).anchor();
    var end = invertAxes ? endSlot.x1 : endSlot.y1;
    if (invertAxes) {
      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);
    } else {
      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);
    }
  };
  return AreaSegment2;
}(line_segment_default);
var area_segment_default = AreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/step-area-segment.js
var StepAreaSegment = function(AreaSegment2) {
  function StepAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    StepAreaSegment2.__proto__ = AreaSegment2;
  StepAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  StepAreaSegment2.prototype.constructor = StepAreaSegment2;
  StepAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));
  };
  StepAreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();
  };
  return StepAreaSegment2;
}(area_segment_default);
deepExtend(StepAreaSegment.prototype, step_line_mixin_default);
var step_area_segment_default = StepAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/spline-area-segment.js
var SplineAreaSegment = function(AreaSegment2) {
  function SplineAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    SplineAreaSegment2.__proto__ = AreaSegment2;
  SplineAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  SplineAreaSegment2.prototype.constructor = SplineAreaSegment2;
  SplineAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    var curveProcessor = new curve_processor_default(this.options.closed);
    var linePoints = this.points();
    return curveProcessor.process(linePoints);
  };
  SplineAreaSegment2.prototype.createStackSegments = function createStackSegments() {
    var strokeSegments = this.strokeSegments();
    var stackSegments = [];
    for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {
      var segment = strokeSegments[idx];
      stackSegments.push(new geometry_exports.Segment(
        segment.anchor(),
        segment.controlOut(),
        segment.controlIn()
      ));
    }
    return stackSegments;
  };
  return SplineAreaSegment2;
}(area_segment_default);
var spline_area_segment_default = SplineAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-chart.js
var AreaChart = function(LineChart2) {
  function AreaChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2)
    AreaChart2.__proto__ = LineChart2;
  AreaChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  AreaChart2.prototype.constructor = AreaChart2;
  AreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    if (isStacked && seriesIx > 0 && prevSegment) {
      var missingValues = this.seriesMissingValues(currentSeries);
      if (missingValues !== "gap") {
        stackPoints = prevSegment.linePoints;
        previousSegment = prevSegment;
      } else {
        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);
      }
    }
    var pointType;
    if (style === STEP) {
      pointType = step_area_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_area_segment_default;
    } else {
      pointType = area_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
  };
  AreaChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    LineChart2.prototype.reflow.call(this, targetBox);
    var stackPoints = this._stackPoints;
    if (stackPoints) {
      for (var idx = 0; idx < stackPoints.length; idx++) {
        var stackPoint = stackPoints[idx];
        var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);
        stackPoint.reflow(pointSlot);
      }
    }
  };
  AreaChart2.prototype._gapStackPoints = function _gapStackPoints(linePoints, seriesIx, style) {
    var this$1 = this;
    var seriesPoints = this.seriesPoints;
    var startIdx = linePoints[0].categoryIx;
    var length = linePoints.length;
    if (startIdx < 0) {
      startIdx = 0;
      length--;
    }
    var endIdx = startIdx + length;
    var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;
    var stackPoints = [];
    this._stackPoints = this._stackPoints || [];
    for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {
      var pointIx = categoryIx + pointOffset;
      var currentSeriesIx = seriesIx;
      var point2 = void 0;
      do {
        currentSeriesIx--;
        point2 = seriesPoints[currentSeriesIx][pointIx];
      } while (currentSeriesIx > 0 && !point2);
      if (point2) {
        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {
          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));
        }
        stackPoints.push(point2);
        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {
          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));
        }
      } else {
        var gapStackPoint = this$1._createGapStackPoint(categoryIx);
        this$1._stackPoints.push(gapStackPoint);
        stackPoints.push(gapStackPoint);
      }
    }
    return stackPoints;
  };
  AreaChart2.prototype._previousSegmentPoint = function _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {
    var seriesPoints = this.seriesPoints;
    var index = seriesIdx;
    var point2;
    while (index > 0 && !point2) {
      index--;
      point2 = seriesPoints[index][segmentIx];
    }
    if (!point2) {
      point2 = this._createGapStackPoint(categoryIx);
      this._stackPoints.push(point2);
    } else {
      point2 = seriesPoints[index][pointIx];
    }
    return point2;
  };
  AreaChart2.prototype._createGapStackPoint = function _createGapStackPoint(categoryIx) {
    var options2 = this.pointOptions({}, 0);
    var point2 = new line_point_default(0, options2);
    point2.categoryIx = categoryIx;
    point2.series = {};
    return point2;
  };
  AreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO2;
  };
  AreaChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return AreaChart2;
}(line_chart_default);
var area_chart_default = AreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/axis-group-range-tracker.js
var AxisGroupRangeTracker = function(Class3) {
  function AxisGroupRangeTracker2() {
    Class3.call(this);
    this.axisRanges = {};
  }
  if (Class3)
    AxisGroupRangeTracker2.__proto__ = Class3;
  AxisGroupRangeTracker2.prototype = Object.create(Class3 && Class3.prototype);
  AxisGroupRangeTracker2.prototype.constructor = AxisGroupRangeTracker2;
  AxisGroupRangeTracker2.prototype.update = function update(chartAxisRanges) {
    var axisRanges2 = this.axisRanges;
    for (var axisName in chartAxisRanges) {
      var chartRange = chartAxisRanges[axisName];
      var range = axisRanges2[axisName];
      axisRanges2[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };
      range.min = Math.min(range.min, chartRange.min);
      range.max = Math.max(range.max, chartRange.max);
    }
  };
  AxisGroupRangeTracker2.prototype.reset = function reset(axisName) {
    this.axisRanges[axisName] = void 0;
  };
  AxisGroupRangeTracker2.prototype.query = function query(axisName) {
    return this.axisRanges[axisName];
  };
  return AxisGroupRangeTracker2;
}(class_default);
var axis_group_range_tracker_default = AxisGroupRangeTracker;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-label.js
var BarLabel = function(ChartElement2) {
  function BarLabel2(content, options2, pointData) {
    ChartElement2.call(this, options2);
    this.textBox = new text_box_default(content, this.options, pointData);
    this.append(this.textBox);
  }
  if (ChartElement2)
    BarLabel2.__proto__ = ChartElement2;
  BarLabel2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BarLabel2.prototype.constructor = BarLabel2;
  BarLabel2.prototype.createVisual = function createVisual() {
    this.textBox.options.noclip = this.options.noclip;
  };
  BarLabel2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var vertical = options2.vertical;
    var aboveAxis = options2.aboveAxis;
    var text = this.children[0];
    var textOptions = text.options;
    var box = text.box;
    var padding = text.options.padding;
    var labelBox = targetBox;
    textOptions.align = vertical ? CENTER : LEFT;
    textOptions.vAlign = vertical ? TOP : CENTER;
    if (options2.position === INSIDE_END) {
      if (vertical) {
        textOptions.vAlign = TOP;
        if (!aboveAxis && box.height() < targetBox.height()) {
          textOptions.vAlign = BOTTOM;
        }
      } else {
        textOptions.align = aboveAxis ? RIGHT : LEFT;
      }
    } else if (options2.position === CENTER) {
      textOptions.vAlign = CENTER;
      textOptions.align = CENTER;
    } else if (options2.position === INSIDE_BASE) {
      if (vertical) {
        textOptions.vAlign = aboveAxis ? BOTTOM : TOP;
      } else {
        textOptions.align = aboveAxis ? LEFT : RIGHT;
      }
    } else if (options2.position === OUTSIDE_END) {
      if (vertical) {
        if (aboveAxis) {
          labelBox = new box_default(
            targetBox.x1,
            targetBox.y1 - box.height(),
            targetBox.x2,
            targetBox.y1
          );
        } else {
          labelBox = new box_default(
            targetBox.x1,
            targetBox.y2,
            targetBox.x2,
            targetBox.y2 + box.height()
          );
        }
      } else {
        textOptions.align = CENTER;
        if (aboveAxis) {
          labelBox = new box_default(
            targetBox.x2,
            targetBox.y1,
            targetBox.x2 + box.width(),
            targetBox.y2
          );
        } else {
          labelBox = new box_default(
            targetBox.x1 - box.width(),
            targetBox.y1,
            targetBox.x1,
            targetBox.y2
          );
        }
      }
    }
    if (!options2.rotation) {
      if (vertical) {
        padding.left = padding.right = (labelBox.width() - text.contentBox.width()) / 2;
      } else {
        padding.top = padding.bottom = (labelBox.height() - text.contentBox.height()) / 2;
      }
    }
    text.reflow(labelBox);
  };
  BarLabel2.prototype.alignToClipBox = function alignToClipBox(clipBox) {
    var vertical = this.options.vertical;
    var field = vertical ? Y : X;
    var start = field + "1";
    var end = field + "2";
    var text = this.children[0];
    var parentBox = this.parent.box;
    if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {
      var targetBox = text.paddingBox.clone();
      targetBox[start] = Math.max(parentBox[start], clipBox[start]);
      targetBox[end] = Math.min(parentBox[end], clipBox[end]);
      this.reflow(targetBox);
    }
  };
  return BarLabel2;
}(chart_element_default);
setDefaultOptions(BarLabel, {
  position: OUTSIDE_END,
  margin: getSpacing(3),
  padding: getSpacing(4),
  color: BLACK,
  background: "",
  border: {
    width: 1,
    color: ""
  },
  aboveAxis: true,
  vertical: false,
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  zIndex: 2
});
var bar_label_default = BarLabel;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-gradient-overlay.js
function hasGradientOverlay(options2) {
  var overlay = options2.overlay;
  return overlay && overlay.gradient && overlay.gradient !== "none";
}

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar.js
var BAR_ALIGN_MIN_WIDTH = 6;
var Bar = function(ChartElement2) {
  function Bar2(value, options2) {
    ChartElement2.call(this);
    this.options = options2;
    this.color = options2.color || WHITE;
    this.aboveAxis = valueOrDefault2(this.options.aboveAxis, true);
    this.value = value;
  }
  if (ChartElement2)
    Bar2.__proto__ = ChartElement2;
  Bar2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bar2.prototype.constructor = Bar2;
  Bar2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  Bar2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      var pointData = this.pointData();
      var labelTemplate = getTemplate(labels);
      var labelText;
      if (labelTemplate) {
        labelText = labelTemplate(pointData);
      } else {
        labelText = this.formatValue(labels.format);
      }
      this.label = new bar_label_default(
        labelText,
        deepExtend(
          {
            vertical: options2.vertical
          },
          labels
        ),
        pointData
      );
      this.append(this.label);
    }
  };
  Bar2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Bar2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    if (this.errorBars) {
      for (var i = 0; i < this.errorBars.length; i++) {
        this$1.errorBars[i].reflow(targetBox);
      }
    }
  };
  Bar2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var options2 = ref2.options;
    var customVisual = options2.visual;
    if (this.visible !== false) {
      ChartElement2.prototype.createVisual.call(this);
      if (customVisual) {
        var visual = this.rectVisual = customVisual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          sender: this.getSender(),
          series: this.series,
          percentage: this.percentage,
          stackValue: this.stackValue,
          runningTotal: this.runningTotal,
          total: this.total,
          rect: box.toRect(),
          createVisual: function() {
            var group = new drawing_exports.Group();
            this$1.createRect(group);
            return group;
          },
          options: options2
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else if (box.width() > 0 && box.height() > 0) {
        this.createRect(this.visual);
      }
    }
  };
  Bar2.prototype.createRect = function createRect(visual) {
    var options2 = this.options;
    var border = options2.border;
    var strokeOpacity = defined2(border.opacity) ? border.opacity : options2.opacity;
    var rect = this.box.toRect();
    rect.size.width = Math.round(rect.size.width);
    var path = this.rectVisual = drawing_exports.Path.fromRect(rect, {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: {
        color: this.getBorderColor(),
        width: border.width,
        opacity: strokeOpacity,
        dashType: border.dashType
      }
    });
    var width = this.box.width();
    var height = this.box.height();
    var size = options2.vertical ? width : height;
    if (size > BAR_ALIGN_MIN_WIDTH) {
      alignPathToPixel(path);
      if (width < 1 || height < 1) {
        path.options.stroke.lineJoin = "round";
      }
    }
    visual.append(path);
    if (hasGradientOverlay(options2)) {
      var overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({
        end: !options2.vertical ? [0, 1] : void 0
      }, options2.overlay));
      visual.append(overlay);
    }
  };
  Bar2.prototype.createHighlight = function createHighlight(style) {
    var highlight = drawing_exports.Path.fromRect(this.box.toRect(), style);
    return alignPathToPixel(highlight);
  };
  Bar2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  Bar2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  Bar2.prototype.getBorderColor = function getBorderColor() {
    var color = this.color;
    var border = this.options.border;
    var brightness = border._brightness || BORDER_BRIGHTNESS;
    var borderColor = border.color;
    if (!defined2(borderColor)) {
      borderColor = new color_default(color).brightness(brightness).toHex();
    }
    return borderColor;
  };
  Bar2.prototype.tooltipAnchor = function tooltipAnchor() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var aboveAxis = ref2.aboveAxis;
    var clipBox = this.owner.pane.clipBox() || box;
    var horizontalAlign = LEFT;
    var verticalAlign = TOP;
    var x, y;
    if (options2.vertical) {
      x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;
      if (aboveAxis) {
        y = Math.max(box.y1, clipBox.y1);
      } else {
        y = Math.min(box.y2, clipBox.y2);
        verticalAlign = BOTTOM;
      }
    } else {
      var x1 = Math.max(box.x1, clipBox.x1);
      var x2 = Math.min(box.x2, clipBox.x2);
      if (options2.isStacked) {
        verticalAlign = BOTTOM;
        if (aboveAxis) {
          horizontalAlign = RIGHT;
          x = x2;
        } else {
          x = x1;
        }
        y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;
      } else {
        if (aboveAxis) {
          x = x2 + TOOLTIP_OFFSET;
        } else {
          x = x1 - TOOLTIP_OFFSET;
          horizontalAlign = RIGHT;
        }
        y = Math.max(box.y1, clipBox.y1);
      }
    }
    return {
      point: new point_default2(x, y),
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  Bar2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Bar2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      runningTotal: this.runningTotal,
      total: this.total,
      series: this.series
    };
  };
  return Bar2;
}(chart_element_default);
deepExtend(Bar.prototype, point_events_mixin_default);
deepExtend(Bar.prototype, note_mixin_default);
Bar.prototype.defaults = {
  border: {
    width: 1
  },
  vertical: true,
  overlay: {
    gradient: "glass"
  },
  labels: {
    visible: false,
    format: "{0}"
  },
  opacity: 1,
  notes: {
    label: {}
  }
};
var bar_default = Bar;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/utils.js
function forEach2(elements, callback) {
  elements.forEach(callback);
}
function forEachReverse2(elements, callback) {
  var length = elements.length;
  for (var idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx - length - 1);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/layout/cluster-layout.js
var ClusterLayout = function(ChartElement2) {
  function ClusterLayout2(options2) {
    ChartElement2.call(this, options2);
    this.forEach = options2.rtl ? forEachReverse2 : forEach2;
  }
  if (ChartElement2)
    ClusterLayout2.__proto__ = ChartElement2;
  ClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ClusterLayout2.prototype.constructor = ClusterLayout2;
  ClusterLayout2.prototype.reflow = function reflow(box) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var gap = ref2.gap;
    var spacing = ref2.spacing;
    var children = this.children;
    var count = children.length;
    var axis = vertical ? Y : X;
    var slots = count + gap + spacing * (count - 1);
    var slotSize = (vertical ? box.height() : box.width()) / slots;
    var position3 = box[axis + 1] + slotSize * (gap / 2);
    this.forEach(children, function(child, idx) {
      var childBox = (child.box || box).clone();
      childBox[axis + 1] = position3;
      childBox[axis + 2] = position3 + slotSize;
      child.reflow(childBox);
      if (idx < count - 1) {
        position3 += slotSize * spacing;
      }
      position3 += slotSize;
    });
  };
  return ClusterLayout2;
}(chart_element_default);
setDefaultOptions(ClusterLayout, {
  vertical: false,
  gap: 0,
  spacing: 0
});
var cluster_layout_default = ClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/stack-wrap.js
var StackWrap = function(ChartElement2) {
  function StackWrap2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2)
    StackWrap2.__proto__ = ChartElement2;
  StackWrap2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  StackWrap2.prototype.constructor = StackWrap2;
  StackWrap2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var positionAxis = this.options.vertical ? X : Y;
    var children = this.children;
    var childrenCount = children.length;
    var box = this.box = new box_default();
    for (var i = 0; i < childrenCount; i++) {
      var currentChild = children[i];
      if (currentChild.visible !== false) {
        var childBox = currentChild.box.clone();
        childBox.snapTo(targetBox, positionAxis);
        if (i === 0) {
          box = this$1.box = childBox.clone();
        }
        currentChild.reflow(childBox);
        box.wrap(childBox);
      }
    }
  };
  return StackWrap2;
}(chart_element_default);
setDefaultOptions(StackWrap, {
  vertical: true
});
var stack_wrap_default = StackWrap;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-chart.js
var BarChart = function(CategoricalChart2) {
  function BarChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    BarChart2.__proto__ = CategoricalChart2;
  BarChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BarChart2.prototype.constructor = BarChart2;
  BarChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
  };
  BarChart2.prototype.pointType = function pointType() {
    return bar_default;
  };
  BarChart2.prototype.clusterType = function clusterType() {
    return cluster_layout_default;
  };
  BarChart2.prototype.stackType = function stackType() {
    return stack_wrap_default;
  };
  BarChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var limits = CategoricalChart2.prototype.stackLimits.call(this, axisName, stackName);
    return limits;
  };
  BarChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var isStacked = options2.isStacked;
    var value = this.pointValue(data);
    var pointOptions = this.pointOptions(series, seriesIx);
    var labelOptions = pointOptions.labels;
    if (isStacked) {
      if (labelOptions.position === OUTSIDE_END) {
        labelOptions.position = INSIDE_END;
      }
    }
    pointOptions.isStacked = isStacked;
    var color = data.fields.color || series.color;
    if (value < 0 && pointOptions.negativeColor) {
      color = pointOptions.negativeColor;
    }
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    var pointType = this.pointType();
    var point2 = new pointType(value, pointOptions);
    point2.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      var clusterType = this.clusterType();
      cluster = new clusterType({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (isStacked) {
      var stackWrap = this.getStackWrap(series, cluster);
      stackWrap.append(point2);
    } else {
      cluster.append(point2);
    }
    return point2;
  };
  BarChart2.prototype.getStackWrap = function getStackWrap(series, cluster) {
    var stack2 = series.stack;
    var stackGroup = stack2 ? stack2.group || stack2 : stack2;
    var wraps = cluster.children;
    var stackWrap;
    if (typeof stackGroup === STRING) {
      for (var i = 0; i < wraps.length; i++) {
        if (wraps[i]._stackGroup === stackGroup) {
          stackWrap = wraps[i];
          break;
        }
      }
    } else {
      stackWrap = wraps[0];
    }
    if (!stackWrap) {
      var stackType = this.stackType();
      stackWrap = new stackType({
        vertical: !this.options.invertAxes
      });
      stackWrap._stackGroup = stackGroup;
      cluster.append(stackWrap);
    }
    return stackWrap;
  };
  BarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx, valueAxis) {
    var options2 = this.options;
    var categorySlot2 = categoryAxis.getSlot(categoryIx);
    var startValue = valueAxis.startValue();
    if (options2.isStacked) {
      var zeroSlot = valueAxis.getSlot(startValue, startValue, true);
      var stackAxis = options2.invertAxes ? X : Y;
      categorySlot2[stackAxis + 1] = categorySlot2[stackAxis + 2] = zeroSlot[stackAxis + 1];
    }
    return categorySlot2;
  };
  BarChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  BarChart2.prototype.createAnimation = function createAnimation() {
    this._setAnimationOptions();
    CategoricalChart2.prototype.createAnimation.call(this);
    if (anyHasZIndex(this.options.series)) {
      this._setChildrenAnimation();
    }
  };
  BarChart2.prototype._setChildrenAnimation = function _setChildrenAnimation() {
    var this$1 = this;
    var points3 = this.points;
    for (var idx = 0; idx < points3.length; idx++) {
      var point2 = points3[idx];
      var pointVisual = point2.visual;
      if (pointVisual && defined2(pointVisual.options.zIndex)) {
        point2.options.animation = this$1.options.animation;
        point2.createAnimation();
      }
    }
  };
  BarChart2.prototype._setAnimationOptions = function _setAnimationOptions() {
    var options2 = this.options;
    var animation = options2.animation || {};
    var origin;
    if (options2.isStacked) {
      var valueAxis = this.seriesValueAxis(options2.series[0]);
      origin = valueAxis.getSlot(valueAxis.startValue());
    } else {
      origin = this.categoryAxis.getSlot(0);
    }
    animation.origin = new geometry_exports.Point(origin.x1, origin.y1);
    animation.vertical = !options2.invertAxes;
  };
  return BarChart2;
}(categorical_chart_default);
setDefaultOptions(BarChart, {
  animation: {
    type: BAR
  }
});
var bar_chart_default = BarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick.js
var Candlestick = function(ChartElement2) {
  function Candlestick2(value, options2) {
    ChartElement2.call(this, options2);
    this.value = value;
  }
  if (ChartElement2)
    Candlestick2.__proto__ = ChartElement2;
  Candlestick2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Candlestick2.prototype.constructor = Candlestick2;
  Candlestick2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var ocSlot = valueAxis.getSlot(value.open, value.close);
    var lhSlot = valueAxis.getSlot(value.low, value.high);
    ocSlot.x1 = lhSlot.x1 = box.x1;
    ocSlot.x2 = lhSlot.x2 = box.x2;
    this.realBody = ocSlot;
    var mid = lhSlot.center().x;
    var points3 = [];
    points3.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);
    points3.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);
    this.lines = points3;
    this.box = lhSlot.clone().wrap(ocSlot);
    if (!this._rendered) {
      this._rendered = true;
      this.createNote();
    }
    this.reflowNote();
  };
  Candlestick2.prototype.reflowNote = function reflowNote() {
    if (this.note) {
      this.note.reflow(this.box);
    }
  };
  Candlestick2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this._mainVisual = this.mainVisual(this.options);
    this.visual.append(
      this._mainVisual
    );
    this.createOverlay();
  };
  Candlestick2.prototype.mainVisual = function mainVisual(options2) {
    var group = new drawing_exports.Group();
    this.createBody(group, options2);
    this.createLines(group, options2);
    return group;
  };
  Candlestick2.prototype.createBody = function createBody(container, options2) {
    var body = drawing_exports.Path.fromRect(this.realBody.toRect(), {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: null
    });
    if (options2.border.width > 0) {
      body.options.set("stroke", {
        color: this.getBorderColor(),
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: valueOrDefault2(options2.border.opacity, options2.opacity)
      });
    }
    alignPathToPixel(body);
    container.append(body);
    if (hasGradientOverlay(options2)) {
      container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({
        end: !options2.vertical ? [0, 1] : void 0
      }, options2.overlay)));
    }
  };
  Candlestick2.prototype.createLines = function createLines(container, options2) {
    this.drawLines(container, options2, this.lines, options2.line);
  };
  Candlestick2.prototype.drawLines = function drawLines(container, options2, lines, lineOptions) {
    if (!lines) {
      return;
    }
    var lineStyle = {
      stroke: {
        color: lineOptions.color || this.color,
        opacity: valueOrDefault2(lineOptions.opacity, options2.opacity),
        width: lineOptions.width,
        dashType: lineOptions.dashType,
        lineCap: "butt"
      }
    };
    for (var i = 0; i < lines.length; i++) {
      var line = drawing_exports.Path.fromPoints(lines[i], lineStyle);
      alignPathToPixel(line);
      container.append(line);
    }
  };
  Candlestick2.prototype.getBorderColor = function getBorderColor() {
    var border = this.options.border;
    var borderColor = border.color;
    if (!defined2(borderColor)) {
      borderColor = new color_default(this.color).brightness(border._brightness).toHex();
    }
    return borderColor;
  };
  Candlestick2.prototype.createOverlay = function createOverlay() {
    var overlay = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null
    });
    this.visual.append(overlay);
  };
  Candlestick2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var normalColor = this.color;
    this.color = highlight.color || this.color;
    var overlay = this.mainVisual(
      deepExtend({}, this.options, {
        line: {
          color: this.getBorderColor()
        }
      }, highlight)
    );
    this.color = normalColor;
    return overlay;
  };
  Candlestick2.prototype.highlightVisual = function highlightVisual() {
    return this._mainVisual;
  };
  Candlestick2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this._mainVisual
    };
  };
  Candlestick2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    var clipBox = this.owner.pane.clipBox() || box;
    return {
      point: new point_default2(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),
      align: {
        horizontal: LEFT,
        vertical: TOP
      }
    };
  };
  Candlestick2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Candlestick2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  return Candlestick2;
}(chart_element_default);
setDefaultOptions(Candlestick, {
  vertical: true,
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{4:d}</th></tr><tr><td>Open:</td><td>{0:C}</td></tr><tr><td>High:</td><td>{1:C}</td></tr><tr><td>Low:</td><td>{2:C}</td></tr><tr><td>Close:</td><td>{3:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  }
});
deepExtend(Candlestick.prototype, point_events_mixin_default);
deepExtend(Candlestick.prototype, note_mixin_default);
var candlestick_default = Candlestick;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/are-numbers.js
function areNumbers(values5) {
  return countNumbers(values5) === values5.length;
}

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick-chart.js
var CandlestickChart = function(CategoricalChart2) {
  function CandlestickChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    CandlestickChart2.__proto__ = CategoricalChart2;
  CandlestickChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  CandlestickChart2.prototype.constructor = CandlestickChart2;
  CandlestickChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  CandlestickChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var value = data.valueFields;
    var valueParts = this.splitValue(value);
    var hasValue3 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point2;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue3) {
      point2 = this.createPoint(data, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point2) {
      this.updateRange(value, fields);
      cluster.append(point2);
      point2.categoryIx = categoryIx;
      point2.category = category;
      point2.series = series;
      point2.seriesIx = seriesIx;
      point2.owner = this;
      point2.dataItem = dataItem;
      point2.noteText = data.fields.noteText;
    }
    this.points.push(point2);
    categoryPoints.push(point2);
  };
  CandlestickChart2.prototype.pointType = function pointType() {
    return candlestick_default;
  };
  CandlestickChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var pointType = this.pointType();
    var value = data.valueFields;
    var pointOptions = deepExtend({}, series);
    var color = data.fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    if (series.type === CANDLESTICK) {
      if (value.open > value.close) {
        color = data.fields.downColor || series.downColor || series.color;
      }
    }
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.vertical = !this.options.invertAxes;
    var point2 = new pointType(value, pointOptions);
    point2.color = color;
    return point2;
  };
  CandlestickChart2.prototype.splitValue = function splitValue(value) {
    return [value.low, value.open, value.close, value.high];
  };
  CandlestickChart2.prototype.updateRange = function updateRange(value, fields) {
    var axisName = fields.series.axis;
    var parts = this.splitValue(value);
    var axisRange = this.valueAxisRanges[axisName];
    axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
    axisRange = this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  CandlestickChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(
      format2,
      value.open,
      value.high,
      value.low,
      value.close,
      point2.category
    );
  };
  CandlestickChart2.prototype.animationPoints = function animationPoints() {
    return this.points;
  };
  return CandlestickChart2;
}(categorical_chart_default);
deepExtend(CandlestickChart.prototype, clip_animation_mixin_default);
var candlestick_chart_default = CandlestickChart;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot.js
var BoxPlot = function(Candlestick2) {
  function BoxPlot2(value, options2) {
    Candlestick2.call(this, value, options2);
    this.createNote();
  }
  if (Candlestick2)
    BoxPlot2.__proto__ = Candlestick2;
  BoxPlot2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  BoxPlot2.prototype.constructor = BoxPlot2;
  BoxPlot2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var whiskerSlot, boxSlot;
    this.boxSlot = boxSlot = valueAxis.getSlot(value.q1, value.q3);
    this.realBody = boxSlot;
    this.reflowBoxSlot(box);
    this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value.lower, value.upper);
    this.reflowWhiskerSlot(box);
    var medianSlot = valueAxis.getSlot(value.median);
    if (value.mean) {
      var meanSlot = valueAxis.getSlot(value.mean);
      this.meanPoints = this.calcMeanPoints(box, meanSlot);
    }
    this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);
    this.medianPoints = this.calcMedianPoints(box, medianSlot);
    this.box = whiskerSlot.clone().wrap(boxSlot);
    this.reflowNote();
  };
  BoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.x1 = box.x1;
    this.boxSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.x1 = box.x1;
    this.whiskerSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [
      [[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]
    ];
  };
  BoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().x;
    return [[
      [mid - 5, whiskerSlot.y1],
      [mid + 5, whiskerSlot.y1],
      [mid, whiskerSlot.y1],
      [mid, boxSlot.y1]
    ], [
      [mid - 5, whiskerSlot.y2],
      [mid + 5, whiskerSlot.y2],
      [mid, whiskerSlot.y2],
      [mid, boxSlot.y2]
    ]];
  };
  BoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [
      [[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]
    ];
  };
  BoxPlot2.prototype.renderOutliers = function renderOutliers(options2) {
    var this$1 = this;
    var value = this.value;
    var outliers = value.outliers || [];
    var outerFence = Math.abs(value.q3 - value.q1) * 3;
    var elements = [];
    var markers = options2.markers || {};
    for (var i = 0; i < outliers.length; i++) {
      var outlierValue = outliers[i];
      if (outlierValue < value.q3 + outerFence && outlierValue > value.q1 - outerFence) {
        markers = options2.outliers;
      } else {
        markers = options2.extremes;
      }
      var markersBorder = deepExtend({}, markers.border);
      if (!defined2(markersBorder.color)) {
        if (defined2(this$1.color)) {
          markersBorder.color = this$1.color;
        } else {
          markersBorder.color = new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex();
        }
      }
      var shape2 = new shape_element_default({
        type: markers.type,
        width: markers.size,
        height: markers.size,
        rotation: markers.rotation,
        background: markers.background,
        border: markersBorder,
        opacity: markers.opacity
      });
      shape2.value = outlierValue;
      elements.push(shape2);
    }
    this.reflowOutliers(elements);
    return elements;
  };
  BoxPlot2.prototype.reflowOutliers = function reflowOutliers(outliers) {
    var this$1 = this;
    var valueAxis = this.owner.seriesValueAxis(this.options);
    var center = this.box.center();
    for (var i = 0; i < outliers.length; i++) {
      var outlierValue = outliers[i].value;
      var markerBox = valueAxis.getSlot(outlierValue);
      if (this$1.options.vertical) {
        markerBox.move(center.x);
      } else {
        markerBox.move(void 0, center.y);
      }
      this$1.box = this$1.box.wrap(markerBox);
      outliers[i].reflow(markerBox);
    }
  };
  BoxPlot2.prototype.mainVisual = function mainVisual(options2) {
    var group = Candlestick2.prototype.mainVisual.call(this, options2);
    var outliers = this.renderOutliers(options2);
    for (var i = 0; i < outliers.length; i++) {
      var element2 = outliers[i].getElement();
      if (element2) {
        group.append(element2);
      }
    }
    return group;
  };
  BoxPlot2.prototype.createLines = function createLines(container, options2) {
    this.drawLines(container, options2, this.whiskerPoints, options2.whiskers);
    this.drawLines(container, options2, this.medianPoints, options2.median);
    this.drawLines(container, options2, this.meanPoints, options2.mean);
  };
  BoxPlot2.prototype.getBorderColor = function getBorderColor() {
    if ((this.options.border || {}).color) {
      return this.options.border.color;
    }
    if (this.color) {
      return this.color;
    }
    return Candlestick2.prototype.getBorderColor.call(this);
  };
  return BoxPlot2;
}(candlestick_default);
setDefaultOptions(BoxPlot, {
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  median: {
    color: "#f6f6f6"
  },
  mean: {
    width: 2,
    dashType: "dash",
    color: "#f6f6f6"
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{6:d}</th></tr><tr><td>Lower:</td><td>{0:C}</td></tr><tr><td>Q1:</td><td>{1:C}</td></tr><tr><td>Median:</td><td>{2:C}</td></tr><tr><td>Mean:</td><td>{5:C}</td></tr><tr><td>Q3:</td><td>{3:C}</td></tr><tr><td>Upper:</td><td>{4:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  outliers: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CROSS,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  },
  extremes: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  }
});
deepExtend(BoxPlot.prototype, point_events_mixin_default);
var box_plot_default = BoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/vertical-box-plot.js
var VerticalBoxPlot = function(BoxPlot2) {
  function VerticalBoxPlot2() {
    BoxPlot2.apply(this, arguments);
  }
  if (BoxPlot2)
    VerticalBoxPlot2.__proto__ = BoxPlot2;
  VerticalBoxPlot2.prototype = Object.create(BoxPlot2 && BoxPlot2.prototype);
  VerticalBoxPlot2.prototype.constructor = VerticalBoxPlot2;
  VerticalBoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.y1 = box.y1;
    this.boxSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.y1 = box.y1;
    this.whiskerSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [
      [[meanSlot.x1, box.y1], [meanSlot.x1, box.y2]]
    ];
  };
  VerticalBoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().y;
    return [[
      [whiskerSlot.x1, mid - 5],
      [whiskerSlot.x1, mid + 5],
      [whiskerSlot.x1, mid],
      [boxSlot.x1, mid]
    ], [
      [whiskerSlot.x2, mid - 5],
      [whiskerSlot.x2, mid + 5],
      [whiskerSlot.x2, mid],
      [boxSlot.x2, mid]
    ]];
  };
  VerticalBoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [
      [[medianSlot.x1, box.y1], [medianSlot.x1, box.y2]]
    ];
  };
  return VerticalBoxPlot2;
}(box_plot_default);
var vertical_box_plot_default = VerticalBoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot-chart.js
var BoxPlotChart = function(CandlestickChart2) {
  function BoxPlotChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2)
    BoxPlotChart2.__proto__ = CandlestickChart2;
  BoxPlotChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  BoxPlotChart2.prototype.constructor = BoxPlotChart2;
  BoxPlotChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var value = data.valueFields;
    var valueParts = this.splitValue(value);
    var hasValue3 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point2;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue3) {
      point2 = this.createPoint(data, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point2) {
      this.updateRange(value, fields);
      cluster.append(point2);
      point2.categoryIx = categoryIx;
      point2.category = category;
      point2.series = series;
      point2.seriesIx = seriesIx;
      point2.owner = this;
      point2.dataItem = dataItem;
    }
    this.points.push(point2);
    categoryPoints.push(point2);
  };
  BoxPlotChart2.prototype.pointType = function pointType() {
    if (this.options.invertAxes) {
      return vertical_box_plot_default;
    }
    return box_plot_default;
  };
  BoxPlotChart2.prototype.splitValue = function splitValue(value) {
    return [
      value.lower,
      value.q1,
      value.median,
      value.q3,
      value.upper
    ];
  };
  BoxPlotChart2.prototype.updateRange = function updateRange(value, fields) {
    var axisName = fields.series.axis;
    var axisRange = this.valueAxisRanges[axisName];
    var parts = this.splitValue(value).concat(this.filterOutliers(value.outliers));
    if (defined2(value.mean)) {
      parts = parts.concat(value.mean);
    }
    axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
    axisRange = this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  BoxPlotChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(
      format2,
      value.lower,
      value.q1,
      value.median,
      value.q3,
      value.upper,
      value.mean,
      point2.category
    );
  };
  BoxPlotChart2.prototype.filterOutliers = function filterOutliers(items) {
    var length = (items || []).length;
    var result = [];
    for (var i = 0; i < length; i++) {
      var item = items[i];
      if (defined2(item) && item !== null) {
        result.push(item);
      }
    }
    return result;
  };
  BoxPlotChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return BoxPlotChart2;
}(candlestick_chart_default);
var box_plot_chart_default = BoxPlotChart;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/scatter-error-bar.js
var ScatterErrorBar = function(ErrorBarBase2) {
  function ScatterErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2)
    ScatterErrorBar2.__proto__ = ErrorBarBase2;
  ScatterErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  ScatterErrorBar2.prototype.constructor = ScatterErrorBar2;
  ScatterErrorBar2.prototype.getAxis = function getAxis() {
    var axes = this.chart.seriesAxes(this.series);
    var axis = this.isVertical ? axes.y : axes.x;
    return axis;
  };
  return ScatterErrorBar2;
}(error_bar_base_default);
var scatter_error_bar_default = ScatterErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-value.js
function hasValue(value) {
  return defined2(value) && value !== null;
}

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-chart.js
var ScatterChart = function(ChartElement2) {
  function ScatterChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2)
    ScatterChart2.__proto__ = ChartElement2;
  ScatterChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ScatterChart2.prototype.constructor = ScatterChart2;
  ScatterChart2.prototype._initFields = function _initFields() {
    this.xAxisRanges = {};
    this.yAxisRanges = {};
    this.points = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
  };
  ScatterChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  ScatterChart2.prototype.addErrorBar = function addErrorBar(point2, field, fields) {
    var value = point2.value[field];
    var valueErrorField = field + "Value";
    var lowField = field + "ErrorLow";
    var highField = field + "ErrorHigh";
    var seriesIx = fields.seriesIx;
    var series = fields.series;
    var errorBars = point2.options.errorBars;
    var lowValue = fields[lowField];
    var highValue = fields[highField];
    if (isNumber2(value)) {
      var errorRange;
      if (isNumber2(lowValue) && isNumber2(highValue)) {
        errorRange = { low: lowValue, high: highValue };
      }
      if (errorBars && defined2(errorBars[valueErrorField])) {
        this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };
        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new error_range_calculator_default(errorBars[valueErrorField], series, field);
        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);
      }
      if (errorRange) {
        this.addPointErrorBar(errorRange, point2, field);
      }
    }
  };
  ScatterChart2.prototype.addPointErrorBar = function addPointErrorBar(errorRange, point2, field) {
    var low = errorRange.low;
    var high = errorRange.high;
    var series = point2.series;
    var options2 = point2.options.errorBars;
    var isVertical = field === Y;
    var item = {};
    point2[field + "Low"] = low;
    point2[field + "High"] = high;
    point2.errorBars = point2.errorBars || [];
    var errorBar = new scatter_error_bar_default(low, high, isVertical, this, series, options2);
    point2.errorBars.push(errorBar);
    point2.append(errorBar);
    item[field] = low;
    this.updateRange(item, series);
    item[field] = high;
    this.updateRange(item, series);
  };
  ScatterChart2.prototype.addValue = function addValue(value, fields) {
    var x = value.x;
    var y = value.y;
    var seriesIx = fields.seriesIx;
    var series = this.options.series[seriesIx];
    var missingValues = this.seriesMissingValues(series);
    var seriesPoints = this.seriesPoints[seriesIx];
    var pointValue = value;
    if (!(hasValue(x) && hasValue(y))) {
      pointValue = this.createMissingValue(pointValue, missingValues);
    }
    var point2;
    if (pointValue) {
      point2 = this.createPoint(pointValue, fields);
      if (point2) {
        Object.assign(point2, fields);
        this.addErrorBar(point2, X, fields);
        this.addErrorBar(point2, Y, fields);
      }
      this.updateRange(pointValue, fields.series);
    }
    this.points.push(point2);
    seriesPoints.push(point2);
  };
  ScatterChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues;
  };
  ScatterChart2.prototype.createMissingValue = function createMissingValue() {
  };
  ScatterChart2.prototype.updateRange = function updateRange(value, series) {
    var intlService = this.chartService.intl;
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var x = value.x;
    var y = value.y;
    var xAxisRange = this.xAxisRanges[xAxisName];
    var yAxisRange = this.yAxisRanges[yAxisName];
    if (hasValue(x)) {
      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString2(x)) {
        x = parseDate3(intlService, x);
      }
      xAxisRange.min = Math.min(xAxisRange.min, x);
      xAxisRange.max = Math.max(xAxisRange.max, x);
    }
    if (hasValue(y)) {
      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString2(y)) {
        y = parseDate3(intlService, y);
      }
      yAxisRange.min = Math.min(yAxisRange.min, y);
      yAxisRange.max = Math.max(yAxisRange.max, y);
    }
  };
  ScatterChart2.prototype.evalPointOptions = function evalPointOptions(options2, value, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined2(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, options2);
      evalOptions(pointOptions, {
        value,
        series,
        dataItem: fields.dataItem
      }, state);
    }
    return pointOptions;
  };
  ScatterChart2.prototype.pointType = function pointType() {
    return line_point_default;
  };
  ScatterChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options2;
  };
  ScatterChart2.prototype.createPoint = function createPoint(value, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new line_point_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  ScatterChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      x: xAxis,
      y: yAxis
    };
  };
  ScatterChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value, fields) {
      var point2 = chartPoints[pointIx++];
      var seriesAxes = this$1.seriesAxes(fields.series);
      var slotX = seriesAxes.x.getSlot(value.x, value.x, limit);
      var slotY = seriesAxes.y.getSlot(value.y, value.y, limit);
      if (point2) {
        if (slotX && slotY) {
          var pointSlot = this$1.pointSlot(slotX, slotY);
          point2.reflow(pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  ScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  ScatterChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var seriesPoints = ref2.seriesPoints;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var currentSeriesPoints = seriesPoints[seriesIx];
      if (!currentSeriesPoints) {
        seriesPoints[seriesIx] = [];
      }
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1._bindPoint(currentSeries, seriesIx, pointIx);
        var value = ref$1.valueFields;
        var fields = ref$1.fields;
        callback(value, deepExtend({
          pointIx,
          series: currentSeries,
          seriesIx,
          dataItem: currentSeries.data[pointIx],
          owner: this$1
        }, fields));
      }
    }
  };
  ScatterChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(format2, value.x, value.y);
  };
  ScatterChart2.prototype.animationPoints = function animationPoints() {
    var points3 = this.points;
    var result = [];
    for (var idx = 0; idx < points3.length; idx++) {
      result.push((points3[idx] || {}).marker);
    }
    return result;
  };
  return ScatterChart2;
}(chart_element_default);
setDefaultOptions(ScatterChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}"
  },
  labels: {
    format: "{0}, {1}"
  },
  clip: true
});
deepExtend(ScatterChart.prototype, clip_animation_mixin_default, {
  _bindPoint: categorical_chart_default.prototype._bindPoint
});
var scatter_chart_default = ScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble.js
var Bubble = function(LinePoint2) {
  function Bubble2(value, options2) {
    LinePoint2.call(this, value, options2);
    this.category = value.category;
  }
  if (LinePoint2)
    Bubble2.__proto__ = LinePoint2;
  Bubble2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  Bubble2.prototype.constructor = Bubble2;
  Bubble2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var border = highlight.border;
    var markers = this.options.markers;
    var center = this.box.center();
    var radius = (markers.size + markers.border.width + border.width) / 2;
    var highlightGroup = new drawing_exports.Group();
    var shadow = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y + radius / 5 + border.width / 2], radius + border.width / 2), {
      stroke: {
        color: "none"
      },
      fill: this.createGradient({
        gradient: "bubbleShadow",
        color: markers.background,
        stops: [{
          offset: 0,
          color: markers.background,
          opacity: 0.3
        }, {
          offset: 1,
          color: markers.background,
          opacity: 0
        }]
      })
    });
    var overlay = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), {
      stroke: {
        color: border.color || new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),
        width: border.width,
        opacity: border.opacity
      },
      fill: {
        color: markers.background,
        opacity: highlight.opacity
      }
    });
    highlightGroup.append(shadow, overlay);
    return highlightGroup;
  };
  return Bubble2;
}(line_point_default);
Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {
  labels: {
    position: CENTER
  },
  highlight: {
    opacity: 1,
    border: {
      color: "#fff",
      width: 2,
      opacity: 1
    }
  }
});
Bubble.prototype.defaults.highlight.zIndex = void 0;
var bubble_default = Bubble;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble-chart.js
var BubbleChart = function(ScatterChart2) {
  function BubbleChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    BubbleChart2.__proto__ = ScatterChart2;
  BubbleChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  BubbleChart2.prototype.constructor = BubbleChart2;
  BubbleChart2.prototype._initFields = function _initFields() {
    this._maxSize = MIN_VALUE;
    ScatterChart2.prototype._initFields.call(this);
  };
  BubbleChart2.prototype.addValue = function addValue(value, fields) {
    if (value.size !== null && (value.size > 0 || value.size < 0 && fields.series.negativeValues.visible)) {
      this._maxSize = Math.max(this._maxSize, Math.abs(value.size));
      ScatterChart2.prototype.addValue.call(this, value, fields);
    } else {
      this.points.push(null);
      this.seriesPoints[fields.seriesIx].push(null);
    }
  };
  BubbleChart2.prototype.reflow = function reflow(box) {
    this.updateBubblesSize(box);
    ScatterChart2.prototype.reflow.call(this, box);
  };
  BubbleChart2.prototype.pointType = function pointType() {
    return bubble_default;
  };
  BubbleChart2.prototype.createPoint = function createPoint(value, fields) {
    var series = fields.series;
    var pointsCount = series.data.length;
    var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);
    var animationOptions = {
      delay,
      duration: INITIAL_ANIMATION_DURATION - delay,
      type: BUBBLE
    };
    var color = fields.color || series.color;
    if (value.size < 0 && series.negativeValues.visible) {
      color = valueOrDefault2(
        series.negativeValues.color,
        color
      );
    }
    var pointOptions = deepExtend({
      labels: {
        animation: {
          delay,
          duration: INITIAL_ANIMATION_DURATION - delay
        }
      }
    }, this.pointOptions(series, fields.seriesIx), {
      markers: {
        type: CIRCLE,
        border: series.border,
        opacity: series.opacity,
        animation: animationOptions
      }
    });
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.markers.background = color;
    var point2 = new bubble_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  BubbleChart2.prototype.updateBubblesSize = function updateBubblesSize(box) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var boxSize = Math.min(box.width(), box.height());
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesPoints = this$1.seriesPoints[seriesIx];
      var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);
      var maxSize = currentSeries.maxSize || boxSize * 0.2;
      var minR = minSize / 2;
      var maxR = maxSize / 2;
      var minArea = Math.PI * minR * minR;
      var maxArea = Math.PI * maxR * maxR;
      var areaRange = maxArea - minArea;
      var areaRatio = areaRange / this$1._maxSize;
      for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {
        var point2 = seriesPoints[pointIx];
        if (point2) {
          var area = Math.abs(point2.value.size) * areaRatio;
          var radius = Math.sqrt((minArea + area) / Math.PI);
          var baseZIndex = valueOrDefault2(point2.options.zIndex, 0);
          var zIndex3 = baseZIndex + (1 - radius / maxR);
          deepExtend(point2.options, {
            zIndex: zIndex3,
            markers: {
              size: radius * 2,
              zIndex: zIndex3
            },
            labels: {
              zIndex: zIndex3 + 1
            }
          });
        }
      }
    }
  };
  BubbleChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(format2, value.x, value.y, value.size, point2.category);
  };
  BubbleChart2.prototype.createAnimation = function createAnimation() {
  };
  BubbleChart2.prototype.createVisual = function createVisual() {
  };
  return BubbleChart2;
}(scatter_chart_default);
setDefaultOptions(BubbleChart, {
  tooltip: {
    format: "{3}"
  },
  labels: {
    format: "{3}"
  }
});
var bubble_chart_default = BubbleChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/target.js
var Target = function(ShapeElement2) {
  function Target2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2)
    Target2.__proto__ = ShapeElement2;
  Target2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  Target2.prototype.constructor = Target2;
  return Target2;
}(shape_element_default);
deepExtend(Target.prototype, point_events_mixin_default);
var target_default = Target;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet.js
var Bullet = function(ChartElement2) {
  function Bullet2(value, options2) {
    ChartElement2.call(this, options2);
    this.aboveAxis = this.options.aboveAxis;
    this.color = options2.color || WHITE;
    this.value = value;
  }
  if (ChartElement2)
    Bullet2.__proto__ = ChartElement2;
  Bullet2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bullet2.prototype.constructor = Bullet2;
  Bullet2.prototype.render = function render() {
    var options2 = this.options;
    if (!this._rendered) {
      this._rendered = true;
      if (defined2(this.value.target)) {
        this.target = new target_default({
          type: options2.target.shape,
          background: options2.target.color || this.color,
          opacity: options2.opacity,
          zIndex: options2.zIndex,
          border: options2.target.border,
          vAlign: TOP,
          align: RIGHT
        });
        this.target.value = this.value;
        this.target.dataItem = this.dataItem;
        this.target.series = this.series;
        this.append(this.target);
      }
      this.createLabel();
      this.createNote();
    }
  };
  Bullet2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      var pointData = this.pointData();
      var labelTemplate = getTemplate(labels);
      var labelText;
      if (labelTemplate) {
        labelText = labelTemplate(pointData);
      } else {
        labelText = this.formatValue(labels.format);
      }
      this.label = new bar_label_default(labelText, labels, pointData);
      this.append(this.label);
    }
  };
  Bullet2.prototype.reflow = function reflow(box) {
    this.render();
    var ref2 = this;
    var options2 = ref2.options;
    var target = ref2.target;
    var chart = ref2.owner;
    var invertAxes = options2.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.options);
    var categorySlot = chart.categorySlot(chart.categoryAxis, options2.categoryIx, valueAxis);
    var targetValueSlot = valueAxis.getSlot(this.value.target);
    var targetSlotX = invertAxes ? targetValueSlot : categorySlot;
    var targetSlotY = invertAxes ? categorySlot : targetValueSlot;
    if (target) {
      var targetSlot = new box_default(
        targetSlotX.x1,
        targetSlotY.y1,
        targetSlotX.x2,
        targetSlotY.y2
      );
      target.options.height = invertAxes ? targetSlot.height() : options2.target.line.width;
      target.options.width = invertAxes ? options2.target.line.width : targetSlot.width();
      target.reflow(targetSlot);
    }
    var label = this.label;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(box);
    }
    if (this.note) {
      this.note.reflow(box);
    }
    this.box = box;
  };
  Bullet2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    var body = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: null
    });
    if (options2.border.width > 0) {
      body.options.set("stroke", {
        color: options2.border.color || this.color,
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: valueOrDefault2(options2.border.opacity, options2.opacity)
      });
    }
    this.bodyVisual = body;
    alignPathToPixel(body);
    this.visual.append(body);
  };
  Bullet2.prototype.createAnimation = function createAnimation() {
    if (this.bodyVisual) {
      this.animation = drawing_exports.Animation.create(
        this.bodyVisual,
        this.options.animation
      );
    }
  };
  Bullet2.prototype.createHighlight = function createHighlight(style) {
    return drawing_exports.Path.fromRect(this.box.toRect(), style);
  };
  Bullet2.prototype.highlightVisual = function highlightVisual() {
    return this.bodyVisual;
  };
  Bullet2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      rect: this.box.toRect(),
      visual: this.bodyVisual,
      options: this.options
    };
  };
  Bullet2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Bullet2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series
    };
  };
  Bullet2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  return Bullet2;
}(chart_element_default);
Bullet.prototype.tooltipAnchor = bar_default.prototype.tooltipAnchor;
setDefaultOptions(Bullet, {
  border: {
    width: 1
  },
  vertical: false,
  opacity: 1,
  target: {
    shape: "",
    border: {
      width: 0,
      color: "green"
    },
    line: {
      width: 2
    }
  },
  labels: {
    visible: false
  },
  tooltip: {
    format: "Current: {0}<br />Target: {1}"
  },
  notes: {
    label: {}
  }
});
deepExtend(Bullet.prototype, point_events_mixin_default);
deepExtend(Bullet.prototype, note_mixin_default);
var bullet_default = Bullet;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet-chart.js
var BulletChart = function(CategoricalChart2) {
  function BulletChart2(plotArea, options2) {
    wrapData(options2);
    CategoricalChart2.call(this, plotArea, options2);
  }
  if (CategoricalChart2)
    BulletChart2.__proto__ = CategoricalChart2;
  BulletChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BulletChart2.prototype.constructor = BulletChart2;
  BulletChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  BulletChart2.prototype.plotRange = function plotRange(point2) {
    var series = point2.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, point2.value.current || axisCrossingValue];
  };
  BulletChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var value = data.valueFields;
    var bulletOptions = deepExtend({
      vertical: !options2.invertAxes,
      overlay: series.overlay,
      categoryIx,
      invertAxes: options2.invertAxes
    }, series);
    var color = data.fields.color || series.color;
    bulletOptions = this.evalPointOptions(bulletOptions, value, fields);
    if (isFunction3(series.color)) {
      color = bulletOptions.color;
    }
    var bullet = new bullet_default(value, bulletOptions);
    bullet.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    cluster.append(bullet);
    return bullet;
  };
  BulletChart2.prototype.updateRange = function updateRange(value, fields) {
    var current4 = value.current;
    var target = value.target;
    var axisName = fields.series.axis;
    var axisRange = this.valueAxisRanges[axisName];
    if (defined2(current4) && !isNaN(current4) && defined2(target && !isNaN(target))) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, current4, target);
      axisRange.max = Math.max(axisRange.max, current4, target);
    }
  };
  BulletChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.chartService.format.auto(format2, point2.value.current, point2.value.target);
  };
  BulletChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields.current;
  };
  BulletChart2.prototype.aboveAxis = function aboveAxis(point2) {
    var value = point2.value.current;
    return value > 0;
  };
  BulletChart2.prototype.createAnimation = function createAnimation() {
    var this$1 = this;
    var points3 = this.points;
    this._setAnimationOptions();
    for (var idx = 0; idx < points3.length; idx++) {
      var point2 = points3[idx];
      point2.options.animation = this$1.options.animation;
      point2.createAnimation();
    }
  };
  return BulletChart2;
}(categorical_chart_default);
BulletChart.prototype._setAnimationOptions = bar_chart_default.prototype._setAnimationOptions;
setDefaultOptions(BulletChart, {
  animation: {
    type: BAR
  }
});
function wrapData(options2) {
  var series = options2.series;
  for (var i = 0; i < series.length; i++) {
    var seriesItem = series[i];
    var data = seriesItem.data;
    if (data && !isArray(data[0]) && !isObject(data[0])) {
      seriesItem.data = [data];
    }
  }
}
var bullet_chart_default = BulletChart;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/base-tooltip.js
var BaseTooltip = function(Class3) {
  function BaseTooltip2(chartService, options2) {
    Class3.call(this);
    this.chartService = chartService;
    this.options = deepExtend({}, this.options, options2);
  }
  if (Class3)
    BaseTooltip2.__proto__ = Class3;
  BaseTooltip2.prototype = Object.create(Class3 && Class3.prototype);
  BaseTooltip2.prototype.constructor = BaseTooltip2;
  BaseTooltip2.prototype.getStyle = function getStyle(options2, point2) {
    var background = options2.background;
    var border = options2.border.color;
    if (point2) {
      var pointColor = point2.color || point2.options.color;
      background = valueOrDefault2(background, pointColor);
      border = valueOrDefault2(border, pointColor);
    }
    var padding = getSpacing(options2.padding || {}, "auto");
    return {
      backgroundColor: background,
      borderColor: border,
      font: options2.font,
      color: options2.color,
      opacity: options2.opacity,
      borderWidth: styleValue(options2.border.width),
      paddingTop: styleValue(padding.top),
      paddingBottom: styleValue(padding.bottom),
      paddingLeft: styleValue(padding.left),
      paddingRight: styleValue(padding.right)
    };
  };
  BaseTooltip2.prototype.show = function show2(options2, tooltipOptions, point2) {
    options2.format = tooltipOptions.format;
    var style = this.getStyle(tooltipOptions, point2);
    options2.style = style;
    var background = new color_default(style.backgroundColor);
    if (!defined2(tooltipOptions.color) && !background.isDark()) {
      options2.className = "k-chart-tooltip-inverse";
    }
    this.chartService.notify(SHOW_TOOLTIP, options2);
    this.visible = true;
  };
  BaseTooltip2.prototype.hide = function hide2() {
    if (this.chartService) {
      this.chartService.notify(HIDE_TOOLTIP);
    }
    this.visible = false;
  };
  BaseTooltip2.prototype.destroy = function destroy2() {
    delete this.chartService;
  };
  return BaseTooltip2;
}(class_default);
setDefaultOptions(BaseTooltip, {
  border: {
    width: 1
  },
  opacity: 1
});
var base_tooltip_default = BaseTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair-tooltip.js
var CrosshairTooltip = function(BaseTooltip2) {
  function CrosshairTooltip3(chartService, crosshair, options2) {
    BaseTooltip2.call(this, chartService, options2);
    this.crosshair = crosshair;
    this.formatService = chartService.format;
    this.initAxisName();
  }
  if (BaseTooltip2)
    CrosshairTooltip3.__proto__ = BaseTooltip2;
  CrosshairTooltip3.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  CrosshairTooltip3.prototype.constructor = CrosshairTooltip3;
  CrosshairTooltip3.prototype.initAxisName = function initAxisName() {
    var axis = this.crosshair.axis;
    var plotArea = axis.plotArea;
    var name2;
    if (plotArea.categoryAxis) {
      name2 = axis.getCategory ? "categoryAxis" : "valueAxis";
    } else {
      name2 = axis.options.vertical ? "yAxis" : "xAxis";
    }
    this.axisName = name2;
  };
  CrosshairTooltip3.prototype.showAt = function showAt(point2) {
    var ref2 = this;
    var axis = ref2.crosshair.axis;
    var options2 = ref2.options;
    var value = axis[options2.stickyMode ? "getCategory" : "getValue"](point2);
    var formattedValue = value;
    if (options2.format) {
      formattedValue = this.formatService.auto(options2.format, value);
    } else if (axis.options.type === DATE) {
      formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);
    }
    this.show({
      point: point2,
      anchor: this.getAnchor(),
      crosshair: this.crosshair,
      value: formattedValue,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    }, this.options);
  };
  CrosshairTooltip3.prototype.hide = function hide2() {
    this.chartService.notify(HIDE_TOOLTIP, {
      crosshair: this.crosshair,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    });
  };
  CrosshairTooltip3.prototype.getAnchor = function getAnchor() {
    var ref2 = this;
    var crosshair = ref2.crosshair;
    var ref_options = ref2.options;
    var position3 = ref_options.position;
    var padding = ref_options.padding;
    var vertical = !crosshair.axis.options.vertical;
    var lineBox = crosshair.line.bbox();
    var horizontalAlign, verticalAlign, point2;
    if (vertical) {
      horizontalAlign = CENTER;
      if (position3 === BOTTOM) {
        verticalAlign = TOP;
        point2 = lineBox.bottomLeft().translate(0, padding);
      } else {
        verticalAlign = BOTTOM;
        point2 = lineBox.topLeft().translate(0, -padding);
      }
    } else {
      verticalAlign = CENTER;
      if (position3 === LEFT) {
        horizontalAlign = RIGHT;
        point2 = lineBox.topLeft().translate(-padding, 0);
      } else {
        horizontalAlign = LEFT;
        point2 = lineBox.topRight().translate(padding, 0);
      }
    }
    return {
      point: point2,
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  return CrosshairTooltip3;
}(base_tooltip_default);
setDefaultOptions(CrosshairTooltip, {
  padding: 10
});
var crosshair_tooltip_default = CrosshairTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair.js
var Crosshair = function(ChartElement2) {
  function Crosshair2(chartService, axis, options2) {
    ChartElement2.call(this, options2);
    this.axis = axis;
    this.stickyMode = axis instanceof category_axis_default;
    var tooltipOptions = this.options.tooltip;
    if (tooltipOptions.visible) {
      this.tooltip = new crosshair_tooltip_default(
        chartService,
        this,
        deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })
      );
    }
  }
  if (ChartElement2)
    Crosshair2.__proto__ = ChartElement2;
  Crosshair2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Crosshair2.prototype.constructor = Crosshair2;
  Crosshair2.prototype.showAt = function showAt(point2) {
    this.point = point2;
    this.moveLine();
    this.line.visible(true);
    if (this.tooltip) {
      this.tooltip.showAt(point2);
    }
  };
  Crosshair2.prototype.hide = function hide2() {
    this.line.visible(false);
    if (this.tooltip) {
      this.tooltip.hide();
    }
  };
  Crosshair2.prototype.moveLine = function moveLine() {
    var ref2 = this;
    var axis = ref2.axis;
    var point2 = ref2.point;
    var vertical = axis.options.vertical;
    var box = this.getBox();
    var dim = vertical ? Y : X;
    var lineStart = new geometry_exports.Point(box.x1, box.y1);
    var lineEnd;
    if (vertical) {
      lineEnd = new geometry_exports.Point(box.x2, box.y1);
    } else {
      lineEnd = new geometry_exports.Point(box.x1, box.y2);
    }
    if (point2) {
      if (this.stickyMode) {
        var slot = axis.getSlot(axis.pointCategoryIndex(point2));
        lineStart[dim] = lineEnd[dim] = slot.center()[dim];
      } else {
        lineStart[dim] = lineEnd[dim] = point2[dim];
      }
    }
    this.box = box;
    this.line.moveTo(lineStart).lineTo(lineEnd);
  };
  Crosshair2.prototype.getBox = function getBox() {
    var axis = this.axis;
    var axes = axis.pane.axes;
    var length = axes.length;
    var vertical = axis.options.vertical;
    var box = axis.lineBox().clone();
    var dim = vertical ? X : Y;
    var axisLineBox;
    for (var i = 0; i < length; i++) {
      var currentAxis = axes[i];
      if (currentAxis.options.vertical !== vertical) {
        if (!axisLineBox) {
          axisLineBox = currentAxis.lineBox().clone();
        } else {
          axisLineBox.wrap(currentAxis.lineBox());
        }
      }
    }
    box[dim + 1] = axisLineBox[dim + 1];
    box[dim + 2] = axisLineBox[dim + 2];
    return box;
  };
  Crosshair2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    this.line = new drawing_exports.Path({
      stroke: {
        color: options2.color,
        width: options2.width,
        opacity: options2.opacity,
        dashType: options2.dashType
      },
      visible: false
    });
    this.moveLine();
    this.visual.append(this.line);
  };
  Crosshair2.prototype.destroy = function destroy2() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    ChartElement2.prototype.destroy.call(this);
  };
  return Crosshair2;
}(chart_element_default);
setDefaultOptions(Crosshair, {
  color: BLACK,
  width: 2,
  zIndex: -1,
  tooltip: {
    visible: false
  }
});
var crosshair_default = Crosshair;

// node_modules/@progress/kendo-charts/dist/es/chart/chart-container.js
var ChartContainer = function(ChartElement2) {
  function ChartContainer2(options2, pane) {
    ChartElement2.call(this, options2);
    this.pane = pane;
  }
  if (ChartElement2)
    ChartContainer2.__proto__ = ChartElement2;
  ChartContainer2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ChartContainer2.prototype.constructor = ChartContainer2;
  ChartContainer2.prototype.shouldClip = function shouldClip() {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      if (children[i].options.clip === true) {
        return true;
      }
    }
    return false;
  };
  ChartContainer2.prototype._clipBox = function _clipBox() {
    return this.pane.chartsBox();
  };
  ChartContainer2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: 0
    });
    if (this.shouldClip()) {
      var clipBox = this.clipBox = this._clipBox();
      var clipRect = clipBox.toRect();
      var clipPath = drawing_exports.Path.fromRect(clipRect);
      alignPathToPixel(clipPath);
      this.visual.clip(clipPath);
      this.unclipLabels();
    }
  };
  ChartContainer2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  ChartContainer2.prototype.unclipLabels = function unclipLabels() {
    var ref2 = this;
    var charts = ref2.children;
    var clipBox = ref2.clipBox;
    for (var i = 0; i < charts.length; i++) {
      var points3 = charts[i].points || {};
      var length = points3.length;
      for (var j = 0; j < length; j++) {
        var point2 = points3[j];
        if (point2 && point2.visible !== false && point2.overlapsBox && point2.overlapsBox(clipBox)) {
          if (point2.unclipElements) {
            point2.unclipElements();
          } else {
            var label = point2.label;
            var note = point2.note;
            if (label && label.options.visible) {
              if (label.alignToClipBox) {
                label.alignToClipBox(clipBox);
              }
              label.options.noclip = true;
            }
            if (note && note.options.visible) {
              note.options.noclip = true;
            }
          }
        }
      }
    }
  };
  ChartContainer2.prototype.destroy = function destroy2() {
    ChartElement2.prototype.destroy.call(this);
    delete this.parent;
  };
  return ChartContainer2;
}(chart_element_default);
ChartContainer.prototype.isStackRoot = true;
var chart_container_default = ChartContainer;

// node_modules/@progress/kendo-charts/dist/es/chart/pane.js
var Pane = function(BoxElement2) {
  function Pane3(options2) {
    BoxElement2.call(this, options2);
    this.id = paneID();
    this.createTitle();
    this.content = new chart_element_default();
    this.chartContainer = new chart_container_default({}, this);
    this.append(this.content);
    this.axes = [];
    this.charts = [];
  }
  if (BoxElement2)
    Pane3.__proto__ = BoxElement2;
  Pane3.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Pane3.prototype.constructor = Pane3;
  Pane3.prototype.createTitle = function createTitle() {
    var titleOptions = this.options.title;
    if (isObject(titleOptions)) {
      titleOptions = deepExtend({}, titleOptions, {
        align: titleOptions.position,
        position: TOP
      });
    }
    this.title = title_default.buildTitle(titleOptions, Pane3.prototype.options.title);
    if (this.title) {
      this.append(this.title);
    }
  };
  Pane3.prototype.appendAxis = function appendAxis(axis) {
    this.content.append(axis);
    this.axes.push(axis);
    axis.pane = this;
  };
  Pane3.prototype.appendAxisAt = function appendAxisAt(axis, pos) {
    this.content.append(axis);
    this.axes.splice(pos, 0, axis);
    axis.pane = this;
  };
  Pane3.prototype.appendChart = function appendChart(chart) {
    if (this.chartContainer.parent !== this.content) {
      this.content.append(this.chartContainer);
    }
    this.charts.push(chart);
    this.chartContainer.append(chart);
    chart.pane = this;
  };
  Pane3.prototype.empty = function empty() {
    var this$1 = this;
    var plotArea = this.parent;
    if (plotArea) {
      for (var i = 0; i < this.axes.length; i++) {
        plotArea.removeAxis(this$1.axes[i]);
      }
      for (var i$1 = 0; i$1 < this.charts.length; i$1++) {
        plotArea.removeChart(this$1.charts[i$1]);
      }
    }
    this.axes = [];
    this.charts = [];
    this.content.destroy();
    this.content.children = [];
    this.chartContainer.children = [];
  };
  Pane3.prototype.reflow = function reflow(targetBox) {
    var content;
    if (last2(this.children) === this.content) {
      content = this.children.pop();
    }
    BoxElement2.prototype.reflow.call(this, targetBox);
    if (content) {
      this.children.push(content);
    }
    if (this.title) {
      this.contentBox.y1 += this.title.box.height();
    }
  };
  Pane3.prototype.visualStyle = function visualStyle() {
    var style = BoxElement2.prototype.visualStyle.call(this);
    style.zIndex = -10;
    return style;
  };
  Pane3.prototype.renderComplete = function renderComplete() {
    if (this.options.visible) {
      this.createGridLines();
    }
  };
  Pane3.prototype.stackRoot = function stackRoot() {
    return this;
  };
  Pane3.prototype.clipRoot = function clipRoot() {
    return this;
  };
  Pane3.prototype.createGridLines = function createGridLines() {
    var axes = this.axes;
    var allAxes = axes.concat(this.parent.axes);
    var vGridLines = [];
    var hGridLines = [];
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var vertical = axis.options.vertical;
      var gridLines = vertical ? vGridLines : hGridLines;
      for (var j = 0; j < allAxes.length; j++) {
        if (gridLines.length === 0) {
          var altAxis = allAxes[j];
          if (vertical !== altAxis.options.vertical) {
            append2(gridLines, axis.createGridLines(altAxis));
          }
        }
      }
    }
  };
  Pane3.prototype.refresh = function refresh() {
    this.visual.clear();
    this.content.parent = null;
    this.content.createGradient = this.createGradient.bind(this);
    this.content.renderVisual();
    this.content.parent = this;
    if (this.title) {
      this.visual.append(this.title.visual);
    }
    this.visual.append(this.content.visual);
    this.renderComplete();
    this.notifyRender();
  };
  Pane3.prototype.chartsBox = function chartsBox() {
    var axes = this.axes;
    var length = axes.length;
    var chartsBox2 = new box_default();
    for (var idx = 0; idx < length; idx++) {
      var axis = axes[idx];
      var axisValueField = axis.options.vertical ? Y : X;
      var lineBox = axis.lineBox();
      chartsBox2[axisValueField + 1] = lineBox[axisValueField + 1];
      chartsBox2[axisValueField + 2] = lineBox[axisValueField + 2];
    }
    if (chartsBox2.x2 === 0) {
      var allAxes = this.parent.axes;
      var length$1 = allAxes.length;
      for (var idx$1 = 0; idx$1 < length$1; idx$1++) {
        var axis$1 = allAxes[idx$1];
        if (!axis$1.options.vertical) {
          var lineBox$1 = axis$1.lineBox();
          chartsBox2.x1 = lineBox$1.x1;
          chartsBox2.x2 = lineBox$1.x2;
        }
      }
    }
    return chartsBox2;
  };
  Pane3.prototype.clipBox = function clipBox() {
    return this.chartContainer.clipBox;
  };
  Pane3.prototype.notifyRender = function notifyRender() {
    var service = this.getService();
    if (service) {
      service.notify(PANE_RENDER, {
        pane: new chart_pane_default(this),
        index: this.paneIndex,
        name: this.options.name
      });
    }
  };
  return Pane3;
}(box_element_default);
var ID = 1;
function paneID() {
  return "pane" + ID++;
}
Pane.prototype.isStackRoot = true;
setDefaultOptions(Pane, {
  zIndex: -1,
  shrinkToFit: true,
  title: {
    align: LEFT
  },
  visible: true
});
var pane_default = Pane;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/append-if-not-null.js
function appendIfNotNull(array, element2) {
  if (element2 !== null) {
    array.push(element2);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/segment-visible.js
function segmentVisible(series, fields, index) {
  var visible = fields.visible;
  if (defined2(visible)) {
    return visible;
  }
  var pointVisibility = series.pointVisibility;
  if (pointVisibility) {
    return pointVisibility[index];
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/bind-segments.js
function bindSegments(series) {
  var data = series.data;
  var points3 = [];
  var sum = 0;
  var count = 0;
  for (var idx = 0; idx < data.length; idx++) {
    var pointData = series_binder_default.current.bindPoint(series, idx);
    var value = pointData.valueFields.value;
    if (isString2(value)) {
      value = parseFloat(value);
    }
    if (isNumber2(value)) {
      pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;
      pointData.value = Math.abs(value);
      points3.push(pointData);
      if (pointData.visible) {
        sum += pointData.value;
      }
      if (value !== 0) {
        count++;
      }
    } else {
      points3.push(null);
    }
  }
  return {
    total: sum,
    points: points3,
    count
  };
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/equals-ignore-case.js
function equalsIgnoreCase(a, b) {
  if (a && b) {
    return a.toLowerCase() === b.toLowerCase();
  }
  return a === b;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/filter-series-by-type.js
function filterSeriesByType(series, types) {
  var result = [];
  var seriesTypes = [].concat(types);
  for (var idx = 0; idx < series.length; idx++) {
    var currentSeries = series[idx];
    if (inArray(currentSeries.type, seriesTypes)) {
      result.push(currentSeries);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/get-date-field.js
function getDateField(field, row, intlService) {
  if (row === null) {
    return row;
  }
  var key = "_date_" + field;
  var value = row[key];
  if (!value) {
    value = parseDate3(intlService, getter(field, true)(row));
    row[key] = value;
  }
  return value;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/is-date-axis.js
function isDateAxis(axisOptions2, sampleCategory) {
  var type = axisOptions2.type;
  var dateCategory = sampleCategory instanceof Date;
  return !type && dateCategory || equalsIgnoreCase(type, DATE);
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/single-item-or-array.js
function singleItemOrArray(array) {
  return array.length === 1 ? array[0] : array;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/create-out-of-range-points.js
var AREA_REGEX = /area/i;
function seriesMissingValues(series) {
  if (series.missingValues) {
    return series.missingValues;
  }
  return AREA_REGEX.test(series.type) || series.stack ? ZERO2 : INTERPOLATE;
}
function hasValue2(series, item) {
  var fields = series_binder_default.current.bindPoint(series, null, item);
  var valueFields = fields.valueFields;
  for (var field in valueFields) {
    if (convertableToNumber(valueFields[field])) {
      return true;
    }
  }
}
function findNext(ref2) {
  var start = ref2.start;
  var dir = ref2.dir;
  var min3 = ref2.min;
  var max2 = ref2.max;
  var getter2 = ref2.getter;
  var hasItem = ref2.hasItem;
  var series = ref2.series;
  var pointHasValue, outPoint;
  var idx = start;
  do {
    idx += dir;
    if (hasItem(idx)) {
      outPoint = getter2(idx);
      pointHasValue = hasValue2(series, outPoint.item);
    }
  } while (min3 <= idx && idx <= max2 && !pointHasValue);
  if (pointHasValue) {
    return outPoint;
  }
}
function createOutOfRangePoints(series, range, count, getter2, hasItem) {
  var min3 = range.min;
  var max2 = range.max;
  var hasMinPoint = min3 > 0 && min3 < count;
  var hasMaxPoint = max2 + 1 < count;
  if (hasMinPoint || hasMaxPoint) {
    var missingValues = seriesMissingValues(series);
    var minPoint, maxPoint;
    if (missingValues !== INTERPOLATE) {
      if (hasMinPoint) {
        minPoint = getter2(min3 - 1);
      }
      if (hasMaxPoint) {
        maxPoint = getter2(max2 + 1);
      }
    } else {
      var outPoint, pointHasValue;
      if (hasMinPoint) {
        outPoint = getter2(min3 - 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          minPoint = findNext({
            start: min3,
            dir: -1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          minPoint = outPoint;
        }
      }
      if (hasMaxPoint) {
        outPoint = getter2(max2 + 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          maxPoint = findNext({
            start: max2,
            dir: 1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          maxPoint = outPoint;
        }
      }
    }
    if (minPoint) {
      series._outOfRangeMinPoint = minPoint;
    }
    if (maxPoint) {
      series._outOfRangeMaxPoint = maxPoint;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-base.js
var PlotAreaBase = function(ChartElement2) {
  function PlotAreaBase2(series, options2, chartService) {
    ChartElement2.call(this, options2);
    this.initFields(series, options2);
    this.series = series;
    this.initSeries();
    this.charts = [];
    this.options.legend = this.options.legend || {};
    this.options.legend.items = [];
    this.axes = [];
    this.crosshairs = [];
    this.chartService = chartService;
    this.originalOptions = options2;
    this.createPanes();
    this.render();
    this.createCrosshairs();
  }
  if (ChartElement2)
    PlotAreaBase2.__proto__ = ChartElement2;
  PlotAreaBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PlotAreaBase2.prototype.constructor = PlotAreaBase2;
  PlotAreaBase2.prototype.initFields = function initFields() {
  };
  PlotAreaBase2.prototype.initSeries = function initSeries() {
    var series = this.series;
    for (var i = 0; i < series.length; i++) {
      series[i].index = i;
    }
  };
  PlotAreaBase2.prototype.createPanes = function createPanes() {
    var this$1 = this;
    var titleOptions = this.options.title || {};
    var paneDefaults = this.options.paneDefaults;
    var paneOptions = this.options.panes || [];
    var panesLength = Math.max(paneOptions.length, 1);
    var panes = [];
    var defaults = deepExtend({
      title: {
        color: titleOptions.color
      }
    }, paneDefaults);
    for (var i = 0; i < panesLength; i++) {
      var options2 = deepExtend({}, defaults, paneOptions[i]);
      if (isString2(options2.title)) {
        options2.title = deepExtend({ text: options2.title }, defaults.title);
      }
      var currentPane = new pane_default(options2);
      currentPane.paneIndex = i;
      panes.push(currentPane);
      this$1.append(currentPane);
    }
    this.panes = panes;
  };
  PlotAreaBase2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return axis.options.crosshair;
  };
  PlotAreaBase2.prototype.createCrosshairs = function createCrosshairs(panes) {
    var this$1 = this;
    if (panes === void 0)
      panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      for (var j = 0; j < pane.axes.length; j++) {
        var axis = pane.axes[j];
        var options2 = this$1.crosshairOptions(axis);
        if (options2 && options2.visible) {
          var currentCrosshair = new crosshair_default(this$1.chartService, axis, options2);
          this$1.crosshairs.push(currentCrosshair);
          pane.content.append(currentCrosshair);
        }
      }
    }
  };
  PlotAreaBase2.prototype.removeCrosshairs = function removeCrosshairs(pane) {
    var crosshairs = this.crosshairs;
    var axes = pane.axes;
    for (var i = crosshairs.length - 1; i >= 0; i--) {
      for (var j = 0; j < axes.length; j++) {
        if (crosshairs[i].axis === axes[j]) {
          crosshairs.splice(i, 1);
          break;
        }
      }
    }
  };
  PlotAreaBase2.prototype.hideCrosshairs = function hideCrosshairs() {
    var crosshairs = this.crosshairs;
    for (var idx = 0; idx < crosshairs.length; idx++) {
      crosshairs[idx].hide();
    }
  };
  PlotAreaBase2.prototype.findPane = function findPane(name2) {
    var panes = this.panes;
    var matchingPane;
    for (var i = 0; i < panes.length; i++) {
      if (panes[i].options.name === name2) {
        matchingPane = panes[i];
        break;
      }
    }
    return matchingPane || panes[0];
  };
  PlotAreaBase2.prototype.findPointPane = function findPointPane(point2) {
    var panes = this.panes;
    var matchingPane;
    for (var i = 0; i < panes.length; i++) {
      if (panes[i].box.containsPoint(point2)) {
        matchingPane = panes[i];
        break;
      }
    }
    return matchingPane;
  };
  PlotAreaBase2.prototype.appendAxis = function appendAxis(axis) {
    var pane = this.findPane(axis.options.pane);
    pane.appendAxis(axis);
    this.axes.push(axis);
    axis.plotArea = this;
  };
  PlotAreaBase2.prototype.removeAxis = function removeAxis(axisToRemove) {
    var this$1 = this;
    var filteredAxes = [];
    for (var i = 0; i < this.axes.length; i++) {
      var axis = this$1.axes[i];
      if (axisToRemove !== axis) {
        filteredAxes.push(axis);
      } else {
        axis.destroy();
      }
    }
    this.axes = filteredAxes;
  };
  PlotAreaBase2.prototype.appendChart = function appendChart(chart, pane) {
    this.charts.push(chart);
    if (pane) {
      pane.appendChart(chart);
    } else {
      this.append(chart);
    }
  };
  PlotAreaBase2.prototype.removeChart = function removeChart(chartToRemove) {
    var this$1 = this;
    var filteredCharts = [];
    for (var i = 0; i < this.charts.length; i++) {
      var chart = this$1.charts[i];
      if (chart !== chartToRemove) {
        filteredCharts.push(chart);
      } else {
        chart.destroy();
      }
    }
    this.charts = filteredCharts;
  };
  PlotAreaBase2.prototype.addToLegend = function addToLegend(series) {
    var count = series.length;
    var legend2 = this.options.legend;
    var labels = legend2.labels || {};
    var inactiveItems = legend2.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    var data = [];
    for (var i = 0; i < count; i++) {
      var currentSeries = series[i];
      var seriesVisible = currentSeries.visible !== false;
      if (currentSeries.visibleInLegend === false) {
        continue;
      }
      var text = currentSeries.name;
      var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);
      if (labelTemplate) {
        text = labelTemplate({
          text: hasValue(text) ? text : "",
          series: currentSeries
        });
      }
      var defaults = currentSeries._defaults;
      var color = currentSeries.color;
      if (isFunction3(color) && defaults) {
        color = defaults.color;
      }
      var itemLabelOptions = void 0, markerColor = void 0;
      if (seriesVisible) {
        itemLabelOptions = {};
        markerColor = color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = inactiveItems.markers.color;
      }
      if (hasValue(text) && text !== "") {
        data.push({
          text,
          labels: itemLabelOptions,
          markerColor,
          series: currentSeries,
          active: seriesVisible
        });
      }
    }
    append2(legend2.items, data);
  };
  PlotAreaBase2.prototype.groupAxes = function groupAxes(panes) {
    var xAxes = [];
    var yAxes = [];
    for (var paneIx = 0; paneIx < panes.length; paneIx++) {
      var paneAxes = panes[paneIx].axes;
      for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {
        var axis = paneAxes[axisIx];
        if (axis.options.vertical) {
          yAxes.push(axis);
        } else {
          xAxes.push(axis);
        }
      }
    }
    return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };
  };
  PlotAreaBase2.prototype.groupSeriesByPane = function groupSeriesByPane() {
    var this$1 = this;
    var series = this.series;
    var seriesByPane = {};
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var pane = this$1.seriesPaneName(currentSeries);
      if (seriesByPane[pane]) {
        seriesByPane[pane].push(currentSeries);
      } else {
        seriesByPane[pane] = [currentSeries];
      }
    }
    return seriesByPane;
  };
  PlotAreaBase2.prototype.filterVisibleSeries = function filterVisibleSeries(series) {
    var result = [];
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      if (currentSeries.visible !== false) {
        result.push(currentSeries);
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options.plotArea;
    var panes = this.panes;
    var margin = getSpacing(options2.margin);
    this.box = targetBox.clone().unpad(margin);
    this.reflowPanes();
    this.detachLabels();
    this.reflowAxes(panes);
    this.reflowCharts(panes);
  };
  PlotAreaBase2.prototype.redraw = function redraw(panes) {
    var this$1 = this;
    var panesArray = [].concat(panes);
    this.initSeries();
    var root = this.getRoot();
    if (root) {
      root.cleanGradients();
    }
    for (var i = 0; i < panesArray.length; i++) {
      this$1.removeCrosshairs(panesArray[i]);
      panesArray[i].empty();
    }
    this.render(panesArray);
    this.detachLabels();
    this.reflowAxes(this.panes);
    this.reflowCharts(panesArray);
    this.createCrosshairs(panesArray);
    for (var i$1 = 0; i$1 < panesArray.length; i$1++) {
      panesArray[i$1].refresh();
    }
  };
  PlotAreaBase2.prototype.axisCrossingValues = function axisCrossingValues(axis, crossingAxes) {
    var options2 = axis.options;
    var crossingValues = [].concat(
      options2.axisCrossingValues || options2.axisCrossingValue
    );
    var valuesToAdd = crossingAxes.length - crossingValues.length;
    var defaultValue = crossingValues[0] || 0;
    for (var i = 0; i < valuesToAdd; i++) {
      crossingValues.push(defaultValue);
    }
    return crossingValues;
  };
  PlotAreaBase2.prototype.alignAxisTo = function alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {
    var slot = axis.getSlot(crossingValue, crossingValue, true);
    var slotEdge = axis.options.reverse ? 2 : 1;
    var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);
    var targetEdge = targetAxis.options.reverse ? 2 : 1;
    var axisBox = axis.box.translate(
      targetSlot[X + targetEdge] - slot[X + slotEdge],
      targetSlot[Y + targetEdge] - slot[Y + slotEdge]
    );
    if (axis.pane !== targetAxis.pane) {
      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);
    }
    axis.reflow(axisBox);
  };
  PlotAreaBase2.prototype.alignAxes = function alignAxes(xAxes, yAxes) {
    var this$1 = this;
    var xAnchor = xAxes[0];
    var yAnchor = yAxes[0];
    var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);
    var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);
    var leftAnchors = {};
    var rightAnchors = {};
    var topAnchors = {};
    var bottomAnchors = {};
    for (var i = 0; i < yAxes.length; i++) {
      var axis = yAxes[i];
      var pane = axis.pane;
      var paneId = pane.id;
      var visible = axis.options.visible !== false;
      var anchor = paneAnchor(xAxes, pane) || xAnchor;
      var anchorCrossings = xAnchorCrossings;
      if (anchor !== xAnchor) {
        anchorCrossings = this$1.axisCrossingValues(anchor, yAxes);
      }
      this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);
      if (axis.options._overlap) {
        continue;
      }
      if (round3(axis.lineBox().x1) === round3(anchor.lineBox().x1)) {
        if (leftAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0)
          );
        }
        if (visible) {
          leftAnchors[paneId] = axis;
        }
      }
      if (round3(axis.lineBox().x2) === round3(anchor.lineBox().x2)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);
        if (rightAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0)
          );
        }
        if (visible) {
          rightAnchors[paneId] = axis;
        }
      }
      if (i !== 0 && yAnchor.pane === axis.pane) {
        axis.alignTo(yAnchor);
        axis.reflow(axis.box);
      }
    }
    for (var i$1 = 0; i$1 < xAxes.length; i$1++) {
      var axis$1 = xAxes[i$1];
      var pane$1 = axis$1.pane;
      var paneId$1 = pane$1.id;
      var visible$1 = axis$1.options.visible !== false;
      var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;
      var anchorCrossings$1 = yAnchorCrossings;
      if (anchor$1 !== yAnchor) {
        anchorCrossings$1 = this$1.axisCrossingValues(anchor$1, xAxes);
      }
      this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);
      if (axis$1.options._overlap) {
        continue;
      }
      if (round3(axis$1.lineBox().y1) === round3(anchor$1.lineBox().y1)) {
        if (!axis$1._mirrored) {
          axis$1.options.labels.mirror = !axis$1.options.labels.mirror;
          axis$1._mirrored = true;
        }
        this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);
        if (topAnchors[paneId$1]) {
          axis$1.reflow(
            axis$1.box.alignTo(topAnchors[paneId$1].box, TOP).translate(0, -axis$1.options.margin)
          );
        }
        if (visible$1) {
          topAnchors[paneId$1] = axis$1;
        }
      }
      if (round3(axis$1.lineBox().y2, COORD_PRECISION) === round3(anchor$1.lineBox().y2, COORD_PRECISION)) {
        if (bottomAnchors[paneId$1]) {
          axis$1.reflow(
            axis$1.box.alignTo(bottomAnchors[paneId$1].box, BOTTOM).translate(0, axis$1.options.margin)
          );
        }
        if (visible$1) {
          bottomAnchors[paneId$1] = axis$1;
        }
      }
      if (i$1 !== 0) {
        axis$1.alignTo(xAnchor);
        axis$1.reflow(axis$1.box);
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisWidth = function shrinkAxisWidth(panes) {
    var axes = this.groupAxes(panes).any;
    var axisBox = axisGroupBox(axes);
    var overflowX = 0;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      if (currentPane.axes.length > 0) {
        overflowX = Math.max(
          overflowX,
          axisBox.width() - currentPane.contentBox.width()
        );
      }
    }
    if (overflowX !== 0) {
      for (var i$1 = 0; i$1 < axes.length; i$1++) {
        var currentAxis = axes[i$1];
        if (!currentAxis.options.vertical) {
          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));
        }
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisHeight = function shrinkAxisHeight(panes) {
    var shrinked;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      var axes = currentPane.axes;
      var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());
      if (overflowY !== 0) {
        for (var j = 0; j < axes.length; j++) {
          var currentAxis = axes[j];
          if (currentAxis.options.vertical) {
            currentAxis.reflow(
              currentAxis.box.shrink(0, overflowY)
            );
          }
        }
        shrinked = true;
      }
    }
    return shrinked;
  };
  PlotAreaBase2.prototype.fitAxes = function fitAxes(panes) {
    var axes = this.groupAxes(panes).any;
    var offsetX = 0;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      var paneAxes = currentPane.axes;
      var paneBox = currentPane.contentBox;
      if (paneAxes.length > 0) {
        var axisBox = axisGroupBox(paneAxes);
        var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);
        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);
        for (var j = 0; j < paneAxes.length; j++) {
          var currentAxis = paneAxes[j];
          currentAxis.reflow(
            currentAxis.box.translate(0, offsetY)
          );
        }
      }
    }
    for (var i$1 = 0; i$1 < axes.length; i$1++) {
      var currentAxis$1 = axes[i$1];
      currentAxis$1.reflow(
        currentAxis$1.box.translate(offsetX, 0)
      );
    }
  };
  PlotAreaBase2.prototype.reflowAxes = function reflowAxes(panes) {
    var this$1 = this;
    var axes = this.groupAxes(panes);
    for (var i = 0; i < panes.length; i++) {
      this$1.reflowPaneAxes(panes[i]);
    }
    if (axes.x.length > 0 && axes.y.length > 0) {
      this.alignAxes(axes.x, axes.y);
      this.shrinkAxisWidth(panes);
      this.autoRotateAxisLabels(axes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisWidth(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.shrinkAxisHeight(panes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisHeight(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.fitAxes(panes);
    }
  };
  PlotAreaBase2.prototype.autoRotateAxisLabels = function autoRotateAxisLabels(groupedAxes) {
    var this$1 = this;
    var ref2 = this;
    var panes = ref2.panes;
    var axes = allPaneAxes(panes);
    var rotated;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      if (axis.autoRotateLabels()) {
        rotated = true;
      }
    }
    if (rotated) {
      for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {
        this$1.reflowPaneAxes(panes[idx$1]);
      }
      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {
        this.alignAxes(groupedAxes.x, groupedAxes.y);
        this.shrinkAxisWidth(panes);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPaneAxes = function reflowPaneAxes(pane) {
    var axes = pane.axes;
    var length = axes.length;
    if (length > 0) {
      for (var i = 0; i < length; i++) {
        axes[i].reflow(pane.contentBox);
      }
    }
  };
  PlotAreaBase2.prototype.reflowCharts = function reflowCharts(panes) {
    var charts = this.charts;
    var count = charts.length;
    var box = this.box;
    for (var i = 0; i < count; i++) {
      var chartPane = charts[i].pane;
      if (!chartPane || inArray(chartPane, panes)) {
        charts[i].reflow(box);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPanes = function reflowPanes() {
    var ref2 = this;
    var box = ref2.box;
    var panes = ref2.panes;
    var panesLength = panes.length;
    var remainingHeight = box.height();
    var remainingPanes = panesLength;
    var autoHeightPanes = 0;
    var top = box.y1;
    for (var i = 0; i < panesLength; i++) {
      var currentPane = panes[i];
      var height = currentPane.options.height;
      currentPane.options.width = box.width();
      if (!currentPane.options.height) {
        autoHeightPanes++;
      } else {
        if (height.indexOf && height.indexOf("%")) {
          var percents = parseInt(height, 10) / 100;
          currentPane.options.height = percents * box.height();
        }
        currentPane.reflow(box.clone());
        remainingHeight -= currentPane.options.height;
      }
    }
    for (var i$1 = 0; i$1 < panesLength; i$1++) {
      var currentPane$1 = panes[i$1];
      if (!currentPane$1.options.height) {
        currentPane$1.options.height = remainingHeight / autoHeightPanes;
      }
    }
    for (var i$2 = 0; i$2 < panesLength; i$2++) {
      var currentPane$2 = panes[i$2];
      var paneBox = box.clone().move(box.x1, top);
      currentPane$2.reflow(paneBox);
      remainingPanes--;
      top += currentPane$2.options.height;
    }
  };
  PlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    var axes = this.axes;
    var axesCount = axes.length;
    var box;
    for (var i = 0; i < axesCount; i++) {
      var axisA = axes[i];
      for (var j = 0; j < axesCount; j++) {
        var axisB = axes[j];
        if (axisA.options.vertical !== axisB.options.vertical) {
          var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());
          if (!box) {
            box = lineBox;
          } else {
            box = box.wrap(lineBox);
          }
        }
      }
    }
    return box || this.box;
  };
  PlotAreaBase2.prototype.chartsBoxes = function chartsBoxes() {
    var panes = this.panes;
    var boxes = [];
    for (var idx = 0; idx < panes.length; idx++) {
      boxes.push(panes[idx].chartsBox());
    }
    return boxes;
  };
  PlotAreaBase2.prototype.addBackgroundPaths = function addBackgroundPaths(multipath) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      multipath.paths.push(drawing_exports.Path.fromRect(boxes[idx].toRect()));
    }
  };
  PlotAreaBase2.prototype.backgroundContainsPoint = function backgroundContainsPoint(point2) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      if (boxes[idx].containsPoint(point2)) {
        return true;
      }
    }
  };
  PlotAreaBase2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options.plotArea;
    var opacity = options2.opacity;
    var background = options2.background;
    var border = options2.border;
    if (border === void 0)
      border = {};
    if (isTransparent2(background)) {
      background = WHITE;
      opacity = 0;
    }
    var bg = this._bgVisual = new drawing_exports.MultiPath({
      fill: {
        color: background,
        opacity
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      zIndex: -1
    });
    this.addBackgroundPaths(bg);
    this.appendVisual(bg);
  };
  PlotAreaBase2.prototype.pointsByCategoryIndex = function pointsByCategoryIndex(categoryIndex) {
    var charts = this.charts;
    var result = [];
    if (categoryIndex !== null) {
      for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];
        if (chart.pane.options.name === "_navigator") {
          continue;
        }
        var points3 = charts[i].categoryPoints[categoryIndex];
        if (points3 && points3.length) {
          for (var j = 0; j < points3.length; j++) {
            var point2 = points3[j];
            if (point2 && defined2(point2.value) && point2.value !== null) {
              result.push(point2);
            }
          }
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.pointsBySeriesIndex = function pointsBySeriesIndex(seriesIndex) {
    return this.filterPoints(function(point2) {
      return point2.series.index === seriesIndex;
    });
  };
  PlotAreaBase2.prototype.pointsBySeriesName = function pointsBySeriesName(name2) {
    return this.filterPoints(function(point2) {
      return point2.series.name === name2;
    });
  };
  PlotAreaBase2.prototype.filterPoints = function filterPoints(callback) {
    var charts = this.charts;
    var result = [];
    for (var i = 0; i < charts.length; i++) {
      var chart = charts[i];
      var points3 = chart.points;
      for (var j = 0; j < points3.length; j++) {
        var point2 = points3[j];
        if (point2 && point2.visible !== false && callback(point2)) {
          result.push(point2);
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.findPoint = function findPoint(callback) {
    var charts = this.charts;
    for (var i = 0; i < charts.length; i++) {
      var chart = charts[i];
      var points3 = chart.points;
      for (var j = 0; j < points3.length; j++) {
        var point2 = points3[j];
        if (point2 && point2.visible !== false && callback(point2)) {
          return point2;
        }
      }
    }
  };
  PlotAreaBase2.prototype.paneByPoint = function paneByPoint(point2) {
    var panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      if (pane.box.containsPoint(point2)) {
        return pane;
      }
    }
  };
  PlotAreaBase2.prototype.detachLabels = function detachLabels() {
    var axes = this.groupAxes(this.panes);
    var xAxes = axes.x;
    var yAxes = axes.y;
    this.detachAxisGroupLabels(yAxes, xAxes);
    this.detachAxisGroupLabels(xAxes, yAxes);
  };
  PlotAreaBase2.prototype.detachAxisGroupLabels = function detachAxisGroupLabels(axes, crossingAxes) {
    var this$1 = this;
    var labelAxisCount = 0;
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var pane = axis.pane;
      var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];
      var axisIndex = i + labelAxisCount;
      var labelAxis = this$1.createLabelAxis(axis, axisIndex, anchor);
      if (labelAxis) {
        labelAxisCount++;
        var pos = pane.axes.indexOf(axis) + labelAxisCount;
        pane.appendAxisAt(labelAxis, pos);
      }
    }
  };
  PlotAreaBase2.prototype.createLabelAxis = function createLabelAxis(axis, axisIndex, anchor) {
    var labelOptions = axis.options.labels;
    var position3 = labelOptions.position;
    var onAxis = position3 !== END && position3 !== START;
    var visible = labelOptions.visible;
    if (onAxis || visible === false) {
      return null;
    }
    var allAxes = this.groupAxes(this.panes);
    var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;
    var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);
    var end = position3 === END;
    var range = anchor.range();
    var edge = end ? range.max : range.min;
    var crossingValue = limitValue2(anchorCrossings[axisIndex], range.min, range.max);
    if (crossingValue - edge === 0) {
      return null;
    }
    anchorCrossings.splice(axisIndex + 1, 0, edge);
    anchor.options.axisCrossingValues = anchorCrossings;
    var labelAxis = axis.clone();
    axis.clear();
    labelAxis.options.name = void 0;
    labelAxis.options.line.visible = false;
    labelAxis.options.crosshair = void 0;
    labelAxis.options.notes = void 0;
    labelAxis.options.plotBands = void 0;
    return labelAxis;
  };
  return PlotAreaBase2;
}(chart_element_default);
function isSingleAxis(axis) {
  return !axis.pane.axes.some(
    function(a) {
      return a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false;
    }
  );
}
function axisGroupBox(axes) {
  var length = axes.length;
  var box;
  for (var i = 0; i < length; i++) {
    var axis = axes[i];
    var visible = axis.options.visible !== false;
    if (visible || isSingleAxis(axis)) {
      var axisBox = visible ? axis.contentBox() : axis.lineBox();
      if (!box) {
        box = axisBox.clone();
      } else {
        box.wrap(axisBox);
      }
    }
  }
  return box || new box_default();
}
function paneAnchor(axes, pane) {
  for (var i = 0; i < axes.length; i++) {
    var anchor = axes[i];
    if (anchor && anchor.pane === pane) {
      return anchor;
    }
  }
}
function isTransparent2(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined2(color);
}
var allPaneAxes = function(panes) {
  return panes.reduce(function(acc, pane) {
    return acc.concat(pane.axes);
  }, []);
};
setDefaultOptions(PlotAreaBase, {
  series: [],
  plotArea: {
    margin: {}
  },
  background: "",
  border: {
    color: BLACK,
    width: 0
  },
  paneDefaults: {
    title: {}
  },
  legend: {
    inactiveItems: {
      labels: {
        color: "#919191"
      },
      markers: {
        color: "#919191"
      }
    }
  }
});
var plotarea_base_default = PlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/plotarea-events-mixin.js
var PlotAreaEventsMixin = {
  hover: function(chart, e) {
    this._dispatchEvent(chart, e, PLOT_AREA_HOVER);
  },
  click: function(chart, e) {
    this._dispatchEvent(chart, e, PLOT_AREA_CLICK);
  }
};
var plotarea_events_mixin_default = PlotAreaEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/series-aggregator.js
var SeriesAggregator = function(Class3) {
  function SeriesAggregator2(series, binder, defaultAggregates) {
    Class3.call(this);
    var canonicalFields = binder.canonicalFields(series);
    var valueFields = binder.valueFields(series);
    var sourceFields = binder.sourceFields(series, canonicalFields);
    var seriesFields = this._seriesFields = [];
    var defaults = defaultAggregates.query(series.type);
    var rootAggregate = series.aggregate || defaults;
    this._series = series;
    this._binder = binder;
    for (var i = 0; i < canonicalFields.length; i++) {
      var field = canonicalFields[i];
      var fieldAggregate = void 0;
      if (isObject(rootAggregate)) {
        fieldAggregate = rootAggregate[field];
      } else if (i === 0 || inArray(field, valueFields)) {
        fieldAggregate = rootAggregate;
      } else {
        break;
      }
      if (fieldAggregate) {
        seriesFields.push({
          canonicalName: field,
          name: sourceFields[i],
          transform: isFunction3(fieldAggregate) ? fieldAggregate : aggregates_default[fieldAggregate]
        });
      }
    }
  }
  if (Class3)
    SeriesAggregator2.__proto__ = Class3;
  SeriesAggregator2.prototype = Object.create(Class3 && Class3.prototype);
  SeriesAggregator2.prototype.constructor = SeriesAggregator2;
  SeriesAggregator2.prototype.aggregatePoints = function aggregatePoints(srcPoints, group) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2._series;
    var seriesFields = ref2._seriesFields;
    var data = this._bindPoints(srcPoints || []);
    var firstDataItem = data.dataItems[0];
    var result = {};
    if (firstDataItem && !isNumber2(firstDataItem) && !isArray(firstDataItem)) {
      var fn = function() {
      };
      fn.prototype = firstDataItem;
      result = new fn();
    }
    for (var i = 0; i < seriesFields.length; i++) {
      var field = seriesFields[i];
      var srcValues = this$1._bindField(data.values, field.canonicalName);
      var value = field.transform(srcValues, series, data.dataItems, group);
      if (value !== null && isObject(value) && !defined2(value.length) && !(value instanceof Date)) {
        result = value;
        break;
      } else {
        if (defined2(value)) {
          setValue(field.name, result, value);
        }
      }
    }
    return result;
  };
  SeriesAggregator2.prototype._bindPoints = function _bindPoints(points3) {
    var ref2 = this;
    var binder = ref2._binder;
    var series = ref2._series;
    var values5 = [];
    var dataItems = [];
    for (var i = 0; i < points3.length; i++) {
      var pointIx = points3[i];
      values5.push(binder.bindPoint(series, pointIx));
      dataItems.push(series.data[pointIx]);
    }
    return {
      values: values5,
      dataItems
    };
  };
  SeriesAggregator2.prototype._bindField = function _bindField(data, field) {
    var values5 = [];
    var count = data.length;
    for (var i = 0; i < count; i++) {
      var item = data[i];
      var valueFields = item.valueFields;
      var value = void 0;
      if (defined2(valueFields[field])) {
        value = valueFields[field];
      } else {
        value = item.fields[field];
      }
      values5.push(value);
    }
    return values5;
  };
  return SeriesAggregator2;
}(class_default);
function setValue(fieldName, target, value) {
  var parentObj = target;
  var field = fieldName;
  if (fieldName.indexOf(".") > -1) {
    var parts = fieldName.split(".");
    while (parts.length > 1) {
      field = parts.shift();
      if (!defined2(parentObj[field])) {
        parentObj[field] = {};
      }
      parentObj = parentObj[field];
    }
    field = parts.shift();
  }
  parentObj[field] = value;
}
var series_aggregator_default = SeriesAggregator;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/default-aggregates.js
var DefaultAggregates = function(Class3) {
  function DefaultAggregates2() {
    Class3.call(this);
    this._defaults = {};
  }
  if (Class3)
    DefaultAggregates2.__proto__ = Class3;
  DefaultAggregates2.prototype = Object.create(Class3 && Class3.prototype);
  DefaultAggregates2.prototype.constructor = DefaultAggregates2;
  DefaultAggregates2.prototype.register = function register4(seriesTypes, aggregates) {
    var this$1 = this;
    for (var i = 0; i < seriesTypes.length; i++) {
      this$1._defaults[seriesTypes[i]] = aggregates;
    }
  };
  DefaultAggregates2.prototype.query = function query(seriesType) {
    return this._defaults[seriesType];
  };
  return DefaultAggregates2;
}(class_default);
DefaultAggregates.current = new DefaultAggregates();
var default_aggregates_default = DefaultAggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar.js
var RangeBar = function(Bar2) {
  function RangeBar2() {
    Bar2.apply(this, arguments);
  }
  if (Bar2)
    RangeBar2.__proto__ = Bar2;
  RangeBar2.prototype = Object.create(Bar2 && Bar2.prototype);
  RangeBar2.prototype.constructor = RangeBar2;
  RangeBar2.prototype.createLabel = function createLabel() {
    var labels = this.options.labels;
    var fromOptions = deepExtend({}, labels, labels.from);
    var toOptions = deepExtend({}, labels, labels.to);
    if (fromOptions.visible) {
      this.labelFrom = this._createLabel(fromOptions);
      this.append(this.labelFrom);
    }
    if (toOptions.visible) {
      this.labelTo = this._createLabel(toOptions);
      this.append(this.labelTo);
    }
  };
  RangeBar2.prototype._createLabel = function _createLabel(options2) {
    var labelTemplate = getTemplate(options2);
    var pointData = this.pointData();
    var labelText;
    if (labelTemplate) {
      labelText = labelTemplate(pointData);
    } else {
      labelText = this.formatValue(options2.format);
    }
    return new bar_label_default(
      labelText,
      deepExtend(
        {
          vertical: this.options.vertical
        },
        options2
      ),
      pointData
    );
  };
  RangeBar2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var ref2 = this;
    var labelFrom = ref2.labelFrom;
    var labelTo = ref2.labelTo;
    var value = ref2.value;
    this.box = targetBox;
    if (labelFrom) {
      labelFrom.options.aboveAxis = value.from > value.to;
      labelFrom.reflow(targetBox);
    }
    if (labelTo) {
      labelTo.options.aboveAxis = value.to > value.from;
      labelTo.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
  };
  return RangeBar2;
}(bar_default);
RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {
  labels: {
    format: "{0} - {1}"
  },
  tooltip: {
    format: "{1}"
  }
});
var range_bar_default = RangeBar;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar-chart.js
var RangeBarChart = function(BarChart2) {
  function RangeBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    RangeBarChart2.__proto__ = BarChart2;
  RangeBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RangeBarChart2.prototype.constructor = RangeBarChart2;
  RangeBarChart2.prototype.pointType = function pointType() {
    return range_bar_default;
  };
  RangeBarChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields;
  };
  RangeBarChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    if (point2.value.from === null && point2.value.to === null) {
      return "";
    }
    return this.chartService.format.auto(format2, point2.value.from, point2.value.to);
  };
  RangeBarChart2.prototype.plotRange = function plotRange(point2) {
    if (!point2) {
      return 0;
    }
    return [point2.value.from, point2.value.to];
  };
  RangeBarChart2.prototype.updateRange = function updateRange(value, fields) {
    var axisName = fields.series.axis;
    var from = value.from;
    var to = value.to;
    var axisRange = this.valueAxisRanges[axisName];
    if (value !== null && isNumber2(from) && isNumber2(to)) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, from);
      axisRange.max = Math.max(axisRange.max, from);
      axisRange.min = Math.min(axisRange.min, to);
      axisRange.max = Math.max(axisRange.max, to);
    }
  };
  RangeBarChart2.prototype.aboveAxis = function aboveAxis(point2) {
    var value = point2.value;
    return value.from < value.to;
  };
  return RangeBarChart2;
}(bar_chart_default);
RangeBarChart.prototype.plotLimits = categorical_chart_default.prototype.plotLimits;
var range_bar_chart_default = RangeBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-line-point.js
var RangeLinePoint = function(LinePoint2) {
  function RangeLinePoint2() {
    LinePoint2.apply(this, arguments);
  }
  if (LinePoint2)
    RangeLinePoint2.__proto__ = LinePoint2;
  RangeLinePoint2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  RangeLinePoint2.prototype.constructor = RangeLinePoint2;
  RangeLinePoint2.prototype.aliasFor = function aliasFor() {
    return this.parent;
  };
  return RangeLinePoint2;
}(line_point_default);
var range_line_point_default = RangeLinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-point.js
var AUTO2 = "auto";
var DEFAULT_FROM_FORMAT = "{0}";
var DEFAULT_TO_FORMAT = "{1}";
var RangeAreaPoint = function(ChartElement2) {
  function RangeAreaPoint2(value, options2) {
    ChartElement2.call(this);
    this.value = value;
    this.options = options2;
    this.aboveAxis = valueOrDefault2(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this.initLabelsFormat();
  }
  if (ChartElement2)
    RangeAreaPoint2.__proto__ = ChartElement2;
  RangeAreaPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RangeAreaPoint2.prototype.constructor = RangeAreaPoint2;
  RangeAreaPoint2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    var ref2 = this.options;
    var markers = ref2.markers;
    var labels = ref2.labels;
    var value = this.value;
    var fromPoint = this.fromPoint = new range_line_point_default(value, deepExtend({}, this.options, {
      labels: labels.from,
      markers: markers.from
    }));
    var toPoint = this.toPoint = new range_line_point_default(value, deepExtend({}, this.options, {
      labels: labels.to,
      markers: markers.to
    }));
    this.copyFields(fromPoint);
    this.copyFields(toPoint);
    this.append(fromPoint);
    this.append(toPoint);
  };
  RangeAreaPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var fromBox = targetBox.from;
    var toBox = targetBox.to;
    this.positionLabels(fromBox, toBox);
    this.fromPoint.reflow(fromBox);
    this.toPoint.reflow(toBox);
    this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());
  };
  RangeAreaPoint2.prototype.createHighlight = function createHighlight() {
    var group = new drawing_exports.Group();
    group.append(this.fromPoint.createHighlight());
    group.append(this.toPoint.createHighlight());
    return group;
  };
  RangeAreaPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.visual;
  };
  RangeAreaPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      from: this.fromPoint.highlightVisualArgs(),
      to: this.toPoint.highlightVisualArgs()
    };
  };
  RangeAreaPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(this.box);
    if (showTooltip) {
      var box = this.box;
      var center = box.center();
      var horizontalAlign = LEFT;
      var x, y, verticalAlign;
      if (this.options.vertical) {
        x = center.x;
        y = box.y1 - TOOLTIP_OFFSET;
        verticalAlign = BOTTOM;
      } else {
        x = box.x2 + TOOLTIP_OFFSET;
        y = center.y;
        verticalAlign = CENTER;
      }
      return {
        point: new point_default2(x, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  RangeAreaPoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  RangeAreaPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  RangeAreaPoint2.prototype.unclipElements = function unclipElements() {
    this.fromPoint.unclipElements();
    this.toPoint.unclipElements();
  };
  RangeAreaPoint2.prototype.initLabelsFormat = function initLabelsFormat() {
    var labels = this.options.labels;
    if (!labels.format) {
      if (!labels.from || !labels.from.format) {
        labels.from = Object.assign({}, labels.from, {
          format: DEFAULT_FROM_FORMAT
        });
      }
      if (!labels.to || !labels.to.format) {
        labels.to = Object.assign({}, labels.to, {
          format: DEFAULT_TO_FORMAT
        });
      }
    }
  };
  RangeAreaPoint2.prototype.positionLabels = function positionLabels(fromBox, toBox) {
    var ref2 = this.options;
    var labels = ref2.labels;
    var vertical = ref2.vertical;
    if (labels.position === AUTO2) {
      var fromLabelPosition, toLabelPosition;
      if (vertical) {
        if (toBox.y1 <= fromBox.y1) {
          toLabelPosition = ABOVE;
          fromLabelPosition = BELOW;
        } else {
          toLabelPosition = BELOW;
          fromLabelPosition = ABOVE;
        }
      } else {
        if (toBox.x1 <= fromBox.x1) {
          toLabelPosition = LEFT;
          fromLabelPosition = RIGHT;
        } else {
          toLabelPosition = RIGHT;
          fromLabelPosition = LEFT;
        }
      }
      if (!labels.from || !labels.from.position) {
        this.fromPoint.options.labels.position = fromLabelPosition;
      }
      if (!labels.to || !labels.to.position) {
        this.toPoint.options.labels.position = toLabelPosition;
      }
    }
  };
  RangeAreaPoint2.prototype.copyFields = function copyFields(point2) {
    point2.dataItem = this.dataItem;
    point2.category = this.category;
    point2.series = this.series;
    point2.color = this.color;
    point2.owner = this.owner;
  };
  return RangeAreaPoint2;
}(chart_element_default);
deepExtend(RangeAreaPoint.prototype, point_events_mixin_default);
deepExtend(RangeAreaPoint.prototype, note_mixin_default);
RangeAreaPoint.prototype.defaults = {
  markers: {
    visible: false,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    },
    position: AUTO2
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: WHITE,
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  tooltip: {
    format: "{0} - {1}"
  }
};
var range_area_point_default = RangeAreaPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-segment.js
var RangeAreaSegment = function(AreaSegment2) {
  function RangeAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    RangeAreaSegment2.__proto__ = AreaSegment2;
  RangeAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RangeAreaSegment2.prototype.constructor = RangeAreaSegment2;
  RangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));
  };
  RangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));
    }
    return fromSegments;
  };
  RangeAreaSegment2.prototype.createStroke = function createStroke(style) {
    var toPath = new drawing_exports.Path(style);
    var fromPath = new drawing_exports.Path(style);
    toPath.segments.push.apply(toPath.segments, this.strokeSegments());
    fromPath.segments.push.apply(fromPath.segments, this.stackSegments());
    this.visual.append(toPath);
    this.visual.append(fromPath);
  };
  RangeAreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return true;
  };
  RangeAreaSegment2.prototype.fromPoints = function fromPoints() {
    return this.linePoints.map(function(point2) {
      return point2.fromPoint;
    });
  };
  RangeAreaSegment2.prototype.toPoints = function toPoints() {
    return this.linePoints.map(function(point2) {
      return point2.toPoint;
    });
  };
  return RangeAreaSegment2;
}(area_segment_default);
var range_area_segment_default = RangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/spline-range-area-segment.js
var SplineRangeAreaSegment = function(RangeAreaSegment2) {
  function SplineRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2)
    SplineRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  SplineRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  SplineRangeAreaSegment2.prototype.constructor = SplineRangeAreaSegment2;
  SplineRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.createCurveSegments(this.toPoints());
  };
  SplineRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());
    }
    return fromSegments;
  };
  SplineRangeAreaSegment2.prototype.createCurveSegments = function createCurveSegments(points3) {
    var curveProcessor = new curve_processor_default();
    return curveProcessor.process(this.toGeometryPoints(points3));
  };
  return SplineRangeAreaSegment2;
}(range_area_segment_default);
var spline_range_area_segment_default = SplineRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/step-range-area-segment.js
var StepRangeAreaSegment = function(RangeAreaSegment2) {
  function StepRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2)
    StepRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  StepRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  StepRangeAreaSegment2.prototype.constructor = StepRangeAreaSegment2;
  StepRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));
  };
  StepRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));
      fromSegments.reverse();
    }
    return fromSegments;
  };
  return StepRangeAreaSegment2;
}(range_area_segment_default);
deepExtend(StepRangeAreaSegment.prototype, step_line_mixin_default);
var step_range_area_segment_default = StepRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-chart.js
var RangeAreaChart = function(CategoricalChart2) {
  function RangeAreaChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    RangeAreaChart2.__proto__ = CategoricalChart2;
  RangeAreaChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  RangeAreaChart2.prototype.constructor = RangeAreaChart2;
  RangeAreaChart2.prototype.render = function render() {
    CategoricalChart2.prototype.render.call(this);
    this.renderSegments();
  };
  RangeAreaChart2.prototype.pointType = function pointType() {
    return range_area_point_default;
  };
  RangeAreaChart2.prototype.createPoint = function createPoint(data, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var value = data.valueFields;
    if (!hasValue(value.from) && !hasValue(value.to)) {
      if (this.seriesMissingValues(series) === ZERO2) {
        value = {
          from: 0,
          to: 0
        };
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    var color = data.fields.color || series.color;
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new range_area_point_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  RangeAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = (currentSeries.line || {}).style;
    var segmentType2;
    if (style === "smooth") {
      segmentType2 = spline_range_area_segment_default;
    } else if (style === "step") {
      segmentType2 = step_range_area_segment_default;
    } else {
      segmentType2 = range_area_segment_default;
    }
    return new segmentType2(linePoints, currentSeries, seriesIx);
  };
  RangeAreaChart2.prototype.plotRange = function plotRange(point2, startValue) {
    if (!point2) {
      return [startValue, startValue];
    }
    return [point2.value.from, point2.value.to];
  };
  RangeAreaChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);
    var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);
    if (fromSlot && toSlot) {
      return {
        from: fromSlot,
        to: toSlot
      };
    }
  };
  RangeAreaChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var from = valueSlot.from;
    var to = valueSlot.to;
    var fromSlot, toSlot;
    if (this.options.invertAxes) {
      fromSlot = new box_default(from.x1, categorySlot.y1, from.x2, categorySlot.y2);
      toSlot = new box_default(to.x1, categorySlot.y1, to.x2, categorySlot.y2);
    } else {
      fromSlot = new box_default(categorySlot.x1, from.y1, categorySlot.x2, from.y2);
      toSlot = new box_default(categorySlot.x1, to.y1, categorySlot.x2, to.y2);
    }
    return {
      from: fromSlot,
      to: toSlot
    };
  };
  RangeAreaChart2.prototype.addValue = function addValue(data, fields) {
    var valueFields = data.valueFields;
    if (!isNumber2(valueFields.from)) {
      valueFields.from = valueFields.to;
    }
    if (!isNumber2(valueFields.to)) {
      valueFields.to = valueFields.from;
    }
    CategoricalChart2.prototype.addValue.call(this, data, fields);
  };
  RangeAreaChart2.prototype.updateRange = function updateRange(value, fields) {
    if (value !== null && isNumber2(value.from) && isNumber2(value.to)) {
      var axisName = fields.series.axis;
      var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
      var from = value.from;
      var to = value.to;
      axisRange.min = Math.min(axisRange.min, from, to);
      axisRange.max = Math.max(axisRange.max, from, to);
    }
  };
  RangeAreaChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(format2, value.from, value.to);
  };
  RangeAreaChart2.prototype.animationPoints = function animationPoints() {
    var points3 = this.points;
    var result = [];
    for (var idx = 0; idx < points3.length; idx++) {
      var point2 = points3[idx];
      if (point2) {
        result.push((point2.fromPoint || {}).marker);
        result.push((point2.toPoint || {}).marker);
      }
    }
    return result.concat(this._segments);
  };
  return RangeAreaChart2;
}(categorical_chart_default);
deepExtend(RangeAreaChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var range_area_chart_default = RangeAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-point.js
var OHLCPoint = function(Candlestick2) {
  function OHLCPoint2() {
    Candlestick2.apply(this, arguments);
  }
  if (Candlestick2)
    OHLCPoint2.__proto__ = Candlestick2;
  OHLCPoint2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  OHLCPoint2.prototype.constructor = OHLCPoint2;
  OHLCPoint2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var oPoints = [];
    var cPoints = [];
    var lhPoints = [];
    var lhSlot = valueAxis.getSlot(value.low, value.high);
    var oSlot = valueAxis.getSlot(value.open, value.open);
    var cSlot = valueAxis.getSlot(value.close, value.close);
    oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;
    oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;
    var mid = lhSlot.center().x;
    oPoints.push([oSlot.x1, oSlot.y1]);
    oPoints.push([mid, oSlot.y1]);
    cPoints.push([mid, cSlot.y1]);
    cPoints.push([cSlot.x2, cSlot.y1]);
    lhPoints.push([mid, lhSlot.y1]);
    lhPoints.push([mid, lhSlot.y2]);
    this.lines = [
      oPoints,
      cPoints,
      lhPoints
    ];
    this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));
    this.reflowNote();
  };
  OHLCPoint2.prototype.createBody = function createBody() {
  };
  return OHLCPoint2;
}(candlestick_default);
var ohlc_point_default = OHLCPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-chart.js
var OHLCChart = function(CandlestickChart2) {
  function OHLCChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2)
    OHLCChart2.__proto__ = CandlestickChart2;
  OHLCChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  OHLCChart2.prototype.constructor = OHLCChart2;
  OHLCChart2.prototype.pointType = function pointType() {
    return ohlc_point_default;
  };
  return OHLCChart2;
}(candlestick_chart_default);
var ohlc_chart_default = OHLCChart;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-segment.js
var WaterfallSegment = function(ChartElement2) {
  function WaterfallSegment2(from, to, series) {
    ChartElement2.call(this);
    this.from = from;
    this.to = to;
    this.series = series;
  }
  if (ChartElement2)
    WaterfallSegment2.__proto__ = ChartElement2;
  WaterfallSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  WaterfallSegment2.prototype.constructor = WaterfallSegment2;
  WaterfallSegment2.prototype.linePoints = function linePoints() {
    var from = this.from;
    var ref2 = this;
    var fromBox = ref2.from.box;
    var toBox = ref2.to.box;
    var points3 = [];
    if (from.isVertical) {
      var y = from.aboveAxis ? fromBox.y1 : fromBox.y2;
      points3.push(
        [fromBox.x1, y],
        [toBox.x2, y]
      );
    } else {
      var x = from.aboveAxis ? fromBox.x2 : fromBox.x1;
      points3.push(
        [x, fromBox.y1],
        [x, toBox.y2]
      );
    }
    return points3;
  };
  WaterfallSegment2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var line = this.series.line || {};
    var path = drawing_exports.Path.fromPoints(this.linePoints(), {
      stroke: {
        color: line.color,
        width: line.width,
        opacity: line.opacity,
        dashType: line.dashType
      }
    });
    alignPathToPixel(path);
    this.visual.append(path);
  };
  return WaterfallSegment2;
}(chart_element_default);
setDefaultOptions(WaterfallSegment, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  }
});
var waterfall_segment_default = WaterfallSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-chart.js
var WaterfallChart = function(BarChart2) {
  function WaterfallChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    WaterfallChart2.__proto__ = BarChart2;
  WaterfallChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  WaterfallChart2.prototype.constructor = WaterfallChart2;
  WaterfallChart2.prototype.render = function render() {
    BarChart2.prototype.render.call(this);
    this.createSegments();
  };
  WaterfallChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var series = this.options.series;
    var totalCategories = categoriesCount(series);
    var isVertical = !this.options.invertAxes;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var total3 = 0;
      var runningTotal = 0;
      for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {
        var data = series_binder_default.current.bindPoint(currentSeries, categoryIx);
        var value = data.valueFields.value;
        var summary = data.fields.summary;
        var from = total3;
        var to = void 0;
        if (summary) {
          if (summary.toLowerCase() === "total") {
            data.valueFields.value = total3;
            from = 0;
            to = total3;
          } else {
            data.valueFields.value = runningTotal;
            to = from - runningTotal;
            runningTotal = 0;
          }
        } else if (isNumber2(value)) {
          runningTotal += value;
          total3 += value;
          to = total3;
        }
        callback(data, {
          category: this$1.categoryAxis.categoryAt(categoryIx),
          categoryIx,
          series: currentSeries,
          seriesIx,
          total: total3,
          runningTotal,
          from,
          to,
          isVertical
        });
      }
    }
  };
  WaterfallChart2.prototype.updateRange = function updateRange(value, fields) {
    BarChart2.prototype.updateRange.call(this, { value: fields.to }, fields);
  };
  WaterfallChart2.prototype.aboveAxis = function aboveAxis(point2) {
    return point2.value >= 0;
  };
  WaterfallChart2.prototype.plotRange = function plotRange(point2) {
    return [point2.from, point2.to];
  };
  WaterfallChart2.prototype.createSegments = function createSegments() {
    var this$1 = this;
    var series = this.options.series;
    var seriesPoints = this.seriesPoints;
    var segments = this.segments = [];
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var points3 = seriesPoints[seriesIx];
      if (points3) {
        var prevPoint = void 0;
        for (var pointIx = 0; pointIx < points3.length; pointIx++) {
          var point2 = points3[pointIx];
          if (point2 && prevPoint) {
            var segment = new waterfall_segment_default(prevPoint, point2, currentSeries);
            segments.push(segment);
            this$1.append(segment);
          }
          prevPoint = point2;
        }
      }
    }
  };
  return WaterfallChart2;
}(bar_chart_default);
var waterfall_chart_default = WaterfallChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/categorical-plotarea.js
var AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];
var OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);
var CategoricalPlotArea = function(PlotAreaBase2) {
  function CategoricalPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    CategoricalPlotArea2.__proto__ = PlotAreaBase2;
  CategoricalPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  CategoricalPlotArea2.prototype.constructor = CategoricalPlotArea2;
  CategoricalPlotArea2.prototype.initFields = function initFields(series) {
    var this$1 = this;
    this.namedCategoryAxes = {};
    this.namedValueAxes = {};
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
    if (series.length > 0) {
      this.invertAxes = inArray(
        series[0].type,
        [
          BAR,
          BULLET,
          VERTICAL_LINE,
          VERTICAL_AREA,
          VERTICAL_RANGE_AREA,
          RANGE_BAR,
          HORIZONTAL_WATERFALL,
          VERTICAL_BOX_PLOT
        ]
      );
      for (var i = 0; i < series.length; i++) {
        var stack2 = series[i].stack;
        if (stack2 && stack2.type === "100%") {
          this$1.stack100 = true;
          break;
        }
      }
    }
  };
  CategoricalPlotArea2.prototype.render = function render(panes) {
    if (panes === void 0)
      panes = this.panes;
    this.createCategoryAxes(panes);
    this.aggregateCategories(panes);
    this.createCategoryAxesLabels(panes);
    this.createCharts(panes);
    this.createValueAxes(panes);
  };
  CategoricalPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis instanceof category_axis_default) {
      delete this.namedCategoryAxes[axisName];
    } else {
      this.valueAxisRangeTracker.reset(axisName);
      delete this.namedValueAxes[axisName];
    }
    if (axis === this.categoryAxis) {
      delete this.categoryAxis;
    }
    if (axis === this.valueAxis) {
      delete this.valueAxis;
    }
  };
  CategoricalPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var visibleSeries = this$1.filterVisibleSeries(paneSeries);
      if (!visibleSeries) {
        continue;
      }
      var groups = this$1.groupSeriesByCategoryAxis(visibleSeries);
      for (var groupIx = 0; groupIx < groups.length; groupIx++) {
        this$1.createChartGroup(groups[groupIx], pane);
      }
    }
  };
  CategoricalPlotArea2.prototype.createChartGroup = function createChartGroup(series, pane) {
    this.createAreaChart(
      filterSeriesByType(series, [AREA, VERTICAL_AREA]),
      pane
    );
    this.createRangeAreaChart(
      filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [COLUMN, BAR]),
      pane
    );
    this.createRangeBarChart(
      filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]),
      pane
    );
    this.createBulletChart(
      filterSeriesByType(series, [BULLET, VERTICAL_BULLET]),
      pane
    );
    this.createCandlestickChart(
      filterSeriesByType(series, CANDLESTICK),
      pane
    );
    this.createBoxPlotChart(
      filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]),
      pane
    );
    this.createOHLCChart(
      filterSeriesByType(series, OHLC),
      pane
    );
    this.createWaterfallChart(
      filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [LINE, VERTICAL_LINE]),
      pane
    );
  };
  CategoricalPlotArea2.prototype.aggregateCategories = function aggregateCategories(panes) {
    var this$1 = this;
    var series = this.srcSeries || this.series;
    var processedSeries = [];
    this._currentPointsCache = {};
    this._seriesPointsCache = this._seriesPointsCache || {};
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var categoryAxis = this$1.seriesCategoryAxis(currentSeries);
      var axisPane = this$1.findPane(categoryAxis.options.pane);
      var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
      if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {
        currentSeries = this$1.aggregateSeries(currentSeries, categoryAxis);
      } else {
        currentSeries = this$1.filterSeries(currentSeries, categoryAxis);
      }
      processedSeries.push(currentSeries);
    }
    this._seriesPointsCache = this._currentPointsCache;
    this._currentPointsCache = null;
    this.srcSeries = series;
    this.series = processedSeries;
  };
  CategoricalPlotArea2.prototype.filterSeries = function filterSeries(series, categoryAxis) {
    var dataLength = (series.data || {}).length;
    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);
    if (!(isNumber2(categoryAxis.options.min) || isNumber2(categoryAxis.options.max))) {
      return series;
    }
    var range = categoryAxis.currentRangeIndices();
    var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);
    var currentSeries = deepExtend({}, series);
    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);
    if (outOfRangePoints) {
      createOutOfRangePoints(currentSeries, range, dataLength, function(idx) {
        return {
          item: series.data[idx],
          category: categoryAxis.categoryAt(idx, true),
          categoryIx: idx - range.min
        };
      }, function(idx) {
        return defined2(series.data[idx]);
      });
    }
    return currentSeries;
  };
  CategoricalPlotArea2.prototype.clearSeriesPointsCache = function clearSeriesPointsCache() {
    this._seriesPointsCache = {};
  };
  CategoricalPlotArea2.prototype.seriesSourcePoints = function seriesSourcePoints(series, categoryAxis) {
    var this$1 = this;
    var key = series.index + ";" + categoryAxis.categoriesHash();
    if (this._seriesPointsCache[key]) {
      this._currentPointsCache[key] = this._seriesPointsCache[key];
      return this._seriesPointsCache[key];
    }
    var axisOptions2 = categoryAxis.options;
    var srcCategories = axisOptions2.srcCategories;
    var dateAxis = equalsIgnoreCase(axisOptions2.type, DATE);
    var srcData = series.data;
    var getFn = dateAxis ? getDateField : getField;
    var result = [];
    if (!dateAxis) {
      categoryAxis.mapCategories();
    }
    for (var idx = 0; idx < srcData.length; idx++) {
      var category = void 0;
      if (series.categoryField) {
        category = getFn(series.categoryField, srcData[idx], this$1.chartService.intl);
      } else {
        category = srcCategories[idx];
      }
      if (defined2(category) && category !== null) {
        var categoryIx = categoryAxis.totalIndex(category);
        result[categoryIx] = result[categoryIx] || { items: [], category };
        result[categoryIx].items.push(idx);
      }
    }
    this._currentPointsCache[key] = result;
    return result;
  };
  CategoricalPlotArea2.prototype.aggregateSeries = function aggregateSeries(series, categoryAxis) {
    var srcData = series.data;
    if (!srcData.length) {
      return series;
    }
    var srcPoints = this.seriesSourcePoints(series, categoryAxis);
    var result = deepExtend({}, series);
    var aggregator = new series_aggregator_default(deepExtend({}, series), series_binder_default.current, default_aggregates_default.current);
    var data = result.data = [];
    var dataItems = categoryAxis.options.dataItems || [];
    var range = categoryAxis.currentRangeIndices();
    var categoryItem = function(idx2) {
      var categoryIdx = idx2 - range.min;
      var point3 = srcPoints[idx2];
      if (!point3) {
        point3 = srcPoints[idx2] = {};
      }
      point3.categoryIx = categoryIdx;
      if (!point3.item) {
        var category = categoryAxis.categoryAt(idx2, true);
        point3.category = category;
        point3.item = aggregator.aggregatePoints(point3.items, category);
      }
      return point3;
    };
    for (var idx = range.min; idx <= range.max; idx++) {
      var point2 = categoryItem(idx);
      data[point2.categoryIx] = point2.item;
      if (point2.items && point2.items.length) {
        dataItems[point2.categoryIx] = point2.item;
      }
    }
    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {
      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function(idx2) {
        return srcPoints[idx2];
      });
    }
    categoryAxis.options.dataItems = dataItems;
    return result;
  };
  CategoricalPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    var series = chart.options.series;
    var categoryAxis = this.seriesCategoryAxis(series[0]);
    var categories = categoryAxis.options.categories;
    var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);
    if (categoriesToAdd > 0) {
      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);
      while (categoriesToAdd--) {
        categories.push("");
      }
    }
    this.valueAxisRangeTracker.update(chart.valueAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  CategoricalPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var axisName = series.axis;
    var axisOptions2 = [].concat(options2.valueAxis);
    var axis = grep(axisOptions2, function(a) {
      return a.name === axisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = (panes[0] || {}).name || "default";
    var paneName = (axis || {}).pane || defaultPaneName;
    return paneName;
  };
  CategoricalPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis(series) {
    var axisName = series.categoryAxis;
    var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;
    if (!axis) {
      throw new Error("Unable to locate category axis with name " + axisName);
    }
    return axis;
  };
  CategoricalPlotArea2.prototype.stackableChartOptions = function stackableChartOptions(firstSeries, pane) {
    var stack2 = firstSeries.stack;
    var isStacked100 = stack2 && stack2.type === "100%";
    var clip = pane.options.clip;
    return {
      isStacked: stack2,
      isStacked100,
      clip
    };
  };
  CategoricalPlotArea2.prototype.groupSeriesByCategoryAxis = function groupSeriesByCategoryAxis(series) {
    var categoryAxes = [];
    var unique = {};
    for (var idx = 0; idx < series.length; idx++) {
      var name2 = series[idx].categoryAxis || "$$default$$";
      if (!unique.hasOwnProperty(name2)) {
        unique[name2] = true;
        categoryAxes.push(name2);
      }
    }
    var groups = [];
    for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {
      var axis = categoryAxes[axisIx];
      var axisSeries = groupSeries(series, axis, axisIx);
      if (axisSeries.length === 0) {
        continue;
      }
      groups.push(axisSeries);
    }
    return groups;
  };
  CategoricalPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var barChart = new bar_chart_default(this, Object.assign({
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    }, this.stackableChartOptions(firstSeries, pane)));
    this.appendChart(barChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeBarChart = function createRangeBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var rangeColumnChart = new range_bar_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(rangeColumnChart, pane);
  };
  CategoricalPlotArea2.prototype.createBulletChart = function createBulletChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var bulletChart = new bullet_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(bulletChart, pane);
  };
  CategoricalPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var lineChart = new line_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(firstSeries, pane)));
    this.appendChart(lineChart, pane);
  };
  CategoricalPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var areaChart = new area_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(firstSeries, pane)));
    this.appendChart(areaChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeAreaChart = function createRangeAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var rangeAreaChart = new range_area_chart_default(this, {
      invertAxes: this.invertAxes,
      series,
      clip: pane.options.clip
    });
    this.appendChart(rangeAreaChart, pane);
  };
  CategoricalPlotArea2.prototype.createOHLCChart = function createOHLCChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new ohlc_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createCandlestickChart = function createCandlestickChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new candlestick_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createBoxPlotChart = function createBoxPlotChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new box_plot_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createWaterfallChart = function createWaterfallChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var waterfallChart = new waterfall_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(waterfallChart, pane);
  };
  CategoricalPlotArea2.prototype.axisRequiresRounding = function axisRequiresRounding(categoryAxisName, categoryAxisIndex) {
    var this$1 = this;
    var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);
    for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {
      var currentSeries = this$1.series[seriesIx];
      if (inArray(currentSeries.type, AREA_SERIES)) {
        var line = currentSeries.line;
        if (line && line.style === STEP) {
          centeredSeries.push(currentSeries);
        }
      }
    }
    for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {
      var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || "";
      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.aggregatedAxis = function aggregatedAxis(categoryAxisName, categoryAxisIndex) {
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var seriesAxis = series[seriesIx].categoryAxis || "";
      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    var axes = this.axes;
    for (var i = 0; i < axes.length; i++) {
      if (axes[i] instanceof category_axis_default) {
        axes[i].createLabels();
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxes = function createCategoryAxes(panes) {
    var this$1 = this;
    var invertAxes = this.invertAxes;
    var definitions = [].concat(this.options.categoryAxis);
    var axes = [];
    for (var i = 0; i < definitions.length; i++) {
      var axisOptions2 = definitions[i];
      var axisPane = this$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name2 = axisOptions2.name;
        var categories = axisOptions2.categories;
        if (categories === void 0)
          categories = [];
        axisOptions2 = deepExtend({
          vertical: invertAxes,
          reverse: !invertAxes && this$1.chartService.rtl,
          axisCrossingValue: invertAxes ? MAX_VALUE : 0
        }, axisOptions2);
        if (!defined2(axisOptions2.justified)) {
          axisOptions2.justified = this$1.isJustified();
        }
        if (this$1.axisRequiresRounding(name2, i)) {
          axisOptions2.justified = false;
        }
        var categoryAxis = void 0;
        if (isDateAxis(axisOptions2, categories[0])) {
          categoryAxis = new date_category_axis_default(axisOptions2, this$1.chartService);
        } else {
          categoryAxis = new category_axis_default(axisOptions2, this$1.chartService);
        }
        definitions[i].categories = categoryAxis.options.srcCategories;
        if (name2) {
          if (this$1.namedCategoryAxes[name2]) {
            throw new Error("Category axis with name " + name2 + " is already defined");
          }
          this$1.namedCategoryAxes[name2] = categoryAxis;
        }
        categoryAxis.axisIndex = i;
        axes.push(categoryAxis);
        this$1.appendAxis(categoryAxis);
      }
    }
    var primaryAxis = this.categoryAxis || axes[0];
    this.categoryAxis = primaryAxis;
    if (invertAxes) {
      this.axisY = primaryAxis;
    } else {
      this.axisX = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype.isJustified = function isJustified() {
    var series = this.series;
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      if (!inArray(currentSeries.type, AREA_SERIES)) {
        return false;
      }
    }
    return true;
  };
  CategoricalPlotArea2.prototype.createValueAxes = function createValueAxes(panes) {
    var this$1 = this;
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var definitions = [].concat(this.options.valueAxis);
    var invertAxes = this.invertAxes;
    var baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };
    var axes = [];
    if (this.stack100) {
      baseOptions.roundToMajorUnit = false;
      baseOptions.labels = { format: "P0" };
    }
    for (var i = 0; i < definitions.length; i++) {
      var axisOptions2 = definitions[i];
      var axisPane = this$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name2 = axisOptions2.name;
        var defaultAxisRange = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
        var range = tracker.query(name2) || defaultRange || defaultAxisRange;
        if (i === 0 && range && defaultRange) {
          range.min = Math.min(range.min, defaultRange.min);
          range.max = Math.max(range.max, defaultRange.max);
        }
        var axisType = void 0;
        if (equalsIgnoreCase(axisOptions2.type, LOGARITHMIC)) {
          axisType = logarithmic_axis_default;
        } else {
          axisType = numeric_axis_default;
        }
        var valueAxis = new axisType(
          range.min,
          range.max,
          deepExtend({}, baseOptions, axisOptions2),
          this$1.chartService
        );
        if (name2) {
          if (this$1.namedValueAxes[name2]) {
            throw new Error("Value axis with name " + name2 + " is already defined");
          }
          this$1.namedValueAxes[name2] = valueAxis;
        }
        valueAxis.axisIndex = i;
        axes.push(valueAxis);
        this$1.appendAxis(valueAxis);
      }
    }
    var primaryAxis = this.valueAxis || axes[0];
    this.valueAxis = primaryAxis;
    if (invertAxes) {
      this.axisX = primaryAxis;
    } else {
      this.axisY = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var pane = this.pointPane(point2);
    var categories = [];
    var values5 = [];
    if (!pane) {
      return;
    }
    var allAxes = pane.axes;
    for (var i = 0; i < allAxes.length; i++) {
      var axis = allAxes[i];
      if (axis.getValue) {
        appendIfNotNull(values5, axis.getValue(point2));
      } else {
        appendIfNotNull(categories, axis.getCategory(point2));
      }
    }
    if (categories.length === 0) {
      appendIfNotNull(categories, this.categoryAxis.getCategory(point2));
    }
    if (categories.length > 0 && values5.length > 0) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        originalEvent: e,
        category: singleItemOrArray(categories),
        value: singleItemOrArray(values5)
      });
    }
  };
  CategoricalPlotArea2.prototype.pointPane = function pointPane(point2) {
    var panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      if (currentPane.contentBox.containsPoint(point2)) {
        return currentPane;
      }
    }
  };
  CategoricalPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options2) {
    updateAxisOptions(this.options, axis, options2);
    updateAxisOptions(this.originalOptions, axis, options2);
  };
  return CategoricalPlotArea2;
}(plotarea_base_default);
function updateAxisOptions(targetOptions, axis, options2) {
  var axesOptions = axis instanceof category_axis_default ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);
  deepExtend(axesOptions[axis.axisIndex], options2);
}
function groupSeries(series, axis, axisIx) {
  return grep(series, function(s) {
    return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;
  });
}
setDefaultOptions(CategoricalPlotArea, {
  categoryAxis: {},
  valueAxis: {}
});
deepExtend(CategoricalPlotArea.prototype, plotarea_events_mixin_default);
var categorical_plotarea_default = CategoricalPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/highlight.js
var Highlight = function(Class3) {
  function Highlight2() {
    Class3.call(this);
    this._points = [];
  }
  if (Class3)
    Highlight2.__proto__ = Class3;
  Highlight2.prototype = Object.create(Class3 && Class3.prototype);
  Highlight2.prototype.constructor = Highlight2;
  Highlight2.prototype.destroy = function destroy2() {
    this._points = [];
  };
  Highlight2.prototype.show = function show2(points3, opacity) {
    var this$1 = this;
    var arrayPoints = [].concat(points3);
    this.hide();
    for (var i = 0; i < arrayPoints.length; i++) {
      var point2 = arrayPoints[i];
      if (point2 && point2.toggleHighlight && point2.hasHighlight()) {
        this$1.togglePointHighlight(point2, true, opacity);
        this$1._points.push(point2);
      }
    }
  };
  Highlight2.prototype.togglePointHighlight = function togglePointHighlight(point2, show2, opacity) {
    var toggleHandler = (point2.options.highlight || {}).toggle;
    if (toggleHandler) {
      var eventArgs2 = {
        category: point2.category,
        series: point2.series,
        dataItem: point2.dataItem,
        value: point2.value,
        stackValue: point2.stackValue,
        preventDefault: preventDefault2,
        visual: point2.highlightVisual(),
        show: show2
      };
      toggleHandler(eventArgs2);
      if (!eventArgs2._defaultPrevented) {
        point2.toggleHighlight(show2, opacity);
      }
    } else {
      point2.toggleHighlight(show2, opacity);
    }
  };
  Highlight2.prototype.hide = function hide2() {
    var this$1 = this;
    var points3 = this._points;
    while (points3.length) {
      this$1.togglePointHighlight(points3.pop(), false);
    }
  };
  Highlight2.prototype.isHighlighted = function isHighlighted(element2) {
    var points3 = this._points;
    for (var i = 0; i < points3.length; i++) {
      var point2 = points3[i];
      if (element2 === point2) {
        return true;
      }
    }
    return false;
  };
  return Highlight2;
}(class_default);
function preventDefault2() {
  this._defaultPrevented = true;
}
var highlight_default = Highlight;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/accept-key.js
function acceptKey(e, mouseKey) {
  var key = (mouseKey || "").toLowerCase();
  var event = e.event;
  var accept = key === "none" && !(event.ctrlKey || event.shiftKey || event.altKey) || event[key + "Key"];
  return accept;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/to-chart-axis-ranges.js
function toChartAxisRanges(axisRanges2) {
  var ranges = {};
  for (var idx = 0; idx < axisRanges2.length; idx++) {
    var axisRange = axisRanges2[idx];
    if (axisRange.axis.options.name) {
      ranges[axisRange.axis.options.name] = {
        min: axisRange.range.min,
        max: axisRange.range.max
      };
    }
  }
  return ranges;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/pannable.js
var Pannable = function(Class3) {
  function Pannable2(plotArea, options2) {
    Class3.call(this);
    this.plotArea = plotArea;
    this.options = deepExtend({}, this.options, options2);
  }
  if (Class3)
    Pannable2.__proto__ = Class3;
  Pannable2.prototype = Object.create(Class3 && Class3.prototype);
  Pannable2.prototype.constructor = Pannable2;
  Pannable2.prototype.start = function start(e) {
    this._active = acceptKey(e, this.options.key);
    return this._active;
  };
  Pannable2.prototype.move = function move(e) {
    if (this._active) {
      var axisRanges2 = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));
      if (axisRanges2.length) {
        this.axisRanges = axisRanges2;
        return toChartAxisRanges(axisRanges2);
      }
    }
  };
  Pannable2.prototype.end = function end() {
    var active = this._active;
    this._active = false;
    return active;
  };
  Pannable2.prototype.pan = function pan() {
    var ref2 = this;
    var plotArea = ref2.plotArea;
    var axisRanges2 = ref2.axisRanges;
    if (axisRanges2.length) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var range = axisRanges2[idx];
        plotArea.updateAxisOptions(range.axis, range.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  Pannable2.prototype.destroy = function destroy2() {
    delete this.plotArea;
  };
  Pannable2.prototype._panAxes = function _panAxes(e, position3) {
    var plotArea = this.plotArea;
    var delta = -e[position3].delta;
    var lock = (this.options.lock || "").toLowerCase();
    var updatedAxes = [];
    if (delta !== 0 && (lock || "").toLowerCase() !== position3) {
      var axes = plotArea.axes;
      for (var idx = 0; idx < axes.length; idx++) {
        var axis = axes[idx];
        if (position3 === X && !axis.options.vertical || position3 === Y && axis.options.vertical) {
          var range = axis.pan(delta);
          if (range) {
            range.limitRange = true;
            updatedAxes.push({
              axis,
              range
            });
          }
        }
      }
    }
    return updatedAxes;
  };
  return Pannable2;
}(class_default);
Pannable.prototype.options = {
  key: "none",
  lock: "none"
};
var pannable_default = Pannable;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/zoom-selection.js
var ZoomSelection = function(Class3) {
  function ZoomSelection2(chart, options2) {
    Class3.call(this);
    this.chart = chart;
    this.options = deepExtend({}, this.options, options2);
    this.createElement();
  }
  if (Class3)
    ZoomSelection2.__proto__ = Class3;
  ZoomSelection2.prototype = Object.create(Class3 && Class3.prototype);
  ZoomSelection2.prototype.constructor = ZoomSelection2;
  ZoomSelection2.prototype.createElement = function createElement17() {
    var marquee = this._marquee = document.createElement("div");
    marquee.className = "k-marquee";
    var marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
  };
  ZoomSelection2.prototype.removeElement = function removeElement() {
    if (this._marquee.parentNode) {
      this._marquee.parentNode.removeChild(this._marquee);
    }
  };
  ZoomSelection2.prototype.setStyles = function setStyles(styles) {
    elementStyles2(this._marquee, styles);
  };
  ZoomSelection2.prototype.start = function start(e) {
    if (acceptKey(e, this.options.key)) {
      var chart = this.chart;
      var point2 = chart._eventCoordinates(e);
      var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point2);
      var clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;
      if (zoomPane && clipBox) {
        var offset3 = this._elementOffset();
        clipBox.translate(offset3.left, offset3.top);
        this._zoomPaneClipBox = clipBox;
        document.body.appendChild(this._marquee);
        this.setStyles({
          left: e.pageX + 1,
          top: e.pageY + 1,
          width: 0,
          height: 0
        });
        return true;
      }
    }
    return false;
  };
  ZoomSelection2.prototype._elementOffset = function _elementOffset() {
    var chartElement = this.chart.element;
    var ref2 = elementStyles2(chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref2.paddingLeft;
    var paddingTop = ref2.paddingTop;
    var offset3 = elementOffset2(chartElement);
    return {
      left: paddingLeft + offset3.left,
      top: paddingTop + offset3.top
    };
  };
  ZoomSelection2.prototype.move = function move(e) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      this.setStyles(this._selectionPosition(e));
    }
  };
  ZoomSelection2.prototype.end = function end(e) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      var elementOffset3 = this._elementOffset();
      var selectionPosition = this._selectionPosition(e);
      selectionPosition.left -= elementOffset3.left;
      selectionPosition.top -= elementOffset3.top;
      var start = { x: selectionPosition.left, y: selectionPosition.top };
      var end2 = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };
      this._updateAxisRanges(start, end2);
      this.removeElement();
      delete this._zoomPane;
      return toChartAxisRanges(this.axisRanges);
    }
  };
  ZoomSelection2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    if (axisRanges2 && axisRanges2.length) {
      var plotArea = this.chart._plotArea;
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  ZoomSelection2.prototype.destroy = function destroy2() {
    this.removeElement();
    delete this._marquee;
    delete this.chart;
  };
  ZoomSelection2.prototype._updateAxisRanges = function _updateAxisRanges(start, end) {
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this._zoomPane.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined2(axis.axisIndex)) {
        var range = axis.pointsRange(start, end);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
  };
  ZoomSelection2.prototype._selectionPosition = function _selectionPosition(e) {
    var clipBox = this._zoomPaneClipBox;
    var startLocation = {
      x: e.x.startLocation,
      y: e.y.startLocation
    };
    var pageX = e.x.location;
    var pageY = e.y.location;
    var lock = (this.options.lock || "").toLowerCase();
    var left = Math.min(startLocation.x, pageX);
    var top = Math.min(startLocation.y, pageY);
    var width = Math.abs(startLocation.x - pageX);
    var height = Math.abs(startLocation.y - pageY);
    if (lock === X) {
      left = clipBox.x1;
      width = clipBox.width();
    }
    if (lock === Y) {
      top = clipBox.y1;
      height = clipBox.height();
    }
    if (pageX > clipBox.x2) {
      width = clipBox.x2 - startLocation.x;
    }
    if (pageX < clipBox.x1) {
      width = startLocation.x - clipBox.x1;
    }
    if (pageY > clipBox.y2) {
      height = clipBox.y2 - startLocation.y;
    }
    if (pageY < clipBox.y1) {
      height = startLocation.y - clipBox.y1;
    }
    return {
      left: Math.max(left, clipBox.x1),
      top: Math.max(top, clipBox.y1),
      width,
      height
    };
  };
  return ZoomSelection2;
}(class_default);
ZoomSelection.prototype.options = {
  key: "shift",
  lock: "none"
};
var zoom_selection_default = ZoomSelection;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/mousewheel-zoom.js
var MIN_RATE = 0.01;
var MAX_RATE = 0.9;
var DEFAULT_RATE = 0.3;
var MousewheelZoom = function(Class3) {
  function MousewheelZoom2(chart, options2) {
    Class3.call(this);
    this.chart = chart;
    this.options = deepExtend({
      rate: DEFAULT_RATE
    }, this.options, options2);
  }
  if (Class3)
    MousewheelZoom2.__proto__ = Class3;
  MousewheelZoom2.prototype = Object.create(Class3 && Class3.prototype);
  MousewheelZoom2.prototype.constructor = MousewheelZoom2;
  MousewheelZoom2.prototype.updateRanges = function updateRanges(delta, coords) {
    var this$1 = this;
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this.chart._plotArea.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {
        var rate = limitValue2(this$1.options.rate, MIN_RATE, MAX_RATE);
        var range = axis.zoomRange(-delta * rate, coords);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
    return toChartAxisRanges(axisRanges2);
  };
  MousewheelZoom2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    var plotArea = this.chart._plotArea;
    if (axisRanges2 && axisRanges2.length && plotArea.updateAxisOptions) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  MousewheelZoom2.prototype.destroy = function destroy2() {
    delete this.chart;
  };
  return MousewheelZoom2;
}(class_default);
var mousewheel_zoom_default = MousewheelZoom;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-layout.js
var LegendLayout = function(ChartElement2) {
  function LegendLayout2(options2, chartService) {
    ChartElement2.call(this, options2);
    this.chartService = chartService;
  }
  if (ChartElement2)
    LegendLayout2.__proto__ = ChartElement2;
  LegendLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LegendLayout2.prototype.constructor = LegendLayout2;
  LegendLayout2.prototype.render = function render() {
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var vertical = options2.vertical;
    this.visual = new drawing_exports.Layout(null, {
      spacing: vertical ? 0 : options2.spacing,
      lineSpacing: vertical ? options2.spacing : 0,
      orientation: vertical ? "vertical" : "horizontal",
      reverse: options2.rtl,
      alignItems: vertical ? "start" : "center"
    });
    for (var idx = 0; idx < children.length; idx++) {
      var legendItem = children[idx];
      legendItem.reflow(new box_default());
      legendItem.renderVisual();
    }
  };
  LegendLayout2.prototype.reflow = function reflow(box) {
    this.visual.rect(box.toRect());
    this.visual.reflow();
    var bbox = this.visual.clippedBBox();
    if (bbox) {
      this.box = rectToBox(bbox);
    } else {
      this.box = new box_default();
    }
  };
  LegendLayout2.prototype.renderVisual = function renderVisual() {
    this.addVisual();
  };
  LegendLayout2.prototype.createVisual = function createVisual() {
  };
  return LegendLayout2;
}(chart_element_default);
var legend_layout_default = LegendLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item.js
var LegendItem = function(BoxElement2) {
  function LegendItem2(options2) {
    BoxElement2.call(this, options2);
    this.createContainer();
    if (!options2.rtl) {
      this.createMarker();
      this.createLabel();
    } else {
      this.createLabel();
      this.createMarker();
    }
  }
  if (BoxElement2)
    LegendItem2.__proto__ = BoxElement2;
  LegendItem2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  LegendItem2.prototype.constructor = LegendItem2;
  LegendItem2.prototype.createContainer = function createContainer() {
    this.container = new float_element_default({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });
    this.append(this.container);
  };
  LegendItem2.prototype.createMarker = function createMarker() {
    this.container.append(new shape_element_default(this.markerOptions()));
  };
  LegendItem2.prototype.markerOptions = function markerOptions() {
    var options2 = this.options;
    var markerColor = options2.markerColor;
    return deepExtend({}, options2.markers, {
      background: markerColor,
      border: {
        color: markerColor
      }
    });
  };
  LegendItem2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labelOptions = deepExtend({}, options2.labels);
    this.container.append(new text_box_default(options2.text, labelOptions));
  };
  LegendItem2.prototype.renderComplete = function renderComplete() {
    BoxElement2.prototype.renderComplete.call(this);
    var cursor = this.options.cursor || {};
    var eventSink = this._itemOverlay = drawing_exports.Path.fromRect(this.container.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null,
      cursor: cursor.style || cursor
    });
    this.appendVisual(eventSink);
  };
  LegendItem2.prototype.click = function click(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e && e.type === "contextmenu") {
      e.preventDefault();
    }
  };
  LegendItem2.prototype.over = function over(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {
      widget._legendItemHover(args.seriesIndex, args.pointIndex);
    }
    return true;
  };
  LegendItem2.prototype.out = function out(widget, e) {
    widget._unsetActivePoint();
    widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e));
  };
  LegendItem2.prototype.eventArgs = function eventArgs2(e) {
    var options2 = this.options;
    return {
      element: eventElement2(e),
      text: options2.text,
      series: options2.series,
      seriesIndex: options2.series.index,
      pointIndex: options2.pointIndex
    };
  };
  LegendItem2.prototype.renderVisual = function renderVisual() {
    var this$1 = this;
    var options2 = this.options;
    var customVisual = options2.visual;
    if (customVisual) {
      this.visual = customVisual({
        active: options2.active,
        series: options2.series,
        sender: this.getSender(),
        pointIndex: options2.pointIndex,
        options: {
          markers: this.markerOptions(),
          labels: options2.labels
        },
        createVisual: function() {
          this$1.createVisual();
          this$1.renderChildren();
          this$1.renderComplete();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      });
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  return LegendItem2;
}(box_element_default);
var legend_item_default = LegendItem;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend.js
var HORIZONTAL = "horizontal";
var POINTER = "pointer";
var CUSTOM = "custom";
var Legend = function(ChartElement2) {
  function Legend2(options2, chartService) {
    if (chartService === void 0)
      chartService = {};
    ChartElement2.call(this, options2);
    this.chartService = chartService;
    if (!inArray(this.options.position, [TOP, RIGHT, BOTTOM, LEFT, CUSTOM])) {
      this.options.position = RIGHT;
    }
    this.createContainers();
    this.createLegendTitle(options2.title);
    this.createItems();
  }
  if (ChartElement2)
    Legend2.__proto__ = ChartElement2;
  Legend2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Legend2.prototype.constructor = Legend2;
  Legend2.prototype.createContainers = function createContainers() {
    var options2 = this.options;
    var position3 = options2.position;
    var userAlign = options2.align;
    var align3 = position3;
    var vAlign2 = CENTER;
    if (position3 === CUSTOM) {
      align3 = LEFT;
    } else if (inArray(position3, [TOP, BOTTOM])) {
      if (userAlign === "start") {
        align3 = LEFT;
      } else if (userAlign === "end") {
        align3 = RIGHT;
      } else {
        align3 = CENTER;
      }
      vAlign2 = position3;
    } else if (userAlign) {
      if (userAlign === "start") {
        vAlign2 = TOP;
      } else if (userAlign === "end") {
        vAlign2 = BOTTOM;
      }
    }
    this.container = new box_element_default({
      margin: options2.margin,
      padding: options2.padding,
      background: options2.background,
      border: options2.border,
      vAlign: vAlign2,
      align: align3,
      zIndex: options2.zIndex,
      shrinkToFit: true
    });
    if (this.hasTitle()) {
      this.itemsContainer = new box_element_default({
        vAlign: vAlign2,
        align: align3,
        zIndex: options2.zIndex,
        shrinkToFit: true
      });
    } else {
      this.itemsContainer = this.container;
    }
    this.append(this.container);
  };
  Legend2.prototype.createItems = function createItems() {
    var chartService = this.getService();
    var options2 = this.options;
    var vertical = this.isVertical();
    var innerElement = new legend_layout_default({
      vertical,
      spacing: options2.spacing,
      rtl: chartService.rtl
    }, chartService);
    var items = options2.items;
    if (options2.reverse) {
      items = items.slice(0).reverse();
    }
    var count = items.length;
    for (var i = 0; i < count; i++) {
      var item = items[i];
      innerElement.append(new legend_item_default(deepExtend({}, {
        markers: options2.markers,
        labels: options2.labels,
        rtl: chartService.rtl
      }, options2.item, item)));
    }
    innerElement.render();
    this.itemsContainer.append(innerElement);
  };
  Legend2.prototype.isVertical = function isVertical() {
    var ref2 = this.options;
    var orientation = ref2.orientation;
    var position3 = ref2.position;
    var vertical = position3 === CUSTOM && orientation !== HORIZONTAL || (defined2(orientation) ? orientation !== HORIZONTAL : inArray(position3, [LEFT, RIGHT]));
    return vertical;
  };
  Legend2.prototype.hasItems = function hasItems() {
    return this.container.children[0].children.length > 0;
  };
  Legend2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var legendBox = targetBox.clone();
    if (!this.hasItems()) {
      this.box = legendBox;
      return;
    }
    if (options2.position === CUSTOM) {
      this.containerCustomReflow(legendBox);
      this.box = legendBox;
    } else {
      this.containerReflow(legendBox);
    }
    if (this.hasTitle()) {
      this.title.reflow(new box_default(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));
    }
  };
  Legend2.prototype.containerReflow = function containerReflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var container = ref2.container;
    var position3 = options2.position;
    var width = options2.width;
    var height = options2.height;
    var pos = position3 === TOP || position3 === BOTTOM ? X : Y;
    var vertical = this.isVertical();
    var alignTarget = targetBox.clone();
    var containerBox = targetBox.clone();
    if (position3 === LEFT || position3 === RIGHT) {
      containerBox.y1 = alignTarget.y1 = 0;
    }
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
      containerBox.align(alignTarget, Y, container.options.vAlign);
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
      containerBox.align(alignTarget, X, container.options.align);
    }
    container.reflow(containerBox);
    containerBox = container.box;
    var box = containerBox.clone();
    if (options2.offsetX || options2.offsetY) {
      containerBox.translate(options2.offsetX, options2.offsetY);
      container.reflow(containerBox);
    }
    box[pos + 1] = targetBox[pos + 1];
    box[pos + 2] = targetBox[pos + 2];
    this.box = box;
  };
  Legend2.prototype.containerCustomReflow = function containerCustomReflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var container = ref2.container;
    var offsetX = options2.offsetX;
    var offsetY = options2.offsetY;
    var width = options2.width;
    var height = options2.height;
    var vertical = this.isVertical();
    var containerBox = targetBox.clone();
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
    }
    container.reflow(containerBox);
    containerBox = container.box;
    container.reflow(new box_default(
      offsetX,
      offsetY,
      offsetX + containerBox.width(),
      offsetY + containerBox.height()
    ));
  };
  Legend2.prototype.renderVisual = function renderVisual() {
    if (this.hasItems()) {
      ChartElement2.prototype.renderVisual.call(this);
    }
  };
  Legend2.prototype.createLegendTitle = function createLegendTitle(title2) {
    var titleOptions = deepExtend({}, {
      color: BLACK,
      position: TOP,
      align: CENTER
    }, title2);
    var text = titleOptions.text;
    if (!title2 || title2.visible === false) {
      return;
    }
    if (defined2(titleOptions) && titleOptions.visible) {
      var labelTemplate = getTemplate(titleOptions);
      if (labelTemplate) {
        text = labelTemplate({ text });
      } else if (titleOptions.format) {
        text = this.chartService.format.auto(titleOptions.format, text);
      }
    }
    this.title = new text_box_default(text, titleOptions);
    this.createTitleLayout();
    this.appendTitleLayoutContent();
  };
  Legend2.prototype.createTitleLayout = function createTitleLayout() {
    this.layout = new float_element_default({
      vertical: true,
      wrap: false
    });
    this.container.append(this.layout);
  };
  Legend2.prototype.hasTitle = function hasTitle() {
    return Boolean(this.options.title && this.options.title.visible !== false);
  };
  Legend2.prototype.appendTitleLayoutContent = function appendTitleLayoutContent() {
    var options2 = this.options;
    if (options2.title.position === BOTTOM) {
      this.layout.append(this.itemsContainer);
      this.layout.append(this.title);
    } else {
      this.layout.append(this.title);
      this.layout.append(this.itemsContainer);
    }
  };
  return Legend2;
}(chart_element_default);
setDefaultOptions(Legend, {
  position: RIGHT,
  items: [],
  offsetX: 0,
  offsetY: 0,
  margin: getSpacing(5),
  padding: getSpacing(5),
  border: {
    color: BLACK,
    width: 0
  },
  item: {
    cursor: POINTER,
    spacing: 6
  },
  spacing: 6,
  background: "",
  zIndex: 1,
  markers: {
    border: {
      width: 0
    },
    width: 15,
    height: 3,
    type: "rect",
    align: LEFT,
    vAlign: CENTER
  }
});
var legend_default = Legend;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-factory.js
var PlotAreaFactory = function(Class3) {
  function PlotAreaFactory2() {
    Class3.call(this);
    this._registry = [];
  }
  if (Class3)
    PlotAreaFactory2.__proto__ = Class3;
  PlotAreaFactory2.prototype = Object.create(Class3 && Class3.prototype);
  PlotAreaFactory2.prototype.constructor = PlotAreaFactory2;
  PlotAreaFactory2.prototype.register = function register4(type, seriesTypes) {
    this._registry.push({
      type,
      seriesTypes
    });
  };
  PlotAreaFactory2.prototype.create = function create3(srcSeries, options2, chartService) {
    var registry = this._registry;
    var match = registry[0];
    var series;
    for (var idx = 0; idx < registry.length; idx++) {
      var entry = registry[idx];
      series = filterSeriesByType(srcSeries, entry.seriesTypes);
      if (series.length > 0) {
        match = entry;
        break;
      }
    }
    return new match.type(series, options2, chartService);
  };
  return PlotAreaFactory2;
}(class_default);
PlotAreaFactory.current = new PlotAreaFactory();
var plotarea_factory_default = PlotAreaFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/selection.js
var ZOOM_ACCELERATION = 3;
var SELECTOR_HEIGHT_ADJUST = 0.1;
function createDiv(classNames2) {
  var element2 = document.createElement("div");
  if (classNames2) {
    element2.className = classNames2;
  }
  return element2;
}
function closestHandle(element2) {
  var current4 = element2;
  while (current4 && !hasClasses(current4, "k-handle")) {
    current4 = current4.parentNode;
  }
  return current4;
}
var Selection = function(Class3) {
  function Selection2(chart, categoryAxis, options2, observer) {
    Class3.call(this);
    var chartElement = chart.element;
    this.options = deepExtend({}, this.options, options2);
    this.chart = chart;
    this.observer = observer;
    this.chartElement = chartElement;
    this.categoryAxis = categoryAxis;
    this._dateAxis = this.categoryAxis instanceof date_category_axis_default;
    this.initOptions();
    this.visible = this.options.visible && chartElement.offsetHeight;
    if (this.visible) {
      this.createElements();
      this.set(this._index(this.options.from), this._index(this.options.to));
      this.bindEvents();
    }
  }
  if (Class3)
    Selection2.__proto__ = Class3;
  Selection2.prototype = Object.create(Class3 && Class3.prototype);
  Selection2.prototype.constructor = Selection2;
  Selection2.prototype.onPane = function onPane(pane) {
    return this.categoryAxis.pane === pane;
  };
  Selection2.prototype.createElements = function createElements() {
    var options2 = this.options;
    var wrapper = this.wrapper = createDiv("k-selector k-pointer-events-none");
    elementStyles2(wrapper, {
      top: options2.offset.top,
      left: options2.offset.left,
      width: options2.width,
      height: options2.height,
      direction: "ltr"
    });
    var selection = this.selection = createDiv("k-selection k-pointer-events-none");
    this.leftMask = createDiv("k-mask k-pointer-events-none");
    this.rightMask = createDiv("k-mask k-pointer-events-none");
    wrapper.appendChild(this.leftMask);
    wrapper.appendChild(this.rightMask);
    wrapper.appendChild(selection);
    var body = this.body = createDiv("k-selection-bg k-pointer-events-none");
    selection.appendChild(body);
    var leftHandle = this.leftHandle = createDiv("k-handle k-left-handle k-pointer-events-auto");
    var rightHandle = this.rightHandle = createDiv("k-handle k-right-handle k-pointer-events-auto");
    leftHandle.appendChild(createDiv());
    rightHandle.appendChild(createDiv());
    selection.appendChild(leftHandle);
    selection.appendChild(rightHandle);
    this.chartElement.appendChild(wrapper);
    var selectionStyles = elementStyles2(selection, ["borderLeftWidth", "borderRightWidth", "height"]);
    var leftHandleHeight = elementStyles2(leftHandle, "height").height;
    var rightHandleHeight = elementStyles2(rightHandle, "height").height;
    options2.selection = {
      border: {
        left: selectionStyles.borderLeftWidth,
        right: selectionStyles.borderRightWidth
      }
    };
    elementStyles2(leftHandle, {
      top: (selectionStyles.height - leftHandleHeight) / 2
    });
    elementStyles2(rightHandle, {
      top: (selectionStyles.height - rightHandleHeight) / 2
    });
    wrapper.style.cssText = wrapper.style.cssText;
  };
  Selection2.prototype.bindEvents = function bindEvents$1() {
    var obj;
    if (this.options.mousewheel !== false) {
      this._mousewheelHandler = this._mousewheel.bind(this);
      bindEvents2(this.chartElement, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));
    }
    this._domEvents = dom_events_builder_default.create(this.chartElement, {
      stopPropagation: true,
      // applicable for the jQuery UserEvents
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      press: this._press.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
  };
  Selection2.prototype.initOptions = function initOptions() {
    var ref2 = this;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var box = categoryAxis.pane.chartsBox();
    var intlService = this.chart.chartService.intl;
    if (this._dateAxis) {
      deepExtend(options2, {
        min: parseDate3(intlService, options2.min),
        max: parseDate3(intlService, options2.max),
        from: parseDate3(intlService, options2.from),
        to: parseDate3(intlService, options2.to)
      });
    }
    var ref$1 = elementStyles2(this.chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref$1.paddingLeft;
    var paddingTop = ref$1.paddingTop;
    this.options = deepExtend({}, {
      width: box.width(),
      height: box.height() + SELECTOR_HEIGHT_ADJUST,
      //workaround for sub-pixel hover on the paths in chrome
      padding: {
        left: paddingLeft,
        top: paddingTop
      },
      offset: {
        left: box.x1 + paddingLeft,
        top: box.y1 + paddingTop
      },
      from: options2.min,
      to: options2.max
    }, options2);
  };
  Selection2.prototype.destroy = function destroy2() {
    var obj;
    if (this._domEvents) {
      this._domEvents.destroy();
      delete this._domEvents;
    }
    clearTimeout(this._mwTimeout);
    this._state = null;
    if (this.wrapper) {
      if (this._mousewheelHandler) {
        unbindEvents2(this.chartElement, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));
        this._mousewheelHandler = null;
      }
      this.chartElement.removeChild(this.wrapper);
      this.wrapper = null;
    }
  };
  Selection2.prototype._rangeEventArgs = function _rangeEventArgs(range) {
    return {
      axis: this.categoryAxis.options,
      from: this._value(range.from),
      to: this._value(range.to)
    };
  };
  Selection2.prototype._pointInPane = function _pointInPane(x, y) {
    var paneBox = this.categoryAxis.pane.box;
    var modelCoords = this.chart._toModelCoordinates(x, y);
    return paneBox.containsPoint(modelCoords);
  };
  Selection2.prototype._start = function _start(e) {
    var options2 = this.options;
    var target = eventElement2(e);
    if (this._state || !target) {
      return;
    }
    var coords = eventCoordinates2(e);
    var inPane = this._pointInPane(coords.x, coords.y);
    if (!inPane) {
      return;
    }
    var handle = closestHandle(target);
    var bodyRect = this.body.getBoundingClientRect();
    var inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width && coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;
    this.chart._unsetActivePoint();
    this._state = {
      moveTarget: handle,
      startLocation: e.x ? e.x.location : 0,
      inBody,
      range: {
        from: this._index(options2.from),
        to: this._index(options2.to)
      }
    };
    var args = this._rangeEventArgs({
      from: this._index(options2.from),
      to: this._index(options2.to)
    });
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    }
  };
  Selection2.prototype._press = function _press(e) {
    var handle;
    if (this._state) {
      handle = this._state.moveTarget;
    } else {
      handle = closestHandle(eventElement2(e));
    }
    if (handle) {
      addClass(handle, "k-handle-active");
    }
  };
  Selection2.prototype._move = function _move(e) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var state = ref2._state;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var target = state.moveTarget;
    var reverse = categoryAxis.options.reverse;
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var delta = state.startLocation - e.x.location;
    var oldRange = { from: range.from, to: range.to };
    var span = range.to - range.from;
    var scale = elementStyles2(this.wrapper, "width").width / (categoryAxis.categoriesCount() - 1);
    var offset3 = Math.round(delta / scale) * (reverse ? -1 : 1);
    if (!target && !state.inBody) {
      return;
    }
    var leftHandle = target && hasClasses(target, "k-left-handle");
    var rightHandle = target && hasClasses(target, "k-right-handle");
    if (state.inBody) {
      range.from = Math.min(
        Math.max(min3, from - offset3),
        max2 - span
      );
      range.to = Math.min(
        range.from + span,
        max2
      );
    } else if (leftHandle && !reverse || rightHandle && reverse) {
      range.from = Math.min(
        Math.max(min3, from - offset3),
        max2 - 1
      );
      range.to = Math.max(range.from + 1, range.to);
    } else if (leftHandle && reverse || rightHandle && !reverse) {
      range.to = Math.min(
        Math.max(min3 + 1, to - offset3),
        max2
      );
      range.from = Math.min(range.to - 1, range.from);
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.move(range.from, range.to);
      this.trigger(SELECT, this._rangeEventArgs(range));
    }
  };
  Selection2.prototype._end = function _end() {
    if (this._state) {
      var moveTarget = this._state.moveTarget;
      if (moveTarget) {
        removeClass(moveTarget, "k-handle-active");
      }
      var range = this._state.range;
      this.set(range.from, range.to);
      this.trigger(SELECT_END, this._rangeEventArgs(range));
      delete this._state;
    }
  };
  Selection2.prototype._tap = function _tap(e) {
    var ref2 = this;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var coords = this.chart._eventCoordinates(e);
    var categoryIx = categoryAxis.pointCategoryIndex(new point_default2(coords.x, categoryAxis.box.y1));
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var span = to - from;
    var mid = from + span / 2;
    var range = {};
    var rightClick = e.event.which === 3;
    var offset3 = Math.round(mid - categoryIx);
    if (this._state || rightClick) {
      return;
    }
    this.chart._unsetActivePoint();
    if (!categoryAxis.options.justified) {
      offset3--;
    }
    range.from = Math.min(
      Math.max(min3, from - offset3),
      max2 - span
    );
    range.to = Math.min(range.from + span, max2);
    this._start(e);
    if (this._state) {
      this._state.range = range;
      this.trigger(SELECT, this._rangeEventArgs(range));
      this._end();
    }
  };
  Selection2.prototype._mousewheel = function _mousewheel(e) {
    var this$1 = this;
    var delta = mousewheelDelta(e);
    this._start(e);
    if (this._state) {
      var range = this._state.range;
      e.preventDefault();
      e.stopPropagation();
      if (Math.abs(delta) > 1) {
        delta *= ZOOM_ACCELERATION;
      }
      if (this.options.mousewheel.reverse) {
        delta *= -1;
      }
      if (this.expand(delta)) {
        this.trigger(SELECT, {
          axis: this.categoryAxis.options,
          delta,
          originalEvent: e,
          from: this._value(range.from),
          to: this._value(range.to)
        });
      }
      if (this._mwTimeout) {
        clearTimeout(this._mwTimeout);
      }
      this._mwTimeout = setTimeout(function() {
        this$1._end();
      }, MOUSEWHEEL_DELAY);
    }
  };
  Selection2.prototype._gesturestart = function _gesturestart(e) {
    var options2 = this.options;
    var touch = e.touches[0];
    var inPane = this._pointInPane(touch.pageX, touch.pageY);
    if (!inPane) {
      return;
    }
    this._state = {
      range: {
        from: this._index(options2.from),
        to: this._index(options2.to)
      }
    };
    var args = this._rangeEventArgs(this._state.range);
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    } else {
      e.preventDefault();
    }
  };
  Selection2.prototype._gestureend = function _gestureend() {
    if (this._state) {
      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));
      delete this._state;
    }
  };
  Selection2.prototype._gesturechange = function _gesturechange(e) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var chart = ref2.chart;
    var state = ref2._state;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var p0 = chart._toModelCoordinates(e.touches[0].x.location).x;
    var p1 = chart._toModelCoordinates(e.touches[1].x.location).x;
    var left = Math.min(p0, p1);
    var right = Math.max(p0, p1);
    e.preventDefault();
    range.from = categoryAxis.pointCategoryIndex(new point_default2(left)) || options2.min;
    range.to = categoryAxis.pointCategoryIndex(new point_default2(right)) || options2.max;
    this.move(range.from, range.to);
    this.trigger(SELECT, this._rangeEventArgs(range));
  };
  Selection2.prototype._index = function _index(value) {
    var index = value;
    if (value instanceof Date) {
      index = this.categoryAxis.categoryIndex(value);
    }
    return index;
  };
  Selection2.prototype._value = function _value(index) {
    var value = index;
    if (this._dateAxis) {
      value = this.categoryAxis.categoryAt(index);
      if (value > this.options.max) {
        value = this.options.max;
      }
    }
    return value;
  };
  Selection2.prototype._slot = function _slot(value) {
    var categoryAxis = this.categoryAxis;
    var index = this._index(value);
    return categoryAxis.getSlot(index, index, true);
  };
  Selection2.prototype.move = function move(from, to) {
    var options2 = this.options;
    var reverse = this.categoryAxis.options.reverse;
    var offset3 = options2.offset;
    var padding = options2.padding;
    var border = options2.selection.border;
    var left = reverse ? to : from;
    var right = reverse ? from : to;
    var edge = "x" + (reverse ? 2 : 1);
    var box = this._slot(left);
    var leftMaskWidth = round3(box[edge] - offset3.left + padding.left);
    elementStyles2(this.leftMask, {
      width: leftMaskWidth
    });
    elementStyles2(this.selection, {
      left: leftMaskWidth
    });
    box = this._slot(right);
    var rightMaskWidth = round3(options2.width - (box[edge] - offset3.left + padding.left));
    elementStyles2(this.rightMask, {
      width: rightMaskWidth
    });
    var distance = options2.width - rightMaskWidth;
    if (distance !== options2.width) {
      distance += border.right;
    }
    elementStyles2(this.rightMask, {
      left: distance
    });
    elementStyles2(this.selection, {
      width: Math.max(options2.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)
    });
  };
  Selection2.prototype.set = function set2(from, to) {
    var options2 = this.options;
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var fromValue = limitValue2(this._index(from), min3, max2);
    var toValue = limitValue2(this._index(to), fromValue + 1, max2);
    if (options2.visible) {
      this.move(fromValue, toValue);
    }
    options2.from = this._value(fromValue);
    options2.to = this._value(toValue);
  };
  Selection2.prototype.expand = function expand(delta) {
    var options2 = this.options;
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var zDir = options2.mousewheel.zoom;
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var range = { from, to };
    var oldRange = deepExtend({}, range);
    if (this._state) {
      range = this._state.range;
    }
    if (zDir !== RIGHT) {
      range.from = limitValue2(
        limitValue2(from - delta, 0, to - 1),
        min3,
        max2
      );
    }
    if (zDir !== LEFT) {
      range.to = limitValue2(
        limitValue2(to + delta, range.from + 1, max2),
        min3,
        max2
      );
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.zoom = function zoom(delta, coords) {
    var options2 = this.options;
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var range = { from, to };
    var oldRange = deepExtend({}, range);
    var ref2 = this.categoryAxis.options;
    var reverse = ref2.reverse;
    var origin = X + (reverse ? "2" : "1");
    var lineBox = this.categoryAxis.lineBox();
    var relative = Math.abs(lineBox[origin] - coords[X]);
    var size = lineBox.width();
    var position3 = round3(relative / size, 2);
    var minDelta = round3(position3 * delta);
    var maxDelta = round3((1 - position3) * delta);
    if (this._state) {
      range = this._state.range;
    }
    range.from = limitValue2(
      limitValue2(from - minDelta, 0, to - 1),
      min3,
      max2
    );
    range.to = limitValue2(
      limitValue2(to + maxDelta, range.from + 1, max2),
      min3,
      max2
    );
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.trigger = function trigger2(name2, args) {
    return (this.observer || this.chart).trigger(name2, args);
  };
  return Selection2;
}(class_default);
setDefaultOptions(Selection, {
  visible: true,
  mousewheel: {
    zoom: "both"
  },
  min: MIN_VALUE,
  max: MAX_VALUE
});
var selection_default = Selection;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/tooltip.js
var Tooltip = function(BaseTooltip2) {
  function Tooltip3() {
    BaseTooltip2.apply(this, arguments);
  }
  if (BaseTooltip2)
    Tooltip3.__proto__ = BaseTooltip2;
  Tooltip3.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  Tooltip3.prototype.constructor = Tooltip3;
  Tooltip3.prototype.show = function show2(point2) {
    if (!point2 || !point2.tooltipAnchor || this._current && this._current === point2) {
      return;
    }
    var options2 = deepExtend({}, this.options, point2.options.tooltip);
    var anchor = point2.tooltipAnchor();
    if (anchor) {
      this._current = point2;
      BaseTooltip2.prototype.show.call(this, {
        point: point2,
        anchor
      }, options2, point2);
    } else {
      this.hide();
    }
  };
  Tooltip3.prototype.hide = function hide2() {
    delete this._current;
    BaseTooltip2.prototype.hide.call(this);
  };
  return Tooltip3;
}(base_tooltip_default);
var tooltip_default = Tooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/shared-tooltip.js
var SharedTooltip = function(BaseTooltip2) {
  function SharedTooltip3(plotArea, options2) {
    BaseTooltip2.call(this, plotArea.chartService, options2);
    this.plotArea = plotArea;
    this.formatService = plotArea.chartService.format;
  }
  if (BaseTooltip2)
    SharedTooltip3.__proto__ = BaseTooltip2;
  SharedTooltip3.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  SharedTooltip3.prototype.constructor = SharedTooltip3;
  SharedTooltip3.prototype.showAt = function showAt(points3, coords) {
    var tooltipPoints = grep(points3, function(point3) {
      var tooltip = point3.series.tooltip;
      var excluded = tooltip && tooltip.visible === false;
      return !excluded;
    });
    if (tooltipPoints.length > 0) {
      var point2 = tooltipPoints[0];
      var slot = this.plotArea.categoryAxis.getSlot(point2.categoryIx);
      var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point2, slot);
      this.show({
        anchor,
        shared: true,
        points: points3,
        category: point2.category,
        categoryText: this.formatService.auto(this.options.categoryFormat, point2.category),
        series: this.plotArea.series
      }, this.options);
    }
  };
  SharedTooltip3.prototype._slotAnchor = function _slotAnchor(point2, slot) {
    var axis = this.plotArea.categoryAxis;
    var align3 = {
      horizontal: "left",
      vertical: "center"
    };
    if (!axis.options.vertical) {
      point2.x = slot.center().x;
    }
    return {
      point: point2,
      align: align3
    };
  };
  SharedTooltip3.prototype._defaultAnchor = function _defaultAnchor(point2, slot) {
    var box = point2.owner.pane.chartsBox();
    var vertical = this.plotArea.categoryAxis.options.vertical;
    var center = box.center();
    var slotCenter = slot.center();
    var align3 = {
      horizontal: "center",
      vertical: "center"
    };
    var centerPoint;
    if (vertical) {
      centerPoint = new point_default2(center.x, slotCenter.y);
    } else {
      centerPoint = new point_default2(slotCenter.x, center.y);
    }
    return {
      point: centerPoint,
      align: align3
    };
  };
  return SharedTooltip3;
}(base_tooltip_default);
setDefaultOptions(SharedTooltip, {
  categoryFormat: "{0:d}"
});
var shared_tooltip_default = SharedTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bar-chart-animation.js
var BarChartAnimation = function(superclass) {
  function BarChartAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BarChartAnimation2.__proto__ = superclass;
  BarChartAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarChartAnimation2.prototype.constructor = BarChartAnimation2;
  BarChartAnimation2.prototype.setup = function setup() {
    var ref2 = this;
    var element2 = ref2.element;
    var options2 = ref2.options;
    var bbox = element2.bbox();
    if (bbox) {
      this.origin = options2.origin;
      var axis = options2.vertical ? Y : X;
      var fromScale = this.fromScale = new geometry_exports.Point(1, 1);
      fromScale[axis] = START_SCALE;
      element2.transform(
        geometry_exports.transform().scale(fromScale.x, fromScale.y)
      );
    } else {
      this.abort();
    }
  };
  BarChartAnimation2.prototype.step = function step(pos) {
    var scaleX = interpolateValue(this.fromScale.x, 1, pos);
    var scaleY = interpolateValue(this.fromScale.y, 1, pos);
    this.element.transform(
      geometry_exports.transform().scale(scaleX, scaleY, this.origin)
    );
  };
  BarChartAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    this.element.transform(null);
  };
  return BarChartAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BarChartAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(BAR, BarChartAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bubble-animation.js
var BubbleAnimation = function(superclass) {
  function BubbleAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BubbleAnimation2.__proto__ = superclass;
  BubbleAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BubbleAnimation2.prototype.constructor = BubbleAnimation2;
  BubbleAnimation2.prototype.setup = function setup() {
    var center = this.center = this.element.bbox().center();
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, center)
    );
  };
  BubbleAnimation2.prototype.step = function step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.center)
    );
  };
  return BubbleAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BubbleAnimation, {
  easing: "easeOutElastic"
});
drawing_exports.AnimationFactory.current.register(BUBBLE, BubbleAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/fade-in-animation.js
var FadeInAnimation = function(superclass) {
  function FadeInAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    FadeInAnimation2.__proto__ = superclass;
  FadeInAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeInAnimation2.prototype.constructor = FadeInAnimation2;
  FadeInAnimation2.prototype.setup = function setup() {
    this.fadeTo = this.element.opacity();
    this.element.opacity(0);
  };
  FadeInAnimation2.prototype.step = function step(pos) {
    this.element.opacity(pos * this.fadeTo);
  };
  return FadeInAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(FadeInAnimation, {
  duration: 200,
  easing: "linear"
});
drawing_exports.AnimationFactory.current.register(FADEIN, FadeInAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/pie-animation.js
var PieAnimation = function(superclass) {
  function PieAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    PieAnimation2.__proto__ = superclass;
  PieAnimation2.prototype = Object.create(superclass && superclass.prototype);
  PieAnimation2.prototype.constructor = PieAnimation2;
  PieAnimation2.prototype.setup = function setup() {
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, this.options.center)
    );
  };
  PieAnimation2.prototype.step = function step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.options.center)
    );
  };
  return PieAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(PieAnimation, {
  easing: "easeOutElastic",
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(PIE, PieAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-line-chart.js
var ScatterLineChart = function(ScatterChart2) {
  function ScatterLineChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    ScatterLineChart2.__proto__ = ScatterChart2;
  ScatterLineChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  ScatterLineChart2.prototype.constructor = ScatterLineChart2;
  ScatterLineChart2.prototype.render = function render() {
    ScatterChart2.prototype.render.call(this);
    this.renderSegments();
  };
  ScatterLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  ScatterLineChart2.prototype.animationPoints = function animationPoints() {
    var points3 = ScatterChart2.prototype.animationPoints.call(this);
    return points3.concat(this._segments);
  };
  ScatterLineChart2.prototype.createMissingValue = function createMissingValue(value, missingValues) {
    if (missingValues === ZERO2) {
      var missingValue = {
        x: value.x,
        y: value.y
      };
      if (!hasValue(missingValue.x)) {
        missingValue.x = 0;
      }
      if (!hasValue(missingValue.y)) {
        missingValue.y = 0;
      }
      return missingValue;
    }
  };
  return ScatterLineChart2;
}(scatter_chart_default);
deepExtend(ScatterLineChart.prototype, line_chart_mixin_default);
var scatter_line_chart_default = ScatterLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/xy-plotarea.js
var XYPlotArea = function(PlotAreaBase2) {
  function XYPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    XYPlotArea2.__proto__ = PlotAreaBase2;
  XYPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  XYPlotArea2.prototype.constructor = XYPlotArea2;
  XYPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
    this.xAxisRangeTracker = new axis_group_range_tracker_default();
    this.yAxisRangeTracker = new axis_group_range_tracker_default();
  };
  XYPlotArea2.prototype.render = function render(panes) {
    var this$1 = this;
    if (panes === void 0)
      panes = this.panes;
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var filteredSeries = this$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1.createScatterChart(
        filterSeriesByType(filteredSeries, SCATTER),
        pane
      );
      this$1.createScatterLineChart(
        filterSeriesByType(filteredSeries, SCATTER_LINE),
        pane
      );
      this$1.createBubbleChart(
        filterSeriesByType(filteredSeries, BUBBLE),
        pane
      );
    }
    this.createAxes(panes);
  };
  XYPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.xAxisRangeTracker.update(chart.xAxisRanges);
    this.yAxisRangeTracker.update(chart.yAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  XYPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      this.yAxisRangeTracker.reset(axisName);
      delete this.namedYAxes[axisName];
    } else {
      this.xAxisRangeTracker.reset(axisName);
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  XYPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxis = grep(xAxisOptions, function(a) {
      return a.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxis = grep(yAxisOptions, function(a) {
      return a.name === yAxisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  XYPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createScatterLineChart = function createScatterLineChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_line_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createBubbleChart = function createBubbleChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new bubble_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createXYAxis = function createXYAxis(options2, vertical, axisIndex) {
    var axisName = options2.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;
    var axisOptions2 = deepExtend({ reverse: !vertical && this.chartService.rtl }, options2, { vertical });
    var isLog = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC);
    var defaultRange = tracker.query();
    var defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
    var range = tracker.query(axisName) || defaultRange || defaultAxisRange;
    var typeSamples = [axisOptions2.min, axisOptions2.max];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    if (axisIndex === 0 && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var inferredDate;
    for (var i = 0; i < typeSamples.length; i++) {
      if (typeSamples[i] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_value_axis_default;
    } else if (isLog) {
      axisType = logarithmic_axis_default;
    } else {
      axisType = numeric_axis_default;
    }
    var axis = new axisType(range.min, range.max, axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    return axis;
  };
  XYPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1 = this;
    var options2 = this.options;
    var xAxesOptions = [].concat(options2.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options2.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  XYPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i = 0; i < length; i++) {
      var axis = allAxes[i];
      var values5 = axis.options.vertical ? yValues : xValues;
      var currentValue = axis.getValue(point2);
      if (currentValue !== null) {
        values5.push(currentValue);
      }
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        originalEvent: e,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  XYPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options2) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions2(this.options, index, vertical, options2);
    updateAxisOptions2(this.originalOptions, index, vertical, options2);
  };
  return XYPlotArea2;
}(plotarea_base_default);
function updateAxisOptions2(targetOptions, axisIndex, vertical, options2) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options2);
}
setDefaultOptions(XYPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(XYPlotArea.prototype, plotarea_events_mixin_default);
var xy_plotarea_default = XYPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-segment.js
var PieSegment = function(ChartElement2) {
  function PieSegment2(value, sector, options2) {
    ChartElement2.call(this, options2);
    this.value = value;
    this.sector = sector;
  }
  if (ChartElement2)
    PieSegment2.__proto__ = ChartElement2;
  PieSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieSegment2.prototype.constructor = PieSegment2;
  PieSegment2.prototype.render = function render() {
    var labels = this.options.labels;
    var chartService = this.owner.chartService;
    var labelText = this.value;
    if (this._rendered || this.visible === false) {
      return;
    }
    this._rendered = true;
    var labelTemplate = getTemplate(labels);
    var pointData = this.pointData();
    if (labelTemplate) {
      labelText = labelTemplate(pointData);
    } else if (labels.format) {
      labelText = chartService.format.auto(labels.format, labelText);
    }
    if (labels.visible && (labelText || labelText === 0)) {
      if (labels.position === CENTER || labels.position === INSIDE_END) {
        if (!labels.color) {
          labels.color = auto_text_color_default(this.options.color);
        }
        if (!labels.background) {
          labels.background = this.options.color;
        }
      } else {
        var themeLabels = chartService.theme.seriesDefaults.labels;
        labels.color = labels.color || themeLabels.color;
        labels.background = labels.background || themeLabels.background;
      }
      this.label = new text_box_default(labelText, deepExtend({}, labels, {
        align: CENTER,
        vAlign: "",
        animation: {
          type: FADEIN,
          delay: this.animationDelay
        }
      }), pointData);
      this.append(this.label);
    }
  };
  PieSegment2.prototype.reflow = function reflow(targetBox) {
    this.render();
    this.box = targetBox;
    this.reflowLabel();
  };
  PieSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var labelsDistance = labelsOptions.distance;
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      var labelWidth = label.box.width();
      var lp;
      if (labelsOptions.position === CENTER) {
        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else if (labelsOptions.position === INSIDE_END) {
        sector.radius = sector.radius - labelHeight / 2;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        var x1;
        lp = sector.clone().expand(labelsDistance).point(angle);
        if (lp.x >= sector.center.x) {
          x1 = lp.x + labelWidth;
          label.orientation = RIGHT;
        } else {
          x1 = lp.x - labelWidth;
          label.orientation = LEFT;
        }
        label.reflow(new box_default(x1, lp.y - labelHeight, lp.x, lp.y));
      }
    }
  };
  PieSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var sector = ref2.sector;
    var options2 = ref2.options;
    ChartElement2.prototype.createVisual.call(this);
    if (this.value) {
      if (options2.visual) {
        var startAngle = (sector.startAngle + 180) % 360;
        var visual = options2.visual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          series: this.series,
          percentage: this.percentage,
          center: new geometry_exports.Point(sector.center.x, sector.center.y),
          radius: sector.radius,
          innerRadius: sector.innerRadius,
          startAngle,
          endAngle: startAngle + sector.angle,
          options: options2,
          sender: this.getSender(),
          createVisual: function() {
            var group = new drawing_exports.Group();
            this$1.createSegmentVisual(group);
            return group;
          }
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else {
        this.createSegmentVisual(this.visual);
      }
    }
  };
  PieSegment2.prototype.createSegmentVisual = function createSegmentVisual(group) {
    var ref2 = this;
    var sector = ref2.sector;
    var options2 = ref2.options;
    var borderOptions = options2.border || {};
    var border = borderOptions.width > 0 ? {
      stroke: {
        color: borderOptions.color,
        width: borderOptions.width,
        opacity: borderOptions.opacity,
        dashType: borderOptions.dashType
      }
    } : {};
    var color = options2.color;
    var fill = {
      color,
      opacity: options2.opacity
    };
    var visual = this.createSegment(sector, deepExtend({
      fill,
      stroke: {
        opacity: options2.opacity
      },
      zIndex: options2.zIndex
    }, border));
    group.append(visual);
    if (hasGradientOverlay(options2)) {
      group.append(this.createGradientOverlay(visual, {
        baseColor: color,
        fallbackFill: fill
      }, deepExtend({
        center: [sector.center.x, sector.center.y],
        innerRadius: sector.innerRadius,
        radius: sector.radius,
        userSpace: true
      }, options2.overlay)));
    }
  };
  PieSegment2.prototype.createSegment = function createSegment(sector, options2) {
    if (options2.singleSegment) {
      return new drawing_exports.Circle(new geometry_exports.Circle(new geometry_exports.Point(sector.center.x, sector.center.y), sector.radius), options2);
    }
    return shape_builder_default.current.createRing(sector, options2);
  };
  PieSegment2.prototype.createAnimation = function createAnimation() {
    var ref2 = this;
    var options2 = ref2.options;
    var center = ref2.sector.center;
    deepExtend(options2, {
      animation: {
        center: [center.x, center.y],
        delay: this.animationDelay
      }
    });
    ChartElement2.prototype.createAnimation.call(this);
  };
  PieSegment2.prototype.createHighlight = function createHighlight(options2) {
    var highlight = this.options.highlight || {};
    var border = highlight.border || {};
    return this.createSegment(this.sector, deepExtend({}, options2, {
      fill: {
        color: highlight.color,
        opacity: highlight.opacity
      },
      stroke: {
        opacity: border.opacity,
        width: border.width,
        color: border.color
      }
    }));
  };
  PieSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  PieSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var sector = this.sector;
    return {
      options: this.options,
      radius: sector.radius,
      innerRadius: sector.innerRadius,
      center: new geometry_exports.Point(sector.center.x, sector.center.y),
      startAngle: sector.startAngle,
      endAngle: sector.angle + sector.startAngle,
      visual: this.visual
    };
  };
  PieSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var sector = this.sector.clone().expand(TOOLTIP_OFFSET);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    return {
      point: midPoint,
      align: tooltipAlignment(midAndle + 180)
    };
  };
  PieSegment2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  PieSegment2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  };
  return PieSegment2;
}(chart_element_default);
var RAD_30 = round3(rad2(30), DEFAULT_PRECISION);
var RAD_60 = round3(rad2(60), DEFAULT_PRECISION);
function tooltipAlignment(angle) {
  var radians = rad2(angle);
  var sine = round3(Math.sin(radians), DEFAULT_PRECISION);
  var cosine = round3(Math.cos(radians), DEFAULT_PRECISION);
  var horizontal;
  if (Math.abs(sine) > RAD_60) {
    horizontal = CENTER;
  } else if (cosine < 0) {
    horizontal = RIGHT;
  } else {
    horizontal = LEFT;
  }
  var vertical;
  if (Math.abs(sine) < RAD_30) {
    vertical = CENTER;
  } else if (sine < 0) {
    vertical = BOTTOM;
  } else {
    vertical = TOP;
  }
  return {
    horizontal,
    vertical
  };
}
setDefaultOptions(PieSegment, {
  color: WHITE,
  overlay: {
    gradient: "roundedBevel"
  },
  border: {
    width: 0.5
  },
  labels: {
    visible: false,
    distance: 35,
    font: DEFAULT_FONT,
    margin: getSpacing(0.5),
    align: CIRCLE,
    zIndex: 1,
    position: OUTSIDE_END
  },
  animation: {
    type: PIE
  },
  highlight: {
    visible: true,
    border: {
      width: 1
    }
  },
  visible: true
});
deepExtend(PieSegment.prototype, point_events_mixin_default);
var pie_segment_default = PieSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/pie-chart-mixin.js
var PieChartMixin = {
  createLegendItem: function(value, point2, options2) {
    var legendOptions = this.options.legend || {};
    var labelsOptions = legendOptions.labels || {};
    var inactiveItems = legendOptions.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    if (options2 && options2.visibleInLegend !== false) {
      var pointVisible = options2.visible !== false;
      var labelTemplate = pointVisible ? getTemplate(labelsOptions) : getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);
      var text = options2.category;
      if (labelTemplate) {
        text = labelTemplate({
          text,
          series: options2.series,
          dataItem: options2.dataItem,
          percentage: options2.percentage,
          value
        });
      }
      var itemLabelOptions, markerColor;
      if (pointVisible) {
        itemLabelOptions = {};
        markerColor = point2.color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = (inactiveItems.markers || {}).color;
      }
      if (hasValue(text) && text !== "") {
        this.legendItems.push({
          active: pointVisible,
          pointIndex: options2.index,
          text,
          series: options2.series,
          markerColor,
          labels: itemLabelOptions
        });
      }
    }
  }
};
var pie_chart_mixin_default = PieChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-chart.js
var PIE_SECTOR_ANIM_DELAY = 70;
var PieChart = function(ChartElement2) {
  function PieChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2)
    PieChart2.__proto__ = ChartElement2;
  PieChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieChart2.prototype.constructor = PieChart2;
  PieChart2.prototype.render = function render() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  PieChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0)
      seriesColors = [];
    var colorsCount = seriesColors.length;
    var series = options2.series;
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var data = currentSeries.data;
      var ref$1 = bindSegments(currentSeries);
      var total3 = ref$1.total;
      var points3 = ref$1.points;
      var count = ref$1.count;
      var anglePerValue = 360 / total3;
      var constantAngle = void 0;
      if (!isFinite(anglePerValue)) {
        constantAngle = 360 / count;
      }
      var currentAngle = void 0;
      if (defined2(currentSeries.startAngle)) {
        currentAngle = currentSeries.startAngle;
      } else {
        currentAngle = options2.startAngle;
      }
      if (seriesIx !== seriesCount - 1) {
        if (currentSeries.labels.position === OUTSIDE_END) {
          currentSeries.labels.position = CENTER;
        }
      }
      for (var i = 0; i < points3.length; i++) {
        var pointData = points3[i];
        if (!pointData) {
          continue;
        }
        var fields = pointData.fields;
        var value = pointData.value;
        var visible = pointData.visible;
        var angle = value !== 0 ? constantAngle || value * anglePerValue : 0;
        var explode = data.length !== 1 && Boolean(fields.explode);
        if (!isFunction3(currentSeries.color)) {
          currentSeries.color = fields.color || seriesColors[i % colorsCount];
        }
        callback(value, new ring_default(null, 0, 0, currentAngle, angle), {
          owner: this$1,
          category: defined2(fields.category) ? fields.category : "",
          index: i,
          series: currentSeries,
          seriesIx,
          dataItem: data[i],
          percentage: total3 !== 0 ? value / total3 : 0,
          explode,
          visibleInLegend: fields.visibleInLegend,
          visible,
          zIndex: seriesCount - seriesIx,
          animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)
        });
        if (visible !== false) {
          currentAngle += angle;
        }
      }
    }
  };
  PieChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options2, value, fields) {
    var series = fields.series;
    evalOptions(options2, {
      value,
      series,
      dataItem: fields.dataItem,
      category: fields.category,
      percentage: fields.percentage
    }, { defaults: series._defaults, excluded: ["data", "content", "template", "visual", "toggle"] });
  };
  PieChart2.prototype.addValue = function addValue(value, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    this.evalSegmentOptions(segmentOptions, value, fields);
    this.createLegendItem(value, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new pie_segment_default(value, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  PieChart2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var points3 = ref2.points;
    var seriesConfigs = ref2.seriesConfigs;
    if (seriesConfigs === void 0)
      seriesConfigs = [];
    var count = points3.length;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var newBox = new box_default(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);
    var newBoxCenter = newBox.center();
    var boxCenter = box.center();
    var seriesCount = options2.series.length;
    var leftSideLabels = [];
    var rightSideLabels = [];
    var padding = valueOrDefault2(options2.padding, defaultPadding);
    this.targetBox = targetBox;
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);
    var radius = halfMinWidth - padding;
    var center = new point_default2(
      radius + newBox.x1 + padding,
      radius + newBox.y1 + padding
    );
    for (var i = 0; i < count; i++) {
      var segment = points3[i];
      var sector = segment.sector;
      var seriesIndex = segment.seriesIx;
      sector.radius = radius;
      sector.center = center;
      if (seriesConfigs.length) {
        var seriesConfig = seriesConfigs[seriesIndex];
        sector.innerRadius = seriesConfig.innerRadius;
        sector.radius = seriesConfig.radius;
      }
      if (seriesIndex === seriesCount - 1 && segment.explode) {
        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());
      }
      segment.reflow(newBox);
      var label = segment.label;
      if (label) {
        if (label.options.position === OUTSIDE_END) {
          if (seriesIndex === seriesCount - 1) {
            if (label.orientation === RIGHT) {
              rightSideLabels.push(label);
            } else {
              leftSideLabels.push(label);
            }
          }
        }
      }
    }
    if (leftSideLabels.length > 0) {
      leftSideLabels.sort(this.labelComparator(true));
      this.leftLabelsReflow(leftSideLabels);
    }
    if (rightSideLabels.length > 0) {
      rightSideLabels.sort(this.labelComparator(false));
      this.rightLabelsReflow(rightSideLabels);
    }
    this.box = newBox;
  };
  PieChart2.prototype.leftLabelsReflow = function leftLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.rightLabelsReflow = function rightLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.distanceBetweenLabels = function distanceBetweenLabels(labels) {
    var segment = last2(this.points);
    var sector = segment.sector;
    var count = labels.length - 1;
    var lr = sector.radius + segment.options.labels.distance;
    var distances = [];
    var firstBox = labels[0].box;
    var distance = round3(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));
    distances.push(distance);
    for (var i = 0; i < count; i++) {
      var secondBox = labels[i + 1].box;
      firstBox = labels[i].box;
      distance = round3(secondBox.y1 - firstBox.y2);
      distances.push(distance);
    }
    distance = round3(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
    distances.push(distance);
    return distances;
  };
  PieChart2.prototype.distributeLabels = function distributeLabels(distances, labels) {
    var this$1 = this;
    var count = distances.length;
    var left, right, remaining;
    for (var i = 0; i < count; i++) {
      remaining = -distances[i];
      left = right = i;
      while (remaining > 0 && (left >= 0 || right < count)) {
        remaining = this$1._takeDistance(distances, i, --left, remaining);
        remaining = this$1._takeDistance(distances, i, ++right, remaining);
      }
    }
    this.reflowLabels(distances, labels);
  };
  PieChart2.prototype._takeDistance = function _takeDistance(distances, anchor, position3, amount) {
    var result = amount;
    if (distances[position3] > 0) {
      var available = Math.min(distances[position3], result);
      result -= available;
      distances[position3] -= available;
      distances[anchor] += available;
    }
    return result;
  };
  PieChart2.prototype.reflowLabels = function reflowLabels(distances, labels) {
    var this$1 = this;
    var segment = last2(this.points);
    var sector = segment.sector;
    var labelOptions = segment.options.labels;
    var labelsCount = labels.length;
    var labelDistance = labelOptions.distance;
    var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();
    var boxX;
    distances[0] += 2;
    for (var i = 0; i < labelsCount; i++) {
      var label = labels[i];
      var box = label.box;
      boxY += distances[i];
      boxX = this$1.hAlignLabel(
        box.x2,
        sector.clone().expand(labelDistance),
        boxY,
        boxY + box.height(),
        label.orientation === RIGHT
      );
      if (label.orientation === RIGHT) {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.radius + sector.center.x + labelDistance;
        }
        label.reflow(new box_default(boxX + box.width(), boxY, boxX, boxY));
      } else {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.center.x - sector.radius - labelDistance;
        }
        label.reflow(new box_default(boxX - box.width(), boxY, boxX, boxY));
      }
      boxY += box.height();
    }
  };
  PieChart2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var connectors = ref2.options.connectors;
    var points3 = ref2.points;
    var count = points3.length;
    var space = 4;
    ChartElement2.prototype.createVisual.call(this);
    this._connectorLines = [];
    for (var i = 0; i < count; i++) {
      var segment = points3[i];
      var sector = segment.sector;
      var label = segment.label;
      var angle = sector.middle();
      var connectorsColor = (segment.options.connectors || {}).color || connectors.color;
      if (label) {
        var connectorLine = new drawing_exports.Path({
          stroke: {
            color: connectorsColor,
            width: connectors.width
          },
          animation: {
            type: FADEIN,
            delay: segment.animationDelay
          }
        });
        if (label.options.position === OUTSIDE_END) {
          var box = label.box;
          var centerPoint = sector.center;
          var start = sector.point(angle);
          var middle = new point_default2(box.x1, box.center().y);
          var sr = void 0, end = void 0, crossing = void 0;
          start = sector.clone().expand(connectors.padding).point(angle);
          connectorLine.moveTo(start.x, start.y);
          if (label.orientation === RIGHT) {
            end = new point_default2(box.x1 - connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default2(end.x - space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.min(crossing.x, middle.x);
            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {
              sr = sector.center.x + sector.radius + space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr < middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x + space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          } else {
            end = new point_default2(box.x2 + connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default2(end.x + space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.max(crossing.x, middle.x);
            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {
              sr = sector.center.x - sector.radius - space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr > middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x - space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          }
          connectorLine.lineTo(end.x, end.y);
          this$1._connectorLines.push(connectorLine);
          this$1.visual.append(connectorLine);
        }
      }
    }
  };
  PieChart2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    if (find(this.options.series, function(options2) {
      return options2.autoFit;
    })) {
      var targetBox = this.targetBox;
      var pieCenter = this.box.center();
      var bbox = this.visual.bbox();
      if (!bbox) {
        return;
      }
      var bboxBottom = bbox.bottomRight();
      var scale = Math.min(
        (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),
        (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),
        (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),
        (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)
      );
      if (scale < 1) {
        this.visual.transform(geometry_exports.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));
      }
    }
  };
  PieChart2.prototype.labelComparator = function labelComparator(reverse) {
    var reverseValue = reverse ? -1 : 1;
    return function(a, b) {
      var first = (a.parent.sector.middle() + 270) % 360;
      var second = (b.parent.sector.middle() + 270) % 360;
      return (first - second) * reverseValue;
    };
  };
  PieChart2.prototype.hAlignLabel = function hAlignLabel(originalX, sector, y1, y2, direction) {
    var radius = sector.radius;
    var sector_center = sector.center;
    var cx = sector_center.x;
    var cy = sector_center.y;
    var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));
    if (t > radius) {
      return originalX;
    }
    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);
  };
  PieChart2.prototype.pointInCircle = function pointInCircle(point2, center, radius) {
    return Math.pow(center.x - point2.x, 2) + Math.pow(center.y - point2.y, 2) < Math.pow(radius, 2);
  };
  PieChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.chartService.format.auto(format2, point2.value);
  };
  PieChart2.prototype.animationDelay = function animationDelay(categoryIndex) {
    return categoryIndex * PIE_SECTOR_ANIM_DELAY;
  };
  PieChart2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  return PieChart2;
}(chart_element_default);
function intersection(a1, a2, b1, b2) {
  var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
  var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
  var result;
  if (ub !== 0) {
    var ua = uat / ub;
    result = new point_default2(
      a1.x + ua * (a2.x - a1.x),
      a1.y + ua * (a2.y - a1.y)
    );
  }
  return result;
}
setDefaultOptions(PieChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  },
  inactiveItems: {
    markers: {},
    labels: {}
  }
});
deepExtend(PieChart.prototype, pie_chart_mixin_default);
PieChart.prototype.isStackRoot = true;
var pie_chart_default = PieChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/pie-plotarea.js
var PiePlotArea = function(PlotAreaBase2) {
  function PiePlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    PiePlotArea2.__proto__ = PlotAreaBase2;
  PiePlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PiePlotArea2.prototype.constructor = PiePlotArea2;
  PiePlotArea2.prototype.render = function render() {
    this.createPieChart(this.series);
  };
  PiePlotArea2.prototype.createPieChart = function createPieChart(series) {
    var firstSeries = series[0];
    var pieChart = new pie_chart_default(this, {
      series,
      padding: firstSeries.padding,
      startAngle: firstSeries.startAngle,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(pieChart);
  };
  PiePlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append2(this.options.legend.items, chart.legendItems);
  };
  return PiePlotArea2;
}(plotarea_base_default);
var pie_plotarea_default = PiePlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-segment.js
var DonutSegment = function(PieSegment2) {
  function DonutSegment2() {
    PieSegment2.apply(this, arguments);
  }
  if (PieSegment2)
    DonutSegment2.__proto__ = PieSegment2;
  DonutSegment2.prototype = Object.create(PieSegment2 && PieSegment2.prototype);
  DonutSegment2.prototype.constructor = DonutSegment2;
  DonutSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      if (labelsOptions.position === CENTER) {
        sector.radius -= (sector.radius - sector.innerRadius) / 2;
        var lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        PieSegment2.prototype.reflowLabel.call(this);
      }
    }
  };
  DonutSegment2.prototype.createSegment = function createSegment(sector, options2) {
    return shape_builder_default.current.createRing(sector, options2);
  };
  return DonutSegment2;
}(pie_segment_default);
setDefaultOptions(DonutSegment, {
  overlay: {
    gradient: "roundedGlass"
  },
  labels: {
    position: CENTER
  },
  animation: {
    type: PIE
  }
});
deepExtend(DonutSegment.prototype, point_events_mixin_default);
var donut_segment_default = DonutSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-chart.js
var DONUT_SECTOR_ANIM_DELAY = 50;
var DonutChart = function(PieChart2) {
  function DonutChart2() {
    PieChart2.apply(this, arguments);
  }
  if (PieChart2)
    DonutChart2.__proto__ = PieChart2;
  DonutChart2.prototype = Object.create(PieChart2 && PieChart2.prototype);
  DonutChart2.prototype.constructor = DonutChart2;
  DonutChart2.prototype.addValue = function addValue(value, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    this.evalSegmentOptions(segmentOptions, value, fields);
    this.createLegendItem(value, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new donut_segment_default(value, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  DonutChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var options2 = this.options;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var series = options2.series;
    var seriesCount = series.length;
    var padding = valueOrDefault2(options2.padding, defaultPadding);
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    var totalSize = halfMinWidth - padding;
    var seriesWithoutSize = 0;
    var holeSize;
    for (var i = 0; i < seriesCount; i++) {
      var currentSeries = series[i];
      if (i === 0) {
        if (defined2(currentSeries.holeSize)) {
          holeSize = currentSeries.holeSize;
          totalSize -= currentSeries.holeSize;
        }
      }
      if (defined2(currentSeries.size)) {
        totalSize -= currentSeries.size;
      } else {
        seriesWithoutSize++;
      }
      if (defined2(currentSeries.margin) && i !== seriesCount - 1) {
        totalSize -= currentSeries.margin;
      }
    }
    if (!defined2(holeSize)) {
      var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);
      holeSize = currentSize * 0.75;
      totalSize -= holeSize;
    }
    var innerRadius = holeSize;
    var margin = 0;
    var size, radius;
    this.seriesConfigs = [];
    for (var i$1 = 0; i$1 < seriesCount; i$1++) {
      var currentSeries$1 = series[i$1];
      size = valueOrDefault2(currentSeries$1.size, totalSize / seriesWithoutSize);
      innerRadius += margin;
      radius = innerRadius + size;
      this$1.seriesConfigs.push({ innerRadius, radius });
      margin = currentSeries$1.margin || 0;
      innerRadius = radius;
    }
    PieChart2.prototype.reflow.call(this, targetBox);
  };
  DonutChart2.prototype.animationDelay = function animationDelay(categoryIndex, seriesIndex, seriesCount) {
    return categoryIndex * DONUT_SECTOR_ANIM_DELAY + INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1);
  };
  return DonutChart2;
}(pie_chart_default);
setDefaultOptions(DonutChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  }
});
var donut_chart_default = DonutChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/donut-plotarea.js
var DonutPlotArea = function(PiePlotArea2) {
  function DonutPlotArea2() {
    PiePlotArea2.apply(this, arguments);
  }
  if (PiePlotArea2)
    DonutPlotArea2.__proto__ = PiePlotArea2;
  DonutPlotArea2.prototype = Object.create(PiePlotArea2 && PiePlotArea2.prototype);
  DonutPlotArea2.prototype.constructor = DonutPlotArea2;
  DonutPlotArea2.prototype.render = function render() {
    this.createDonutChart(this.series);
  };
  DonutPlotArea2.prototype.createDonutChart = function createDonutChart(series) {
    var firstSeries = series[0];
    var donutChart = new donut_chart_default(this, {
      series,
      padding: firstSeries.padding,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(donutChart);
  };
  return DonutPlotArea2;
}(pie_plotarea_default);
var donut_plotarea_default = DonutPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea-base.js
var DEFAULT_PADDING = 0.15;
var PolarPlotAreaBase = function(PlotAreaBase2) {
  function PolarPlotAreaBase2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    PolarPlotAreaBase2.__proto__ = PlotAreaBase2;
  PolarPlotAreaBase2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PolarPlotAreaBase2.prototype.constructor = PolarPlotAreaBase2;
  PolarPlotAreaBase2.prototype.initFields = function initFields() {
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
  };
  PolarPlotAreaBase2.prototype.render = function render() {
    this.addToLegend(this.series);
    this.createPolarAxis();
    this.createCharts();
    this.createValueAxis();
  };
  PolarPlotAreaBase2.prototype.alignAxes = function alignAxes() {
    var axis = this.valueAxis;
    var range = axis.range();
    var crossingValue = axis.options.reverse ? range.max : range.min;
    var slot = axis.getSlot(crossingValue);
    var center = this.polarAxis.getSlot(0).center;
    var axisBox = axis.box.translate(
      center.x - slot.x1,
      center.y - slot.y1
    );
    axis.reflow(axisBox);
  };
  PolarPlotAreaBase2.prototype.createValueAxis = function createValueAxis() {
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var axisOptions2 = this.valueAxisOptions({
      roundToMajorUnit: false,
      zIndex: -1
    });
    var axisType, axisDefaultRange;
    if (axisOptions2.type === LOGARITHMIC) {
      axisType = radar_logarithmic_axis_default;
      axisDefaultRange = { min: 0.1, max: 1 };
    } else {
      axisType = radar_numeric_axis_default;
      axisDefaultRange = { min: 0, max: 1 };
    }
    var range = tracker.query(name) || defaultRange || axisDefaultRange;
    if (range && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var valueAxis = new axisType(
      range.min,
      range.max,
      axisOptions2,
      this.chartService
    );
    this.valueAxis = valueAxis;
    this.appendAxis(valueAxis);
  };
  PolarPlotAreaBase2.prototype.reflowAxes = function reflowAxes() {
    var ref2 = this;
    var options2 = ref2.options.plotArea;
    var valueAxis = ref2.valueAxis;
    var polarAxis = ref2.polarAxis;
    var box = ref2.box;
    var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;
    var padding = getSpacing(options2.padding || {}, defaultPadding);
    var paddingBox = box.clone().unpad(padding);
    var axisBox = paddingBox.clone();
    axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());
    axisBox.align(paddingBox, Y, CENTER);
    var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);
    polarAxis.reflow(axisBox);
    valueAxis.reflow(valueAxisBox);
    var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();
    valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));
    this.axisBox = axisBox;
    this.alignAxes(axisBox);
  };
  PolarPlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    return this.box;
  };
  PolarPlotAreaBase2.prototype.detachLabels = function detachLabels() {
  };
  return PolarPlotAreaBase2;
}(plotarea_base_default);
var polar_plotarea_base_default = PolarPlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-scatter-chart/polar-scatter-chart.js
var PolarScatterChart = function(ScatterChart2) {
  function PolarScatterChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    PolarScatterChart2.__proto__ = ScatterChart2;
  PolarScatterChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  PolarScatterChart2.prototype.constructor = PolarScatterChart2;
  PolarScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    var valueRadius = slotX.center.y - slotY.y1;
    var slot = point_default2.onCircle(slotX.center, slotX.startAngle, valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  };
  return PolarScatterChart2;
}(scatter_chart_default);
setDefaultOptions(PolarScatterChart, {
  clip: false
});
var polar_scatter_chart_default = PolarScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-line-chart/polar-line-chart.js
var PolarLineChart = function(ScatterLineChart2) {
  function PolarLineChart2() {
    ScatterLineChart2.apply(this, arguments);
  }
  if (ScatterLineChart2)
    PolarLineChart2.__proto__ = ScatterLineChart2;
  PolarLineChart2.prototype = Object.create(ScatterLineChart2 && ScatterLineChart2.prototype);
  PolarLineChart2.prototype.constructor = PolarLineChart2;
  return PolarLineChart2;
}(scatter_line_chart_default);
PolarLineChart.prototype.pointSlot = polar_scatter_chart_default.prototype.pointSlot;
setDefaultOptions(PolarLineChart, {
  clip: false
});
var polar_line_chart_default = PolarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/spline-polar-area-segment.js
var SplinePolarAreaSegment = function(SplineAreaSegment2) {
  function SplinePolarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2)
    SplinePolarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplinePolarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplinePolarAreaSegment2.prototype.constructor = SplinePolarAreaSegment2;
  SplinePolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var center = this._polarAxisCenter();
    fillPath.lineTo(center.x, center.y);
  };
  SplinePolarAreaSegment2.prototype._polarAxisCenter = function _polarAxisCenter() {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    return center;
  };
  SplinePolarAreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      var center = this._polarAxisCenter();
      var curveProcessor = new curve_processor_default(false);
      var linePoints = this.points();
      linePoints.push(center);
      segments = this._strokeSegments = curveProcessor.process(linePoints);
      segments.pop();
    }
    return segments;
  };
  return SplinePolarAreaSegment2;
}(spline_area_segment_default);
var spline_polar_area_segment_default = SplinePolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-segment.js
var PolarAreaSegment = function(AreaSegment2) {
  function PolarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    PolarAreaSegment2.__proto__ = AreaSegment2;
  PolarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  PolarAreaSegment2.prototype.constructor = PolarAreaSegment2;
  PolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    var centerSegment = new geometry_exports.Segment([center.x, center.y]);
    fillPath.segments.unshift(centerSegment);
    fillPath.segments.push(centerSegment);
  };
  return PolarAreaSegment2;
}(area_segment_default);
var polar_area_segment_default = PolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-chart.js
var PolarAreaChart = function(PolarLineChart2) {
  function PolarAreaChart2() {
    PolarLineChart2.apply(this, arguments);
  }
  if (PolarLineChart2)
    PolarAreaChart2.__proto__ = PolarLineChart2;
  PolarAreaChart2.prototype = Object.create(PolarLineChart2 && PolarLineChart2.prototype);
  PolarAreaChart2.prototype.constructor = PolarAreaChart2;
  PolarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = (currentSeries.line || {}).style;
    var segment;
    if (style === SMOOTH) {
      segment = new spline_polar_area_segment_default(linePoints, currentSeries, seriesIx);
    } else {
      segment = new polar_area_segment_default(linePoints, currentSeries, seriesIx);
    }
    return segment;
  };
  PolarAreaChart2.prototype.createMissingValue = function createMissingValue(value, missingValues) {
    var missingValue;
    if (hasValue(value.x) && missingValues !== INTERPOLATE) {
      missingValue = {
        x: value.x,
        y: value.y
      };
      if (missingValues === ZERO2) {
        missingValue.y = 0;
      }
    }
    return missingValue;
  };
  PolarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO2;
  };
  PolarAreaChart2.prototype._hasMissingValuesGap = function _hasMissingValuesGap() {
    var this$1 = this;
    var series = this.options.series;
    for (var idx = 0; idx < series.length; idx++) {
      if (this$1.seriesMissingValues(series[idx]) === GAP) {
        return true;
      }
    }
  };
  PolarAreaChart2.prototype.sortPoints = function sortPoints(points3) {
    var this$1 = this;
    points3.sort(xComparer);
    if (this._hasMissingValuesGap()) {
      for (var idx = 0; idx < points3.length; idx++) {
        var point2 = points3[idx];
        if (point2) {
          var value = point2.value;
          if (!hasValue(value.y) && this$1.seriesMissingValues(point2.series) === GAP) {
            delete points3[idx];
          }
        }
      }
    }
    return points3;
  };
  return PolarAreaChart2;
}(polar_line_chart_default);
function xComparer(a, b) {
  return a.value.x - b.value.x;
}
var polar_area_chart_default = PolarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea.js
var PolarPlotArea = function(PolarPlotAreaBase2) {
  function PolarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2)
    PolarPlotArea2.__proto__ = PolarPlotAreaBase2;
  PolarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  PolarPlotArea2.prototype.constructor = PolarPlotArea2;
  PolarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var polarAxis = new polar_axis_default(this.options.xAxis, this.chartService);
    this.polarAxis = polarAxis;
    this.axisX = polarAxis;
    this.appendAxis(polarAxis);
  };
  PolarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    return deepExtend(defaults, {
      majorGridLines: { type: ARC },
      minorGridLines: { type: ARC }
    }, this.options.yAxis);
  };
  PolarPlotArea2.prototype.createValueAxis = function createValueAxis() {
    PolarPlotAreaBase2.prototype.createValueAxis.call(this);
    this.axisY = this.valueAxis;
  };
  PolarPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.valueAxisRangeTracker.update(chart.yAxisRanges);
    plotarea_base_default.prototype.appendChart.call(this, chart, pane);
  };
  PolarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createLineChart(
      filterSeriesByType(series, [POLAR_LINE]),
      pane
    );
    this.createScatterChart(
      filterSeriesByType(series, [POLAR_SCATTER]),
      pane
    );
    this.createAreaChart(
      filterSeriesByType(series, [POLAR_AREA]),
      pane
    );
  };
  PolarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new polar_line_chart_default(this, { series });
    this.appendChart(lineChart, pane);
  };
  PolarPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var scatterChart = new polar_scatter_chart_default(this, { series });
    this.appendChart(scatterChart, pane);
  };
  PolarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new polar_area_chart_default(this, { series });
    this.appendChart(areaChart, pane);
  };
  PolarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var xValue = this.axisX.getValue(point2);
    var yValue = this.axisY.getValue(point2);
    if (xValue !== null && yValue !== null) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        x: xValue,
        y: yValue
      });
    }
  };
  PolarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  return PolarPlotArea2;
}(polar_plotarea_base_default);
setDefaultOptions(PolarPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(PolarPlotArea.prototype, plotarea_events_mixin_default);
var polar_plotarea_default = PolarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-line-chart/radar-line-chart.js
function groupBySeriesIx(segments) {
  var seriesSegments = [];
  for (var idx = 0; idx < segments.length; idx++) {
    var segment = segments[idx];
    seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];
    seriesSegments[segment.seriesIx].push(segment);
  }
  return seriesSegments;
}
var RadarLineChart = function(LineChart2) {
  function RadarLineChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2)
    RadarLineChart2.__proto__ = LineChart2;
  RadarLineChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  RadarLineChart2.prototype.constructor = RadarLineChart2;
  RadarLineChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var valueRadius = categorySlot.center.y - valueSlot.y1;
    var slot = point_default2.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  };
  RadarLineChart2.prototype.renderSegments = function renderSegments() {
    LineChart2.prototype.renderSegments.call(this);
    if (this._segments && this._segments.length > 1) {
      var seriesSegments = groupBySeriesIx(this._segments);
      for (var idx = 0; idx < seriesSegments.length; idx++) {
        var segments = seriesSegments[idx];
        if (segments && segments.length > 1) {
          var firstPoint = segments[0].linePoints[0];
          var lastSegment = last2(segments);
          var lastPoint = last2(lastSegment.linePoints);
          var isFirstDataPoint = firstPoint.categoryIx === 0;
          var isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;
          if (isFirstDataPoint && isLastDataPoint) {
            last2(segments).linePoints.push(firstPoint);
          }
        }
      }
    }
  };
  RadarLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    var segment = new pointType(linePoints, currentSeries, seriesIx);
    var missingValues = this.seriesMissingValues(currentSeries);
    if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {
      segment.options.closed = true;
    }
    return segment;
  };
  return RadarLineChart2;
}(line_chart_default);
setDefaultOptions(RadarLineChart, {
  clip: false,
  limitPoints: false
});
var radar_line_chart_default = RadarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/spline-radar-area-segment.js
var SplineRadarAreaSegment = function(SplineAreaSegment2) {
  function SplineRadarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2)
    SplineRadarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplineRadarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplineRadarAreaSegment2.prototype.constructor = SplineRadarAreaSegment2;
  SplineRadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return SplineRadarAreaSegment2;
}(spline_area_segment_default);
var spline_radar_area_segment_default = SplineRadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-segment.js
var RadarAreaSegment = function(AreaSegment2) {
  function RadarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    RadarAreaSegment2.__proto__ = AreaSegment2;
  RadarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RadarAreaSegment2.prototype.constructor = RadarAreaSegment2;
  RadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return RadarAreaSegment2;
}(area_segment_default);
var radar_area_segment_default = RadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-chart.js
var RadarAreaChart = function(RadarLineChart2) {
  function RadarAreaChart2() {
    RadarLineChart2.apply(this, arguments);
  }
  if (RadarLineChart2)
    RadarAreaChart2.__proto__ = RadarLineChart2;
  RadarAreaChart2.prototype = Object.create(RadarLineChart2 && RadarLineChart2.prototype);
  RadarAreaChart2.prototype.constructor = RadarAreaChart2;
  RadarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    var segment;
    if (isStacked && seriesIx > 0 && prevSegment) {
      stackPoints = prevSegment.linePoints.slice(0);
      previousSegment = prevSegment;
    }
    if (style === SMOOTH) {
      segment = new spline_radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
      segment.options.closed = true;
    } else {
      linePoints.push(linePoints[0]);
      segment = new radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
    }
    return segment;
  };
  RadarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO2;
  };
  return RadarAreaChart2;
}(radar_line_chart_default);
var radar_area_chart_default = RadarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-segment.js
var RadarSegment = function(DonutSegment2) {
  function RadarSegment2(value, options2) {
    DonutSegment2.call(this, value, null, options2);
  }
  if (DonutSegment2)
    RadarSegment2.__proto__ = DonutSegment2;
  RadarSegment2.prototype = Object.create(DonutSegment2 && DonutSegment2.prototype);
  RadarSegment2.prototype.constructor = RadarSegment2;
  return RadarSegment2;
}(donut_segment_default);
setDefaultOptions(RadarSegment, {
  overlay: {
    gradient: "none"
  },
  labels: {
    distance: 10
  }
});
var radar_segment_default = RadarSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-cluster-layout.js
var RadarClusterLayout = function(ChartElement2) {
  function RadarClusterLayout2(options2) {
    ChartElement2.call(this, options2);
    this.forEach = options2.rtl ? forEachReverse2 : forEach2;
  }
  if (ChartElement2)
    RadarClusterLayout2.__proto__ = ChartElement2;
  RadarClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarClusterLayout2.prototype.constructor = RadarClusterLayout2;
  RadarClusterLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var gap = options2.gap;
    var spacing = options2.spacing;
    var count = children.length;
    var slots = count + gap + spacing * (count - 1);
    var slotAngle = sector.angle / slots;
    var angle = sector.startAngle + slotAngle * (gap / 2);
    this.forEach(children, function(child) {
      var slotSector = sector.clone();
      slotSector.startAngle = angle;
      slotSector.angle = slotAngle;
      if (child.sector) {
        slotSector.radius = child.sector.radius;
      }
      child.reflow(slotSector);
      child.sector = slotSector;
      angle += slotAngle + slotAngle * spacing;
    });
  };
  return RadarClusterLayout2;
}(chart_element_default);
setDefaultOptions(RadarClusterLayout, {
  gap: 1,
  spacing: 0
});
var radar_cluster_layout_default = RadarClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-stack-layout.js
var RadarStackLayout = function(ChartElement2) {
  function RadarStackLayout2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2)
    RadarStackLayout2.__proto__ = ChartElement2;
  RadarStackLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarStackLayout2.prototype.constructor = RadarStackLayout2;
  RadarStackLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var reverse = ref2.options.reverse;
    var children = ref2.children;
    var childrenCount = children.length;
    var first = reverse ? childrenCount - 1 : 0;
    var step = reverse ? -1 : 1;
    this.box = new box_default();
    for (var i = first; i >= 0 && i < childrenCount; i += step) {
      var childSector = children[i].sector;
      childSector.startAngle = sector.startAngle;
      childSector.angle = sector.angle;
    }
  };
  return RadarStackLayout2;
}(chart_element_default);
var radar_stack_layout_default = RadarStackLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-bar-chart.js
var RadarBarChart = function(BarChart2) {
  function RadarBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    RadarBarChart2.__proto__ = BarChart2;
  RadarBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RadarBarChart2.prototype.constructor = RadarBarChart2;
  RadarBarChart2.prototype.pointType = function pointType() {
    return radar_segment_default;
  };
  RadarBarChart2.prototype.clusterType = function clusterType() {
    return radar_cluster_layout_default;
  };
  RadarBarChart2.prototype.stackType = function stackType() {
    return radar_stack_layout_default;
  };
  RadarBarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  RadarBarChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var slot = categorySlot.clone();
    var y = categorySlot.center.y;
    slot.radius = y - valueSlot.y1;
    slot.innerRadius = y - valueSlot.y2;
    return slot;
  };
  RadarBarChart2.prototype.reflowPoint = function reflowPoint(point2, pointSlot) {
    point2.sector = pointSlot;
    point2.reflow();
  };
  RadarBarChart2.prototype.createAnimation = function createAnimation() {
    this.options.animation.center = this.box.toRect().center();
    BarChart2.prototype.createAnimation.call(this);
  };
  return RadarBarChart2;
}(bar_chart_default);
RadarBarChart.prototype.reflow = categorical_chart_default.prototype.reflow;
setDefaultOptions(RadarBarChart, {
  clip: false,
  limitPoints: false,
  animation: {
    type: "pie"
  }
});
var radar_bar_chart_default = RadarBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/radar-plotarea.js
var RadarPlotArea = function(PolarPlotAreaBase2) {
  function RadarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2)
    RadarPlotArea2.__proto__ = PolarPlotAreaBase2;
  RadarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  RadarPlotArea2.prototype.constructor = RadarPlotArea2;
  RadarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var categoryAxis = new radar_category_axis_default(this.options.categoryAxis, this.chartService);
    this.polarAxis = categoryAxis;
    this.categoryAxis = categoryAxis;
    this.appendAxis(categoryAxis);
    this.aggregateCategories();
    this.createCategoryAxesLabels();
  };
  RadarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    if (this._hasBarCharts) {
      deepExtend(defaults, {
        majorGridLines: { type: ARC },
        minorGridLines: { type: ARC }
      });
    }
    if (this._isStacked100) {
      deepExtend(defaults, {
        roundToMajorUnit: false,
        labels: { format: "P0" }
      });
    }
    return deepExtend(defaults, this.options.valueAxis);
  };
  RadarPlotArea2.prototype.aggregateCategories = function aggregateCategories() {
    categorical_plotarea_default.prototype.aggregateCategories.call(this, this.panes);
  };
  RadarPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    categorical_plotarea_default.prototype.createCategoryAxesLabels.call(this, this.panes);
  };
  RadarPlotArea2.prototype.filterSeries = function filterSeries(currentSeries) {
    return currentSeries;
  };
  RadarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createAreaChart(
      filterSeriesByType(series, [RADAR_AREA]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [RADAR_LINE]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [RADAR_COLUMN]),
      pane
    );
  };
  RadarPlotArea2.prototype.chartOptions = function chartOptions(series) {
    var options2 = { series };
    var firstSeries = series[0];
    if (firstSeries) {
      var filteredSeries = this.filterVisibleSeries(series);
      var stack2 = firstSeries.stack;
      options2.isStacked = stack2 && filteredSeries.length > 1;
      options2.isStacked100 = stack2 && stack2.type === "100%" && filteredSeries.length > 1;
      if (options2.isStacked100) {
        this._isStacked100 = true;
      }
    }
    return options2;
  };
  RadarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new radar_area_chart_default(this, this.chartOptions(series));
    this.appendChart(areaChart, pane);
  };
  RadarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new radar_line_chart_default(this, this.chartOptions(series));
    this.appendChart(lineChart, pane);
  };
  RadarPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var options2 = this.chartOptions(series);
    options2.gap = firstSeries.gap;
    options2.spacing = firstSeries.spacing;
    var barChart = new radar_bar_chart_default(this, options2);
    this.appendChart(barChart, pane);
    this._hasBarCharts = true;
  };
  RadarPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis() {
    return this.categoryAxis;
  };
  RadarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var category = this.categoryAxis.getCategory(point2);
    var value = this.valueAxis.getValue(point2);
    if (category !== null && value !== null) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        category,
        value
      });
    }
  };
  RadarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  return RadarPlotArea2;
}(polar_plotarea_base_default);
deepExtend(RadarPlotArea.prototype, plotarea_events_mixin_default, {
  appendChart: categorical_plotarea_default.prototype.appendChart,
  aggregateSeries: categorical_plotarea_default.prototype.aggregateSeries,
  seriesSourcePoints: categorical_plotarea_default.prototype.seriesSourcePoints
});
setDefaultOptions(RadarPlotArea, {
  categoryAxis: {
    categories: []
  },
  valueAxis: {}
});
var radar_plotarea_default = RadarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-segment.js
var FunnelSegment = function(ChartElement2) {
  function FunnelSegment2(value, options2, segmentOptions) {
    ChartElement2.call(this, options2);
    this.value = value;
    this.options.index = segmentOptions.index;
  }
  if (ChartElement2)
    FunnelSegment2.__proto__ = ChartElement2;
  FunnelSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelSegment2.prototype.constructor = FunnelSegment2;
  FunnelSegment2.prototype.reflow = function reflow(chartBox) {
    var points3 = this.points;
    var label = this.children[0];
    this.box = new box_default(points3[0].x, points3[0].y, points3[1].x, points3[2].y);
    if (label) {
      label.reflow(new box_default(chartBox.x1, points3[0].y, chartBox.x2, points3[2].y));
    }
  };
  FunnelSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var options2 = this.options;
    var visual;
    ChartElement2.prototype.createVisual.call(this);
    if (options2.visual) {
      visual = options2.visual({
        category: this.category,
        dataItem: this.dataItem,
        value: this.value,
        series: this.series,
        percentage: this.percentage,
        points: this.points,
        options: options2,
        sender: this.getSender(),
        createVisual: function() {
          return this$1.createPath();
        }
      });
    } else {
      visual = this.createPath();
    }
    if (visual) {
      this.visual.append(visual);
    }
  };
  FunnelSegment2.prototype.createPath = function createPath() {
    var options2 = this.options;
    var border = options2.border;
    var path = drawing_exports.Path.fromPoints(this.points, {
      fill: {
        color: options2.color,
        opacity: options2.opacity
      },
      stroke: {
        color: border.color,
        opacity: border.opacity,
        width: border.width
      }
    }).close();
    return path;
  };
  FunnelSegment2.prototype.createHighlight = function createHighlight(style) {
    return drawing_exports.Path.fromPoints(this.points, style);
  };
  FunnelSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  FunnelSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var path = drawing_exports.Path.fromPoints(this.points).close();
    return {
      options: this.options,
      path
    };
  };
  FunnelSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    return {
      point: new point_default2(box.center().x, box.y1),
      align: {
        horizontal: "center",
        vertical: "top"
      }
    };
  };
  FunnelSegment2.prototype.formatValue = function formatValue(format2) {
    var point2 = this;
    return point2.owner.formatPointValue(point2, format2);
  };
  return FunnelSegment2;
}(chart_element_default);
setDefaultOptions(FunnelSegment, {
  color: WHITE,
  border: {
    width: 1
  }
});
deepExtend(FunnelSegment.prototype, point_events_mixin_default);
var funnel_segment_default = FunnelSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-chart.js
var FunnelChart = function(ChartElement2) {
  function FunnelChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.points = [];
    this.labels = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2)
    FunnelChart2.__proto__ = ChartElement2;
  FunnelChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelChart2.prototype.constructor = FunnelChart2;
  FunnelChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.chartService.format.auto(format2, point2.value);
  };
  FunnelChart2.prototype.render = function render() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0)
      seriesColors = [];
    var series = options2.series[0];
    var data = series.data;
    if (!data) {
      return;
    }
    var ref$1 = bindSegments(series);
    var total3 = ref$1.total;
    var points3 = ref$1.points;
    for (var i = 0; i < points3.length; i++) {
      var pointData = points3[i];
      if (!pointData) {
        continue;
      }
      var fields = pointData.fields;
      if (!isFunction3(series.color)) {
        series.color = fields.color || seriesColors[i % seriesColors.length];
      }
      fields = deepExtend({
        index: i,
        owner: this$1,
        series,
        dataItem: data[i],
        percentage: pointData.value / total3
      }, fields, { visible: pointData.visible });
      var value = pointData.valueFields.value;
      var segment = this$1.createSegment(value, fields);
      var label = this$1.createLabel(value, fields);
      if (segment && label) {
        segment.append(label);
      }
    }
  };
  FunnelChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options2, value, fields) {
    var series = fields.series;
    evalOptions(options2, {
      value,
      series,
      dataItem: fields.dataItem,
      index: fields.index
    }, { defaults: series._defaults, excluded: ["data", "content", "template", "toggle", "visual"] });
  };
  FunnelChart2.prototype.createSegment = function createSegment(value, fields) {
    var seriesOptions = deepExtend({}, fields.series);
    this.evalSegmentOptions(seriesOptions, value, fields);
    this.createLegendItem(value, seriesOptions, fields);
    if (fields.visible !== false) {
      var segment = new funnel_segment_default(value, seriesOptions, fields);
      Object.assign(segment, fields);
      this.append(segment);
      this.points.push(segment);
      return segment;
    }
  };
  FunnelChart2.prototype.createLabel = function createLabel(value, fields) {
    var series = fields.series;
    var dataItem = fields.dataItem;
    var labels = deepExtend({}, this.options.labels, series.labels);
    var text = value;
    if (labels.visible) {
      var labelTemplate = getTemplate(labels);
      var data = {
        dataItem,
        value,
        percentage: fields.percentage,
        category: fields.category,
        series
      };
      if (labelTemplate) {
        text = labelTemplate(data);
      } else if (labels.format) {
        text = this.plotArea.chartService.format.auto(labels.format, text);
      }
      if (!labels.color) {
        labels.color = auto_text_color_default(series.color);
        if (!labels.background) {
          labels.background = series.color;
        }
      }
      this.evalSegmentOptions(labels, value, fields);
      var textBox = new text_box_default(text, deepExtend({
        vAlign: labels.position
      }, labels), data);
      this.labels.push(textBox);
      return textBox;
    }
  };
  FunnelChart2.prototype.labelPadding = function labelPadding() {
    var labels = this.labels;
    var padding = { left: 0, right: 0 };
    for (var i = 0; i < labels.length; i++) {
      var label = labels[i];
      var align3 = label.options.align;
      if (align3 !== CENTER) {
        var width = labels[i].box.width();
        if (align3 === LEFT) {
          padding.left = Math.max(padding.left, width);
        } else {
          padding.right = Math.max(padding.right, width);
        }
      }
    }
    return padding;
  };
  FunnelChart2.prototype.dynamicSlopeReflow = function dynamicSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options2 = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var firstSegment = segments[0];
    var maxSegment = firstSegment;
    for (var idx = 0; idx < segments.length; idx++) {
      if (segments[idx].percentage > maxSegment.percentage) {
        maxSegment = segments[idx];
      }
    }
    var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;
    var previousOffset = (width - lastUpperSide) / 2;
    var previousHeight = 0;
    for (var idx$1 = 0; idx$1 < count; idx$1++) {
      var percentage = segments[idx$1].percentage;
      var nextSegment = segments[idx$1 + 1];
      var nextPercentage = nextSegment ? nextSegment.percentage : percentage;
      var points3 = segments[idx$1].points = [];
      var height = options2.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      var offset3 = void 0;
      if (!percentage) {
        offset3 = nextPercentage ? 0 : width / 2;
      } else {
        offset3 = (width - lastUpperSide * (nextPercentage / percentage)) / 2;
      }
      offset3 = limitValue2(offset3, 0, width);
      points3.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + width - offset3, box.y1 + height + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + offset3, box.y1 + height + previousHeight));
      previousOffset = offset3;
      previousHeight += height + options2.segmentSpacing;
      lastUpperSide = limitValue2(width - 2 * offset3, 0, width);
    }
  };
  FunnelChart2.prototype.constantSlopeReflow = function constantSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options2 = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var decreasingWidth = options2.neckRatio <= 1;
    var neckRatio = decreasingWidth ? options2.neckRatio * width : width;
    var previousOffset = decreasingWidth ? 0 : (width - width / options2.neckRatio) / 2;
    var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;
    var finalNarrow = (topMostWidth - neckRatio) / 2;
    var previousHeight = 0;
    for (var idx = 0; idx < count; idx++) {
      var points3 = segments[idx].points = [];
      var percentage = segments[idx].percentage;
      var offset3 = options2.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;
      var height = options2.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      points3.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + width - previousOffset - offset3, box.y1 + height + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + previousOffset + offset3, box.y1 + height + previousHeight));
      previousOffset += offset3;
      previousHeight += height + options2.segmentSpacing;
    }
  };
  FunnelChart2.prototype.reflow = function reflow(chartBox) {
    var points3 = this.points;
    var count = points3.length;
    if (!count) {
      return;
    }
    var options2 = this.options;
    var box = chartBox.clone().unpad(this.labelPadding());
    var totalHeight = box.height() - options2.segmentSpacing * (count - 1);
    var width = box.width();
    if (options2.dynamicSlope) {
      this.dynamicSlopeReflow(box, width, totalHeight);
    } else {
      this.constantSlopeReflow(box, width, totalHeight);
    }
    for (var idx = 0; idx < count; idx++) {
      points3[idx].reflow(chartBox);
    }
  };
  return FunnelChart2;
}(chart_element_default);
setDefaultOptions(FunnelChart, {
  neckRatio: 0.3,
  width: 300,
  dynamicSlope: false,
  dynamicHeight: true,
  segmentSpacing: 0,
  labels: {
    visible: false,
    align: CENTER,
    position: CENTER,
    zIndex: 1
  }
});
deepExtend(FunnelChart.prototype, pie_chart_mixin_default);
var funnel_chart_default = FunnelChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/funnel-plotarea.js
var FunnelPlotArea = function(PlotAreaBase2) {
  function FunnelPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    FunnelPlotArea2.__proto__ = PlotAreaBase2;
  FunnelPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  FunnelPlotArea2.prototype.constructor = FunnelPlotArea2;
  FunnelPlotArea2.prototype.render = function render() {
    this.createFunnelChart(this.series);
  };
  FunnelPlotArea2.prototype.createFunnelChart = function createFunnelChart(series) {
    var firstSeries = series[0];
    var funnelChart = new funnel_chart_default(this, {
      series,
      legend: this.options.legend,
      neckRatio: firstSeries.neckRatio,
      dynamicHeight: firstSeries.dynamicHeight,
      dynamicSlope: firstSeries.dynamicSlope,
      segmentSpacing: firstSeries.segmentSpacing,
      highlight: firstSeries.highlight
    });
    this.appendChart(funnelChart);
  };
  FunnelPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append2(this.options.legend.items, chart.legendItems);
  };
  return FunnelPlotArea2;
}(plotarea_base_default);
var funnel_plotarea_default = FunnelPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/color-scale.js
var colorScale = function(color, minLightnessOffset) {
  if (minLightnessOffset === void 0)
    minLightnessOffset = 0.05;
  var baseColor = parseColor(color);
  var offset3 = 1 - minLightnessOffset;
  return function(value) {
    var hsl = baseColor.toHSL();
    var range = 100 - hsl.l;
    var point2 = offset3 - value;
    hsl.l += Math.min(point2 * range, range);
    return hsl.toCss();
  };
};
var color_scale_default = colorScale;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-point.js
var HeatmapPoint = function(ChartElement2) {
  function HeatmapPoint2(value, options2) {
    ChartElement2.call(this);
    this.options = options2;
    this.color = options2.color || WHITE;
    this.value = value;
  }
  if (ChartElement2)
    HeatmapPoint2.__proto__ = ChartElement2;
  HeatmapPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapPoint2.prototype.constructor = HeatmapPoint2;
  HeatmapPoint2.prototype.render = function render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createMarker();
    this.createLabel();
    this.createNote();
  };
  HeatmapPoint2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      var pointData = this.pointData();
      var labelTemplate = getTemplate(labels);
      var labelText;
      var labelColor = labels.color;
      if (labelTemplate) {
        labelText = labelTemplate(pointData);
      } else {
        labelText = this.formatValue(labels.format);
      }
      if (!labelColor) {
        labelColor = auto_text_color_default(this.color);
      }
      this.label = new text_box_default(
        labelText,
        deepExtend(
          {
            align: CENTER,
            vAlign: CENTER,
            margin: {
              left: 5,
              right: 5
            },
            zIndex: valueOrDefault2(labels.zIndex, this.series.zIndex)
          },
          labels,
          {
            color: labelColor
          }
        ),
        pointData
      );
      this.append(this.label);
    }
  };
  HeatmapPoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  HeatmapPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.reflow(this.markerBox());
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    this.marker.reflow(this.markerBox());
  };
  HeatmapPoint2.prototype.markerBox = function markerBox() {
    var options2 = this.options;
    var markers = options2.markers;
    var border = markers.border;
    var rect = this.box.toRect();
    var type = valueOrDefault2(markers.type, "rect");
    var isRoundRect = type === ROUNDED_RECT;
    var borderWidth = valueOrDefault2(border.width, isRoundRect ? 1 : 0);
    var halfBorderWidth = Math.round(borderWidth / 2);
    if (markers.size) {
      var center = rect.center();
      rect.size.width = rect.size.height = markers.size;
      rect.origin.x = Math.round(center.x - rect.size.width / 2);
      rect.origin.y = Math.round(center.y - rect.size.height / 2);
    }
    rect.size.width -= borderWidth;
    rect.size.height -= borderWidth;
    rect.origin.y += halfBorderWidth + 0.5;
    rect.origin.x += halfBorderWidth + 0.5;
    return rectToBox(rect);
  };
  HeatmapPoint2.prototype.markerBorder = function markerBorder() {
    var options2 = this.options;
    var markers = options2.markers;
    var border = markers.border;
    var opacity = valueOrDefault2(border.opacity, options2.opacity);
    return {
      color: border.color || this.color,
      width: border.width,
      opacity,
      dashType: border.dashType
    };
  };
  HeatmapPoint2.prototype.createMarker = function createMarker() {
    var options2 = this.options;
    var markerOptions = options2.markers;
    var marker = new shape_element_default({
      type: valueOrDefault2(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options2.opacity,
      zIndex: valueOrDefault2(options2.zIndex, this.series.zIndex),
      animation: options2.animation,
      visual: options2.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    this.marker = marker;
    this.append(marker);
  };
  HeatmapPoint2.prototype.createHighlight = function createHighlight(style) {
    var options2 = this.options;
    var markerOptions = this.options.highlight.markers || this.options.markers;
    var highlight = new shape_element_default({
      type: valueOrDefault2(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: markerOptions.color || this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options2.opacity,
      zIndex: valueOrDefault2(options2.zIndex, this.series.zIndex)
    });
    highlight.reflow(this.markerBox());
    var visual = highlight.getElement();
    visual.options.fill = style.fill;
    visual.options.stroke = style.stroke;
    return visual;
  };
  HeatmapPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  HeatmapPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  HeatmapPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var left = this.box.center().x;
    var top = this.box.y1 - TOOLTIP_OFFSET;
    return {
      point: new point_default2(left, top),
      align: {
        horizontal: CENTER,
        vertical: BOTTOM
      }
    };
  };
  HeatmapPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  HeatmapPoint2.prototype.unclipElements = function unclipElements() {
  };
  HeatmapPoint2.prototype.pointData = function pointData() {
    return {
      x: this.value.x,
      y: this.value.y,
      value: this.value.value,
      dataItem: this.dataItem,
      series: this.series
    };
  };
  return HeatmapPoint2;
}(chart_element_default);
deepExtend(HeatmapPoint.prototype, point_events_mixin_default);
deepExtend(HeatmapPoint.prototype, note_mixin_default);
HeatmapPoint.prototype.defaults = {
  markers: {
    type: "rect",
    borderRadius: 4,
    border: {
      color: "transparent"
    }
  },
  padding: { top: 1 },
  labels: {
    visible: false,
    padding: 3
  },
  opacity: 1,
  notes: {
    label: {}
  }
};
var heatmap_point_default = HeatmapPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-chart.js
var HeatmapChart = function(ChartElement2) {
  function HeatmapChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2)
    HeatmapChart2.__proto__ = ChartElement2;
  HeatmapChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapChart2.prototype.constructor = HeatmapChart2;
  HeatmapChart2.prototype._initFields = function _initFields() {
    this.points = [];
    this.seriesOptions = [];
    this.valueRange = { min: MAX_VALUE, max: MIN_VALUE };
    this._evalSeries = [];
  };
  HeatmapChart2.prototype.render = function render() {
    this.setRange();
    this.traverseDataPoints(this.addValue.bind(this));
  };
  HeatmapChart2.prototype.setRange = function setRange() {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1._bindPoint(currentSeries, seriesIx, pointIx);
        var valueFields = ref$1.valueFields;
        if (defined2(valueFields.value) && valueFields.value !== null) {
          this$1.valueRange.min = Math.min(this$1.valueRange.min, valueFields.value);
          this$1.valueRange.max = Math.max(this$1.valueRange.max, valueFields.value);
        }
      }
    }
  };
  HeatmapChart2.prototype.addValue = function addValue(value, fields) {
    var point2;
    if (value && defined2(value.value) && value.value !== null) {
      point2 = this.createPoint(value, fields);
      if (point2) {
        Object.assign(point2, fields);
      }
    }
    this.points.push(point2);
  };
  HeatmapChart2.prototype.evalPointOptions = function evalPointOptions(options2, value, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "drilldownSeriesFactory"
      ]
    };
    var doEval = this._evalSeries[seriesIx];
    if (!defined2(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, options2);
      evalOptions(pointOptions, {
        value,
        series,
        dataItem: fields.dataItem,
        min: this.valueRange.min,
        max: this.valueRange.max
      }, state);
    }
    return pointOptions;
  };
  HeatmapChart2.prototype.pointType = function pointType() {
    return heatmap_point_default;
  };
  HeatmapChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options2;
  };
  HeatmapChart2.prototype.createPoint = function createPoint(value, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    } else if (this.valueRange.max !== 0) {
      var scale = color_scale_default(color);
      color = scale(value.value / this.valueRange.max);
    }
    var point2 = new heatmap_point_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  HeatmapChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  };
  HeatmapChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value, fields) {
      var point2 = chartPoints[pointIx++];
      var ref2 = this$1.seriesAxes(fields.series);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var indexX = xAxis.categoryIndex(value.x);
      var indexY = yAxis.categoryIndex(value.y);
      var slotX = xAxis.getSlot(indexX, indexX, limit);
      var slotY = yAxis.getSlot(indexY, indexY, limit);
      if (point2) {
        if (slotX && slotY) {
          var pointSlot = this$1.pointSlot(slotX, slotY);
          point2.reflow(pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  HeatmapChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  HeatmapChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var ref$1 = this$1.seriesAxes(currentSeries);
      var xAxis = ref$1.xAxis;
      var yAxis = ref$1.yAxis;
      var xRange = xAxis.currentRangeIndices();
      var yRange = yAxis.currentRangeIndices();
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$2 = this$1._bindPoint(currentSeries, seriesIx, pointIx);
        var value = ref$2.valueFields;
        var fields = ref$2.fields;
        var xIndex = xAxis.totalIndex(value.x);
        var yIndex = yAxis.totalIndex(value.y);
        var xIn = xRange.min <= xIndex && xIndex <= xRange.max;
        var yIn = yRange.min <= yIndex && yIndex <= yRange.max;
        if (xIn && yIn) {
          callback(value, deepExtend({
            pointIx,
            series: currentSeries,
            seriesIx,
            dataItem: currentSeries.data[pointIx],
            owner: this$1
          }, fields));
        }
      }
    }
  };
  HeatmapChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(format2, value.x, value.y, value.value);
  };
  HeatmapChart2.prototype.animationPoints = function animationPoints() {
    var points3 = this.points;
    var result = [];
    for (var idx = 0; idx < points3.length; idx++) {
      result.push((points3[idx] || {}).marker);
    }
    return result;
  };
  return HeatmapChart2;
}(chart_element_default);
setDefaultOptions(HeatmapChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}: {2}"
  },
  labels: {
    format: "{2}"
  },
  clip: true
});
deepExtend(HeatmapChart.prototype, {
  _bindPoint: categorical_chart_default.prototype._bindPoint
});
var heatmap_chart_default = HeatmapChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/heatmap-plotarea.js
var HeatmapPlotArea = function(PlotAreaBase2) {
  function HeatmapPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    HeatmapPlotArea2.__proto__ = PlotAreaBase2;
  HeatmapPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  HeatmapPlotArea2.prototype.constructor = HeatmapPlotArea2;
  HeatmapPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
  };
  HeatmapPlotArea2.prototype.render = function render(panes) {
    if (panes === void 0)
      panes = this.panes;
    this.bindCategories();
    this.createAxes(panes);
    this.createCharts(panes);
    this.createAxisLabels();
  };
  HeatmapPlotArea2.prototype.bindCategories = function bindCategories() {
    var this$1 = this;
    var series = this.srcSeries || this.series;
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var data = currentSeries.data || [];
      var ref2 = this$1.seriesAxes(currentSeries);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var xCategories = createHashSet(xAxis.categories || []);
      var yCategories = createHashSet(yAxis.categories || []);
      for (var pointIndex = 0; pointIndex < data.length; pointIndex++) {
        var ref$1 = series_binder_default.current.bindPoint(currentSeries, pointIndex).valueFields;
        var x = ref$1.x;
        var y = ref$1.y;
        if (!xCategories.has(x)) {
          xCategories.add(x);
        }
        if (!yCategories.has(y)) {
          yCategories.add(y);
        }
      }
      xAxis.categories = xCategories.values();
      yAxis.categories = yCategories.values();
    }
  };
  HeatmapPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var filteredSeries = this$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1.createHeatmapChart(
        filterSeriesByType(filteredSeries, [HEATMAP]),
        pane
      );
    }
  };
  HeatmapPlotArea2.prototype.createHeatmapChart = function createHeatmapChart(series, pane) {
    var chart = new heatmap_chart_default(this, {
      series
    });
    this.appendChart(chart, pane);
  };
  HeatmapPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxis = grep(xAxisOptions, function(a) {
      return a.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxis = grep(yAxisOptions, function(a) {
      return a.name === yAxisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  HeatmapPlotArea2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxis;
    var yAxis;
    var options2 = this.options;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxisName = series.xAxis;
    if (xAxisName) {
      xAxis = xAxisOptions.find(function(axis) {
        return axis.name === xAxisName;
      });
    } else {
      xAxis = xAxisOptions[0];
    }
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxisName = series.yAxis;
    if (yAxisName) {
      yAxis = yAxisOptions.find(function(axis) {
        return axis.name === yAxisName;
      });
    } else {
      yAxis = yAxisOptions[0];
    }
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  };
  HeatmapPlotArea2.prototype.createAxisLabels = function createAxisLabels() {
    var axes = this.axes;
    for (var i = 0; i < axes.length; i++) {
      axes[i].createLabels();
    }
  };
  HeatmapPlotArea2.prototype.createXYAxis = function createXYAxis(options2, vertical, axisIndex) {
    var axisName = options2.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var axisOptions2 = Object.assign({
      axisCrossingValue: 0
    }, options2, {
      vertical,
      reverse: vertical || this.chartService.rtl ? !options2.reverse : options2.reverse,
      justified: false
    });
    var firstCategory = axisOptions2.categories ? axisOptions2.categories[0] : null;
    var typeSamples = [axisOptions2.min, axisOptions2.max, firstCategory];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    var inferredDate;
    for (var i = 0; i < typeSamples.length; i++) {
      if (typeSamples[i] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_category_axis_default;
    } else {
      axisType = category_axis_default;
    }
    var axis = new axisType(axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    axis.mapCategories();
    return axis;
  };
  HeatmapPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1 = this;
    var options2 = this.options;
    var xAxesOptions = [].concat(options2.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options2.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  HeatmapPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      delete this.namedYAxes[axisName];
    } else {
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  HeatmapPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i = 0; i < length; i++) {
      var axis = allAxes[i];
      var values5 = axis.options.vertical ? yValues : xValues;
      appendIfNotNull(values5, axis.getCategory(point2));
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        originalEvent: e,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  HeatmapPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options2) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions3(this.options, index, vertical, options2);
    updateAxisOptions3(this.originalOptions, index, vertical, options2);
  };
  HeatmapPlotArea2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return Object.assign({}, axis.options.crosshair, { zIndex: 0 });
  };
  return HeatmapPlotArea2;
}(plotarea_base_default);
function updateAxisOptions3(targetOptions, axisIndex, vertical, options2) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options2);
}
setDefaultOptions(HeatmapPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(HeatmapPlotArea.prototype, plotarea_events_mixin_default);
var heatmap_plotarea_default = HeatmapPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/register-charts.js
var COLOR = "color";
var FIRST = "first";
var FROM = "from";
var MAX = "max";
var MIN = "min";
var NOTE_TEXT = "noteText";
var SUMMARY_FIELD = "summary";
var TO = "to";
plotarea_factory_default.current.register(categorical_plotarea_default, [
  BAR,
  COLUMN,
  LINE,
  VERTICAL_LINE,
  AREA,
  VERTICAL_AREA,
  CANDLESTICK,
  OHLC,
  BULLET,
  VERTICAL_BULLET,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL,
  RANGE_AREA,
  VERTICAL_RANGE_AREA
]);
plotarea_factory_default.current.register(xy_plotarea_default, [
  SCATTER,
  SCATTER_LINE,
  BUBBLE
]);
plotarea_factory_default.current.register(pie_plotarea_default, [PIE]);
plotarea_factory_default.current.register(donut_plotarea_default, [DONUT]);
plotarea_factory_default.current.register(funnel_plotarea_default, [FUNNEL]);
plotarea_factory_default.current.register(polar_plotarea_default, [POLAR_AREA, POLAR_LINE, POLAR_SCATTER]);
plotarea_factory_default.current.register(radar_plotarea_default, [RADAR_AREA, RADAR_COLUMN, RADAR_LINE]);
plotarea_factory_default.current.register(heatmap_plotarea_default, [HEATMAP]);
series_binder_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD, DRILLDOWN_FIELD]
);
series_binder_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  [FROM, TO],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD]
);
series_binder_default.current.register(
  [WATERFALL, HORIZONTAL_WATERFALL],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD, DRILLDOWN_FIELD]
);
series_binder_default.current.register([POLAR_AREA, POLAR_LINE, POLAR_SCATTER], [X, Y], [COLOR, DRILLDOWN_FIELD]);
series_binder_default.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], [VALUE], [COLOR, DRILLDOWN_FIELD]);
series_binder_default.current.register(
  [FUNNEL],
  [VALUE],
  [CATEGORY, COLOR, "visibleInLegend", "visible", DRILLDOWN_FIELD]
);
default_aggregates_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL],
  { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }
);
default_aggregates_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  { from: MIN, to: MAX, color: FIRST, noteText: FIRST }
);
default_aggregates_default.current.register(
  [RADAR_AREA, RADAR_COLUMN, RADAR_LINE],
  { value: MAX, color: FIRST }
);
series_binder_default.current.register(
  [SCATTER, SCATTER_LINE, BUBBLE],
  [X, Y],
  [COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD]
);
series_binder_default.current.register(
  [BUBBLE],
  [X, Y, "size"],
  [COLOR, CATEGORY, NOTE_TEXT]
);
series_binder_default.current.register(
  [HEATMAP],
  [X, Y, VALUE],
  [COLOR, NOTE_TEXT]
);
series_binder_default.current.register(
  [CANDLESTICK, OHLC],
  ["open", "high", "low", "close"],
  [CATEGORY, COLOR, "downColor", NOTE_TEXT]
);
default_aggregates_default.current.register(
  [CANDLESTICK, OHLC],
  {
    open: MAX,
    high: MAX,
    low: MIN,
    close: MAX,
    color: FIRST,
    downColor: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  ["lower", "q1", "median", "q3", "upper", "mean", "outliers"],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD]
);
default_aggregates_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  {
    lower: MAX,
    q1: MAX,
    median: MAX,
    q3: MAX,
    upper: MAX,
    mean: MAX,
    outliers: FIRST,
    color: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BULLET, VERTICAL_BULLET],
  ["current", "target"],
  [CATEGORY, COLOR, "visibleInLegend", NOTE_TEXT, DRILLDOWN_FIELD]
);
default_aggregates_default.current.register(
  [BULLET, VERTICAL_BULLET],
  { current: MAX, target: MAX, color: FIRST, noteText: FIRST }
);
series_binder_default.current.register(
  [PIE, DONUT],
  [VALUE],
  [CATEGORY, COLOR, "explode", "visibleInLegend", "visible", DRILLDOWN_FIELD]
);

// node_modules/@progress/kendo-charts/dist/es/chart/chart.js
var AXIS_NAMES = [CATEGORY, VALUE, X, Y];
var MOUSEMOVE = "mousemove";
var CONTEXTMENU = "contextmenu";
var MOUSELEAVE = "mouseleave";
var MOUSEMOVE_DELAY = 20;
var Chart = function(Class3) {
  function Chart3(element2, userOptions, themeOptions, context2) {
    var this$1 = this;
    if (context2 === void 0)
      context2 = {};
    Class3.call(this);
    this.observers = [];
    this.addObserver(context2.observer);
    this.chartService = new chart_service_default(this, context2);
    this.chartService.theme = themeOptions;
    this._initElement(element2);
    var options2 = deepExtend({}, this.options, userOptions);
    this._originalOptions = deepExtend({}, options2);
    this._theme = themeOptions;
    this._initTheme(options2, themeOptions);
    this._initHandlers();
    this._initSurface();
    this.bindCategories();
    font_loader_default.preloadFonts(userOptions, function() {
      this$1.fontLoaded = true;
      if (!this$1._destroyed) {
        this$1.trigger("init");
        this$1._redraw();
        this$1._attachEvents();
      }
    });
  }
  if (Class3)
    Chart3.__proto__ = Class3;
  Chart3.prototype = Object.create(Class3 && Class3.prototype);
  Chart3.prototype.constructor = Chart3;
  Chart3.prototype._initElement = function _initElement(element2) {
    this._setElementClass(element2);
    element2.style.position = "relative";
    while (element2.firstChild) {
      element2.removeChild(element2.firstChild);
    }
    this.element = element2;
  };
  Chart3.prototype._setElementClass = function _setElementClass(element2) {
    addClass(element2, "k-chart");
  };
  Chart3.prototype._initTheme = function _initTheme(options2, themeOptions) {
    var seriesCopies = [];
    var series = options2.series || [];
    for (var i = 0; i < series.length; i++) {
      seriesCopies.push(Object.assign({}, series[i]));
    }
    options2.series = seriesCopies;
    resolveAxisAliases(options2);
    this.applyDefaults(options2, themeOptions);
    if (options2.seriesColors === null) {
      delete options2.seriesColors;
    }
    this.options = deepExtend({}, themeOptions, options2);
    this.applySeriesColors();
  };
  Chart3.prototype.getSize = function getSize() {
    var chartArea = this.options.chartArea || {};
    var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);
    var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);
    return {
      width,
      height
    };
  };
  Chart3.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this._size;
    var hasSize = size.width > 0 || size.height > 0;
    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this._size = size;
      this._resize(size, force);
      this.trigger("resize", size);
    } else if (hasSize && this._selections && find(this._selections, function(s) {
      return !s.visible;
    })) {
      this._destroySelections();
      this._setupSelection();
    }
  };
  Chart3.prototype._resize = function _resize() {
    this._noTransitionsRedraw();
  };
  Chart3.prototype.redraw = function redraw(paneName) {
    this.applyDefaults(this.options);
    this.applySeriesColors();
    if (paneName) {
      var plotArea = this._model._plotArea;
      var pane = plotArea.findPane(paneName);
      plotArea.redraw(pane);
    } else {
      this._redraw();
    }
  };
  Chart3.prototype.getAxis = function getAxis(name2) {
    return findAxisByName(name2, this._plotArea.axes);
  };
  Chart3.prototype.findAxisByName = function findAxisByName2(name2) {
    return this.getAxis(name2);
  };
  Chart3.prototype.findPaneByName = function findPaneByName(name2) {
    var panes = this._plotArea.panes;
    for (var idx = 0; idx < panes.length; idx++) {
      if (panes[idx].options.name === name2) {
        return new chart_pane_default(panes[idx]);
      }
    }
  };
  Chart3.prototype.findPaneByIndex = function findPaneByIndex(idx) {
    var panes = this._plotArea.panes;
    if (panes[idx]) {
      return new chart_pane_default(panes[idx]);
    }
  };
  Chart3.prototype.plotArea = function plotArea() {
    return new chart_plotarea_default(this._plotArea);
  };
  Chart3.prototype.toggleHighlight = function toggleHighlight(show2, filter) {
    var plotArea = this._plotArea;
    var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];
    var points3;
    if (isFunction3(filter)) {
      points3 = plotArea.filterPoints(filter);
    } else {
      var seriesName, categoryName;
      if (isObject(filter)) {
        seriesName = filter.series;
        categoryName = filter.category;
      } else {
        seriesName = categoryName = filter;
      }
      if (firstSeries.type === DONUT) {
        points3 = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);
      } else if (firstSeries.type === PIE || firstSeries.type === FUNNEL) {
        points3 = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);
      } else {
        points3 = plotArea.pointsBySeriesName(seriesName);
      }
    }
    if (points3) {
      this.togglePointsHighlight(show2, points3);
    }
  };
  Chart3.prototype.togglePointsHighlight = function togglePointsHighlight(show2, points3) {
    var highlight = this._highlight;
    for (var idx = 0; idx < points3.length; idx++) {
      highlight.togglePointHighlight(points3[idx], show2);
    }
  };
  Chart3.prototype.showTooltip = function showTooltip(filter) {
    var shared = this._sharedTooltip();
    var ref2 = this;
    var tooltip = ref2._tooltip;
    var plotArea = ref2._plotArea;
    var point2, categoryIndex;
    if (isFunction3(filter)) {
      point2 = plotArea.findPoint(filter);
      if (point2 && shared) {
        categoryIndex = point2.categoryIx;
      }
    } else if (shared && defined2(filter)) {
      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);
    }
    if (shared) {
      if (categoryIndex >= 0) {
        var points3 = this._plotArea.pointsByCategoryIndex(categoryIndex);
        tooltip.showAt(points3);
      }
    } else if (point2) {
      tooltip.show(point2);
    }
  };
  Chart3.prototype.hideTooltip = function hideTooltip() {
    this._tooltip.hide();
  };
  Chart3.prototype._initSurface = function _initSurface() {
    var surface = this.surface;
    var wrap2 = this._surfaceWrap();
    var chartArea = this.options.chartArea || {};
    if (chartArea.width) {
      elementSize2(wrap2, { width: chartArea.width });
    }
    if (chartArea.height) {
      elementSize2(wrap2, { height: chartArea.height });
    }
    if (!surface || surface.options.type !== this.options.renderAs) {
      this._destroySurface();
      this.surface = drawing_exports.Surface.create(wrap2, {
        type: this.options.renderAs
      });
      this.surface.bind("mouseenter", this._surfaceMouseenterHandler);
      this.surface.bind("mouseleave", this._surfaceMouseleaveHandler);
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  };
  Chart3.prototype._surfaceWrap = function _surfaceWrap() {
    return this.element;
  };
  Chart3.prototype._redraw = function _redraw() {
    var model = this._getModel();
    this._size = {
      width: model.options.width,
      height: model.options.height
    };
    this._destroyView();
    this._model = model;
    this._plotArea = model._plotArea;
    model.renderVisual();
    if (this.options.transitions !== false) {
      model.traverse(function(element2) {
        if (element2.animation) {
          element2.animation.setup();
        }
      });
    }
    this._initSurface();
    this.surface.draw(model.visual);
    if (this.options.transitions !== false) {
      model.traverse(function(element2) {
        if (element2.animation) {
          element2.animation.play();
        }
      });
    }
    this._tooltip = this._createTooltip();
    this._highlight = new highlight_default();
    this._setupSelection();
    this._createPannable();
    this._createZoomSelection();
    this._createMousewheelZoom();
    this.trigger(RENDER);
    triggerPaneRender(this._plotArea.panes);
    if (!this._navState) {
      this._cancelDomEvents();
    }
  };
  Chart3.prototype.exportVisual = function exportVisual(exportOptions) {
    var visual;
    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {
      var currentOptions = this.options;
      var options2 = deepExtend({}, exportOptions.options, {
        chartArea: {
          width: exportOptions.width,
          height: exportOptions.height
        }
      });
      clearMissingValues(this._originalOptions, options2);
      this.options = deepExtend({}, this._originalOptions, options2);
      this._initTheme(this.options, this._theme);
      this.bindCategories();
      var model = this._getModel();
      model.renderVisual();
      triggerPaneRender(model._plotArea.panes);
      visual = model.visual;
      this.options = currentOptions;
    } else {
      visual = this.surface.exportVisual();
    }
    return visual;
  };
  Chart3.prototype._sharedTooltip = function _sharedTooltip() {
    return this._plotArea instanceof categorical_plotarea_default && this.options.tooltip && this.options.tooltip.shared;
  };
  Chart3.prototype._createPannable = function _createPannable() {
    var options2 = this.options;
    if (options2.pannable !== false) {
      this._pannable = new pannable_default(this._plotArea, options2.pannable);
    }
  };
  Chart3.prototype._createZoomSelection = function _createZoomSelection() {
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    if (zoomable !== false && selection !== false) {
      this._zoomSelection = new zoom_selection_default(this, selection);
    }
  };
  Chart3.prototype._createMousewheelZoom = function _createMousewheelZoom() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel;
    if (zoomable !== false && mousewheel !== false) {
      this._mousewheelZoom = new mousewheel_zoom_default(this, mousewheel);
    }
  };
  Chart3.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    var pannable = this.options.pannable;
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    var mousewheel = (zoomable || {}).mousewheel;
    var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);
    var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);
    var element2 = this.element;
    if (this._dragZoomEnabled && allowDrag && allowZoom) {
      element2.style.touchAction = this._touchAction || "";
      this._dragZoomEnabled = false;
    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {
      element2.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
    this._toggleDomEvents(!allowDrag, !allowZoom);
  };
  Chart3.prototype._toggleDomEvents = function _toggleDomEvents(drag, zoom) {
    var domEvents = this.domEvents;
    if (!domEvents) {
      return;
    }
    if (domEvents.toggleDrag) {
      domEvents.toggleDrag(drag);
    }
    if (domEvents.toggleZoom) {
      domEvents.toggleZoom(zoom);
    }
  };
  Chart3.prototype._createTooltip = function _createTooltip() {
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var tooltip;
    if (this._sharedTooltip()) {
      tooltip = this._createSharedTooltip(tooltipOptions);
    } else {
      tooltip = new tooltip_default(this.chartService, tooltipOptions);
    }
    return tooltip;
  };
  Chart3.prototype._createSharedTooltip = function _createSharedTooltip(options2) {
    return new shared_tooltip_default(this._plotArea, options2);
  };
  Chart3.prototype.applyDefaults = function applyDefaults2(options2, themeOptions) {
    applyAxisDefaults(options2, themeOptions);
    applySeriesDefaults(options2, themeOptions);
  };
  Chart3.prototype.applySeriesColors = function applySeriesColors() {
    var options2 = this.options;
    var series = options2.series;
    var colors = options2.seriesColors || [];
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var seriesColor = colors[i % colors.length];
      var defaults = currentSeries._defaults;
      currentSeries.color = currentSeries.color || seriesColor;
      if (defaults) {
        defaults.color = defaults.color || seriesColor;
      }
    }
  };
  Chart3.prototype._getModel = function _getModel() {
    var options2 = this.options;
    var plotArea = this._createPlotArea();
    var model = new root_element_default(this._modelOptions());
    model.chart = this;
    model._plotArea = plotArea;
    var title2 = title_default.buildTitle(options2.title);
    var subtitle2 = title_default.buildTitle(options2.subtitle, {
      align: options2.title.align,
      position: options2.title.position
    });
    model.append.apply(model, title_default.orderTitles([title2, subtitle2]));
    if (options2.legend && options2.legend.visible) {
      model.append(new legend_default(plotArea.options.legend, this.chartService));
    }
    model.append(plotArea);
    model.reflow();
    return model;
  };
  Chart3.prototype._modelOptions = function _modelOptions() {
    var options2 = this.options;
    var size = this.getSize();
    return deepExtend({
      transitions: options2.transitions,
      width: size.width || DEFAULT_WIDTH,
      height: size.height || DEFAULT_HEIGHT
    }, options2.chartArea);
  };
  Chart3.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var options2 = this.options;
    var plotArea = plotarea_factory_default.current.create(skipSeries ? [] : options2.series, options2, this.chartService);
    return plotArea;
  };
  Chart3.prototype._setupSelection = function _setupSelection() {
    var this$1 = this;
    var ref2 = this;
    var axes = ref2._plotArea.axes;
    var selections = this._selections = [];
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var options2 = axis.options;
      if (axis instanceof category_axis_default && options2.select && !options2.vertical) {
        var range = axis.range();
        var selection = new selection_default(
          this$1,
          axis,
          deepExtend({ min: range.min, max: range.max }, options2.select)
        );
        selections.push(selection);
      }
    }
  };
  Chart3.prototype._selectStart = function _selectStart(e) {
    return this.trigger(SELECT_START, e);
  };
  Chart3.prototype._select = function _select(e) {
    return this.trigger(SELECT, e);
  };
  Chart3.prototype._selectEnd = function _selectEnd(e) {
    return this.trigger(SELECT_END, e);
  };
  Chart3.prototype._initHandlers = function _initHandlers() {
    this._clickHandler = this._click.bind(this);
    this._mousewheelHandler = this._mousewheel.bind(this);
    this._mouseleaveHandler = this._mouseleave.bind(this);
    this._surfaceMouseenterHandler = this._mouseover.bind(this);
    this._surfaceMouseleaveHandler = this._mouseout.bind(this);
    this._mousemove = throttle(
      this._mousemove.bind(this),
      MOUSEMOVE_DELAY
    );
  };
  Chart3.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Chart3.prototype.removeObserver = function removeObserver(observer) {
    var index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  };
  Chart3.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers = this.observers;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Chart3.prototype.trigger = function trigger2(name2, args) {
    if (args === void 0)
      args = {};
    args.sender = this;
    if (name2 === SHOW_TOOLTIP) {
      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);
    } else if (name2 === SERIES_OVER) {
      this._updateDrilldownPoint(args.point);
    } else if (name2 === SERIES_LEAVE) {
      this._resetDrilldownPoint();
    } else if (name2 === SERIES_CLICK) {
      this._startDrilldown(args.point);
    }
    var observers = this.observers;
    var isDefaultPrevented3 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented3 = true;
      }
    }
    return isDefaultPrevented3;
  };
  Chart3.prototype._attachEvents = function _attachEvents() {
    var obj, obj$1;
    var element2 = this.element;
    this._touchAction = element2.style.touchAction;
    bindEvents2(element2, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSELEAVE] = this._mouseleaveHandler, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents2(element2, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
    this.domEvents = dom_events_builder_default.create(this.element, {
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
    this._toggleDragZoomEvents();
  };
  Chart3.prototype._mouseleave = function _mouseleave2(e) {
    if (this._hoveredPoint) {
      this._hoveredPoint.out(this, e);
      this._hoveredPoint = null;
    }
    if (this._plotAreaHovered) {
      this._plotAreaHovered = false;
      this.trigger(PLOT_AREA_LEAVE);
    }
  };
  Chart3.prototype._cancelDomEvents = function _cancelDomEvents() {
    if (this.domEvents && this.domEvents.cancel) {
      this.domEvents.cancel();
    }
  };
  Chart3.prototype._gesturestart = function _gesturestart(e) {
    if (this._mousewheelZoom && !this._stopChartHandlers(e)) {
      this._gestureDistance = e.distance;
      this._unsetActivePoint();
      this.surface.suspendTracking();
    }
  };
  Chart3.prototype._gestureend = function _gestureend(e) {
    if (this._zooming && !this._stopChartHandlers(e)) {
      if (this.surface) {
        this.surface.resumeTracking();
      }
      this._zooming = false;
      this.trigger(ZOOM_END, {});
    }
  };
  Chart3.prototype._gesturechange = function _gesturechange(e) {
    var mousewheelZoom = this._mousewheelZoom;
    if (mousewheelZoom && !this._stopChartHandlers(e)) {
      e.preventDefault();
      var previousGestureDistance = this._gestureDistance;
      var scaleDelta = -e.distance / previousGestureDistance + 1;
      if (Math.abs(scaleDelta) >= 0.1) {
        scaleDelta = Math.round(scaleDelta * 10);
        this._gestureDistance = e.distance;
        var args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };
        if (this._zooming || !this.trigger(ZOOM_START, args)) {
          var coords = this._eventCoordinates(e);
          if (!this._zooming) {
            this._zooming = true;
          }
          var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);
          if (ranges && !this.trigger(ZOOM, args)) {
            mousewheelZoom.zoom();
          }
        }
      }
    }
  };
  Chart3.prototype._mouseout = function _mouseout(e) {
    if (e.element) {
      var element2 = this._drawingChartElement(e.element, e);
      if (element2 && element2.leave) {
        element2.leave(this, e.originalEvent);
      }
    }
  };
  Chart3.prototype._start = function _start(e) {
    var coords = this._eventCoordinates(e);
    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {
      this._startNavigation(e, coords, DRAG_START);
    }
    if (this._pannable && this._pannable.start(e)) {
      this.surface.suspendTracking();
      this._unsetActivePoint();
      this._suppressHover = true;
      this.chartService.panning = true;
    }
    if (this._zoomSelection) {
      if (this._zoomSelection.start(e)) {
        this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e });
      }
    }
  };
  Chart3.prototype._move = function _move(e) {
    var ref2 = this;
    var state = ref2._navState;
    var pannable = ref2._pannable;
    if (this._stopChartHandlers(e)) {
      return;
    }
    if (pannable) {
      var ranges = pannable.move(e);
      if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e })) {
        pannable.pan();
      }
    } else if (state) {
      var ranges$1 = {};
      var axes = state.axes;
      for (var i = 0; i < axes.length; i++) {
        var currentAxis = axes[i];
        var axisName = currentAxis.options.name;
        if (axisName) {
          var axis = currentAxis.options.vertical ? e.y : e.x;
          var delta = axis.startLocation - axis.location;
          if (delta !== 0) {
            ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);
          }
        }
      }
      state.axisRanges = ranges$1;
      this.trigger(DRAG, {
        axisRanges: ranges$1,
        originalEvent: e
      });
    }
    if (this._zoomSelection) {
      this._zoomSelection.move(e);
    }
  };
  Chart3.prototype._end = function _end(e) {
    if (this._stopChartHandlers(e)) {
      return;
    }
    var pannable = this._pannable;
    if (pannable && pannable.end(e)) {
      this.surface.resumeTracking();
      this.trigger(DRAG_END, {
        axisRanges: axisRanges(this._plotArea.axes),
        originalEvent: e
      });
      this._suppressHover = false;
      this.chartService.panning = false;
    } else {
      this._endNavigation(e, DRAG_END);
    }
    if (this._zoomSelection) {
      var ranges = this._zoomSelection.end(e);
      if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e })) {
        this._zoomSelection.zoom();
        this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e });
      }
    }
  };
  Chart3.prototype._stopChartHandlers = function _stopChartHandlers(e) {
    var selections = this._selections || [];
    if (!selections.length) {
      return false;
    }
    var coords = this._eventCoordinates(e);
    var pane = this._plotArea.paneByPoint(coords);
    if (pane) {
      for (var idx = 0; idx < selections.length; idx++) {
        if (selections[idx].onPane(pane)) {
          return true;
        }
      }
    }
  };
  Chart3.prototype._mousewheelZoomRate = function _mousewheelZoomRate() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel || {};
    return valueOrDefault2(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);
  };
  Chart3.prototype._mousewheel = function _mousewheel(e) {
    var this$1 = this;
    var delta = mousewheelDelta(e);
    var mousewheelZoom = this._mousewheelZoom;
    var coords = this._eventCoordinates(e);
    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (mousewheelZoom) {
      var args = { delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };
      if (this._zooming || !this.trigger(ZOOM_START, args)) {
        e.preventDefault();
        if (!this._zooming) {
          this._unsetActivePoint();
          this.surface.suspendTracking();
          this._zooming = true;
        }
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);
        if (args.axisRanges && !this.trigger(ZOOM, args)) {
          mousewheelZoom.zoom();
        }
        this._mwTimeout = setTimeout(function() {
          this$1.trigger(ZOOM_END, args);
          this$1._zooming = false;
          if (this$1.surface) {
            this$1.surface.resumeTracking();
          }
        }, MOUSEWHEEL_DELAY);
      }
    } else {
      var state = this._navState;
      if (!state) {
        var prevented = this._startNavigation(e, coords, ZOOM_START);
        if (!prevented) {
          state = this._navState;
        }
      }
      if (state) {
        var totalDelta = state.totalDelta || delta;
        state.totalDelta = totalDelta + delta;
        var axes = this._navState.axes;
        var ranges = {};
        for (var i = 0; i < axes.length; i++) {
          var currentAxis = axes[i];
          var axisName = currentAxis.options.name;
          if (axisName) {
            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this$1._mousewheelZoomRate(), coords);
          }
        }
        this.trigger(ZOOM, {
          delta,
          axisRanges: ranges,
          originalEvent: e
        });
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        this._mwTimeout = setTimeout(function() {
          this$1._endNavigation(e, ZOOM_END);
        }, MOUSEWHEEL_DELAY);
      }
    }
  };
  Chart3.prototype._startNavigation = function _startNavigation(e, coords, chartEvent) {
    var plotArea = this._model._plotArea;
    var pane = plotArea.findPointPane(coords);
    var axes = plotArea.axes.slice(0);
    if (!pane) {
      return;
    }
    var ranges = axisRanges(axes);
    var prevented = this.trigger(chartEvent, {
      axisRanges: ranges,
      originalEvent: e
    });
    if (prevented) {
      this._cancelDomEvents();
    } else {
      this._suppressHover = true;
      this._unsetActivePoint();
      this._navState = {
        axisRanges: ranges,
        pane,
        axes
      };
    }
  };
  Chart3.prototype._endNavigation = function _endNavigation(e, chartEvent) {
    if (this._navState) {
      this.trigger(chartEvent, {
        axisRanges: this._navState.axisRanges,
        originalEvent: e
      });
      this._suppressHover = false;
      this._navState = null;
    }
  };
  Chart3.prototype._getChartElement = function _getChartElement(e, match) {
    var element2 = this.surface.eventTarget(e);
    if (element2) {
      return this._drawingChartElement(element2, e, match);
    }
  };
  Chart3.prototype._drawingChartElement = function _drawingChartElement(element2, e, match) {
    var current4 = element2;
    var chartElement;
    while (current4 && !chartElement) {
      chartElement = current4.chartElement;
      current4 = current4.parent;
    }
    if (chartElement) {
      if (chartElement.aliasFor) {
        chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));
      }
      if (match) {
        chartElement = chartElement.closest(match);
        if (chartElement && chartElement.aliasFor) {
          chartElement = chartElement.aliasFor();
        }
      }
      return chartElement;
    }
  };
  Chart3.prototype._eventCoordinates = function _eventCoordinates(e) {
    var coordinates = eventCoordinates2(e);
    return this._toModelCoordinates(coordinates.x, coordinates.y);
  };
  Chart3.prototype._elementPadding = function _elementPadding() {
    if (!this._padding) {
      var ref2 = elementStyles2(this.element, ["paddingLeft", "paddingTop"]);
      var paddingLeft = ref2.paddingLeft;
      var paddingTop = ref2.paddingTop;
      this._padding = {
        top: paddingTop,
        left: paddingLeft
      };
    }
    return this._padding;
  };
  Chart3.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point2) {
    var padding = this._elementPadding();
    var offset3 = elementOffset2(this.element);
    return {
      left: round3(point2.x + padding.left + offset3.left),
      top: round3(point2.y + padding.top + offset3.top)
    };
  };
  Chart3.prototype._toModelCoordinates = function _toModelCoordinates(clientX, clientY) {
    var element2 = this.element;
    var offset3 = elementOffset2(element2);
    var padding = this._elementPadding();
    var inverseTransform = elementScale2(element2).invert();
    var point2 = new geometry_exports.Point(
      clientX - offset3.left - padding.left,
      clientY - offset3.top - padding.top
    ).transform(inverseTransform);
    return new point_default2(point2.x, point2.y);
  };
  Chart3.prototype._tap = function _tap(e) {
    var this$1 = this;
    var drawingElement = this.surface.eventTarget(e);
    var element2 = this._drawingChartElement(drawingElement, e);
    var sharedTooltip = this._sharedTooltip();
    if (!this._startHover(drawingElement, e) && !sharedTooltip) {
      this._unsetActivePoint();
    }
    if (sharedTooltip) {
      this._trackSharedTooltip(this._eventCoordinates(e), e, true);
    }
    this._propagateClick(element2, e);
    this.handlingTap = true;
    setTimeout(function() {
      this$1.handlingTap = false;
    }, 0);
  };
  Chart3.prototype._click = function _click(e) {
    var element2 = this._getChartElement(e);
    this._propagateClick(element2, e);
  };
  Chart3.prototype._propagateClick = function _propagateClick(element2, e) {
    var this$1 = this;
    var current4 = element2;
    while (current4) {
      if (current4.click) {
        current4.click(this$1, e);
      }
      current4 = current4.parent;
    }
  };
  Chart3.prototype._startHover = function _startHover(element2, e) {
    if (this._suppressHover) {
      return false;
    }
    var point2 = this._drawingChartElement(element2, e, function(element3) {
      return (element3.hover || element3.over) && !(element3 instanceof plotarea_base_default);
    });
    this._showInactiveOpacity(point2, e);
    return point2;
  };
  Chart3.prototype._displayTooltip = function _displayTooltip(point2) {
    var tooltipOptions = deepExtend({}, this.options.tooltip, point2.options.tooltip);
    if (tooltipOptions.visible) {
      this._tooltip.show(point2);
    }
  };
  Chart3.prototype._displayInactiveOpacity = function _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {
    var chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);
    if (!chartInstance) {
      return;
    }
    if (multipleSeries) {
      this._updateSeriesOpacity(activePoint);
      this._applySeriesOpacity(chartInstance.children, null, true);
      this._applySeriesOpacity(chartInstance.children, activePoint.series);
      this._highlight.show(highlightPoints || activePoint);
    } else {
      var inactivePoints;
      if (!chartInstance.supportsPointInactiveOpacity()) {
        this._highlight.show(activePoint);
        return;
      }
      inactivePoints = this._getInactivePoints(activePoint, chartInstance);
      if (inactivePoints && inactivePoints.length) {
        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));
      }
    }
  };
  Chart3.prototype._getInactivePoints = function _getInactivePoints(activePoint, chartInstance) {
    var allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);
    return allPoints.filter(function(point2) {
      return point2 !== activePoint;
    });
  };
  Chart3.prototype._getAllPointsOfType = function _getAllPointsOfType(container, type) {
    var this$1 = this;
    var points3 = [];
    for (var i = 0; i < container.children.length; i++) {
      var element2 = container.children[i];
      if (element2.constructor === type) {
        points3.push(element2);
      } else if (element2.children && element2.children.length) {
        points3 = points3.concat(this$1._getAllPointsOfType(element2, type));
      }
    }
    return points3;
  };
  Chart3.prototype._updateHoveredPoint = function _updateHoveredPoint(point2, e) {
    var hoveredPoint = this._hoveredPoint;
    if (hoveredPoint && hoveredPoint !== point2) {
      hoveredPoint.out(this, e);
      this._hoveredPoint = null;
    }
    if (point2 && hoveredPoint !== point2 && point2.over) {
      this._hoveredPoint = point2;
      point2.over(this, e);
    }
  };
  Chart3.prototype._updateDrilldownPoint = function _updateDrilldownPoint(point2) {
    if (!point2 || !point2.series) {
      return;
    }
    var ref2 = series_binder_default.current.bindPoint(point2.series, null, point2.dataItem);
    var fields = ref2.fields;
    if (fields.drilldown) {
      this._drilldownState = { cursor: this.element.style.cursor };
      this.element.style.cursor = "pointer";
    }
  };
  Chart3.prototype._resetDrilldownPoint = function _resetDrilldownPoint() {
    if (this._drilldownState) {
      this.element.style.cursor = this._drilldownState.cursor;
      this._drilldownState = null;
    }
  };
  Chart3.prototype._startDrilldown = function _startDrilldown(point2) {
    if (!point2 || !point2.series) {
      return;
    }
    var series = point2.series;
    var ref2 = series_binder_default.current.bindPoint(series, null, point2.dataItem);
    var fields = ref2.fields;
    var value = fields.drilldown;
    if (value) {
      var args = { series, point: point2, value, sender: this };
      this.trigger(DRILLDOWN, args);
    }
  };
  Chart3.prototype._updateSeriesOpacity = function _updateSeriesOpacity(point2, resetOpacity) {
    var this$1 = this;
    var plotArea = this._plotArea;
    var length = plotArea.series.length;
    for (var i = 0; i < length; i++) {
      var currSeries = plotArea.series[i];
      var defaultOpacity = this$1._getDefaultOpacityForSeries(currSeries);
      var inactiveOpacity = this$1._getInactiveOpacityForSeries(currSeries);
      if (!resetOpacity && currSeries !== point2.series) {
        currSeries.defaultOpacity = defaultOpacity;
        currSeries.opacity = inactiveOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = inactiveOpacity;
        }
      } else {
        currSeries.opacity = defaultOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = defaultOpacity;
        }
      }
    }
  };
  Chart3.prototype._applySeriesOpacity = function _applySeriesOpacity(elements, activeSeries, reset, series) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var element2 = elements[i];
      var currSeries = element2.series || series;
      var shouldHighlight = currSeries && (currSeries.highlight || {}).visible;
      if (shouldHighlight && element2.visual) {
        var opacity = series ? series.opacity : element2.series.opacity;
        if (currSeries !== activeSeries || reset) {
          element2.visual.opacity(reset ? 1 : opacity);
        }
      }
      if (element2.children && element2.children.length) {
        this$1._applySeriesOpacity(element2.children, activeSeries, reset, element2.series);
      }
    }
  };
  Chart3.prototype._chartInstanceFromPoint = function _chartInstanceFromPoint(point2) {
    var chartInstance = point2.parent;
    while (chartInstance && !chartInstance.plotArea) {
      chartInstance = chartInstance.parent;
    }
    return chartInstance;
  };
  Chart3.prototype._showInactiveOpacity = function _showInactiveOpacity(point2, e) {
    var activePoint = this._activePoint;
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    this._updateHoveredPoint(point2, e);
    if (point2 && activePoint !== point2 && point2.hover) {
      this._activePoint = point2;
      if (!this._sharedTooltip() && !point2.hover(this, e)) {
        this._displayTooltip(point2);
        if (hasInactiveOpacity) {
          this._displayInactiveOpacity(point2, multipleSeries);
        } else {
          this._highlight.show(point2);
        }
      }
    }
    return point2;
  };
  Chart3.prototype._hideInactiveOpacity = function _hideInactiveOpacity(point2) {
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      if (multipleSeries && this._activeChartInstance) {
        this._updateSeriesOpacity(point2, true);
        this._applySeriesOpacity(this._activeChartInstance.children, null, true);
        this._activeChartInstance = null;
      }
      this._highlight && this._highlight.hide();
      this._activePoint = null;
    }
  };
  Chart3.prototype._hasInactiveOpacity = function _hasInactiveOpacity() {
    var hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== void 0;
    var hasInactiveOpacity = this.options.series.filter(function(s) {
      return s.highlight.inactiveOpacity !== void 0;
    }).length > 0;
    return hasDefaultInactiveOpacity || hasInactiveOpacity;
  };
  Chart3.prototype._getInactiveOpacityForSeries = function _getInactiveOpacityForSeries(series) {
    var defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;
    var seriesInactiveOpacity = series.highlight.inactiveOpacity;
    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart3.prototype._getDefaultOpacityForSeries = function _getDefaultOpacityForSeries(series) {
    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart3.prototype._mouseover = function _mouseover(e) {
    var obj;
    var point2 = this._startHover(e.element, e.originalEvent);
    if (point2 && point2.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {
      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);
      bindEvents2(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
    }
  };
  Chart3.prototype._mouseMoveTracking = function _mouseMoveTracking(e) {
    var obj;
    var ref2 = this;
    var options2 = ref2.options;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    var point2 = ref2._activePoint;
    var coords = this._eventCoordinates(e);
    if (this._plotArea.box.containsPoint(coords)) {
      if (point2 && point2.tooltipTracking && point2.series && point2.parent.getNearestPoint) {
        var seriesPoint = point2.parent.getNearestPoint(coords.x, coords.y, point2.seriesIx);
        if (seriesPoint && seriesPoint !== point2) {
          this._activePoint = seriesPoint;
          if (!seriesPoint.hover(this, e)) {
            var tooltipOptions = deepExtend({}, options2.tooltip, seriesPoint.options.tooltip);
            if (tooltipOptions.visible) {
              tooltip.show(seriesPoint);
            }
            highlight.show(seriesPoint);
          }
        }
      }
    } else {
      unbindEvents2(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
      this._unsetActivePoint();
      this._mouseMoveTrackHandler = null;
      this._hideInactiveOpacity(point2);
    }
  };
  Chart3.prototype._mousemove = function _mousemove(e) {
    var coords = this._eventCoordinates(e);
    var plotArea = this._plotArea;
    this._trackCrosshairs(coords);
    if (plotArea.hover) {
      var overPlotArea = plotArea.backgroundContainsPoint(coords);
      if (overPlotArea) {
        this._plotAreaHovered = true;
        this._plotArea.hover(this, e);
      } else if (this._plotAreaHovered && !overPlotArea) {
        this._plotAreaHovered = false;
        this.trigger(PLOT_AREA_LEAVE);
      }
    }
    if (this._sharedTooltip()) {
      this._trackSharedTooltip(coords, e);
    }
  };
  Chart3.prototype._trackCrosshairs = function _trackCrosshairs(coords) {
    var crosshairs = this._plotArea.crosshairs;
    for (var i = 0; i < crosshairs.length; i++) {
      var current4 = crosshairs[i];
      if (current4.box.containsPoint(coords)) {
        current4.showAt(coords);
      } else {
        current4.hide();
      }
    }
  };
  Chart3.prototype._trackSharedTooltip = function _trackSharedTooltip(coords, e, toggle2) {
    if (this._suppressHover) {
      return;
    }
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var plotArea = ref2._plotArea;
    var categoryAxis = ref2._plotArea.categoryAxis;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    if (plotArea.backgroundContainsPoint(coords)) {
      var index = categoryAxis.pointCategoryIndex(coords);
      if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle2) {
        var points3 = plotArea.pointsByCategoryIndex(index);
        var pointArgs = points3.map(function(point2) {
          return point2.eventArgs(e);
        });
        var hoverArgs = pointArgs[0] || {};
        hoverArgs.categoryPoints = pointArgs;
        if (points3.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {
          if (tooltipOptions.visible) {
            tooltip.showAt(points3, coords);
          }
          highlight.show(points3);
          this._sharedHighlight = true;
        } else {
          tooltip.hide();
        }
        this._tooltipCategoryIx = index;
      } else if (toggle2 && this._sharedHighlight) {
        highlight.hide();
        tooltip.hide();
        this._sharedHighlight = false;
      }
    } else if (this._sharedHighlight) {
      highlight.hide();
      tooltip.hide();
      this._tooltipCategoryIx = null;
      this._sharedHighlight = false;
    }
  };
  Chart3.prototype.hideElements = function hideElements(options2) {
    var plotArea = this._plotArea;
    this._mousemove.cancel();
    plotArea.hideCrosshairs();
    this._unsetActivePoint(options2);
  };
  Chart3.prototype._unsetActivePoint = function _unsetActivePoint(options2) {
    var ref2 = this;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    this._activePoint = null;
    this._hoveredPoint = null;
    if (tooltip && !(options2 && options2.keepTooltipOpen)) {
      tooltip.hide();
    }
    this._tooltipCategoryIx = null;
    this._sharedHighlight = false;
    if (highlight) {
      highlight.hide();
    }
  };
  Chart3.prototype._deferRedraw = function _deferRedraw() {
    this._redraw();
  };
  Chart3.prototype._clearRedrawTimeout = function _clearRedrawTimeout() {
    if (this._redrawTimeout) {
      clearInterval(this._redrawTimeout);
      this._redrawTimeout = null;
    }
  };
  Chart3.prototype.bindCategories = function bindCategories() {
    var this$1 = this;
    var options2 = this.options;
    var definitions = [].concat(options2.categoryAxis);
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.autoBind !== false) {
        this$1.bindCategoryAxisFromSeries(axis, axisIx);
      }
    }
  };
  Chart3.prototype.bindCategoryAxisFromSeries = function bindCategoryAxisFromSeries(axis, axisIx) {
    var this$1 = this;
    var series = this.options.series;
    var seriesLength = series.length;
    var uniqueCategories = new hash_map_default();
    var items = [];
    var bindable = false;
    var dateAxis;
    for (var seriesIx = 0; seriesIx < seriesLength; seriesIx++) {
      var s = series[seriesIx];
      var onAxis = s.categoryAxis === axis.name || !s.categoryAxis && axisIx === 0;
      var data = s.data;
      var dataLength = data.length;
      var bind = s.categoryField && onAxis;
      bindable = bind || bindable;
      if (bind && dataLength > 0) {
        dateAxis = isDateAxis(axis, getField(s.categoryField, data[0]));
        var getFn = dateAxis ? getDateField : getField;
        for (var dataIx = 0; dataIx < dataLength; dataIx++) {
          var dataRow = data[dataIx];
          var category = getFn(s.categoryField, dataRow, this$1.chartService.intl);
          if (dateAxis || !uniqueCategories.get(category)) {
            items.push([category, dataRow]);
            if (!dateAxis) {
              uniqueCategories.set(category, true);
            }
          }
        }
      }
    }
    if (items.length > 0) {
      if (dateAxis) {
        items = uniqueDates(items, function(a, b) {
          return dateComparer(a[0], b[0]);
        });
      }
      var result = transpose(items);
      axis.categories = result[0];
    } else if (bindable) {
      axis.categories = [];
    }
  };
  Chart3.prototype._isBindable = function _isBindable(series) {
    var valueFields = series_binder_default.current.valueFields(series);
    var result = true;
    for (var i = 0; i < valueFields.length; i++) {
      var field = valueFields[i];
      if (field === VALUE) {
        field = "field";
      } else {
        field = field + "Field";
      }
      if (!defined2(series[field])) {
        result = false;
        break;
      }
    }
    return result;
  };
  Chart3.prototype._noTransitionsRedraw = function _noTransitionsRedraw() {
    var options2 = this.options;
    var transitionsState;
    if (options2.transitions !== false) {
      options2.transitions = false;
      transitionsState = true;
    }
    this._redraw();
    if (transitionsState) {
      options2.transitions = true;
    }
  };
  Chart3.prototype._legendItemHover = function _legendItemHover(seriesIndex, pointIndex) {
    var ref2 = this;
    var plotArea = ref2._plotArea;
    var highlight = ref2._highlight;
    var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];
    var items;
    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL])) {
      items = plotArea.findPoint(function(point3) {
        return point3.series.index === seriesIndex && point3.index === pointIndex;
      });
    } else {
      items = plotArea.pointsBySeriesIndex(seriesIndex);
    }
    if (this._hasInactiveOpacity() && currentSeries.visible && items) {
      var multipleSeries = plotArea.series.length > 1;
      var point2 = items.length ? items[0] : items;
      this._displayInactiveOpacity(point2, multipleSeries, items);
    } else {
      highlight.show(items);
    }
  };
  Chart3.prototype._shouldAttachMouseMove = function _shouldAttachMouseMove() {
    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);
  };
  Chart3.prototype.updateMouseMoveHandler = function updateMouseMoveHandler() {
    var obj, obj$1;
    unbindEvents2(this.element, (obj = {}, obj[MOUSEMOVE] = this._mousemove, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents2(this.element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
  };
  Chart3.prototype.applyOptions = function applyOptions(options2, theme) {
    clearMissingValues(this._originalOptions, options2);
    this._originalOptions = deepExtend(this._originalOptions, options2);
    this.options = deepExtend({}, this._originalOptions);
    if (theme) {
      this._theme = theme;
      this.chartService.theme = theme;
    }
    this._initTheme(this.options, this._theme);
    this._toggleDragZoomEvents();
  };
  Chart3.prototype.setOptions = function setOptions(options2, theme) {
    this.applyOptions(options2, theme);
    this.bindCategories();
    this.redraw();
    this.updateMouseMoveHandler();
  };
  Chart3.prototype.setDirection = function setDirection(rtl) {
    this.chartService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this._destroySurface();
    }
  };
  Chart3.prototype.setIntlService = function setIntlService(intl) {
    this.chartService.intl = intl;
  };
  Chart3.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    this._noTransitionsRedraw();
  };
  Chart3.prototype.destroy = function destroy2() {
    var obj, obj$1;
    this._destroyed = true;
    unbindEvents2(this.element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSEMOVE] = this._mousemove, obj[MOUSELEAVE] = this._mouseleaveHandler, obj));
    if (this.domEvents) {
      this.domEvents.destroy();
      delete this.domEvents;
    }
    if (this._mouseMoveTrackHandler) {
      unbindEvents2(document, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mouseMoveTrackHandler, obj$1));
    }
    this._destroyView();
    this._destroySurface();
    this._clearRedrawTimeout();
  };
  Chart3.prototype._destroySurface = function _destroySurface() {
    var surface = this.surface;
    if (surface) {
      surface.unbind("mouseenter", this._surfaceMouseenterHandler);
      surface.unbind("mouseleave", this._surfaceMouseleaveHandler);
      surface.destroy();
      this.surface = null;
    }
  };
  Chart3.prototype._destroySelections = function _destroySelections() {
    var selections = this._selections;
    if (selections) {
      while (selections.length > 0) {
        selections.shift().destroy();
      }
    }
  };
  Chart3.prototype._destroyView = function _destroyView() {
    var model = this._model;
    if (model) {
      model.destroy();
      this._model = null;
    }
    this._unsetActivePoint();
    this._resetDrilldownPoint();
    this._destroySelections();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this._highlight) {
      this._highlight.destroy();
    }
    if (this._zoomSelection) {
      this._zoomSelection.destroy();
      delete this._zoomSelection;
    }
    if (this._pannable) {
      this._pannable.destroy();
      delete this._pannable;
    }
    if (this._mousewheelZoom) {
      this._mousewheelZoom.destroy();
      delete this._mousewheelZoom;
    }
  };
  return Chart3;
}(class_default);
function resolveAxisAliases(options2) {
  var aliases = AXIS_NAMES;
  for (var idx = 0; idx < aliases.length; idx++) {
    var alias = aliases[idx] + "Axes";
    if (options2[alias]) {
      options2[aliases[idx] + "Axis"] = options2[alias];
      delete options2[alias];
    }
  }
}
function pointByCategoryName(points3, name2) {
  if (points3) {
    for (var idx = 0; idx < points3.length; idx++) {
      if (points3[idx].category === name2) {
        return [points3[idx]];
      }
    }
  }
}
function applyAxisDefaults(options2, themeOptions) {
  var themeAxisDefaults = (themeOptions || {}).axisDefaults || {};
  var axisName, axisDefaults2, axes;
  function mapAxisOptions(axisOptions2) {
    var axisColor = (axisOptions2 || {}).color || axisDefaults2.color;
    var result = deepExtend(
      {},
      themeAxisDefaults,
      themeAxisDefaults[axisName],
      axisDefaults2,
      axisDefaults2[axisName],
      {
        line: { color: axisColor },
        labels: { color: axisColor },
        title: { color: axisColor }
      },
      axisOptions2
    );
    delete result[axisName];
    return result;
  }
  for (var idx = 0; idx < AXIS_NAMES.length; idx++) {
    axisName = AXIS_NAMES[idx] + "Axis";
    axisDefaults2 = options2.axisDefaults || {};
    axes = [].concat(options2[axisName]);
    axes = axes.map(mapAxisOptions);
    options2[axisName] = axes.length > 1 ? axes : axes[0];
  }
}
function applySeriesDefaults(options2, themeOptions) {
  var series = options2.series;
  var seriesLength = series.length;
  var seriesDefaults2 = options2.seriesDefaults;
  var commonDefaults = deepExtend({}, options2.seriesDefaults);
  var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};
  var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);
  cleanupNestedSeriesDefaults(commonDefaults);
  cleanupNestedSeriesDefaults(commonThemeDefaults);
  for (var i = 0; i < seriesLength; i++) {
    var seriesType = series[i].type || options2.seriesDefaults.type;
    var baseOptions = deepExtend(
      { data: [] },
      commonThemeDefaults,
      themeSeriesDefaults[seriesType],
      { tooltip: options2.tooltip },
      commonDefaults,
      seriesDefaults2[seriesType]
    );
    series[i]._defaults = baseOptions;
    series[i] = deepExtend({}, baseOptions, series[i]);
    series[i].data = series[i].data || [];
  }
}
function cleanupNestedSeriesDefaults(seriesDefaults2) {
  delete seriesDefaults2.bar;
  delete seriesDefaults2.column;
  delete seriesDefaults2.rangeColumn;
  delete seriesDefaults2.line;
  delete seriesDefaults2.verticalLine;
  delete seriesDefaults2.pie;
  delete seriesDefaults2.donut;
  delete seriesDefaults2.area;
  delete seriesDefaults2.verticalArea;
  delete seriesDefaults2.scatter;
  delete seriesDefaults2.scatterLine;
  delete seriesDefaults2.bubble;
  delete seriesDefaults2.candlestick;
  delete seriesDefaults2.ohlc;
  delete seriesDefaults2.boxPlot;
  delete seriesDefaults2.bullet;
  delete seriesDefaults2.verticalBullet;
  delete seriesDefaults2.polarArea;
  delete seriesDefaults2.polarLine;
  delete seriesDefaults2.radarArea;
  delete seriesDefaults2.radarLine;
  delete seriesDefaults2.waterfall;
}
function axisRanges(axes) {
  var ranges = {};
  for (var i = 0; i < axes.length; i++) {
    var axis = axes[i];
    var axisName = axis.options.name;
    if (axisName) {
      ranges[axisName] = axis.range();
    }
  }
  return ranges;
}
function sortDates(dates, comparer) {
  if (comparer === void 0)
    comparer = dateComparer;
  for (var i = 1, length = dates.length; i < length; i++) {
    if (comparer(dates[i], dates[i - 1]) < 0) {
      dates.sort(comparer);
      break;
    }
  }
  return dates;
}
function uniqueDates(srcDates, comparer) {
  if (comparer === void 0)
    comparer = dateComparer;
  var dates = sortDates(srcDates, comparer);
  var length = dates.length;
  var result = length > 0 ? [dates[0]] : [];
  for (var i = 1; i < length; i++) {
    if (comparer(dates[i], last2(result)) !== 0) {
      result.push(dates[i]);
    }
  }
  return result;
}
function transpose(rows) {
  var rowCount = rows.length;
  var result = [];
  for (var rowIx = 0; rowIx < rowCount; rowIx++) {
    var row = rows[rowIx];
    var colCount = row.length;
    for (var colIx = 0; colIx < colCount; colIx++) {
      result[colIx] = result[colIx] || [];
      result[colIx].push(row[colIx]);
    }
  }
  return result;
}
var DATA_FIELDS = ["data", "categories"];
function clearMissingValues(originalOptions, options2) {
  for (var field in options2) {
    if (!inArray(field, DATA_FIELDS) && options2.hasOwnProperty(field)) {
      var fieldValue = options2[field];
      var originalValue = originalOptions[field];
      if (defined2(originalValue)) {
        var nullValue = fieldValue === null;
        if (nullValue || !defined2(fieldValue)) {
          delete originalOptions[field];
          if (nullValue) {
            delete options2[field];
          }
        } else if (originalValue && isObject(fieldValue)) {
          if (isObject(originalValue)) {
            clearMissingValues(originalValue, fieldValue);
          }
        }
      }
    }
  }
}
function triggerPaneRender(panes) {
  for (var idx = 0; idx < panes.length; idx++) {
    panes[idx].notifyRender();
  }
}
setDefaultOptions(Chart, {
  renderAs: "",
  chartArea: {},
  legend: {
    visible: true,
    labels: {}
  },
  categoryAxis: {},
  seriesDefaults: {
    type: COLUMN,
    data: [],
    highlight: {
      visible: true
    },
    labels: {},
    negativeValues: {
      visible: false
    }
  },
  series: [],
  seriesColors: null,
  tooltip: {
    visible: false
  },
  transitions: true,
  valueAxis: {},
  plotArea: {},
  title: {},
  xAxis: {},
  yAxis: {},
  panes: [{}],
  pannable: false,
  zoomable: false
});
var chart_default = Chart;

// node_modules/@progress/kendo-charts/dist/es/sparkline/shared-tooltip.js
var TOP_OFFSET = -2;
var SharedTooltip2 = function(ChartSharedTooltip) {
  function SharedTooltip3() {
    ChartSharedTooltip.apply(this, arguments);
  }
  if (ChartSharedTooltip)
    SharedTooltip3.__proto__ = ChartSharedTooltip;
  SharedTooltip3.prototype = Object.create(ChartSharedTooltip && ChartSharedTooltip.prototype);
  SharedTooltip3.prototype.constructor = SharedTooltip3;
  SharedTooltip3.prototype._slotAnchor = function _slotAnchor(coords, slot) {
    var axis = this.plotArea.categoryAxis;
    var vertical = axis.options.vertical;
    var align3 = vertical ? {
      horizontal: "left",
      vertical: "center"
    } : {
      horizontal: "center",
      vertical: "bottom"
    };
    var point2;
    if (vertical) {
      point2 = new point_default2(this.plotArea.box.x2, slot.center().y);
    } else {
      point2 = new point_default2(slot.center().x, TOP_OFFSET);
    }
    return {
      point: point2,
      align: align3
    };
  };
  SharedTooltip3.prototype._defaultAnchor = function _defaultAnchor(point2, slot) {
    return this._slotAnchor({}, slot);
  };
  return SharedTooltip3;
}(shared_tooltip_default);
var shared_tooltip_default2 = SharedTooltip2;

// node_modules/@progress/kendo-charts/dist/es/sparkline/sparkline.js
var DEAULT_BAR_WIDTH = 150;
var DEAULT_BULLET_WIDTH = 150;
var NO_CROSSHAIR = [BAR, BULLET];
function hide(children) {
  var state = [];
  for (var idx = 0; idx < children.length; idx++) {
    var child = children[idx];
    state[idx] = child.style.display;
    child.style.display = "none";
  }
  return state;
}
function show(children, state) {
  for (var idx = 0; idx < children.length; idx++) {
    children[idx].style.display = state[idx];
  }
}
function wrapNumber(value) {
  return isNumber2(value) ? [value] : value;
}
var Sparkline = function(Chart3) {
  function Sparkline2() {
    Chart3.apply(this, arguments);
  }
  if (Chart3)
    Sparkline2.__proto__ = Chart3;
  Sparkline2.prototype = Object.create(Chart3 && Chart3.prototype);
  Sparkline2.prototype.constructor = Sparkline2;
  Sparkline2.prototype._setElementClass = function _setElementClass(element2) {
    addClass(element2, "k-sparkline");
  };
  Sparkline2.prototype._initElement = function _initElement(element2) {
    Chart3.prototype._initElement.call(this, element2);
    this._initialWidth = Math.floor(elementSize2(element2).width);
  };
  Sparkline2.prototype._resize = function _resize() {
    var element2 = this.element;
    var state = hide(element2.childNodes);
    this._initialWidth = Math.floor(elementSize2(element2).width);
    show(element2.childNodes, state);
    Chart3.prototype._resize.call(this);
  };
  Sparkline2.prototype._modelOptions = function _modelOptions() {
    var chartOptions = this.options;
    var stage = this._surfaceWrap();
    var displayState = hide(stage.childNodes);
    var space = document.createElement("span");
    space.innerHTML = "&nbsp;";
    stage.appendChild(space);
    var options2 = deepExtend({
      width: this._autoWidth,
      height: elementSize2(stage).height,
      transitions: chartOptions.transitions
    }, chartOptions.chartArea, {
      inline: true,
      align: false
    });
    elementSize2(stage, {
      width: options2.width,
      height: options2.height
    });
    stage.removeChild(space);
    show(stage.childNodes, displayState);
    if (this.surface) {
      this.surface.resize();
    }
    return options2;
  };
  Sparkline2.prototype._surfaceWrap = function _surfaceWrap() {
    if (!this.stage) {
      var stage = this.stage = document.createElement("span");
      this.element.appendChild(stage);
    }
    return this.stage;
  };
  Sparkline2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var plotArea = Chart3.prototype._createPlotArea.call(this, skipSeries);
    this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);
    return plotArea;
  };
  Sparkline2.prototype._calculateWidth = function _calculateWidth(plotArea) {
    var options2 = this.options;
    var margin = getSpacing(options2.chartArea.margin);
    var charts = plotArea.charts;
    var stage = this._surfaceWrap();
    var total3 = 0;
    for (var i = 0; i < charts.length; i++) {
      var currentChart = charts[i];
      var firstSeries = (currentChart.options.series || [])[0];
      if (!firstSeries) {
        continue;
      }
      if (firstSeries.type === BAR) {
        return DEAULT_BAR_WIDTH;
      }
      if (firstSeries.type === BULLET) {
        return DEAULT_BULLET_WIDTH;
      }
      if (firstSeries.type === PIE) {
        return elementSize2(stage).height;
      }
      var categoryAxis = currentChart.categoryAxis;
      if (categoryAxis) {
        var pointsCount = categoryAxis.categoriesCount() * (!currentChart.options.isStacked && inArray(firstSeries.type, [COLUMN, VERTICAL_BULLET]) ? currentChart.seriesOptions.length : 1);
        total3 = Math.max(total3, pointsCount);
      }
    }
    var size = total3 * options2.pointWidth;
    if (size > 0) {
      size += margin.left + margin.right;
    }
    return size;
  };
  Sparkline2.prototype._createSharedTooltip = function _createSharedTooltip(options2) {
    return new shared_tooltip_default2(this._plotArea, options2);
  };
  Sparkline2.normalizeOptions = function normalizeOptions(userOptions) {
    var options2 = wrapNumber(userOptions);
    if (isArray(options2)) {
      options2 = { seriesDefaults: { data: options2 } };
    } else {
      options2 = deepExtend({}, options2);
    }
    if (!options2.series) {
      options2.series = [{ data: wrapNumber(options2.data) }];
    }
    deepExtend(options2, {
      seriesDefaults: {
        type: options2.type
      }
    });
    if (inArray(options2.series[0].type, NO_CROSSHAIR) || inArray(options2.seriesDefaults.type, NO_CROSSHAIR)) {
      options2 = deepExtend({}, {
        categoryAxis: {
          crosshair: {
            visible: false
          }
        }
      }, options2);
    }
    return options2;
  };
  return Sparkline2;
}(chart_default);
setDefaultOptions(Sparkline, {
  chartArea: {
    margin: 2
  },
  axisDefaults: {
    visible: false,
    majorGridLines: {
      visible: false
    },
    valueAxis: {
      narrowRange: true
    }
  },
  seriesDefaults: {
    type: "line",
    area: {
      line: {
        width: 0.5
      }
    },
    bar: {
      stack: true
    },
    padding: 2,
    width: 0.5,
    overlay: {
      gradient: null
    },
    highlight: {
      visible: false
    },
    border: {
      width: 0
    },
    markers: {
      size: 2,
      visible: false
    }
  },
  tooltip: {
    visible: true,
    shared: true
  },
  categoryAxis: {
    crosshair: {
      visible: true,
      tooltip: {
        visible: false
      }
    }
  },
  legend: {
    visible: false
  },
  transitions: false,
  pointWidth: 5,
  panes: [{ clip: false }]
});

// node_modules/@progress/kendo-charts/dist/es/stock/fade-out-animation.js
var FadeOutAnimation = function(superclass) {
  function FadeOutAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    FadeOutAnimation2.__proto__ = superclass;
  FadeOutAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeOutAnimation2.prototype.constructor = FadeOutAnimation2;
  FadeOutAnimation2.prototype.setup = function setup() {
    this._initialOpacity = parseFloat(elementStyles2(this.element, "opacity").opacity);
  };
  FadeOutAnimation2.prototype.step = function step(pos) {
    elementStyles2(this.element, {
      opacity: String(interpolateValue(this._initialOpacity, 0, pos))
    });
  };
  FadeOutAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    elementStyles2(this.element, {
      display: "none",
      opacity: String(this._initialOpacity)
    });
  };
  FadeOutAnimation2.prototype.cancel = function cancel() {
    superclass.prototype.abort.call(this);
    elementStyles2(this.element, {
      opacity: String(this._initialOpacity)
    });
  };
  return FadeOutAnimation2;
}(drawing_exports.Animation);
var fade_out_animation_default = FadeOutAnimation;

// node_modules/@progress/kendo-charts/dist/es/stock/navigator-hint.js
function createDiv2(className, style) {
  var div = document.createElement("div");
  div.className = className;
  if (style) {
    div.style.cssText = style;
  }
  return div;
}
var NavigatorHint = function(Class3) {
  function NavigatorHint2(container, chartService, options2) {
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.container = container;
    this.chartService = chartService;
    var padding = elementStyles2(container, ["paddingLeft", "paddingTop"]);
    this.chartPadding = {
      top: padding.paddingTop,
      left: padding.paddingLeft
    };
    this.createElements();
    container.appendChild(this.element);
  }
  if (Class3)
    NavigatorHint2.__proto__ = Class3;
  NavigatorHint2.prototype = Object.create(Class3 && Class3.prototype);
  NavigatorHint2.prototype.constructor = NavigatorHint2;
  NavigatorHint2.prototype.createElements = function createElements() {
    var element2 = this.element = createDiv2("k-navigator-hint", "display: none; position: absolute; top: 1px; left: 1px;");
    var tooltip = this.tooltip = createDiv2("k-tooltip k-chart-tooltip");
    var scroll = this.scroll = createDiv2("k-scroll");
    tooltip.innerHTML = "&nbsp;";
    element2.appendChild(tooltip);
    element2.appendChild(scroll);
  };
  NavigatorHint2.prototype.show = function show2(from, to, bbox) {
    var ref2 = this;
    var element2 = ref2.element;
    var options2 = ref2.options;
    var scroll = ref2.scroll;
    var tooltip = ref2.tooltip;
    var middle = toDate(toTime(from) + toTime(to - from) / 2);
    var scrollWidth = bbox.width() * 0.4;
    var minPos = bbox.center().x - scrollWidth;
    var maxPos = bbox.center().x;
    var posRange = maxPos - minPos;
    var range = options2.max - options2.min;
    var scale = posRange / range;
    var offset3 = middle - options2.min;
    var text = this.chartService.intl.format(options2.format, from, to);
    var template3 = getTemplate(options2);
    this.clearHideTimeout();
    if (!this._visible) {
      elementStyles2(element2, {
        visibility: "hidden",
        display: "block"
      });
      this._visible = true;
    }
    if (template3) {
      text = template3({
        from,
        to
      });
    }
    tooltip.innerHTML = text;
    elementStyles2(tooltip, {
      left: bbox.center().x - tooltip.offsetWidth / 2,
      top: bbox.y1
    });
    var tooltipStyle = elementStyles2(tooltip, ["marginTop", "borderTopWidth", "height"]);
    elementStyles2(scroll, {
      width: scrollWidth,
      left: minPos + offset3 * scale,
      top: bbox.y1 + tooltipStyle.marginTop + tooltipStyle.borderTopWidth + tooltipStyle.height / 2
    });
    elementStyles2(element2, {
      visibility: "visible"
    });
  };
  NavigatorHint2.prototype.clearHideTimeout = function clearHideTimeout() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    if (this._hideAnimation) {
      this._hideAnimation.cancel();
    }
  };
  NavigatorHint2.prototype.hide = function hide2() {
    var this$1 = this;
    this.clearHideTimeout();
    this._hideTimeout = setTimeout(function() {
      this$1._visible = false;
      this$1._hideAnimation = new fade_out_animation_default(this$1.element);
      this$1._hideAnimation.setup();
      this$1._hideAnimation.play();
    }, this.options.hideDelay);
  };
  NavigatorHint2.prototype.destroy = function destroy2() {
    this.clearHideTimeout();
    if (this.container) {
      this.container.removeChild(this.element);
    }
    delete this.container;
    delete this.chartService;
    delete this.element;
    delete this.tooltip;
    delete this.scroll;
  };
  return NavigatorHint2;
}(class_default);
setDefaultOptions(NavigatorHint, {
  format: "{0:d} - {1:d}",
  hideDelay: 500
});
var navigator_hint_default = NavigatorHint;

// node_modules/@progress/kendo-charts/dist/es/stock/constants.js
var NAVIGATOR_PANE = "_navigator";
var NAVIGATOR_AXIS = NAVIGATOR_PANE;
var DEFAULT_PANE = "_default";

// node_modules/@progress/kendo-charts/dist/es/stock/navigator.js
var ZOOM_ACCELERATION2 = 3;
var Navigator = function(Class3) {
  function Navigator3(chart) {
    var obj;
    Class3.call(this);
    this.chart = chart;
    var options2 = this.options = deepExtend({}, this.options, chart.options.navigator);
    var select = options2.select;
    if (select) {
      select.from = this.parseDate(select.from);
      select.to = this.parseDate(select.to);
    }
    if (!defined2(options2.hint.visible)) {
      options2.hint.visible = options2.visible;
    }
    this.chartObserver = new instance_observer_default(this, (obj = {}, obj[DRAG] = "_drag", obj[DRAG_END] = "_dragEnd", obj[ZOOM] = "_zoom", obj[ZOOM_END] = "_zoomEnd", obj));
    chart.addObserver(this.chartObserver);
  }
  if (Class3)
    Navigator3.__proto__ = Class3;
  Navigator3.prototype = Object.create(Class3 && Class3.prototype);
  Navigator3.prototype.constructor = Navigator3;
  Navigator3.prototype.parseDate = function parseDate$1(value) {
    return parseDate3(this.chart.chartService.intl, value);
  };
  Navigator3.prototype.clean = function clean() {
    if (this.selection) {
      this.selection.destroy();
      this.selection = null;
    }
    if (this.hint) {
      this.hint.destroy();
      this.hint = null;
    }
  };
  Navigator3.prototype.destroy = function destroy2() {
    if (this.chart) {
      this.chart.removeObserver(this.chartObserver);
      delete this.chart;
    }
    this.clean();
  };
  Navigator3.prototype.redraw = function redraw() {
    this._redrawSelf();
    this.initSelection();
  };
  Navigator3.prototype.initSelection = function initSelection() {
    var ref2 = this;
    var chart = ref2.chart;
    var options2 = ref2.options;
    var axis = this.mainAxis();
    var ref$1 = axis.roundedRange();
    var min3 = ref$1.min;
    var max2 = ref$1.max;
    var ref$2 = options2.select;
    var from = ref$2.from;
    var to = ref$2.to;
    var mousewheel = ref$2.mousewheel;
    var axisClone = clone(axis);
    if (axis.categoriesCount() === 0) {
      return;
    }
    this.clean();
    axisClone.box = axis.box;
    this.selection = new selection_default(chart, axisClone, {
      min: min3,
      max: max2,
      from: from || min3,
      to: to || max2,
      mousewheel: valueOrDefault2(mousewheel, { zoom: "left" }),
      visible: options2.visible
    }, new instance_observer_default(this, {
      selectStart: "_selectStart",
      select: "_select",
      selectEnd: "_selectEnd"
    }));
    if (options2.hint.visible) {
      this.hint = new navigator_hint_default(chart.element, chart.chartService, {
        min: min3,
        max: max2,
        template: getTemplate(options2.hint),
        format: options2.hint.format
      });
    }
  };
  Navigator3.prototype.setRange = function setRange() {
    var plotArea = this.chart._createPlotArea(true);
    var axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    var ref2 = axis.roundedRange();
    var min3 = ref2.min;
    var max2 = ref2.max;
    var select = this.options.select || {};
    var from = select.from || min3;
    if (from < min3) {
      from = min3;
    }
    var to = select.to || max2;
    if (to > max2) {
      to = max2;
    }
    this.options.select = deepExtend({}, select, {
      from,
      to
    });
    this.filterAxes();
  };
  Navigator3.prototype._redrawSelf = function _redrawSelf(silent) {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      plotArea.redraw(last2(plotArea.panes), silent);
    }
  };
  Navigator3.prototype.redrawSlaves = function redrawSlaves() {
    var chart = this.chart;
    var plotArea = chart._plotArea;
    var slavePanes = plotArea.panes.filter(function(pane) {
      return pane.options.name !== NAVIGATOR_PANE;
    });
    plotArea.srcSeries = chart.options.series;
    plotArea.options.categoryAxis = chart.options.categoryAxis;
    plotArea.clearSeriesPointsCache();
    plotArea.redraw(slavePanes);
  };
  Navigator3.prototype._drag = function _drag(e) {
    var ref2 = this;
    var chart = ref2.chart;
    var selection = ref2.selection;
    var coords = chart._eventCoordinates(e.originalEvent);
    var navigatorAxis = this.mainAxis();
    var naviRange = navigatorAxis.roundedRange();
    var inNavigator = navigatorAxis.pane.box.containsPoint(coords);
    var axis = chart._plotArea.categoryAxis;
    var range = e.axisRanges[axis.options.name];
    var select = this.options.select;
    var duration2;
    if (!range || inNavigator || !selection) {
      return;
    }
    if (select.from && select.to) {
      duration2 = toTime(select.to) - toTime(select.from);
    } else {
      duration2 = toTime(selection.options.to) - toTime(selection.options.from);
    }
    var from = toDate(limitValue2(
      toTime(range.min),
      naviRange.min,
      toTime(naviRange.max) - duration2
    ));
    var to = toDate(limitValue2(
      toTime(from) + duration2,
      toTime(naviRange.min) + duration2,
      naviRange.max
    ));
    this.options.select = { from, to };
    if (this.options.liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(from, to);
    this.showHint(from, to);
  };
  Navigator3.prototype._dragEnd = function _dragEnd() {
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    if (this.hint) {
      this.hint.hide();
    }
  };
  Navigator3.prototype.readSelection = function readSelection() {
    var ref2 = this;
    var ref_selection_options = ref2.selection.options;
    var from = ref_selection_options.from;
    var to = ref_selection_options.to;
    var select = ref2.options.select;
    select.from = from;
    select.to = to;
  };
  Navigator3.prototype.filterAxes = function filterAxes() {
    var ref2 = this;
    var select = ref2.options.select;
    if (select === void 0)
      select = {};
    var chart = ref2.chart;
    var allAxes = chart.options.categoryAxis;
    var from = select.from;
    var to = select.to;
    for (var idx = 0; idx < allAxes.length; idx++) {
      var axis = allAxes[idx];
      if (axis.pane !== NAVIGATOR_PANE) {
        axis.min = from;
        axis.max = to;
      }
    }
  };
  Navigator3.prototype.filter = function filter() {
    var ref2 = this;
    var chart = ref2.chart;
    var select = ref2.options.select;
    if (!chart.requiresHandlers(["navigatorFilter"])) {
      return;
    }
    var mainAxis = this.mainAxis();
    var args = {
      from: select.from,
      to: select.to
    };
    if (mainAxis.options.type !== "category") {
      var axisOptions2 = new date_category_axis_default(deepExtend({
        baseUnit: "fit"
      }, chart.options.categoryAxis[0], {
        categories: [select.from, select.to]
      }), chart.chartService).options;
      args.from = addDuration(axisOptions2.min, -axisOptions2.baseUnitStep, axisOptions2.baseUnit);
      args.to = addDuration(axisOptions2.max, axisOptions2.baseUnitStep, axisOptions2.baseUnit);
    }
    this.chart.trigger("navigatorFilter", args);
  };
  Navigator3.prototype._zoom = function _zoom(e) {
    var ref2 = this;
    var axis = ref2.chart._plotArea.categoryAxis;
    var selection = ref2.selection;
    var ref_options = ref2.options;
    var select = ref_options.select;
    var liveDrag = ref_options.liveDrag;
    var mainAxis = this.mainAxis();
    var delta = e.delta;
    if (!selection) {
      return;
    }
    var fromIx = mainAxis.categoryIndex(selection.options.from);
    var toIx = mainAxis.categoryIndex(selection.options.to);
    var coords = this.chart._eventCoordinates(e.originalEvent);
    e.originalEvent.preventDefault();
    if (Math.abs(delta) > 1) {
      delta *= ZOOM_ACCELERATION2;
    }
    if (toIx - fromIx > 1) {
      selection.zoom(delta, coords);
      this.readSelection();
    } else {
      axis.options.min = select.from;
      select.from = axis.scaleRange(-e.delta * this.chart._mousewheelZoomRate(), coords).min;
    }
    if (liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(select.from, select.to);
    this.showHint(this.options.select.from, this.options.select.to);
  };
  Navigator3.prototype._zoomEnd = function _zoomEnd(e) {
    this._dragEnd(e);
  };
  Navigator3.prototype.showHint = function showHint(from, to) {
    var plotArea = this.chart._plotArea;
    if (this.hint) {
      this.hint.show(from, to, plotArea.backgroundBox());
    }
  };
  Navigator3.prototype._selectStart = function _selectStart(e) {
    return this.chart._selectStart(e);
  };
  Navigator3.prototype._select = function _select(e) {
    this.showHint(e.from, e.to);
    return this.chart._select(e);
  };
  Navigator3.prototype._selectEnd = function _selectEnd(e) {
    if (this.hint) {
      this.hint.hide();
    }
    this.readSelection();
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    return this.chart._selectEnd(e);
  };
  Navigator3.prototype.mainAxis = function mainAxis() {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    }
  };
  Navigator3.prototype.select = function select(from, to) {
    var select2 = this.options.select;
    if (from && to) {
      select2.from = this.parseDate(from);
      select2.to = this.parseDate(to);
      this.filterAxes();
      this.filter();
      this.redrawSlaves();
      this.selection.set(from, to);
    }
    return {
      from: select2.from,
      to: select2.to
    };
  };
  Navigator3.setup = function setup(options2, themeOptions) {
    if (options2 === void 0)
      options2 = {};
    if (themeOptions === void 0)
      themeOptions = {};
    if (options2.__navi) {
      return;
    }
    options2.__navi = true;
    var naviOptions = deepExtend({}, themeOptions.navigator, options2.navigator);
    var panes = options2.panes = [].concat(options2.panes);
    var paneOptions = deepExtend({}, naviOptions.pane, { name: NAVIGATOR_PANE });
    if (!naviOptions.visible) {
      paneOptions.visible = false;
      paneOptions.height = 0.1;
    }
    if (options2.navigator.position !== "top") {
      panes.push(paneOptions);
    } else {
      panes.unshift(paneOptions);
    }
    panes.forEach(function(pane) {
      return pane.name = pane.name || DEFAULT_PANE;
    });
    Navigator3.attachAxes(options2, naviOptions);
    Navigator3.attachSeries(options2, naviOptions, themeOptions);
  };
  Navigator3.attachAxes = function attachAxes(options2, naviOptions) {
    var series = naviOptions.series || [];
    var categoryAxes = options2.categoryAxis = [].concat(options2.categoryAxis);
    var valueAxes = options2.valueAxis = [].concat(options2.valueAxis);
    var allAxes = categoryAxes.concat(valueAxes);
    allAxes.forEach(function(axis) {
      return axis.pane = axis.pane || DEFAULT_PANE;
    });
    var equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);
    var justifyAxis = equallySpacedSeries.length === 0;
    var base = deepExtend({
      type: "date",
      pane: NAVIGATOR_PANE,
      roundToBaseUnit: !justifyAxis,
      justified: justifyAxis,
      _collapse: false,
      majorTicks: { visible: true },
      tooltip: { visible: false },
      labels: { step: 1 },
      autoBind: naviOptions.autoBindElements,
      autoBaseUnitSteps: {
        minutes: [1],
        hours: [1, 2],
        days: [1, 2],
        weeks: [],
        months: [1],
        years: [1]
      }
    });
    var user = naviOptions.categoryAxis;
    categoryAxes.push(
      deepExtend({}, base, {
        maxDateGroups: 200
      }, user, {
        name: NAVIGATOR_AXIS,
        title: null,
        baseUnit: "fit",
        baseUnitStep: "auto",
        labels: { visible: false },
        majorTicks: { visible: false }
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_labels",
        maxDateGroups: 20,
        baseUnitStep: "auto",
        labels: { position: "" },
        plotBands: [],
        autoBaseUnitSteps: {
          minutes: []
        },
        _overlap: true
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_ticks",
        maxDateGroups: 200,
        majorTicks: {
          width: 0.5
        },
        plotBands: [],
        title: null,
        labels: { visible: false, mirror: true },
        _overlap: true
      })
    );
    valueAxes.push(deepExtend({
      name: NAVIGATOR_AXIS,
      pane: NAVIGATOR_PANE,
      majorGridLines: {
        visible: false
      },
      visible: false
    }, naviOptions.valueAxis));
  };
  Navigator3.attachSeries = function attachSeries(options2, naviOptions, themeOptions) {
    var series = options2.series = options2.series || [];
    var navigatorSeries = [].concat(naviOptions.series || []);
    var seriesColors = themeOptions.seriesColors;
    var defaults = naviOptions.seriesDefaults;
    for (var idx = 0; idx < navigatorSeries.length; idx++) {
      series.push(
        deepExtend({
          color: seriesColors[idx % seriesColors.length],
          categoryField: naviOptions.dateField,
          visibleInLegend: false,
          tooltip: {
            visible: false
          }
        }, defaults, navigatorSeries[idx], {
          axis: NAVIGATOR_AXIS,
          categoryAxis: NAVIGATOR_AXIS,
          autoBind: naviOptions.autoBindElements
        })
      );
    }
  };
  return Navigator3;
}(class_default);
function ClonedObject() {
}
function clone(obj) {
  ClonedObject.prototype = obj;
  return new ClonedObject();
}
var navigator_default = Navigator;

// node_modules/@progress/kendo-charts/dist/es/stock/stock-chart.js
var AUTO_CATEGORY_WIDTH = 28;
var StockChart = function(Chart3) {
  function StockChart2() {
    Chart3.apply(this, arguments);
  }
  if (Chart3)
    StockChart2.__proto__ = Chart3;
  StockChart2.prototype = Object.create(Chart3 && Chart3.prototype);
  StockChart2.prototype.constructor = StockChart2;
  StockChart2.prototype.applyDefaults = function applyDefaults2(options2, themeOptions) {
    var width = elementSize2(this.element).width || DEFAULT_WIDTH;
    var theme = themeOptions;
    var stockDefaults = {
      seriesDefaults: {
        categoryField: options2.dateField
      },
      axisDefaults: {
        categoryAxis: {
          name: "default",
          majorGridLines: {
            visible: false
          },
          labels: {
            step: 2
          },
          majorTicks: {
            visible: false
          },
          maxDateGroups: Math.floor(width / AUTO_CATEGORY_WIDTH)
        }
      }
    };
    if (theme) {
      theme = deepExtend({}, theme, stockDefaults);
    }
    navigator_default.setup(options2, theme);
    Chart3.prototype.applyDefaults.call(this, options2, theme);
  };
  StockChart2.prototype._setElementClass = function _setElementClass(element2) {
    addClass(element2, "k-chart k-stockchart");
  };
  StockChart2.prototype.setOptions = function setOptions(options2) {
    this.destroyNavigator();
    Chart3.prototype.setOptions.call(this, options2);
  };
  StockChart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this.options.transitions = false;
    this._fullRedraw();
    this.options.transitions = transitions;
  };
  StockChart2.prototype._resize = function _resize() {
    this.noTransitionsRedraw();
  };
  StockChart2.prototype._redraw = function _redraw() {
    var navigator2 = this.navigator;
    if (!this._dirty() && navigator2 && navigator2.options.partialRedraw) {
      navigator2.redrawSlaves();
    } else {
      this._fullRedraw();
    }
  };
  StockChart2.prototype._dirty = function _dirty() {
    var options2 = this.options;
    var series = [].concat(options2.series, options2.navigator.series);
    var seriesCount = grep(series, function(s) {
      return s && s.visible;
    }).length;
    var dirty = this._seriesCount !== seriesCount;
    this._seriesCount = seriesCount;
    return dirty;
  };
  StockChart2.prototype._fullRedraw = function _fullRedraw() {
    var navigator2 = this.navigator;
    if (!navigator2) {
      navigator2 = this.navigator = new navigator_default(this);
      this.trigger("navigatorCreated", { navigator: navigator2 });
    }
    navigator2.clean();
    navigator2.setRange();
    Chart3.prototype._redraw.call(this);
    navigator2.initSelection();
  };
  StockChart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords) {
    var plotArea = this._plotArea;
    var pane = plotArea.paneByPoint(coords);
    if (pane && pane.options.name === NAVIGATOR_PANE) {
      this._unsetActivePoint();
    } else {
      Chart3.prototype._trackSharedTooltip.call(this, coords);
    }
  };
  StockChart2.prototype.bindCategories = function bindCategories() {
    Chart3.prototype.bindCategories.call(this);
    this.copyNavigatorCategories();
  };
  StockChart2.prototype.copyNavigatorCategories = function copyNavigatorCategories() {
    var definitions = [].concat(this.options.categoryAxis);
    var categories;
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.name === NAVIGATOR_AXIS) {
        categories = axis.categories;
      } else if (categories && axis.pane === NAVIGATOR_PANE) {
        axis.categories = categories;
      }
    }
  };
  StockChart2.prototype.destroyNavigator = function destroyNavigator() {
    if (this.navigator) {
      this.navigator.destroy();
      this.navigator = null;
    }
  };
  StockChart2.prototype.destroy = function destroy2() {
    this.destroyNavigator();
    Chart3.prototype.destroy.call(this);
  };
  StockChart2.prototype._stopChartHandlers = function _stopChartHandlers(e) {
    var coords = this._eventCoordinates(e);
    var pane = this._plotArea.paneByPoint(coords);
    return Chart3.prototype._stopChartHandlers.call(this, e) || pane && pane.options.name === NAVIGATOR_PANE;
  };
  StockChart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    if (!this._dragZoomEnabled) {
      this.element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
  };
  return StockChart2;
}(chart_default);
setDefaultOptions(StockChart, {
  dateField: "date",
  axisDefaults: {
    categoryAxis: {
      type: "date",
      baseUnit: "fit",
      justified: true
    },
    valueAxis: {
      narrowRange: true,
      labels: {
        format: "C"
      }
    }
  },
  navigator: {
    select: {},
    seriesDefaults: {
      markers: {
        visible: false
      },
      tooltip: {
        visible: false
      },
      highlight: {
        visible: false
      },
      line: {
        width: 2
      }
    },
    hint: {},
    visible: true
  },
  tooltip: {
    visible: true
  },
  legend: {
    visible: false
  }
});

// node_modules/@progress/kendo-charts/dist/es/gauges/constants.js
var ANGULAR_SPEED = 150;
var LINEAR_SPEED = 250;
var ARROW = "arrow";
var ARROW_POINTER = "arrowPointer";
var BAR_POINTER = "barPointer";
var DEFAULT_HEIGHT2 = 200;
var DEFAULT_LINE_WIDTH = 0.5;
var DEFAULT_WIDTH2 = 200;
var DEGREE = Math.PI / 180;
var INSIDE2 = "inside";
var LINEAR2 = "linear";
var OUTSIDE2 = "outside";
var RADIAL_POINTER = "radialPointer";
var RADIAL_RANGE_POINTER = "radialRangePointer";

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/pad.js
function pad2(bbox, value) {
  var origin = bbox.getOrigin();
  var size = bbox.getSize();
  var spacing = getSpacing(value);
  bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);
  bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);
  return bbox;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/build-label-element.js
var Group2 = drawing_exports.Group;
var Path2 = drawing_exports.Path;
var Text3 = drawing_exports.Text;
function buildLabelElement(label, options2) {
  var labelBox = label.box;
  var textBox = label.children[0].box;
  var border = options2.border || {};
  var background = options2.background || "";
  var wrapper = Path2.fromRect(new geometry_exports.Rect([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {
    stroke: {}
  });
  var text = new Text3(label.text, new geometry_exports.Point(textBox.x1, textBox.y1), {
    font: options2.font,
    fill: { color: options2.color }
  });
  var styleGeometry = pad2(text.bbox().clone(), options2.padding);
  var styleBox = Path2.fromRect(styleGeometry, {
    stroke: {
      color: border.width ? border.color : "",
      width: border.width,
      opacity: border.opacity,
      dashType: border.dashType,
      lineJoin: "round",
      lineCap: "round"
    },
    fill: {
      color: background
    }
  });
  var elements = new Group2();
  elements.append(wrapper);
  elements.append(styleBox);
  elements.append(text);
  return elements;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/get-range.js
function getRange(range, min3, max2) {
  var from = defined2(range.from) ? range.from : MIN_VALUE;
  var to = defined2(range.to) ? range.to : MAX_VALUE;
  range.from = Math.max(Math.min(to, from), min3);
  range.to = Math.min(Math.max(to, from), max2);
  return range;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/unpad.js
function unpad(bbox, value) {
  var spacing = getSpacing(value);
  spacing.left = -spacing.left;
  spacing.top = -spacing.top;
  spacing.right = -spacing.right;
  spacing.bottom = -spacing.bottom;
  return pad2(bbox, spacing);
}

// node_modules/@progress/kendo-charts/dist/es/gauges/gauge.js
var DEFAULT_MARGIN = 5;
var Path3 = drawing_exports.Path;
var Surface5 = drawing_exports.Surface;
var Gauge = function(Class3) {
  function Gauge2(element2, userOptions, theme, context2) {
    if (context2 === void 0)
      context2 = {};
    Class3.call(this);
    this.element = element2;
    this.theme = theme;
    this.contextService = new chart_service_default(this, context2);
    this._originalOptions = deepExtend({}, this.options, userOptions);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  if (Class3)
    Gauge2.__proto__ = Class3;
  Gauge2.prototype = Object.create(Class3 && Class3.prototype);
  Gauge2.prototype.constructor = Gauge2;
  Gauge2.prototype.destroy = function destroy2() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
    }
    delete this.element;
    delete this.surfaceElement;
  };
  Gauge2.prototype.value = function value(pointerValue) {
    var pointer = this.pointers[0];
    if (arguments.length === 0) {
      return pointer.value();
    }
    pointer.value(pointerValue);
    this._setValueOptions(pointerValue);
  };
  Gauge2.prototype._draw = function _draw() {
    var surface = this.surface;
    surface.clear();
    surface.draw(this._visuals);
  };
  Gauge2.prototype.exportVisual = function exportVisual() {
    return this._visuals;
  };
  Gauge2.prototype.allValues = function allValues(values5) {
    var pointers = this.pointers;
    var allValues2 = [];
    if (arguments.length === 0) {
      for (var i = 0; i < pointers.length; i++) {
        allValues2.push(pointers[i].value());
      }
      return allValues2;
    }
    if (isArray(values5)) {
      for (var i$1 = 0; i$1 < values5.length; i$1++) {
        if (isNumber2(values5[i$1])) {
          pointers[i$1].value(values5[i$1]);
        }
      }
    }
    this._setValueOptions(values5);
  };
  Gauge2.prototype._setValueOptions = function _setValueOptions(values5) {
    var pointers = [].concat(this.options.pointer);
    var arrayValues = [].concat(values5);
    for (var i = 0; i < arrayValues.length; i++) {
      pointers[i].value = arrayValues[i];
    }
  };
  Gauge2.prototype.resize = function resize() {
    this.noTransitionsRedraw();
  };
  Gauge2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this._toggleTransitions(false);
    this.redraw();
    this._toggleTransitions(transitions);
  };
  Gauge2.prototype.redraw = function redraw() {
    var size = this._surfaceSize();
    var wrapper = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._initSurface();
    this.gaugeArea = this._createGaugeArea();
    this._createModel();
    var bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);
    this.reflow(bbox);
  };
  Gauge2.prototype.setOptions = function setOptions(options2, theme) {
    this._originalOptions = deepExtend(this._originalOptions, options2);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  };
  Gauge2.prototype.setDirection = function setDirection(rtl) {
    this.contextService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this.surface.destroy();
      this.surface = null;
    }
  };
  Gauge2.prototype.setIntlService = function setIntlService(intl) {
    this.contextService.intl = intl;
  };
  Gauge2.prototype._initTheme = function _initTheme(theme) {
    var currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
    var options2 = this.options;
    var pointer = options2.pointer;
    if (isArray(pointer)) {
      var pointers = [];
      for (var i = 0; i < pointer.length; i++) {
        pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));
      }
      options2.pointer = pointers;
    }
  };
  Gauge2.prototype._createGaugeArea = function _createGaugeArea() {
    var options2 = this.options.gaugeArea;
    var size = this.surface.size();
    var border = options2.border || {};
    var areaGeometry = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._gaugeAreaMargin = options2.margin || DEFAULT_MARGIN;
    if (border.width > 0) {
      areaGeometry = unpad(areaGeometry, border.width);
    }
    var gaugeArea = Path3.fromRect(areaGeometry, {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType,
        lineJoin: "round",
        lineCap: "round"
      },
      fill: {
        color: options2.background
      }
    });
    return gaugeArea;
  };
  Gauge2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    var element2 = this._surfaceElement();
    var size = this._surfaceSize();
    elementSize2(element2, size);
    if (!surface || surface.options.type !== options2.renderAs) {
      if (surface) {
        surface.destroy();
      }
      this.surface = Surface5.create(element2, {
        type: options2.renderAs
      });
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  };
  Gauge2.prototype._surfaceSize = function _surfaceSize() {
    var options2 = this.options;
    var size = this._getSize();
    if (options2.gaugeArea) {
      deepExtend(size, options2.gaugeArea);
    }
    return size;
  };
  Gauge2.prototype._surfaceElement = function _surfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
    return this.surfaceElement;
  };
  Gauge2.prototype.getSize = function getSize() {
    return this._getSize();
  };
  Gauge2.prototype._getSize = function _getSize() {
    var element2 = this.element;
    var defaultSize = this._defaultSize();
    var width = element2.offsetWidth;
    var height = element2.offsetHeight;
    if (!width) {
      width = defaultSize.width;
    }
    if (!height) {
      height = defaultSize.height;
    }
    return { width, height };
  };
  Gauge2.prototype._defaultSize = function _defaultSize() {
    return {
      width: DEFAULT_WIDTH2,
      height: DEFAULT_HEIGHT2
    };
  };
  Gauge2.prototype._toggleTransitions = function _toggleTransitions(value) {
    var this$1 = this;
    this.options.transitions = value;
    for (var i = 0; i < this.pointers.length; i++) {
      this$1.pointers[i].options.animation.transitions = value;
    }
  };
  return Gauge2;
}(class_default);
setDefaultOptions(Gauge, {
  plotArea: {},
  theme: "default",
  renderAs: "",
  pointer: {},
  scale: {},
  gaugeArea: {}
});
var gauge_default = Gauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-scale.js
var Path4 = drawing_exports.Path;
var Group3 = drawing_exports.Group;
var Point3 = geometry_exports.Point;
function renderAxisTick(tickRenderOptions, tickOptions) {
  var position3 = tickRenderOptions.position;
  var tickX = tickRenderOptions.tickX;
  var tickY = tickRenderOptions.tickY;
  var start, end;
  if (tickRenderOptions.vertical) {
    start = new Point3(tickX, position3);
    end = new Point3(tickX + tickOptions.size, position3);
  } else {
    start = new Point3(position3, tickY);
    end = new Point3(position3, tickY + tickOptions.size);
  }
  var tickPath = new Path4({
    stroke: {
      color: tickOptions.color,
      width: tickOptions.width
    }
  }).moveTo(start).lineTo(end);
  return tickPath;
}
function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {
  var count = tickPositions.length;
  if (tickOptions.visible) {
    var mirror = tickRenderOptions.mirror;
    var lineBox = tickRenderOptions.lineBox;
    for (var i = tickOptions.skip; i < count; i += tickOptions.step) {
      if (i % tickOptions.skipUnit === 0) {
        continue;
      }
      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickRenderOptions.position = tickPositions[i];
      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));
    }
  }
}
var LinearScale = function(NumericAxis2) {
  function LinearScale2(options2, service) {
    var scaleOptions = options2 || {};
    if (!defined2(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {
      scaleOptions = Object.assign({}, scaleOptions, {
        reverse: true
      });
    }
    NumericAxis2.call(this, 0, 1, scaleOptions, service);
    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;
  }
  if (NumericAxis2)
    LinearScale2.__proto__ = NumericAxis2;
  LinearScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  LinearScale2.prototype.constructor = LinearScale2;
  LinearScale2.prototype.initUserOptions = function initUserOptions(options2) {
    var scaleOptions = deepExtend({}, this.options, options2);
    scaleOptions = deepExtend({}, scaleOptions, { labels: { mirror: scaleOptions.mirror } });
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    return scaleOptions;
  };
  LinearScale2.prototype.initFields = function initFields() {
  };
  LinearScale2.prototype.render = function render() {
    var elements = this.elements = new Group3();
    var labels = this.renderLabels();
    var scaleLine = this.renderLine();
    var scaleTicks = this.renderTicks();
    var ranges = this.renderRanges();
    elements.append(scaleLine, labels, scaleTicks, ranges);
    return elements;
  };
  LinearScale2.prototype.renderRanges = function renderRanges() {
    var this$1 = this;
    var options2 = this.options;
    var min3 = options2.min;
    var max2 = options2.max;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var ranges = options2.ranges || [];
    var elements = new Group3();
    var count = ranges.length;
    var rangeSize = options2.rangeSize || options2.minorTicks.size / 2;
    for (var i = 0; i < count; i++) {
      var range = getRange(ranges[i], min3, max2);
      var slot = this$1.getSlot(range.from, range.to);
      var slotX = vertical ? this$1.lineBox() : slot;
      var slotY = vertical ? slot : this$1.lineBox();
      if (vertical) {
        slotX.x1 -= rangeSize * (mirror ? -1 : 1);
      } else {
        slotY.y2 += rangeSize * (mirror ? -1 : 1);
      }
      elements.append(Path4.fromRect(new geometry_exports.Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {
        fill: { color: range.color, opacity: range.opacity },
        stroke: {}
      }));
    }
    return elements;
  };
  LinearScale2.prototype.renderLabels = function renderLabels() {
    var ref2 = this;
    var labels = ref2.labels;
    var options2 = ref2.options;
    var elements = new Group3();
    for (var i = 0; i < labels.length; i++) {
      elements.append(buildLabelElement(labels[i], options2.labels));
    }
    return elements;
  };
  LinearScale2.prototype.renderLine = function renderLine() {
    var line = this.options.line;
    var lineBox = this.lineBox();
    var elements = new Group3();
    if (line.width > 0 && line.visible) {
      var linePath = new Path4({
        stroke: {
          color: line.color,
          dashType: line.dashType,
          width: line.width
        }
      });
      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      elements.append(linePath);
    }
    return elements;
  };
  LinearScale2.prototype.renderTicks = function renderTicks$1() {
    var ticks = new Group3();
    var options2 = this.options;
    var majorUnit = options2.majorTicks.visible ? options2.majorUnit : 0;
    var tickRenderOptions = {
      vertical: options2.vertical,
      mirror: options2.labels.mirror,
      lineBox: this.lineBox()
    };
    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options2.majorTicks);
    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {
      skipUnit: majorUnit / options2.minorUnit
    }, options2.minorTicks));
    return ticks;
  };
  return LinearScale2;
}(numeric_axis_default);
setDefaultOptions(LinearScale, {
  min: 0,
  max: 50,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  line: {
    width: DEFAULT_LINE_WIDTH
  },
  labels: {
    position: INSIDE2,
    padding: 2
  },
  mirror: false,
  _alignLines: false
});
var linear_scale_default = LinearScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/pointer.js
var Pointer = function(Class3) {
  function Pointer2(scale, userOptions) {
    Class3.call(this);
    var ref2 = scale.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var options2 = this.options = deepExtend({}, this.options, userOptions);
    options2.fill = options2.color;
    this.scale = scale;
    if (defined2(options2.value)) {
      options2.value = limitValue2(options2.value, min3, max2);
    } else {
      options2.value = min3;
    }
  }
  if (Class3)
    Pointer2.__proto__ = Class3;
  Pointer2.prototype = Object.create(Class3 && Class3.prototype);
  Pointer2.prototype.constructor = Pointer2;
  Pointer2.prototype.value = function value(newValue) {
    var options2 = this.options;
    var value2 = options2.value;
    if (arguments.length === 0) {
      return value2;
    }
    var ref2 = this.scale.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    options2._oldValue = defined2(options2._oldValue) ? options2.value : min3;
    options2.value = limitValue2(newValue, min3, max2);
    if (this.elements) {
      this.repaint();
    }
  };
  return Pointer2;
}(class_default);
setDefaultOptions(Pointer, {
  color: BLACK
});
var pointer_default = Pointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-pointer.js
var LinearPointer = function(Pointer2) {
  function LinearPointer2(scale, options2) {
    Pointer2.call(this, scale, options2);
    this.options = deepExtend({
      track: {
        visible: defined2(options2.track)
      }
    }, this.options);
  }
  if (Pointer2)
    LinearPointer2.__proto__ = Pointer2;
  LinearPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  LinearPointer2.prototype.constructor = LinearPointer2;
  LinearPointer2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options2 = ref2.options;
    var scale = ref2.scale;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var scaleLine = scale.lineBox();
    var trackSize = options2.track.size || options2.size;
    var pointerHalfSize = options2.size / 2;
    var margin = getSpacing(options2.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    var pointerBox, pointerRangeBox, trackBox;
    space = mirror ? -space : space;
    if (vertical) {
      trackBox = new box_default(
        scaleLine.x1 + space,
        scaleLine.y1,
        scaleLine.x1 + space,
        scaleLine.y2
      );
      if (mirror) {
        trackBox.x1 -= trackSize;
      } else {
        trackBox.x2 += trackSize;
      }
      if (options2.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x2 + space,
          scaleLine.y1 - pointerHalfSize,
          scaleLine.x2 + space,
          scaleLine.y2 + pointerHalfSize
        );
        pointerBox = pointerRangeBox;
      }
    } else {
      trackBox = new box_default(
        scaleLine.x1,
        scaleLine.y1 - space,
        scaleLine.x2,
        scaleLine.y1 - space
      );
      if (mirror) {
        trackBox.y2 += trackSize;
      } else {
        trackBox.y1 -= trackSize;
      }
      if (options2.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x1 - pointerHalfSize,
          scaleLine.y1 - space,
          scaleLine.x2 + pointerHalfSize,
          scaleLine.y1 - space
        );
        pointerBox = pointerRangeBox;
      }
    }
    this.trackBox = trackBox;
    this.pointerRangeBox = pointerRangeBox;
    this.box = pointerBox || trackBox.clone().pad(options2.border.width);
  };
  LinearPointer2.prototype.getElementOptions = function getElementOptions() {
    var options2 = this.options;
    return {
      fill: {
        color: options2.color,
        opacity: options2.opacity
      },
      stroke: defined2(options2.border) ? {
        color: options2.border.width ? options2.border.color || options2.color : "",
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: options2.opacity
      } : null
    };
  };
  LinearPointer2.prototype._margin = function _margin() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var margin = getSpacing(options2.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    return space;
  };
  return LinearPointer2;
}(pointer_default);
setDefaultOptions(LinearPointer, {
  shape: BAR_POINTER,
  track: {
    border: {
      width: 1
    }
  },
  color: BLACK,
  border: {
    width: 1
  },
  opacity: 1,
  margin: getSpacing(3),
  animation: {
    type: BAR_POINTER
  },
  visible: true
});
var linear_pointer_default = LinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer-animation.js
var ArrowLinearPointerAnimation = function(superclass) {
  function ArrowLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    ArrowLinearPointerAnimation2.__proto__ = superclass;
  ArrowLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ArrowLinearPointerAnimation2.prototype.constructor = ArrowLinearPointerAnimation2;
  ArrowLinearPointerAnimation2.prototype.setup = function setup() {
    var options2 = this.options;
    var margin = options2.margin;
    var from = options2.from;
    var to = options2.to;
    var vertical = options2.vertical;
    var axis = vertical ? "x1" : "y1";
    if (options2.mirror === vertical) {
      from[axis] -= margin;
      to[axis] -= margin;
    } else {
      from[axis] += margin;
      to[axis] += margin;
    }
    var fromScale = this.fromScale = new geometry_exports.Point(from.x1, from.y1);
    var toScale = this.toScale = new geometry_exports.Point(to.x1, to.y1);
    if (options2.duration !== 0) {
      options2.duration = Math.max(fromScale.distanceTo(toScale) / options2.duration * 1e3, 1);
    }
  };
  ArrowLinearPointerAnimation2.prototype.step = function step(pos) {
    var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);
    var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);
    this.element.transform(geometry_exports.transform().translate(translateX, translateY));
  };
  return ArrowLinearPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(ArrowLinearPointerAnimation, {
  easing: LINEAR2,
  duration: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);
var arrow_linear_pointer_animation_default = ArrowLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer.js
var Point4 = geometry_exports.Point;
var Path5 = drawing_exports.Path;
var ArrowLinearPointer = function(LinearPointer2) {
  function ArrowLinearPointer2(scale, options2) {
    LinearPointer2.call(this, scale, options2);
    if (!defined2(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.6;
    }
  }
  if (LinearPointer2)
    ArrowLinearPointer2.__proto__ = LinearPointer2;
  ArrowLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  ArrowLinearPointer2.prototype.constructor = ArrowLinearPointer2;
  ArrowLinearPointer2.prototype.pointerShape = function pointerShape() {
    var ref2 = this;
    var scale = ref2.scale;
    var size = ref2.options.size;
    var halfSize = size / 2;
    var sign = scale.options.mirror ? -1 : 1;
    var shape2;
    if (scale.options.vertical) {
      shape2 = [
        new Point4(0, 0 - halfSize),
        new Point4(0 - sign * size, 0),
        new Point4(0, 0 + halfSize)
      ];
    } else {
      shape2 = [
        new Point4(0 - halfSize, 0),
        new Point4(0, 0 + sign * size),
        new Point4(0 + halfSize, 0)
      ];
    }
    return shape2;
  };
  ArrowLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var animation = new arrow_linear_pointer_animation_default(this.elements, deepExtend(options2.animation, {
      vertical: scale.options.vertical,
      mirror: scale.options.mirror,
      margin: this._margin(options2.margin),
      from: scale.getSlot(options2._oldValue),
      to: scale.getSlot(options2.value)
    }));
    if (options2.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  ArrowLinearPointer2.prototype.render = function render() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var elementOptions = this.getElementOptions();
    var shape2 = this.pointerShape(options2.value);
    options2.animation.type = ARROW_POINTER;
    var elements = new Path5({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    }).moveTo(shape2[0]).lineTo(shape2[1]).lineTo(shape2[2]).close();
    var slot = scale.getSlot(options2.value);
    elements.transform(geometry_exports.transform().translate(slot.x1, slot.y1));
    this.elements = elements;
    return elements;
  };
  return ArrowLinearPointer2;
}(linear_pointer_default);
var arrow_linear_pointer_default = ArrowLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer-animation.js
var BarLinearPointerAnimation = function(superclass) {
  function BarLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BarLinearPointerAnimation2.__proto__ = superclass;
  BarLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarLinearPointerAnimation2.prototype.constructor = BarLinearPointerAnimation2;
  BarLinearPointerAnimation2.prototype.setup = function setup() {
    var options2 = this.options;
    var axis = this.axis = options2.vertical ? Y : X;
    var to = this.to = options2.newPoints[0][axis];
    var from = this.from = options2.oldPoints[0][axis];
    if (options2.duration !== 0) {
      options2.duration = Math.max(Math.abs(to - from) / options2.speed * 1e3, 1);
    }
    this._set(from);
  };
  BarLinearPointerAnimation2.prototype.step = function step(pos) {
    var value = interpolateValue(this.from, this.to, pos);
    this._set(value);
  };
  BarLinearPointerAnimation2.prototype._set = function _set(value) {
    var setter = "set" + this.axis.toUpperCase();
    var points3 = this.options.newPoints;
    points3[0][setter](value);
    points3[1][setter](value);
  };
  return BarLinearPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BarLinearPointerAnimation, {
  easing: LINEAR2,
  speed: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);
var bar_linear_pointer_animation_default = BarLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer.js
var Group4 = drawing_exports.Group;
var Path6 = drawing_exports.Path;
var BarLinearPointer = function(LinearPointer2) {
  function BarLinearPointer2(scale, options2) {
    LinearPointer2.call(this, scale, options2);
    if (!defined2(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.3;
    }
  }
  if (LinearPointer2)
    BarLinearPointer2.__proto__ = LinearPointer2;
  BarLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  BarLinearPointer2.prototype.constructor = BarLinearPointer2;
  BarLinearPointer2.prototype.pointerShape = function pointerShape(value) {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var dir = mirror === vertical ? -1 : 1;
    var size = options2.size * dir;
    var minSlot = scale.getSlot(scale.options.min);
    var slot = scale.getSlot(value);
    var axis = vertical ? Y : X;
    var sizeAxis = vertical ? X : Y;
    var margin = this._margin() * dir;
    var p1 = new geometry_exports.Point();
    p1[axis] = minSlot[axis + "1"];
    p1[sizeAxis] = minSlot[sizeAxis + "1"];
    var p2 = new geometry_exports.Point();
    p2[axis] = slot[axis + "1"];
    p2[sizeAxis] = slot[sizeAxis + "1"];
    if (vertical) {
      p1.translate(margin, 0);
      p2.translate(margin, 0);
    } else {
      p1.translate(0, margin);
      p2.translate(0, margin);
    }
    var p3 = p2.clone();
    var p4 = p1.clone();
    if (vertical) {
      p3.translate(size, 0);
      p4.translate(size, 0);
    } else {
      p3.translate(0, size);
      p4.translate(0, size);
    }
    return [p1, p2, p3, p4];
  };
  BarLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var shape2 = this.pointerShape(options2.value);
    var pointerPath = this.pointerPath;
    var oldShape = this.pointerShape(options2._oldValue);
    pointerPath.moveTo(shape2[0]).lineTo(shape2[1]).lineTo(shape2[2]).lineTo(shape2[3]).close();
    var animation = new bar_linear_pointer_animation_default(pointerPath, deepExtend(options2.animation, {
      reverse: scale.options.reverse,
      vertical: scale.options.vertical,
      oldPoints: [oldShape[1], oldShape[2]],
      newPoints: [shape2[1], shape2[2]]
    }));
    if (options2.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  BarLinearPointer2.prototype.render = function render() {
    var group = new Group4();
    var elementOptions = this.getElementOptions();
    if (this.options.track.visible) {
      group.append(this.renderTrack());
    }
    var pointer = this.pointerPath = new Path6({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    });
    group.append(pointer);
    this.elements = group;
    return group;
  };
  BarLinearPointer2.prototype.renderTrack = function renderTrack() {
    var trackOptions = this.options.track;
    var border = trackOptions.border || {};
    var trackBox = this.trackBox.clone().pad(border.width || 0);
    return new Path6.fromRect(trackBox.toRect(), {
      fill: {
        color: trackOptions.color,
        opacity: trackOptions.opacity
      },
      stroke: {
        color: border.width ? border.color || trackOptions.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
  };
  return BarLinearPointer2;
}(linear_pointer_default);
var bar_linear_pointer_default = BarLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-gauge.js
var DEFAULT_MIN_WIDTH = 60;
var DEFAULT_MIN_HEIGHT = 60;
var Group5 = drawing_exports.Group;
var LinearGauge = function(Gauge2) {
  function LinearGauge2() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2)
    LinearGauge2.__proto__ = Gauge2;
  LinearGauge2.prototype = Object.create(Gauge2 && Gauge2.prototype);
  LinearGauge2.prototype.constructor = LinearGauge2;
  LinearGauge2.prototype.reflow = function reflow(bbox) {
    var pointers = this.pointers;
    var bboxX = bbox.origin.x;
    var bboxY = bbox.origin.y;
    var box = new box_default(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());
    this.scale.reflow(box);
    this._shrinkScaleWidth(box);
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow();
    }
    this.bbox = this._getBox(box);
    this._alignElements();
    this._shrinkElements();
    this._buildVisual();
    this._draw();
  };
  LinearGauge2.prototype._buildVisual = function _buildVisual() {
    var visuals = new Group5();
    var scaleElements = this.scale.render();
    var pointers = this.pointers;
    visuals.append(this.gaugeArea);
    visuals.append(scaleElements);
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      visuals.append(current4.render());
      current4.value(current4.options.value);
    }
    this._visuals = visuals;
  };
  LinearGauge2.prototype._createModel = function _createModel() {
    var this$1 = this;
    var options2 = this.options;
    var scale = this.scale = new linear_scale_default(options2.scale, this.contextService);
    this.pointers = [];
    var pointers = options2.pointer;
    pointers = isArray(pointers) ? pointers : [pointers];
    for (var i = 0; i < pointers.length; i++) {
      var currentOptions = deepExtend({}, pointers[i], {
        animation: {
          transitions: options2.transitions
        }
      });
      var pointerType = currentOptions.shape === ARROW ? arrow_linear_pointer_default : bar_linear_pointer_default;
      this$1.pointers.push(new pointerType(scale, currentOptions));
    }
  };
  LinearGauge2.prototype._defaultSize = function _defaultSize() {
    var vertical = this.options.scale.vertical;
    return {
      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH2,
      height: vertical ? DEFAULT_HEIGHT2 : DEFAULT_MIN_HEIGHT
    };
  };
  LinearGauge2.prototype._getBox = function _getBox(box) {
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var boxCenter = box.center();
    var plotAreaBox = pointers[0].box.clone().wrap(scale.box);
    for (var i = 0; i < pointers.length; i++) {
      plotAreaBox.wrap(pointers[i].box.clone());
    }
    var size;
    if (scale.options.vertical) {
      size = plotAreaBox.width() / 2;
      plotAreaBox = new box_default(
        boxCenter.x - size,
        box.y1,
        boxCenter.x + size,
        box.y2
      );
    } else {
      size = plotAreaBox.height() / 2;
      plotAreaBox = new box_default(
        box.x1,
        boxCenter.y - size,
        box.x2,
        boxCenter.y + size
      );
    }
    return plotAreaBox;
  };
  LinearGauge2.prototype._alignElements = function _alignElements() {
    var this$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box;
    var box = pointers[0].box.clone().wrap(scale.box);
    var plotAreaBox = this.bbox;
    for (var i = 0; i < pointers.length; i++) {
      box.wrap(pointers[i].box.clone());
    }
    var diff;
    if (scale.options.vertical) {
      diff = plotAreaBox.center().x - box.center().x;
      scale.reflow(new box_default(
        scaleBox.x1 + diff,
        plotAreaBox.y1,
        scaleBox.x2 + diff,
        plotAreaBox.y2
      ));
    } else {
      diff = plotAreaBox.center().y - box.center().y;
      scale.reflow(new box_default(
        scaleBox.x1,
        scaleBox.y1 + diff,
        scaleBox.x2,
        scaleBox.y2 + diff
      ));
    }
    for (var i$1 = 0; i$1 < pointers.length; i$1++) {
      pointers[i$1].reflow(this$1.bbox);
    }
  };
  LinearGauge2.prototype._shrinkScaleWidth = function _shrinkScaleWidth(bbox) {
    var ref2 = this;
    var scale = ref2.scale;
    if (!scale.options.vertical) {
      var overflow = scale.contentBox().width() - bbox.width();
      if (overflow > 0) {
        scale.box.shrink(overflow, 0);
        scale.box.alignTo(bbox, "center");
        scale.reflow(scale.box);
      }
    }
  };
  LinearGauge2.prototype._shrinkElements = function _shrinkElements() {
    var this$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box.clone();
    var pos = scale.options.vertical ? "y" : "x";
    var pointerBox = pointers[0].box;
    for (var i = 0; i < pointers.length; i++) {
      pointerBox.wrap(pointers[i].box.clone());
    }
    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);
    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);
    scale.reflow(scaleBox);
    for (var i$1 = 0; i$1 < pointers.length; i$1++) {
      pointers[i$1].reflow(this$1.bbox);
    }
  };
  return LinearGauge2;
}(gauge_default);
setDefaultOptions(LinearGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  },
  scale: {
    vertical: true
  }
});

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-scale.js
var GEO_ARC_ADJUST_ANGLE = 180;
var Arc3 = drawing_exports.Arc;
var Path7 = drawing_exports.Path;
var Group6 = drawing_exports.Group;
function drawTicks(arc, tickAngles, unit, tickOptions) {
  var ticks = new Group6();
  var center = arc.center;
  var radius = arc.getRadiusX();
  if (tickOptions.visible) {
    for (var i = 0; i < tickAngles.length; i++) {
      var tickStart = arc.pointAt(tickAngles[i]);
      var tickEnd = new geometry_exports.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);
      ticks.append(new Path7({
        stroke: {
          color: tickOptions.color,
          width: tickOptions.width
        }
      }).moveTo(tickStart).lineTo(tickEnd));
    }
  }
  return ticks;
}
function rangeSegment(from, to, color, opacity) {
  return { from, to, color, opacity };
}
var RadialScale = function(NumericAxis2) {
  function RadialScale2(options2, service) {
    NumericAxis2.call(this, 0, 1, options2, service);
  }
  if (NumericAxis2)
    RadialScale2.__proto__ = NumericAxis2;
  RadialScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadialScale2.prototype.constructor = RadialScale2;
  RadialScale2.prototype.initUserOptions = function initUserOptions(options2) {
    var scaleOptions = deepExtend({}, this.options, options2);
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;
    return scaleOptions;
  };
  RadialScale2.prototype.initFields = function initFields() {
  };
  RadialScale2.prototype.render = function render(center, radius) {
    var arc = this.renderArc(center, radius);
    this.bbox = arc.bbox();
    this.labelElements = this.renderLabels();
    this.ticks = this.renderTicks();
    this.ranges = this.renderRanges();
  };
  RadialScale2.prototype.reflow = function reflow(bbox) {
    var center = bbox.center();
    var radius = Math.min(bbox.height(), bbox.width()) / 2;
    if (defined2(this.bbox)) {
      this.bbox = this.arc.bbox();
      this.radius(this.arc.getRadiusX());
      this.repositionRanges();
      this.renderLabels();
    } else {
      return this.render(center, radius);
    }
  };
  RadialScale2.prototype.slotAngle = function slotAngle(value) {
    var ref2 = this.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var reverse = ref2.reverse;
    var startAngle = ref2.startAngle;
    var endAngle = ref2.endAngle;
    var angle = endAngle - startAngle;
    var result;
    if (reverse) {
      result = endAngle - (value - min3) / (max2 - min3) * angle;
    } else {
      result = (value - min3) / (max2 - min3) * angle + startAngle;
    }
    return result + GEO_ARC_ADJUST_ANGLE;
  };
  RadialScale2.prototype.hasRanges = function hasRanges() {
    var ranges = this.options.ranges;
    return ranges && ranges.length;
  };
  RadialScale2.prototype.ticksSize = function ticksSize() {
    var ref2 = this.options;
    var majorTicks = ref2.majorTicks;
    var minorTicks = ref2.minorTicks;
    var size = 0;
    if (majorTicks.visible) {
      size = majorTicks.size;
    }
    if (minorTicks.visible) {
      size = Math.max(minorTicks.size, size);
    }
    return size;
  };
  RadialScale2.prototype.labelsCount = function labelsCount() {
    var count = NumericAxis2.prototype.labelsCount.call(this);
    var options2 = this.options;
    var angle = options2.endAngle - options2.startAngle;
    if (angle >= 360 && options2.max % options2.majorUnit === 0) {
      count -= 1;
    }
    return count;
  };
  RadialScale2.prototype.renderLabels = function renderLabels() {
    var this$1 = this;
    var options2 = this.options;
    var arc = this.arc.clone();
    var radius = arc.getRadiusX();
    var tickAngles = this.tickAngles(arc, options2.majorUnit);
    var rangeSize = options2.rangeSize = options2.rangeSize || radius * 0.1;
    var labelsGroup = new Group6();
    var rangeDistance = radius * 0.05;
    if (defined2(options2.rangeDistance)) {
      rangeDistance = options2.rangeDistance;
    } else {
      options2.rangeDistance = rangeDistance;
    }
    var labelsOptions = options2.labels;
    var isInside = labelsOptions.position === INSIDE2;
    var hasLabelElements = defined2(this.labelElements);
    if (isInside) {
      radius -= this.ticksSize();
      if (this.hasRanges() && !hasLabelElements) {
        radius -= rangeSize + rangeDistance;
      }
      arc.setRadiusX(radius).setRadiusY(radius);
    }
    var labels = this.labels;
    var count = labels.length;
    var padding = getSpacing(labelsOptions.padding);
    var paddingWidth = (padding.left + padding.right) / 2;
    var paddingHeight = (padding.top + padding.bottom) / 2;
    for (var i = 0; i < count; i++) {
      var label = labels[i];
      var halfWidth = label.box.width() / 2;
      var halfHeight = label.box.height() / 2;
      var angle = tickAngles[i];
      var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;
      var lp = arc.pointAt(angle);
      var cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);
      var cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);
      label.reflow(new box_default(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));
      var labelPos = new geometry_exports.Point(label.box.x1, label.box.y1);
      var labelElement = void 0;
      if (!hasLabelElements) {
        labelElement = buildLabelElement(label, options2.labels);
        labelsGroup.append(labelElement);
      } else {
        labelElement = this$1.labelElements.children[i];
        var prevLabelPos = labelElement.bbox().origin;
        var labelTransform = labelElement.transform() || geometry_exports.transform();
        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);
        labelElement.transform(labelTransform);
      }
      this$1.bbox = geometry_exports.Rect.union(this$1.bbox, labelElement.bbox());
    }
    return labelsGroup;
  };
  RadialScale2.prototype.repositionRanges = function repositionRanges() {
    var ranges = this.ranges.children;
    if (ranges.length > 0) {
      var ref2 = this.options;
      var rangeDistance = ref2.rangeDistance;
      var rangeSize = ref2.rangeSize;
      var rangeRadius = this.getRangeRadius();
      if (this.options.labels.position === INSIDE2) {
        rangeRadius += rangeSize + rangeDistance;
      }
      var newRadius = rangeRadius + rangeSize / 2;
      for (var i = 0; i < ranges.length; i++) {
        ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);
      }
      this.bbox = geometry_exports.Rect.union(this.bbox, this.ranges.bbox());
    }
  };
  RadialScale2.prototype.renderRanges = function renderRanges() {
    var this$1 = this;
    var segments = this.rangeSegments();
    var segmentsCount = segments.length;
    var result = new Group6();
    if (segmentsCount) {
      var ref2 = this.options;
      var rangeSize = ref2.rangeSize;
      var reverse = ref2.reverse;
      var rangeDistance = ref2.rangeDistance;
      var rangeRadius = this.getRangeRadius();
      this.radius(this.radius() - rangeSize - rangeDistance);
      for (var i = 0; i < segmentsCount; i++) {
        var segment = segments[i];
        var from = this$1.slotAngle(segment[reverse ? "to" : "from"]);
        var to = this$1.slotAngle(segment[!reverse ? "to" : "from"]);
        if (to - from !== 0) {
          result.append(this$1.createRange(from, to, rangeRadius, segment));
        }
      }
    }
    return result;
  };
  RadialScale2.prototype.createRange = function createRange(startAngle, endAngle, rangeRadius, options2) {
    var rangeSize = this.options.rangeSize;
    var rangeGeom = new geometry_exports.Arc(this.arc.center, {
      radiusX: rangeRadius + rangeSize / 2,
      radiusY: rangeRadius + rangeSize / 2,
      startAngle,
      endAngle
    });
    return new Arc3(rangeGeom, {
      stroke: {
        width: rangeSize,
        color: options2.color,
        opacity: options2.opacity,
        lineCap: options2.lineCap
      }
    });
  };
  RadialScale2.prototype.rangeSegments = function rangeSegments() {
    var options2 = this.options;
    var ranges = options2.ranges || [];
    var count = ranges.length;
    var segments = [];
    if (count) {
      var min3 = options2.min;
      var max2 = options2.max;
      var defaultColor = options2.rangePlaceholderColor;
      segments.push(rangeSegment(min3, max2, defaultColor));
      for (var i = 0; i < count; i++) {
        var range = getRange(ranges[i], min3, max2);
        var segmentsCount = segments.length;
        for (var j = 0; j < segmentsCount; j++) {
          var segment = segments[j];
          if (segment.from <= range.from && range.from <= segment.to) {
            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));
            if (segment.from <= range.to && range.to <= segment.to) {
              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));
            }
            segment.to = range.from;
            break;
          }
        }
      }
    }
    return segments;
  };
  RadialScale2.prototype.getRangeRadius = function getRangeRadius() {
    var ref2 = this;
    var arc = ref2.arc;
    var options2 = ref2.options;
    var rangeSize = options2.rangeSize;
    var rangeDistance = options2.rangeDistance;
    var majorTickSize = options2.majorTicks.size;
    var radius;
    if (options2.labels.position === OUTSIDE2) {
      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;
    } else {
      radius = arc.getRadiusX() - rangeSize;
    }
    return radius;
  };
  RadialScale2.prototype.renderArc = function renderArc(center, radius) {
    var options2 = this.options;
    var arc = this.arc = new geometry_exports.Arc(center, {
      radiusX: radius,
      radiusY: radius,
      startAngle: options2.startAngle + GEO_ARC_ADJUST_ANGLE,
      endAngle: options2.endAngle + GEO_ARC_ADJUST_ANGLE
    });
    return arc;
  };
  RadialScale2.prototype.renderTicks = function renderTicks2() {
    var ref2 = this;
    var arc = ref2.arc;
    var options2 = ref2.options;
    var tickArc = arc.clone();
    this.majorTickAngles = this.tickAngles(arc, options2.majorUnit);
    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options2.majorUnit, options2.majorTicks);
    var allTicks = new Group6();
    allTicks.append(this.majorTicks);
    var majorTickSize = options2.majorTicks.size;
    var minorTickSize = options2.minorTicks.size;
    this._tickDifference = majorTickSize - minorTickSize;
    if (options2.labels.position === OUTSIDE2) {
      var radius = tickArc.getRadiusX();
      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);
    }
    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options2.minorUnit));
    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options2.minorUnit, options2.minorTicks);
    allTicks.append(this.minorTicks);
    return allTicks;
  };
  RadialScale2.prototype.normalizeTickAngles = function normalizeTickAngles(angles) {
    var options2 = this.options;
    var skip = options2.majorUnit / options2.minorUnit;
    for (var i = angles.length - 1; i >= 0; i--) {
      if (i % skip === 0) {
        angles.splice(i, 1);
      }
    }
    return angles;
  };
  RadialScale2.prototype.tickAngles = function tickAngles(ring, stepValue) {
    var options2 = this.options;
    var reverse = options2.reverse;
    var range = options2.max - options2.min;
    var angle = ring.endAngle - ring.startAngle;
    var tickCount = range / stepValue;
    var pos = ring.startAngle;
    var step = angle / tickCount;
    if (reverse) {
      pos += angle;
      step = -step;
    }
    if (angle >= 360 && options2.max % stepValue === 0) {
      tickCount -= 1;
    }
    var positions = [];
    for (var i = 0; i < tickCount; i++) {
      positions.push(round3(pos, COORD_PRECISION));
      pos += step;
    }
    if (round3(pos) <= ring.endAngle) {
      positions.push(pos);
    }
    return positions;
  };
  RadialScale2.prototype.radius = function radius(value) {
    if (value) {
      this.arc.setRadiusX(value).setRadiusY(value);
      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);
      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);
    } else {
      return this.arc.getRadiusX();
    }
  };
  RadialScale2.prototype.repositionTicks = function repositionTicks(ticks, tickAngles, minor) {
    var diff = minor ? this._tickDifference || 0 : 0;
    var tickArc = this.arc;
    var radius = tickArc.getRadiusX();
    if (minor && this.options.labels.position === OUTSIDE2 && diff !== 0) {
      tickArc = this.arc.clone();
      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);
    }
    for (var i = 0; i < ticks.length; i++) {
      var newPoint = tickArc.pointAt(tickAngles[i]);
      var segments = ticks[i].segments;
      var xDiff = newPoint.x - segments[0].anchor().x;
      var yDiff = newPoint.y - segments[0].anchor().y;
      ticks[i].transform(new geometry_exports.transform().translate(xDiff, yDiff));
    }
  };
  return RadialScale2;
}(numeric_axis_default);
setDefaultOptions(RadialScale, {
  min: 0,
  max: 100,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  startAngle: -30,
  endAngle: 210,
  labels: {
    position: INSIDE2,
    padding: 2
  }
});
var radial_scale_default = RadialScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer-animation.js
var RadialPointerAnimation = function(superclass) {
  function RadialPointerAnimation2(element2, options2) {
    superclass.call(this, element2, options2);
    var animationOptions = this.options;
    animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3, 1);
  }
  if (superclass)
    RadialPointerAnimation2.__proto__ = superclass;
  RadialPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RadialPointerAnimation2.prototype.constructor = RadialPointerAnimation2;
  RadialPointerAnimation2.prototype.step = function step(pos) {
    var options2 = this.options;
    var angle = interpolateValue(options2.oldAngle, options2.newAngle, pos);
    this.element.transform(geometry_exports.transform().rotate(angle, options2.center));
  };
  return RadialPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(RadialPointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);
var radial_pointer_animation_default = RadialPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer.js
var CAP_SIZE = 0.05;
var Circle3 = drawing_exports.Circle;
var Group7 = drawing_exports.Group;
var Path8 = drawing_exports.Path;
var RadialPointer = function(Pointer2) {
  function RadialPointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2)
    RadialPointer2.__proto__ = Pointer2;
  RadialPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RadialPointer2.prototype.constructor = RadialPointer2;
  RadialPointer2.prototype.setAngle = function setAngle(angle) {
    this.elements.transform(geometry_exports.transform().rotate(angle, this.center));
  };
  RadialPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var oldAngle = scale.slotAngle(options2._oldValue);
    var newAngle = scale.slotAngle(options2.value);
    if (options2.animation.transitions === false) {
      this.setAngle(newAngle);
    } else {
      new radial_pointer_animation_default(this.elements, deepExtend(options2.animation, {
        oldAngle,
        newAngle
      })).play();
    }
  };
  RadialPointer2.prototype.render = function render() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var elements = new Group7();
    if (options2.animation !== false) {
      deepExtend(options2.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    elements.append(this._renderNeedle(), this._renderCap());
    this.elements = elements;
    this.setAngle(DEGREE);
    return elements;
  };
  RadialPointer2.prototype.reflow = function reflow(arc) {
    var center = this.center = arc.center;
    var length = limitValue2(this.options.length || 1, 0.1, 1.5);
    var radius = this.radius = arc.getRadiusX() * length;
    var capSize = this.capSize = Math.round(radius * this.options.cap.size);
    this.bbox = geometry_exports.Rect.fromPoints(
      new geometry_exports.Point(center.x - capSize, center.y - capSize),
      new geometry_exports.Point(center.x + capSize, center.y + capSize)
    );
  };
  RadialPointer2.prototype._renderNeedle = function _renderNeedle() {
    var minorTickSize = this.scale.options.minorTicks.size;
    var center = this.center;
    var needleColor = this.options.color;
    var needlePath = new Path8({
      fill: { color: needleColor },
      stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }
    });
    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();
    return needlePath;
  };
  RadialPointer2.prototype._renderCap = function _renderCap() {
    var options2 = this.options;
    var capColor = options2.cap.color || options2.color;
    var circle = new geometry_exports.Circle(this.center, this.capSize);
    var cap = new Circle3(circle, {
      fill: { color: capColor },
      stroke: { color: capColor }
    });
    return cap;
  };
  return RadialPointer2;
}(pointer_default);
setDefaultOptions(RadialPointer, {
  cap: {
    size: CAP_SIZE
  },
  arrow: {
    width: 16,
    height: 14
  },
  animation: {
    type: RADIAL_POINTER,
    duration: ANGULAR_SPEED
  }
});
var radial_pointer_default = RadialPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-gauge.js
var Group8 = drawing_exports.Group;
var RadialGauge = function(Gauge2) {
  function RadialGauge2() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2)
    RadialGauge2.__proto__ = Gauge2;
  RadialGauge2.prototype = Object.create(Gauge2 && Gauge2.prototype);
  RadialGauge2.prototype.constructor = RadialGauge2;
  RadialGauge2.prototype.reflow = function reflow(bbox) {
    var this$1 = this;
    var pointers = this.pointers;
    this.scale.reflow(bbox);
    this._initialPlotArea = this.scale.bbox;
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(this$1.scale.arc);
      this$1._initialPlotArea = geometry_exports.Rect.union(this$1._initialPlotArea, pointers[i].bbox);
    }
    this.fitScale(bbox);
    this.alignScale(bbox);
    this._buildVisual(this.gaugeArea, pointers, this.scale);
    this._draw();
  };
  RadialGauge2.prototype._buildVisual = function _buildVisual(gaugeArea, pointers, scale) {
    var visuals = this._visuals = new Group8();
    visuals.append(gaugeArea);
    visuals.append(scale.ticks);
    visuals.append(scale.ranges);
    this._buildPointers(pointers);
    visuals.append(scale.labelElements);
  };
  RadialGauge2.prototype._buildPointers = function _buildPointers(pointers) {
    var this$1 = this;
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      current4.render();
      this$1._visuals.append(current4.elements);
      current4.value(current4.options.value);
    }
  };
  RadialGauge2.prototype.fitScale = function fitScale(bbox) {
    var this$1 = this;
    var arc = this.scale.arc;
    var plotAreaBox = this._initialPlotArea;
    var step = Math.abs(this.getDiff(plotAreaBox, bbox));
    var min3 = round3(step, COORD_PRECISION);
    var max2 = round3(-step, COORD_PRECISION);
    var minDiff, midDiff, maxDiff, mid, oldDiff;
    var staleFlag = 0;
    var i = 0;
    while (i++ < 100) {
      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;
      if (staleFlag > 5) {
        break;
      }
      if (min3 !== mid) {
        minDiff = this$1.getPlotBox(min3, bbox, arc);
        if (0 <= minDiff && minDiff <= 2) {
          break;
        }
      }
      if (max2 !== mid) {
        maxDiff = this$1.getPlotBox(max2, bbox, arc);
        if (0 <= maxDiff && maxDiff <= 2) {
          break;
        }
      }
      if (minDiff > 0 && maxDiff > 0) {
        mid = min3 * 2;
      } else if (minDiff < 0 && maxDiff < 0) {
        mid = max2 * 2;
      } else {
        mid = round3((min3 + max2) / 2 || 1, COORD_PRECISION);
      }
      midDiff = this$1.getPlotBox(mid, bbox, arc);
      if (0 <= midDiff && midDiff <= 2) {
        break;
      }
      oldDiff = maxDiff;
      if (midDiff > 0) {
        max2 = mid;
        maxDiff = midDiff;
      } else {
        min3 = mid;
        minDiff = midDiff;
      }
    }
  };
  RadialGauge2.prototype.getPlotBox = function getPlotBox(step, bbox, arc) {
    var this$1 = this;
    var scale = this.scale;
    var pointers = this.pointers;
    var radius = arc.getRadiusX();
    var scaleArc = arc.clone();
    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);
    scale.arc = scaleArc;
    scale.reflow(bbox);
    this.plotBbox = scale.bbox;
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(scaleArc);
      this$1.plotBbox = geometry_exports.Rect.union(this$1.plotBbox, pointers[i].bbox);
    }
    return this.getDiff(this.plotBbox, bbox);
  };
  RadialGauge2.prototype.getDiff = function getDiff(plotBox, box) {
    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());
  };
  RadialGauge2.prototype.alignScale = function alignScale(bbox) {
    var this$1 = this;
    var plotBoxCenter = this.plotBbox.center();
    var boxCenter = bbox.center();
    var paddingX = plotBoxCenter.x - boxCenter.x;
    var paddingY = plotBoxCenter.y - boxCenter.y;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    scale.arc.center.x -= paddingX;
    scale.arc.center.y -= paddingY;
    scale.reflow(bbox);
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(scale.arc);
      this$1.plotBbox = geometry_exports.Rect.union(scale.bbox, pointers[i].bbox);
    }
  };
  RadialGauge2.prototype._createModel = function _createModel() {
    var this$1 = this;
    var options2 = this.options;
    var pointers = options2.pointer;
    var scale = this.scale = new radial_scale_default(options2.scale, this.contextService);
    this.pointers = [];
    var pointersArr = isArray(pointers) ? pointers : [pointers];
    for (var i = 0; i < pointersArr.length; i++) {
      var current4 = new radial_pointer_default(scale, deepExtend({}, pointersArr[i], {
        animation: {
          transitions: options2.transitions
        }
      }));
      this$1.pointers.push(current4);
    }
  };
  return RadialGauge2;
}(gauge_default);
setDefaultOptions(RadialGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  }
});
var radial_gauge_default = RadialGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-scale.js
var ArcScale = function(RadialScale2) {
  function ArcScale2() {
    RadialScale2.apply(this, arguments);
  }
  if (RadialScale2)
    ArcScale2.__proto__ = RadialScale2;
  ArcScale2.prototype = Object.create(RadialScale2 && RadialScale2.prototype);
  ArcScale2.prototype.constructor = ArcScale2;
  ArcScale2.prototype.rangeSegments = function rangeSegments() {
    var ref2 = this.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var rangePlaceholderColor = ref2.rangePlaceholderColor;
    var rangeLineCap = ref2.rangeLineCap;
    return [{ from: min3, to: max2, color: rangePlaceholderColor, lineCap: rangeLineCap }];
  };
  ArcScale2.prototype.hasRanges = function hasRanges() {
    return true;
  };
  ArcScale2.prototype.placeholderRangeAngle = function placeholderRangeAngle(angle) {
    var geometry = this.ranges.children[0].geometry();
    if (this.options.reverse) {
      geometry.setEndAngle(angle);
    } else {
      geometry.setStartAngle(angle);
    }
  };
  ArcScale2.prototype.addRange = function addRange(from, to, options2) {
    var reverse = this.options.reverse;
    var startAngle = this.slotAngle(reverse ? to : from);
    var endAngle = this.slotAngle(reverse ? from : to);
    var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options2);
    this.ranges.append(range);
    return range;
  };
  return ArcScale2;
}(radial_scale_default);
setDefaultOptions(ArcScale, {
  min: 0,
  max: 100,
  majorTicks: {
    visible: false
  },
  minorTicks: {
    visible: false
  },
  labels: {
    visible: false
  },
  startAngle: 0,
  endAngle: 180,
  rangeLineCap: "round"
});
var arc_scale_default = ArcScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer-animation.js
var MAX_DURATION = 800;
var RangePointerAnimation = function(superclass) {
  function RangePointerAnimation2(element2, options2) {
    superclass.call(this, element2, options2);
    var animationOptions = this.options;
    var duration2 = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3;
    animationOptions.duration = limitValue2(duration2, ANGULAR_SPEED, MAX_DURATION);
    var startColor = element2.elements.options.get("stroke.color");
    var color = element2.currentColor();
    if (startColor !== color) {
      this.startColor = new color_default(startColor);
      this.color = new color_default(color);
    }
  }
  if (superclass)
    RangePointerAnimation2.__proto__ = superclass;
  RangePointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RangePointerAnimation2.prototype.constructor = RangePointerAnimation2;
  RangePointerAnimation2.prototype.step = function step(pos) {
    var ref2 = this;
    var options2 = ref2.options;
    var startColor = ref2.startColor;
    var color = ref2.color;
    var angle = interpolateValue(options2.oldAngle, options2.newAngle, pos);
    this.element.angle(angle);
    if (color) {
      var r = round3(interpolateValue(startColor.r, color.r, pos));
      var g = round3(interpolateValue(startColor.g, color.g, pos));
      var b = round3(interpolateValue(startColor.b, color.b, pos));
      this.element.stroke(new color_default(r, g, b).toHex());
    }
  };
  return RangePointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(RangePointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);
var range_pointer_animation_default = RangePointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer.js
var RangePointer = function(Pointer2) {
  function RangePointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2)
    RangePointer2.__proto__ = Pointer2;
  RangePointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RangePointer2.prototype.constructor = RangePointer2;
  RangePointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var oldAngle = scale.slotAngle(options2._oldValue);
    var newAngle = scale.slotAngle(options2.value);
    if (this.animation) {
      this.animation.abort();
    }
    if (options2.animation.transitions === false) {
      this.angle(newAngle);
      this.stroke(this.currentColor());
    } else {
      this.animation = new range_pointer_animation_default(this, deepExtend(options2.animation, {
        oldAngle,
        newAngle
      }));
      this.animation.play();
    }
  };
  RangePointer2.prototype.angle = function angle(value) {
    var geometry = this.elements.geometry();
    if (this.scale.options.reverse) {
      geometry.setStartAngle(value);
    } else {
      geometry.setEndAngle(value);
    }
    this.scale.placeholderRangeAngle(value);
  };
  RangePointer2.prototype.stroke = function stroke(value) {
    this.elements.stroke(value);
  };
  RangePointer2.prototype.render = function render() {
    if (this.elements) {
      return;
    }
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    if (options2.animation !== false) {
      deepExtend(options2.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    this.elements = scale.addRange(scale.options.min, this.options.value, {
      color: this.currentColor(),
      opacity: options2.opacity,
      lineCap: scale.options.rangeLineCap
    });
  };
  RangePointer2.prototype.currentColor = function currentColor() {
    var ref2 = this.scale.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var ref$1 = this.options;
    var colors = ref$1.colors;
    var color = ref$1.color;
    var value = ref$1.value;
    var currentValue = isNumber2(value) ? value : min3;
    if (colors) {
      for (var idx = 0; idx < colors.length; idx++) {
        var ref$2 = colors[idx];
        var rangeColor = ref$2.color;
        var from = ref$2.from;
        if (from === void 0)
          from = min3;
        var to = ref$2.to;
        if (to === void 0)
          to = max2;
        if (from <= currentValue && currentValue <= to) {
          return rangeColor;
        }
      }
    }
    return color;
  };
  RangePointer2.prototype.reflow = function reflow() {
    this.render();
    this.bbox = this.elements.bbox();
  };
  return RangePointer2;
}(pointer_default);
setDefaultOptions(RangePointer, {
  animation: {
    type: RADIAL_RANGE_POINTER,
    duration: ANGULAR_SPEED
  }
});
var range_pointer_default = RangePointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-gauge.js
var ArcGauge = function(RadialGauge2) {
  function ArcGauge2() {
    RadialGauge2.apply(this, arguments);
  }
  if (RadialGauge2)
    ArcGauge2.__proto__ = RadialGauge2;
  ArcGauge2.prototype = Object.create(RadialGauge2 && RadialGauge2.prototype);
  ArcGauge2.prototype.constructor = ArcGauge2;
  ArcGauge2.prototype._initTheme = function _initTheme(theme) {
    RadialGauge2.prototype._initTheme.call(this, theme);
    this.options.color = this.options.color || (this.theme.pointer || {}).color;
  };
  ArcGauge2.prototype._createModel = function _createModel() {
    var options2 = this.options;
    var scale = this.scale = new arc_scale_default(options2.scale, this.contextService);
    var pointer = new range_pointer_default(scale, deepExtend({}, {
      colors: options2.colors,
      color: options2.color,
      value: options2.value,
      opacity: options2.opacity,
      animation: {
        transitions: options2.transitions
      }
    }));
    this.pointers = [pointer];
  };
  ArcGauge2.prototype._buildPointers = function _buildPointers(pointers) {
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      current4.render();
      current4.value(current4.options.value);
    }
  };
  ArcGauge2.prototype._setValueOptions = function _setValueOptions(value) {
    this.options.value = value;
  };
  ArcGauge2.prototype.currentColor = function currentColor() {
    var pointer = this.pointers[0];
    if (pointer) {
      return pointer.currentColor();
    }
  };
  ArcGauge2.prototype.centerLabelPosition = function centerLabelPosition(width, height) {
    var size = this.getSize();
    var center = this.scale.arc.center;
    var left = center.x - width / 2;
    var top = center.y - height / 2;
    if (width < size.width) {
      var right = left + width;
      left = Math.max(left, 0);
      if (right > size.width) {
        left -= right - size.width;
      }
    }
    if (height < size.height) {
      var bbox = this.scale.bbox;
      var yLimit = bbox.bottomRight().y;
      var bottom = top + height;
      top = Math.max(top, bbox.origin.y);
      if (bottom > yLimit) {
        top -= bottom - yLimit;
      }
    }
    return {
      left,
      top
    };
  };
  return ArcGauge2;
}(radial_gauge_default);
var arc_gauge_default = ArcGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/circular/circular-gauge.js
var defaultStartAngle = 90;
var CircularGauge = function(ArcGauge2) {
  function CircularGauge2() {
    ArcGauge2.apply(this, arguments);
  }
  if (ArcGauge2)
    CircularGauge2.__proto__ = ArcGauge2;
  CircularGauge2.prototype = Object.create(ArcGauge2 && ArcGauge2.prototype);
  CircularGauge2.prototype.constructor = CircularGauge2;
  CircularGauge2.prototype._createModel = function _createModel() {
    var scaleOptions = this.options.scale;
    if (typeof scaleOptions.startAngle !== "number") {
      scaleOptions.startAngle = defaultStartAngle;
    }
    scaleOptions.endAngle = scaleOptions.startAngle + 360;
    ArcGauge2.prototype._createModel.call(this);
  };
  return CircularGauge2;
}(arc_gauge_default);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/encoding.js
var DEFAULT_QUIET_ZONE_LENGTH = 10;
var Encoding = function(Class3) {
  function Encoding2(options2) {
    Class3.call(this);
    this.setOptions(options2);
    this.initProperties();
  }
  if (Class3)
    Encoding2.__proto__ = Class3;
  Encoding2.prototype = Object.create(Class3 && Class3.prototype);
  Encoding2.prototype.constructor = Encoding2;
  Encoding2.prototype.initProperties = function initProperties() {
  };
  Encoding2.prototype.setOptions = function setOptions(options2) {
    this.options = Object.assign({}, this.options, options2);
    this.quietZoneLength = this.options.addQuietZone ? 2 * this.options.quietZoneLength : 0;
  };
  Encoding2.prototype.encode = function encode(value, width, height) {
    var convertedValue = defined2(value) ? String(value) : value;
    this.initValue(convertedValue, width, height);
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    this.addData();
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    return {
      baseUnit: this.baseUnit,
      pattern: this.pattern
    };
  };
  Encoding2.prototype.initValue = function initValue() {
  };
  Encoding2.prototype.addQuietZone = function addQuietZone() {
    this.pattern.push(this.options.quietZoneLength || DEFAULT_QUIET_ZONE_LENGTH);
  };
  Encoding2.prototype.addData = function addData() {
  };
  Encoding2.prototype.invalidCharacterError = function invalidCharacterError(character) {
    throw new Error('Character "' + character + '" is not valid for symbology ' + this.name + ".");
  };
  return Encoding2;
}(class_default);
setDefaultOptions(Encoding, {
  quietZoneLength: DEFAULT_QUIET_ZONE_LENGTH,
  addQuietZone: true,
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code11.js
var extend = Object.assign;
var Code11 = function(Encoding2) {
  function Code112() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Code112.__proto__ = Encoding2;
  Code112.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code112.prototype.constructor = Code112;
  Code112.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend(this, {
      name: "Code 11",
      characterMap: ["111121", "211121", "121121", "221111", "112121", "212111", "122111", "111221", "211211", "211111", "112111"],
      cCheckSumTotal: 10,
      kCheckSumTotal: 9,
      kCheckSumMinLength: 10,
      checkSumMod: 11,
      DASH_VALUE: 10,
      DASH: "-",
      START: "112211",
      STOP: "11221"
    });
  };
  Code112.prototype.initValue = function initValue(value, width) {
    this.pattern = [];
    this.value = value;
    this.width = width;
    this.totalUnits = 0;
  };
  Code112.prototype.addData = function addData() {
    var this$1 = this;
    var value = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value.length; i++) {
      this$1.addCharacter(value.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  Code112.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code112.prototype.addCheckSum = function addCheckSum() {
    var value = this.value;
    var length = value.length;
    var cValue = this.getWeightedSum(value, length, this.cCheckSumTotal) % this.checkSumMod;
    this.checksum = String(cValue);
    this.addPattern(this.characterMap[cValue]);
    length++;
    if (length >= this.kCheckSumMinLength) {
      var kValue = (cValue + this.getWeightedSum(value, length, this.kCheckSumTotal)) % this.checkSumMod;
      this.checksum += kValue;
      this.addPattern(this.characterMap[kValue]);
    }
  };
  Code112.prototype.getWeightedSum = function getWeightedSum(value, length, total3) {
    var this$1 = this;
    var weightedSum = 0;
    for (var i = 0; i < value.length; i++) {
      weightedSum += this$1.weightedValue(this$1.getValue(value.charAt(i)), length, i, total3);
    }
    return weightedSum;
  };
  Code112.prototype.weightedValue = function weightedValue(value, length, index, total3) {
    var weight = (length - index) % total3 || total3;
    return weight * value;
  };
  Code112.prototype.getValue = function getValue(character) {
    if (!isNaN(character)) {
      return parseInt(character, 10);
    } else if (character !== this.DASH) {
      this.invalidCharacterError(character);
    }
    return this.DASH_VALUE;
  };
  Code112.prototype.addCharacter = function addCharacter2(character) {
    var value = this.getValue(character);
    var pattern = this.characterMap[value];
    this.addPattern(pattern);
  };
  Code112.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var value;
    for (var i = 0; i < pattern.length; i++) {
      value = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value);
      this$1.totalUnits += value;
    }
  };
  return Code112;
}(Encoding);
setDefaultOptions(Code11, {
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39.js
var extend2 = Object.assign;
var Code39Base = function(Encoding2) {
  function Code39Base2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Code39Base2.__proto__ = Encoding2;
  Code39Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code39Base2.prototype.constructor = Code39Base2;
  Code39Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend2(this, {
      minBaseUnitLength: 0.7
    });
  };
  Code39Base2.prototype.addData = function addData() {
    var this$1 = this;
    var value = this.value;
    this.addStart();
    for (var idx = 0; idx < value.length; idx++) {
      this$1.addCharacter(value.charAt(idx));
    }
    if (this.options.addCheckSum) {
      this.pushCheckSum();
    }
    this.addStop();
    this.prepareValues();
  };
  Code39Base2.prototype.addCharacter = function addCharacter2(character) {
    var characterData = this.characterMap[character];
    if (!characterData) {
      this.invalidCharacterError(character);
    }
    this.addBase(characterData);
  };
  Code39Base2.prototype.addBase = function addBase() {
  };
  return Code39Base2;
}(Encoding);
var Code39 = function(Code39Base2) {
  function Code392() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2)
    Code392.__proto__ = Code39Base2;
  Code392.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code392.prototype.constructor = Code392;
  Code392.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend2(this, {
      name: "Code 39",
      checkSumMod: 43,
      minRatio: 2.5,
      maxRatio: 3,
      gapWidth: 1,
      splitCharacter: "|",
      patternMappings: {
        "b": "1|",
        "w": "1|",
        "B": "ratio|",
        "W": "ratio|"
      },
      characterMap: {
        "0": { "pattern": "bwbWBwBwb", "value": 0 },
        "1": { "pattern": "BwbWbwbwB", "value": 1 },
        "2": { "pattern": "bwBWbwbwB", "value": 2 },
        "3": { "pattern": "BwBWbwbwb", "value": 3 },
        "4": { "pattern": "bwbWBwbwB", "value": 4 },
        "5": { "pattern": "BwbWBwbwb", "value": 5 },
        "6": { "pattern": "bwBWBwbwb", "value": 6 },
        "7": { "pattern": "bwbWbwBwB", "value": 7 },
        "8": { "pattern": "BwbWbwBwb", "value": 8 },
        "9": { "pattern": "bwBWbwBwb", "value": 9 },
        "A": { "pattern": "BwbwbWbwB", "value": 10 },
        "B": { "pattern": "bwBwbWbwB", "value": 11 },
        "C": { "pattern": "BwBwbWbwb", "value": 12 },
        "D": { "pattern": "bwbwBWbwB", "value": 13 },
        "E": { "pattern": "BwbwBWbwb", "value": 14 },
        "F": { "pattern": "bwBwBWbwb", "value": 15 },
        "G": { "pattern": "bwbwbWBwB", "value": 16 },
        "H": { "pattern": "BwbwbWBwb", "value": 17 },
        "I": { "pattern": "bwBwbWBwb", "value": 18 },
        "J": { "pattern": "bwbwBWBwb", "value": 19 },
        "K": { "pattern": "BwbwbwbWB", "value": 20 },
        "L": { "pattern": "bwBwbwbWB", "value": 21 },
        "M": { "pattern": "BwBwbwbWb", "value": 22 },
        "N": { "pattern": "bwbwBwbWB", "value": 23 },
        "O": { "pattern": "BwbwBwbWb", "value": 24 },
        "P": { "pattern": "bwBwBwbWb", "value": 25 },
        "Q": { "pattern": "bwbwbwBWB", "value": 26 },
        "R": { "pattern": "BwbwbwBWb", "value": 27 },
        "S": { "pattern": "bwBwbwBWb", "value": 28 },
        "T": { "pattern": "bwbwBwBWb", "value": 29 },
        "U": { "pattern": "BWbwbwbwB", "value": 30 },
        "V": { "pattern": "bWBwbwbwB", "value": 31 },
        "W": { "pattern": "BWBwbwbwb", "value": 32 },
        "X": { "pattern": "bWbwBwbwB", "value": 33 },
        "Y": { "pattern": "BWbwBwbwb", "value": 34 },
        "Z": { "pattern": "bWBwBwbwb", "value": 35 },
        "-": { "pattern": "bWbwbwBwB", "value": 36 },
        ".": { "pattern": "BWbwbwBwb", "value": 37 },
        " ": { "pattern": "bWBwbwBwb", "value": 38 },
        "$": { "pattern": "bWbWbWbwb", "value": 39 },
        "/": { "pattern": "bWbWbwbWb", "value": 40 },
        "+": { "pattern": "bWbwbWbWb", "value": 41 },
        "%": { "pattern": "bwbWbWbWb", "value": 42 },
        START: { pattern: "bWbwBwBwb" }
      }
    });
  };
  Code392.prototype.initValue = function initValue(value, width, height) {
    this.width = width;
    this.height = height;
    this.value = value;
    this.dataLength = value.length;
    this.pattern = [];
    this.patternString = "";
  };
  Code392.prototype.prepareValues = function prepareValues() {
    var this$1 = this;
    var minBaseUnit = this.minBaseUnitLength;
    var minRatio = this.minRatio;
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    var baseUnit;
    var ratio = this.maxRatio;
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code39 encoding: the current height is " + this.height + "px and the minimum height is " + minHeight + "px.");
    }
    baseUnit = this.getBaseUnit(ratio);
    while (baseUnit < minBaseUnit && ratio > minRatio) {
      ratio = parseFloat((ratio - 0.1).toFixed(1));
      baseUnit = this$1.getBaseUnit(ratio);
    }
    if (baseUnit < minBaseUnit) {
      var minWidth = Math.ceil(this.getBaseWidth(minRatio) * minBaseUnit);
      throw new Error("Insufficient width for Code39 encoding: the current width is " + this.width + 'px and the minimum width for value "' + this.value + '" is ' + minWidth + "px.");
    }
    this.ratio = ratio;
    this.baseUnit = baseUnit;
    this.patternString = this.patternString.substring(0, this.patternString.length - 1);
    this.pattern = this.pattern.concat(this.patternString.replace(/ratio/g, ratio).split(this.splitCharacter));
  };
  Code392.prototype.getBaseUnit = function getBaseUnit(ratio) {
    return this.width / this.getBaseWidth(ratio);
  };
  Code392.prototype.getBaseWidth = function getBaseWidth(ratio) {
    var characterLength = 3 * (ratio + 2);
    return this.quietZoneLength + characterLength * (this.dataLength + 2) + this.gapWidth * (this.dataLength + 1);
  };
  Code392.prototype.addStart = function addStart() {
    this.addPattern(this.characterMap.START.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addBase = function addBase(character) {
    this.addPattern(character.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addStop = function addStop() {
    this.addPattern(this.characterMap.START.pattern);
  };
  Code392.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    for (var i = 0; i < pattern.length; i++) {
      this$1.patternString += this$1.patternMappings[pattern.charAt(i)];
    }
  };
  Code392.prototype.addCharacterGap = function addCharacterGap() {
    this.patternString += this.gapWidth + this.splitCharacter;
  };
  return Code392;
}(Code39Base);
setDefaultOptions(Code39, {
  addCheckSum: false
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39-extended.js
var Code39ExtendedBase = {
  addCharacter: function addCharacter(character) {
    if (this.characterMap[character]) {
      this.addBase(this.characterMap[character]);
    } else if (character.charCodeAt(0) > 127) {
      this.invalidCharacterError(character);
    } else {
      this.addExtended(character.charCodeAt(0));
    }
  },
  addExtended: function addExtended(code) {
    var this$1 = this;
    var patterns;
    for (var i = 0; i < this.extendedMappings.length; i++) {
      patterns = this$1.extendedMappings[i].call(this$1, code);
      if (patterns) {
        for (var patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
          var pattern = patterns[patternIndex];
          this$1.addBase(pattern);
        }
        this$1.dataLength += patterns.length - 1;
        return;
      }
    }
  },
  extendedMappings: [
    function(code) {
      if (97 <= code && code <= 122) {
        return [this.characterMap[this.shiftCharacters[0]], this.characterMap[String.fromCharCode(code - 32)]];
      }
    },
    function(code) {
      if (33 <= code && code <= 58) {
        return [this.characterMap[this.shiftCharacters[1]], this.characterMap[String.fromCharCode(code + 32)]];
      }
    },
    function(code) {
      if (1 <= code && code <= 26) {
        return [this.characterMap[this.shiftCharacters[2]], this.characterMap[String.fromCharCode(code + 64)]];
      }
    },
    function(code) {
      var this$1 = this;
      var result;
      var dataCharacter;
      if (!this.specialAsciiCodes[code]) {
        dataCharacter = Math.floor(code / 32) * 6 + (code - 27) % 32 + 64;
        result = [this.characterMap[this.shiftCharacters[3]], this.characterMap[String.fromCharCode(dataCharacter)]];
      } else {
        result = [];
        for (var i = 0; i < this.specialAsciiCodes[code].length; i++) {
          result.push(this$1.characterMap[this$1.shiftCharacters[3]]);
          result.push(this$1.characterMap[this$1.specialAsciiCodes[code][i]]);
        }
      }
      return result;
    }
  ],
  specialAsciiCodes: {
    "0": ["U"],
    "64": ["V"],
    "96": ["W"],
    "127": ["T", "X", "Y", "Z"]
  },
  shiftValuesAsciiCodes: {
    "39": 36,
    "40": 47,
    "41": 43,
    "42": 37
  },
  characterMap: {
    "+": false,
    "/": false,
    "$": false,
    "%": false
  },
  shiftCharacters: ["SHIFT0", "SHIFT1", "SHIFT2", "SHIFT3"]
};
var Code39Extended = function(Code392) {
  function Code39Extended2() {
    Code392.apply(this, arguments);
  }
  if (Code392)
    Code39Extended2.__proto__ = Code392;
  Code39Extended2.prototype = Object.create(Code392 && Code392.prototype);
  Code39Extended2.prototype.constructor = Code39Extended2;
  Code39Extended2.prototype.initProperties = function initProperties() {
    Code392.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 39 extended",
      characterMap: {
        SHIFT0: { "pattern": "bWbwbWbWb", "value": 41 },
        SHIFT1: { "pattern": "bWbWbwbWb", "value": 40 },
        SHIFT2: { "pattern": "bWbWbWbwb", "value": 39 },
        SHIFT3: { "pattern": "bwbWbWbWb", "value": 42 }
      }
    });
  };
  return Code39Extended2;
}(Code39);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93.js
var extend3 = Object.assign;
var Code93 = function(Code39Base2) {
  function Code932() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2)
    Code932.__proto__ = Code39Base2;
  Code932.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code932.prototype.constructor = Code932;
  Code932.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend3(this, {
      name: "Code 93",
      cCheckSumTotal: 20,
      kCheckSumTotal: 15,
      checkSumMod: 47,
      characterMap: {
        "0": { "pattern": "131112", "value": 0 },
        "1": { "pattern": "111213", "value": 1 },
        "2": { "pattern": "111312", "value": 2 },
        "3": { "pattern": "111411", "value": 3 },
        "4": { "pattern": "121113", "value": 4 },
        "5": { "pattern": "121212", "value": 5 },
        "6": { "pattern": "121311", "value": 6 },
        "7": { "pattern": "111114", "value": 7 },
        "8": { "pattern": "131211", "value": 8 },
        "9": { "pattern": "141111", "value": 9 },
        "A": { "pattern": "211113", "value": 10 },
        "B": { "pattern": "211212", "value": 11 },
        "C": { "pattern": "211311", "value": 12 },
        "D": { "pattern": "221112", "value": 13 },
        "E": { "pattern": "221211", "value": 14 },
        "F": { "pattern": "231111", "value": 15 },
        "G": { "pattern": "112113", "value": 16 },
        "H": { "pattern": "112212", "value": 17 },
        "I": { "pattern": "112311", "value": 18 },
        "J": { "pattern": "122112", "value": 19 },
        "K": { "pattern": "132111", "value": 20 },
        "L": { "pattern": "111123", "value": 21 },
        "M": { "pattern": "111222", "value": 22 },
        "N": { "pattern": "111321", "value": 23 },
        "O": { "pattern": "121122", "value": 24 },
        "P": { "pattern": "131121", "value": 25 },
        "Q": { "pattern": "212112", "value": 26 },
        "R": { "pattern": "212211", "value": 27 },
        "S": { "pattern": "211122", "value": 28 },
        "T": { "pattern": "211221", "value": 29 },
        "U": { "pattern": "221121", "value": 30 },
        "V": { "pattern": "222111", "value": 31 },
        "W": { "pattern": "112122", "value": 32 },
        "X": { "pattern": "112221", "value": 33 },
        "Y": { "pattern": "122121", "value": 34 },
        "Z": { "pattern": "123111", "value": 35 },
        "-": { "pattern": "121131", "value": 36 },
        ".": { "pattern": "311112", "value": 37 },
        " ": { "pattern": "311211", "value": 38 },
        "$": { "pattern": "321111", "value": 39 },
        "/": { "pattern": "112131", "value": 40 },
        "+": { "pattern": "113121", "value": 41 },
        "%": { "pattern": "211131", "value": 42 },
        SHIFT0: { "pattern": "122211", "value": 46 },
        SHIFT1: { "pattern": "311121", "value": 45 },
        SHIFT2: { "pattern": "121221", "value": 43 },
        SHIFT3: { "pattern": "312111", "value": 44 },
        START: { "pattern": "111141" },
        TERMINATION_BAR: "1"
      }
    });
  };
  Code932.prototype.initValue = function initValue(value, width, height) {
    this.value = value;
    this.width = width;
    this.height = height;
    this.pattern = [];
    this.values = [];
    this.dataLength = value.length;
  };
  Code932.prototype.prepareValues = function prepareValues() {
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code93 encoding: the current height is " + this.height + "px, the minimum required height is " + minHeight + "px.");
    }
    this.setBaseUnit();
    if (this.baseUnit < this.minBaseUnitLength) {
      var minWidth = Math.ceil(this.minBaseUnitLength * (this.width / this.baseUnit));
      throw new Error("Insufficient width for Code93 encoding: the current width is " + this.width + 'px and the minimum required width for value "' + this.value + '" is ' + minWidth + "px.");
    }
  };
  Code932.prototype.setBaseUnit = function setBaseUnit() {
    var checkSumLength = 2;
    this.baseUnit = this.width / (9 * (this.dataLength + 2 + checkSumLength) + this.quietZoneLength + 1);
  };
  Code932.prototype.addStart = function addStart() {
    var pattern = this.characterMap.START.pattern;
    this.addPattern(pattern);
  };
  Code932.prototype.addStop = function addStop() {
    this.addStart();
    this.pattern.push(this.characterMap.TERMINATION_BAR);
  };
  Code932.prototype.addBase = function addBase(charData) {
    this.addPattern(charData.pattern);
    this.values.push(charData.value);
  };
  Code932.prototype.pushCheckSum = function pushCheckSum() {
    var this$1 = this;
    var checkValues = this._getCheckValues();
    var charData;
    this.checksum = checkValues.join("");
    for (var i = 0; i < checkValues.length; i++) {
      charData = this$1.characterMap[this$1._findCharacterByValue(checkValues[i])];
      this$1.addPattern(charData.pattern);
    }
  };
  Code932.prototype._getCheckValues = function _getCheckValues() {
    var this$1 = this;
    var values5 = this.values;
    var length = values5.length;
    var wightedSum = 0;
    var cValue;
    var kValue;
    var idx;
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1.weightedValue(values5[idx], length - idx, this$1.cCheckSumTotal);
    }
    cValue = wightedSum % this.checkSumMod;
    wightedSum = this.weightedValue(cValue, 1, this.kCheckSumTotal);
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1.weightedValue(values5[idx], length - idx + 1, this$1.kCheckSumTotal);
    }
    kValue = wightedSum % this.checkSumMod;
    return [cValue, kValue];
  };
  Code932.prototype._findCharacterByValue = function _findCharacterByValue(value) {
    var this$1 = this;
    for (var character in this$1.characterMap) {
      if (this$1.characterMap[character].value === value) {
        return character;
      }
    }
  };
  Code932.prototype.weightedValue = function weightedValue(value, index, total3) {
    return (index % total3 || total3) * value;
  };
  Code932.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var value;
    for (var i = 0; i < pattern.length; i++) {
      value = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value);
    }
  };
  return Code932;
}(Code39Base);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93-extended.js
var Code93Extended = function(Code932) {
  function Code93Extended2() {
    Code932.apply(this, arguments);
  }
  if (Code932)
    Code93Extended2.__proto__ = Code932;
  Code93Extended2.prototype = Object.create(Code932 && Code932.prototype);
  Code93Extended2.prototype.constructor = Code93Extended2;
  Code93Extended2.prototype.initProperties = function initProperties() {
    Code932.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 93 extended",
      pushCheckSum: function() {
        var this$1 = this;
        var checkValues = this._getCheckValues();
        var value;
        this.checksum = checkValues.join("");
        for (var i = 0; i < checkValues.length; i++) {
          value = checkValues[i];
          if (this$1.shiftValuesAsciiCodes[value]) {
            this$1.addExtended(this$1.shiftValuesAsciiCodes[value]);
          } else {
            var characterByValue = this$1._findCharacterByValue(value);
            this$1.addPattern(this$1.characterMap[characterByValue].pattern);
          }
        }
      }
    });
  };
  return Code93Extended2;
}(Code93);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/postnet.js
var numberRegex2 = /^\d+$/;
var extend4 = Object.assign;
var Postnet = function(Encoding2) {
  function Postnet2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Postnet2.__proto__ = Encoding2;
  Postnet2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Postnet2.prototype.constructor = Postnet2;
  Postnet2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend4(this, {
      name: "Postnet",
      START: "2",
      VALID_CODE_LENGTHS: [5, 9, 11],
      DIGIT_SEPARATOR: "-",
      characterMap: ["22111", "11122", "11212", "11221", "12112", "12121", "12211", "21112", "21121", "21211"]
    });
  };
  Postnet2.prototype.initValue = function initValue(value, width, height) {
    this.height = height;
    this.width = width;
    this.baseHeight = height / 2;
    this.value = value.replace(new RegExp(this.DIGIT_SEPARATOR, "g"), "");
    this.pattern = [];
    this.validate(this.value);
    this.checkSum = 0;
    this.setBaseUnit();
  };
  Postnet2.prototype.addData = function addData() {
    var this$1 = this;
    var value = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value.length; i++) {
      this$1.addCharacter(value.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.START);
    this.pattern.pop();
  };
  Postnet2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    this.checkSum += parseInt(character, 10);
    this.addPattern(pattern);
  };
  Postnet2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = (10 - this.checkSum % 10) % 10;
    this.addCharacter(this.checksum);
  };
  Postnet2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 3;
    this.baseUnit = this.width / ((this.value.length + 1) * 10 + startStopLength + this.quietZoneLength);
  };
  Postnet2.prototype.validate = function validate(value) {
    if (!numberRegex2.test(value)) {
      this.invalidCharacterError(value.match(/[^0-9]/)[0]);
    }
    if (!inArray(value.length, this.VALID_CODE_LENGTHS)) {
      throw new Error("Invalid value length. Valid lengths for the Postnet symbology are " + this.VALID_CODE_LENGTHS.join(",") + ".");
    }
  };
  Postnet2.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var y1;
    for (var i = 0; i < pattern.length; i++) {
      y1 = this$1.height - this$1.baseHeight * pattern.charAt(i);
      this$1.pattern.push({ width: 1, y1, y2: this$1.height });
      this$1.pattern.push(1);
    }
  };
  return Postnet2;
}(Encoding);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code128.js
var numberRegex3 = /^\d+$/;
var alphanumericRegex = /^[a-z0-9]+$/i;
var extend5 = Object.assign;
var State128 = function(Class3) {
  function State1282(encoding) {
    Class3.call(this);
    this.encoding = encoding;
    this.initProperties();
  }
  if (Class3)
    State1282.__proto__ = Class3;
  State1282.prototype = Object.create(Class3 && Class3.prototype);
  State1282.prototype.constructor = State1282;
  State1282.prototype.initProperties = function initProperties() {
  };
  State1282.prototype.addStart = function addStart() {
  };
  State1282.prototype.is = function is() {
  };
  State1282.prototype.isCode = function isCode() {
    return false;
  };
  State1282.prototype.move = function move() {
  };
  State1282.prototype.pushState = function pushState() {
  };
  return State1282;
}(class_default);
var State128AB = function(State1282) {
  function State128AB2(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
    this._initMoves(states);
  }
  if (State1282)
    State128AB2.__proto__ = State1282;
  State128AB2.prototype = Object.create(State1282 && State1282.prototype);
  State128AB2.prototype.constructor = State128AB2;
  State128AB2.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    deepExtend(this, {
      FNC4: "FNC4",
      SHIFT: 98
    });
  };
  State128AB2.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128AB2.prototype.is = function is(value, index) {
    var code = value.charCodeAt(index);
    return this.isCode(code);
  };
  State128AB2.prototype.move = function move(encodingState) {
    var idx = 0;
    while (!this._moves[idx].call(this, encodingState) && idx < this._moves.length) {
      idx++;
    }
  };
  State128AB2.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var states = this.states, value = encodingState.value, maxLength = value.length, code;
    if (inArray("C", states)) {
      var numberMatch = value.substr(encodingState.index).match(/\d{4,}/g);
      if (numberMatch) {
        maxLength = value.indexOf(numberMatch[0], encodingState.index);
      }
    }
    while ((code = encodingState.value.charCodeAt(encodingState.index)) >= 0 && this.isCode(code) && encodingState.index < maxLength) {
      this$1.encoding.addPattern(this$1.getValue(code));
      encodingState.index++;
    }
  };
  State128AB2.prototype._initMoves = function _initMoves(states) {
    this._moves = [];
    if (inArray(this.FNC4, states)) {
      this._moves.push(this._moveFNC);
    }
    if (inArray(this.shiftKey, states)) {
      this._moves.push(this._shiftState);
    }
    this._moves.push(this._moveState);
  };
  State128AB2.prototype._moveFNC = function _moveFNC(encodingState) {
    if (encodingState.fnc) {
      encodingState.fnc = false;
      return encodingState.previousState === this.key;
    }
  };
  State128AB2.prototype._shiftState = function _shiftState(encodingState) {
    if (encodingState.previousState === this.shiftKey && (encodingState.index + 1 >= encodingState.value.length || this.encoding[this.shiftKey].is(encodingState.value, encodingState.index + 1))) {
      this.encoding.addPattern(this.SHIFT);
      encodingState.shifted = true;
      return true;
    }
  };
  State128AB2.prototype._moveState = function _moveState() {
    this.encoding.addPattern(this.MOVE);
    return true;
  };
  return State128AB2;
}(State128);
var states128 = {};
states128.A = function(State128AB2) {
  function State128A() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2)
    State128A.__proto__ = State128AB2;
  State128A.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128A.prototype.constructor = State128A;
  State128A.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend5(this, {
      key: "A",
      shiftKey: "B",
      MOVE: 101,
      START: 103
    });
  };
  State128A.prototype.isCode = function isCode(code) {
    return 0 <= code && code < 96;
  };
  State128A.prototype.getValue = function getValue(code) {
    if (code < 32) {
      return code + 64;
    }
    return code - 32;
  };
  return State128A;
}(State128AB);
states128.B = function(State128AB2) {
  function State128B() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2)
    State128B.__proto__ = State128AB2;
  State128B.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128B.prototype.constructor = State128B;
  State128B.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend5(this, {
      key: "B",
      shiftKey: "A",
      MOVE: 100,
      START: 104
    });
  };
  State128B.prototype.isCode = function isCode(code) {
    return 32 <= code && code < 128;
  };
  State128B.prototype.getValue = function getValue(code) {
    return code - 32;
  };
  return State128B;
}(State128AB);
states128.C = function(State1282) {
  function State128C() {
    State1282.apply(this, arguments);
  }
  if (State1282)
    State128C.__proto__ = State1282;
  State128C.prototype = Object.create(State1282 && State1282.prototype);
  State128C.prototype.constructor = State128C;
  State128C.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend5(this, {
      key: "C",
      MOVE: 99,
      START: 105
    });
  };
  State128C.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128C.prototype.is = function is(value, index) {
    var next4 = getSubstring(value, index, 4);
    return (index + 4 <= value.length || value.length === 2) && numberRegex3.test(next4);
  };
  State128C.prototype.move = function move() {
    this.encoding.addPattern(this.MOVE);
  };
  State128C.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var code;
    while ((code = getSubstring(encodingState.value, encodingState.index, 2)) && numberRegex3.test(code) && code.length === 2) {
      this$1.encoding.addPattern(parseInt(code, 10));
      encodingState.index += 2;
    }
  };
  State128C.prototype.getValue = function getValue(code) {
    return code;
  };
  return State128C;
}(State128);
states128.FNC4 = function(State1282) {
  function State128FNC4(encoding, states) {
    State1282.call(this, encoding);
    this._initSubStates(states);
  }
  if (State1282)
    State128FNC4.__proto__ = State1282;
  State128FNC4.prototype = Object.create(State1282 && State1282.prototype);
  State128FNC4.prototype.constructor = State128FNC4;
  State128FNC4.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend5(this, {
      key: "FNC4",
      dependentStates: ["A", "B"]
    });
  };
  State128FNC4.prototype.addStart = function addStart(encodingState) {
    var code = encodingState.value.charCodeAt(0) - 128, subState = this._getSubState(code);
    this.encoding[subState].addStart();
  };
  State128FNC4.prototype.is = function is(value, index) {
    var code = value.charCodeAt(index);
    return this.isCode(code);
  };
  State128FNC4.prototype.isCode = function isCode(code) {
    return 128 <= code && code < 256;
  };
  State128FNC4.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var subState = this._initSubState(encodingState), encoding = this.encoding, length = subState.value.length;
    var code;
    encodingState.index += length;
    if (length < 3) {
      for (; subState.index < length; subState.index++) {
        code = subState.value.charCodeAt(subState.index);
        subState.state = this$1._getSubState(code);
        if (subState.previousState !== subState.state) {
          subState.previousState = subState.state;
          encoding[subState.state].move(subState);
        }
        encoding.addPattern(encoding[subState.state].MOVE);
        encoding.addPattern(encoding[subState.state].getValue(code));
      }
    } else {
      if (subState.state !== subState.previousState) {
        encoding[subState.state].move(subState);
      }
      this._pushStart(subState);
      encoding.pushData(subState, this.subStates);
      if (encodingState.index < encodingState.value.length) {
        this._pushStart(subState);
      }
    }
    encodingState.fnc = true;
    encodingState.state = subState.state;
  };
  State128FNC4.prototype._pushStart = function _pushStart(subState) {
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
  };
  State128FNC4.prototype._initSubState = function _initSubState(encodingState) {
    var subState = {
      value: this._getAll(encodingState.value, encodingState.index),
      index: 0
    };
    subState.state = this._getSubState(subState.value.charCodeAt(0));
    subState.previousState = encodingState.previousState === this.key ? subState.state : encodingState.previousState;
    return subState;
  };
  State128FNC4.prototype._initSubStates = function _initSubStates(states) {
    var this$1 = this;
    this.subStates = [];
    for (var i = 0; i < states.length; i++) {
      if (inArray(states[i], this$1.dependentStates)) {
        this$1.subStates.push(states[i]);
      }
    }
  };
  State128FNC4.prototype._getSubState = function _getSubState(code) {
    var this$1 = this;
    for (var i = 0; i < this.subStates.length; i++) {
      if (this$1.encoding[this$1.subStates[i]].isCode(code)) {
        return this$1.subStates[i];
      }
    }
  };
  State128FNC4.prototype._getAll = function _getAll(value, index) {
    var code;
    var result = "";
    var i = index;
    while ((code = value.charCodeAt(i++)) && this.isCode(code)) {
      result += String.fromCharCode(code - 128);
    }
    return result;
  };
  return State128FNC4;
}(State128);
states128.FNC1 = function(State1282) {
  function States128FNC1(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
  }
  if (State1282)
    States128FNC1.__proto__ = State1282;
  States128FNC1.prototype = Object.create(State1282 && State1282.prototype);
  States128FNC1.prototype.constructor = States128FNC1;
  States128FNC1.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend5(this, {
      key: "FNC1",
      startState: "C",
      startAI: "(",
      endAI: ")",
      dependentStates: ["C", "B"],
      applicationIdentifiers: {
        "22": { max: 29, type: "alphanumeric" },
        "402": { length: 17 },
        "7004": { max: 4, type: "alphanumeric" },
        "242": { max: 6, type: "alphanumeric" },
        "8020": { max: 25, type: "alphanumeric" },
        "703": { min: 3, max: 30, type: "alphanumeric" },
        "8008": { min: 8, max: 12, type: "alphanumeric" },
        "253": { min: 13, max: 17, type: "alphanumeric" },
        "8003": { min: 14, max: 30, type: "alphanumeric" },
        multiKey: [{
          ids: ["15", "17", "8005", "8100"],
          ranges: [
            [11, 13],
            [310, 316],
            [320, 336],
            [340, 369]
          ],
          type: { length: 6 }
        }, {
          ids: ["240", "241", "250", "251", "400", "401", "403", "7002", "8004", "8007", "8110"],
          ranges: [[90 - 99]],
          type: { max: 30, type: "alphanumeric" }
        }, {
          ids: ["7001"],
          ranges: [[410, 414]],
          type: { length: 13 }
        }, {
          ids: ["10", "21", "254", "420", "8002"],
          type: { max: 20, type: "alphanumeric" }
        }, {
          ids: ["00", "8006", "8017", "8018"],
          type: { length: 18 }
        }, {
          ids: ["01", "02", "8001"],
          type: { length: 14 }
        }, {
          ids: ["422"],
          ranges: [
            [424, 426]
          ],
          type: { length: 3 }
        }, {
          ids: ["20", "8102"],
          type: { length: 2 }
        }, {
          ids: ["30", "37"],
          type: { max: 8, type: "alphanumeric" }
        }, {
          ids: ["390", "392"],
          type: { max: 15, type: "alphanumeric" }
        }, {
          ids: ["421", "423"],
          type: { min: 3, max: 15, type: "alphanumeric" }
        }, {
          ids: ["391", "393"],
          type: { min: 3, max: 18, type: "alphanumeric" }
        }, {
          ids: ["7003", "8101"],
          type: { length: 10 }
        }]
      },
      START: 102
    });
  };
  States128FNC1.prototype.addStart = function addStart() {
    this.encoding[this.startState].addStart();
  };
  States128FNC1.prototype.is = function is() {
    return inArray(this.key, this.states);
  };
  States128FNC1.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var encoding = this.encoding, value = encodingState.value.replace(/\s/g, ""), regexSeparators = new RegExp("[" + this.startAI + this.endAI + "]", "g"), index = encodingState.index, subState = {
      state: this.startState
    }, current4, nextStart, separatorLength;
    encoding.addPattern(this.START);
    var trueCondition = true;
    while (trueCondition) {
      subState.index = 0;
      separatorLength = value.charAt(index) === this$1.startAI ? 2 : 0;
      current4 = separatorLength > 0 ? this$1.getBySeparator(value, index) : this$1.getByLength(value, index);
      if (current4.ai.length) {
        nextStart = index + separatorLength + current4.id.length + current4.ai.length;
      } else {
        nextStart = value.indexOf(this$1.startAI, index + 1);
        if (nextStart < 0) {
          if (index + current4.ai.max + current4.id.length + separatorLength < value.length) {
            throw new Error("Separators are required after variable length identifiers");
          }
          nextStart = value.length;
        }
      }
      subState.value = value.substring(index, nextStart).replace(regexSeparators, "");
      this$1.validate(current4, subState.value);
      encoding.pushData(subState, this$1.dependentStates);
      if (nextStart >= value.length) {
        break;
      }
      index = nextStart;
      if (subState.state !== this$1.startState) {
        encoding[this$1.startState].move(subState);
        subState.state = this$1.startState;
      }
      if (!current4.ai.length) {
        encoding.addPattern(this$1.START);
      }
    }
    encodingState.index = encodingState.value.length;
  };
  States128FNC1.prototype.validate = function validate(current4, value) {
    var code = value.substr(current4.id.length), ai = current4.ai;
    if (!ai.type && !numberRegex3.test(code)) {
      throw new Error("Application identifier " + current4.id + " is numeric only but contains non numeric character(s).");
    }
    if (ai.type === "alphanumeric" && !alphanumericRegex.test(code)) {
      throw new Error("Application identifier " + current4.id + " is alphanumeric only but contains non alphanumeric character(s).");
    }
    if (ai.length && ai.length !== code.length) {
      throw new Error("Application identifier " + current4.id + " must be " + ai.length + " characters long.");
    }
    if (ai.min && ai.min > code.length) {
      throw new Error("Application identifier " + current4.id + " must be at least " + ai.min + " characters long.");
    }
    if (ai.max && ai.max < code.length) {
      throw new Error("Application identifier " + current4.id + " must be at most " + ai.max + " characters long.");
    }
  };
  States128FNC1.prototype.getByLength = function getByLength(value, index) {
    var this$1 = this;
    var id;
    var applicationIdentifier;
    for (var i = 2; i <= 4; i++) {
      id = getSubstring(value, index, i);
      applicationIdentifier = this$1.getApplicationIdentifier(id) || this$1.getApplicationIdentifier(id.substring(0, id.length - 1));
      if (applicationIdentifier) {
        return {
          id,
          ai: applicationIdentifier
        };
      }
    }
    this.unsupportedAIError(id);
  };
  States128FNC1.prototype.unsupportedAIError = function unsupportedAIError(id) {
    throw new Error("'" + id + "' is not a supported Application Identifier");
  };
  States128FNC1.prototype.getBySeparator = function getBySeparator(value, index) {
    var start = value.indexOf(this.startAI, index), end = value.indexOf(this.endAI, start), id = value.substring(start + 1, end), ai = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substr(id.length - 1));
    if (!ai) {
      this.unsupportedAIError(id);
    }
    return {
      ai,
      id
    };
  };
  States128FNC1.prototype.getApplicationIdentifier = function getApplicationIdentifier(id) {
    var applicationIdentifier = this.applicationIdentifiers, multiKey = applicationIdentifier.multiKey;
    if (applicationIdentifier[id]) {
      return applicationIdentifier[id];
    }
    for (var i = 0; i < multiKey.length; i++) {
      if (multiKey[i].ids && inArray(id, multiKey[i].ids)) {
        return multiKey[i].type;
      } else if (multiKey[i].ranges) {
        var ranges = multiKey[i].ranges;
        for (var j = 0; j < ranges.length; j++) {
          if (ranges[j][0] <= id && id <= ranges[j][1]) {
            return multiKey[i].type;
          }
        }
      }
    }
  };
  return States128FNC1;
}(State128);
var Code128Base = function(Encoding2) {
  function Code128Base2(options2) {
    Encoding2.call(this, options2);
    this._initStates();
  }
  if (Encoding2)
    Code128Base2.__proto__ = Encoding2;
  Code128Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code128Base2.prototype.constructor = Code128Base2;
  Code128Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend5(this, {
      characterMap: [
        212222,
        222122,
        222221,
        121223,
        121322,
        131222,
        122213,
        122312,
        132212,
        221213,
        221312,
        231212,
        112232,
        122132,
        122231,
        113222,
        123122,
        123221,
        223211,
        221132,
        221231,
        213212,
        223112,
        312131,
        311222,
        321122,
        321221,
        312212,
        322112,
        322211,
        212123,
        212321,
        232121,
        111323,
        131123,
        131321,
        112313,
        132113,
        132311,
        211313,
        231113,
        231311,
        112133,
        112331,
        132131,
        113123,
        113321,
        133121,
        313121,
        211331,
        231131,
        213113,
        213311,
        213131,
        311123,
        311321,
        331121,
        312113,
        312311,
        332111,
        314111,
        221411,
        431111,
        111224,
        111422,
        121124,
        121421,
        141122,
        141221,
        112214,
        112412,
        122114,
        122411,
        142112,
        142211,
        241211,
        221114,
        413111,
        241112,
        134111,
        111242,
        121142,
        121241,
        114212,
        124112,
        124211,
        411212,
        421112,
        421211,
        212141,
        214121,
        412121,
        111143,
        111341,
        131141,
        114113,
        114311,
        411113,
        411311,
        113141,
        114131,
        311141,
        411131,
        211412,
        211214,
        211232,
        2331112
      ],
      STOP: 106
    });
  };
  Code128Base2.prototype._initStates = function _initStates() {
    var this$1 = this;
    for (var i = 0; i < this.states.length; i++) {
      this$1[this$1.states[i]] = new states128[this$1.states[i]](this$1, this$1.states);
    }
  };
  Code128Base2.prototype.initValue = function initValue(value, width, height) {
    this.pattern = [];
    this.value = value;
    this.width = width;
    this.height = height;
    this.checkSum = 0;
    this.totalUnits = 0;
    this.index = 0;
    this.position = 1;
  };
  Code128Base2.prototype.addData = function addData() {
    var encodingState = {
      value: this.value,
      index: 0,
      state: ""
    };
    if (this.value.length === 0) {
      return;
    }
    encodingState.state = encodingState.previousState = this.getNextState(encodingState, this.states);
    this.addStart(encodingState);
    this.pushData(encodingState, this.states);
    this.addCheckSum();
    this.addStop();
    this.setBaseUnit();
  };
  Code128Base2.prototype.pushData = function pushData(encodingState, states) {
    var this$1 = this;
    var trueCondition = true;
    while (trueCondition) {
      this$1[encodingState.state].pushState(encodingState);
      if (encodingState.index >= encodingState.value.length) {
        break;
      }
      if (!encodingState.shifted) {
        encodingState.previousState = encodingState.state;
        encodingState.state = this$1.getNextState(encodingState, states);
        this$1[encodingState.state].move(encodingState);
      } else {
        var temp = encodingState.state;
        encodingState.state = encodingState.previousState;
        encodingState.previousState = temp;
        encodingState.shifted = false;
      }
    }
  };
  Code128Base2.prototype.addStart = function addStart(encodingState) {
    this[encodingState.state].addStart(encodingState);
    this.position = 1;
  };
  Code128Base2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = this.checkSum % 103;
    this.addPattern(this.checksum);
  };
  Code128Base2.prototype.addStop = function addStop() {
    this.addPattern(this.STOP);
  };
  Code128Base2.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code128Base2.prototype.addPattern = function addPattern(code) {
    var this$1 = this;
    var pattern = this.characterMap[code].toString();
    var value;
    for (var i = 0; i < pattern.length; i++) {
      value = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value);
      this$1.totalUnits += value;
    }
    this.checkSum += code * this.position++;
  };
  Code128Base2.prototype.getNextState = function getNextState(encodingState, states) {
    var this$1 = this;
    for (var i = 0; i < states.length; i++) {
      if (this$1[states[i]].is(encodingState.value, encodingState.index)) {
        return states[i];
      }
    }
    this.invalidCharacterError(encodingState.value.charAt(encodingState.index));
  };
  return Code128Base2;
}(Encoding);
var Code128a = function(Code128Base2) {
  function Code128a2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128a2.__proto__ = Code128Base2;
  Code128a2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128a2.prototype.constructor = Code128a2;
  Code128a2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code 128 A",
      states: ["A"]
    });
  };
  return Code128a2;
}(Code128Base);
var Code128b = function(Code128Base2) {
  function Code128b2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128b2.__proto__ = Code128Base2;
  Code128b2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128b2.prototype.constructor = Code128b2;
  Code128b2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code 128 B",
      states: ["B"]
    });
  };
  return Code128b2;
}(Code128Base);
var Code128c = function(Code128Base2) {
  function Code128c2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128c2.__proto__ = Code128Base2;
  Code128c2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128c2.prototype.constructor = Code128c2;
  Code128c2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code 128 C",
      states: ["C"]
    });
  };
  return Code128c2;
}(Code128Base);
var Code128 = function(Code128Base2) {
  function Code1282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code1282.__proto__ = Code128Base2;
  Code1282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code1282.prototype.constructor = Code1282;
  Code1282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code 128",
      states: ["C", "B", "A", "FNC4"]
    });
  };
  return Code1282;
}(Code128Base);
var CodeGS1128 = function(Code128Base2) {
  function CodeGS11282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    CodeGS11282.__proto__ = Code128Base2;
  CodeGS11282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  CodeGS11282.prototype.constructor = CodeGS11282;
  CodeGS11282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code GS1-128",
      states: ["FNC1", "C", "B"]
    });
  };
  return CodeGS11282;
}(Code128Base);
function getSubstring(value, index, count) {
  return value.substring(index, index + count);
}

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/msi.js
var extend6 = Object.assign;
var MsiBase = function(Encoding2) {
  function MsiBase2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    MsiBase2.__proto__ = Encoding2;
  MsiBase2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  MsiBase2.prototype.constructor = MsiBase2;
  MsiBase2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend6(this, {
      characterMap: [
        "12121212",
        "12121221",
        "12122112",
        "12122121",
        "12211212",
        "12211221",
        "12212112",
        "12212121",
        "21121212",
        "21121221"
      ],
      START: "21",
      STOP: "121",
      checkSumType: "",
      checkSums
    });
  };
  MsiBase2.prototype.initValue = function initValue(value, width) {
    this.pattern = [];
    this.value = value;
    this.checkSumLength = 0;
    this.width = width;
  };
  MsiBase2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 7;
    this.baseUnit = this.width / (12 * (this.value.length + this.checkSumLength) + this.quietZoneLength + startStopLength);
  };
  MsiBase2.prototype.addData = function addData() {
    var this$1 = this;
    var value = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value.length; i++) {
      this$1.addCharacter(value.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  MsiBase2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    if (!pattern) {
      this.invalidCharacterError(character);
    }
    this.addPattern(pattern);
  };
  MsiBase2.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    for (var i = 0; i < pattern.length; i++) {
      this$1.pattern.push(parseInt(pattern.charAt(i), 10));
    }
  };
  MsiBase2.prototype.addCheckSum = function addCheckSum() {
    var this$1 = this;
    var checkSumFunction = this.checkSums[this.checkSumType];
    var checkValues = checkSumFunction.call(this.checkSums, this.value);
    this.checksum = checkValues.join("");
    for (var i = 0; i < checkValues.length; i++) {
      this$1.checkSumLength++;
      this$1.addPattern(this$1.characterMap[checkValues[i]]);
    }
  };
  return MsiBase2;
}(Encoding);
var MsiMod10 = function(MsiBase2) {
  function MsiMod102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod102.__proto__ = MsiBase2;
  MsiMod102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod102.prototype.constructor = MsiMod102;
  MsiMod102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend6(this, {
      name: "MSI Modulo10",
      checkSumType: "Modulo10"
    });
  };
  return MsiMod102;
}(MsiBase);
var MsiMod11 = function(MsiBase2) {
  function MsiMod112() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod112.__proto__ = MsiBase2;
  MsiMod112.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod112.prototype.constructor = MsiMod112;
  MsiMod112.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend6(this, {
      name: "MSI Modulo11",
      checkSumType: "Modulo11"
    });
  };
  return MsiMod112;
}(MsiBase);
var MsiMod1010 = function(MsiBase2) {
  function MsiMod10102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod10102.__proto__ = MsiBase2;
  MsiMod10102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod10102.prototype.constructor = MsiMod10102;
  MsiMod10102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend6(this, {
      name: "MSI Modulo10 Modulo10",
      checkSumType: "Modulo10Modulo10"
    });
  };
  return MsiMod10102;
}(MsiBase);
var MsiMod1110 = function(MsiBase2) {
  function MsiMod11102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod11102.__proto__ = MsiBase2;
  MsiMod11102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod11102.prototype.constructor = MsiMod11102;
  MsiMod11102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend6(this, {
      name: "MSI Modulo11 Modulo10",
      checkSumType: "Modulo11Modulo10"
    });
  };
  return MsiMod11102;
}(MsiBase);
var checkSums = {
  Modulo10: function Modulo10(value) {
    var checkValues = [0, ""], odd = value.length % 2, idx, evenSum, oddSum;
    for (idx = 0; idx < value.length; idx++) {
      checkValues[(idx + odd) % 2] += parseInt(value.charAt(idx), 10);
    }
    oddSum = checkValues[0];
    evenSum = (checkValues[1] * 2).toString();
    for (idx = 0; idx < evenSum.length; idx++) {
      oddSum += parseInt(evenSum.charAt(idx), 10);
    }
    return [(10 - oddSum % 10) % 10];
  },
  Modulo11: function Modulo11(value) {
    var weightedSum = 0, mod = 11, length = value.length, weight, checkValue;
    for (var i = 0; i < length; i++) {
      weight = ((length - i) % 6 || 6) + 1;
      weightedSum += weight * value.charAt(i);
    }
    checkValue = (mod - weightedSum % mod) % mod;
    if (checkValue !== 10) {
      return [checkValue];
    }
    return [1, 0];
  },
  Modulo11Modulo10: function Modulo11Modulo10(value) {
    var checkValues = this.Modulo11(value), mod11Value;
    mod11Value = value + checkValues[0];
    return checkValues.concat(this.Modulo10(mod11Value));
  },
  Modulo10Modulo10: function Modulo10Modulo10(value) {
    var checkValues = this.Modulo10(value), mod10Value;
    mod10Value = value + checkValues[0];
    return checkValues.concat(this.Modulo10(mod10Value));
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean13.js
var extend7 = Object.assign;
var Ean13 = function(Encoding2) {
  function Ean132() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Ean132.__proto__ = Encoding2;
  Ean132.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Ean132.prototype.constructor = Ean132;
  Ean132.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend7(this, {
      name: "EAN 13",
      keyTable: [
        "000000",
        "001011",
        "001101",
        "001110",
        "010011",
        "011001",
        "011100",
        "010101",
        "010110",
        "011010"
      ],
      characterMap: {
        digits: [
          [3, 2, 1, 1],
          [2, 2, 2, 1],
          [2, 1, 2, 2],
          [1, 4, 1, 1],
          [1, 1, 3, 2],
          [1, 2, 3, 1],
          [1, 1, 1, 4],
          [1, 3, 1, 2],
          [1, 2, 1, 3],
          [3, 1, 1, 2]
        ],
        start: [1, 1, 1],
        middle: [1, 1, 1, 1, 1]
      }
    });
  };
  Ean132.prototype.initValue = function initValue(value, width, height) {
    var valueAsString = String(value);
    if (valueAsString.length !== 12 || /\D/.test(valueAsString)) {
      throw new Error('The value of the "EAN13" encoding should be 12 symbols');
    }
    this.pattern = [];
    this.options.height = height;
    this.baseUnit = width / (95 + this.quietZoneLength);
    this.value = valueAsString;
    this.checksum = this.calculateChecksum();
    this.leftKey = valueAsString[0];
    this.leftPart = valueAsString.substr(1, 6);
    this.rightPart = valueAsString.substr(7) + this.checksum;
  };
  Ean132.prototype.addData = function addData() {
    this.addPieces(this.characterMap.start);
    this.addSide(this.leftPart, this.leftKey);
    this.addPieces(this.characterMap.middle);
    this.addSide(this.rightPart);
    this.addPieces(this.characterMap.start);
  };
  Ean132.prototype.addSide = function addSide(leftPart, key) {
    var this$1 = this;
    for (var i = 0; i < leftPart.length; i++) {
      if (key && parseInt(this$1.keyTable[key].charAt(i), 10)) {
        this$1.addPieces(Array.prototype.slice.call(this$1.characterMap.digits[leftPart.charAt(i)]).reverse(), true);
      } else {
        this$1.addPieces(this$1.characterMap.digits[leftPart.charAt(i)], true);
      }
    }
  };
  Ean132.prototype.addPieces = function addPieces(arrToAdd, limitedHeight) {
    var this$1 = this;
    for (var i = 0; i < arrToAdd.length; i++) {
      if (limitedHeight) {
        this$1.pattern.push({
          y1: 0,
          y2: this$1.options.height * 0.95,
          width: arrToAdd[i]
        });
      } else {
        this$1.pattern.push(arrToAdd[i]);
      }
    }
  };
  Ean132.prototype.calculateChecksum = function calculateChecksum() {
    var odd = 0, even = 0, value = this.value.split("").reverse().join("");
    for (var i = 0; i < value.length; i++) {
      if (i % 2) {
        even += parseInt(value.charAt(i), 10);
      } else {
        odd += parseInt(value.charAt(i), 10);
      }
    }
    var checksum = (10 - (3 * odd + even) % 10) % 10;
    return checksum;
  };
  return Ean132;
}(Encoding);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean8.js
var extend8 = Object.assign;
var Ean8 = function(Ean132) {
  function Ean82() {
    Ean132.apply(this, arguments);
  }
  if (Ean132)
    Ean82.__proto__ = Ean132;
  Ean82.prototype = Object.create(Ean132 && Ean132.prototype);
  Ean82.prototype.constructor = Ean82;
  Ean82.prototype.initProperties = function initProperties() {
    Ean132.prototype.initProperties.call(this);
    extend8(this, {
      name: "EAN 8"
    });
  };
  Ean82.prototype.initValue = function initValue(value, width, height) {
    if (value.length !== 7 || /\D/.test(value)) {
      throw new Error("Invalid value provided");
    }
    this.value = value;
    this.options.height = height;
    this.checksum = this.calculateChecksum(this.value);
    this.leftPart = this.value.substr(0, 4);
    this.rightPart = this.value.substr(4) + this.checksum;
    this.pattern = [];
    this.baseUnit = width / (67 + this.quietZoneLength);
  };
  return Ean82;
}(Ean13);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/main.js
var Encodings = {
  code11: Code11,
  code39: Code39,
  code39extended: Code39Extended,
  code93: Code93,
  code93extended: Code93Extended,
  code128: Code128,
  code128a: Code128a,
  code128b: Code128b,
  code128c: Code128c
};
Encodings["gs1-128"] = CodeGS1128;
Encodings.msimod10 = MsiMod10;
Encodings.msimod11 = MsiMod11;
Encodings.msimod1010 = MsiMod1010;
Encodings.msimod1110 = MsiMod1110;
Encodings.postnet = Postnet;
Encodings.ean8 = Ean8;
Encodings.ean13 = Ean13;

// node_modules/@progress/kendo-charts/dist/es/barcode/surface-size.js
function surfaceSize(element2, surfaceType) {
  var display = element2.style.display;
  if (surfaceType === "canvas") {
    element2.style.display = "block";
  }
  var size = {
    width: element2.clientWidth,
    height: element2.clientHeight
  };
  element2.style.display = display;
  return size;
}

// node_modules/@progress/kendo-charts/dist/es/barcode/barcode.js
var DEFAULT_BARCODE_WIDTH = 300;
var DEFAULT_BARCODE_HEIGHT = 100;
var Barcode = function(Class3) {
  function Barcode2(element2, options2, errorHandler) {
    if (errorHandler === void 0)
      errorHandler = defaultErrorHandler;
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.element = element2;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this._setOptions(options2);
    if (options2 && defined2(options2.value)) {
      this.redraw();
    }
  }
  if (Class3)
    Barcode2.__proto__ = Class3;
  Barcode2.prototype = Object.create(Class3 && Class3.prototype);
  Barcode2.prototype.constructor = Barcode2;
  Barcode2.prototype.destroy = function destroy2() {
    this._destroySurface();
  };
  Barcode2.prototype._initElement = function _initElement() {
    addClass(this.element, "k-barcode");
  };
  Barcode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options2.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  Barcode2.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  Barcode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  Barcode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  Barcode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  Barcode2.prototype.setOptions = function setOptions(options2) {
    this._setOptions(options2);
    this._initSurface();
    this.redraw();
  };
  Barcode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size.width,
      height: size.height
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  Barcode2.prototype.getSize = function getSize() {
    return {
      width: this.element.offsetWidth,
      height: this.element.offsetHeight
    };
  };
  Barcode2.prototype._resize = function _resize() {
    this.redraw();
  };
  Barcode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  Barcode2.prototype._render = function _render() {
    var options2 = this.options;
    var value = options2.value;
    var textOptions = options2.text;
    var textMargin = getSpacing(textOptions.margin);
    var size = this._getSize();
    var border = options2.border || {};
    var encoding = this.encoding;
    var contentBox = new box_default(0, 0, size.width, size.height).unpad(border.width).unpad(options2.padding);
    var barHeight = contentBox.height();
    var encodedValue;
    var textToDisplay;
    var textHeight;
    var visual = new drawing_exports.Group();
    this.contentBox = contentBox;
    visual.append(this._getBackground(size));
    if (textOptions.visible) {
      textHeight = drawing_exports.util.measureText(value, { font: textOptions.font }).height;
      barHeight -= textHeight + textMargin.top + textMargin.bottom;
    }
    try {
      encodedValue = encoding.encode(value, contentBox.width(), barHeight);
    } catch (error2) {
      this.onError(error2);
      return visual;
    }
    if (textOptions.visible) {
      textToDisplay = value;
      if (options2.checksum && defined2(encoding.checksum)) {
        textToDisplay += " " + encoding.checksum;
      }
      visual.append(this._getText(textToDisplay));
    }
    this.barHeight = barHeight;
    this._bandsGroup = this._getBands(encodedValue.pattern, encodedValue.baseUnit);
    visual.append(this._bandsGroup);
    return visual;
  };
  Barcode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  Barcode2.prototype._getSize = function _getSize() {
    var element2 = this.element;
    var elementSize3 = surfaceSize(element2, this.options.renderAs);
    var size = new geometry_exports.Size(DEFAULT_BARCODE_WIDTH, DEFAULT_BARCODE_HEIGHT);
    if (elementSize3.width > 0) {
      size.width = elementSize3.width;
    }
    if (elementSize3.height > 0) {
      size.height = elementSize3.height;
    }
    if (this.options.width) {
      size.width = this.options.width;
    }
    if (this.options.height) {
      size.height = this.options.height;
    }
    return size;
  };
  Barcode2.prototype.value = function value(value$1) {
    if (!defined2(value$1)) {
      return this.options.value;
    }
    this.options.value = String(value$1);
    this.redraw();
  };
  Barcode2.prototype._getBands = function _getBands(pattern, baseUnit) {
    var this$1 = this;
    var contentBox = this.contentBox;
    var offsetX = contentBox.x1;
    var stepX;
    var patternItem;
    var group = new drawing_exports.Group();
    for (var i = 0; i < pattern.length; i++) {
      patternItem = isObject(pattern[i]) ? pattern[i] : {
        width: pattern[i],
        y1: 0,
        y2: this$1.barHeight
      };
      stepX = patternItem.width * baseUnit;
      if (i % 2) {
        var rect = geometry_exports.Rect.fromPoints(
          new geometry_exports.Point(offsetX, patternItem.y1 + contentBox.y1),
          new geometry_exports.Point(offsetX + stepX, patternItem.y2 + contentBox.y1)
        );
        var path = drawing_exports.Path.fromRect(rect, {
          fill: {
            color: this$1.options.color
          },
          stroke: null
        });
        group.append(path);
      }
      offsetX += stepX;
    }
    return group;
  };
  Barcode2.prototype._getBackground = function _getBackground(size) {
    var options2 = this.options;
    var border = options2.border || {};
    var box = new box_default(0, 0, size.width, size.height).unpad(border.width / 2);
    var path = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: options2.background
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
    return path;
  };
  Barcode2.prototype._getText = function _getText(value) {
    var textOptions = this.options.text;
    var text = this._textbox = new text_box_default(value, {
      font: textOptions.font,
      color: textOptions.color,
      align: "center",
      vAlign: "bottom",
      margin: textOptions.margin
    });
    text.reflow(this.contentBox);
    text.renderVisual();
    return text.visual;
  };
  Barcode2.prototype._setOptions = function _setOptions(options2) {
    this.type = (options2.type || this.options.type).toLowerCase();
    if (this.type === "upca") {
      this.type = "ean13";
      options2.value = "0" + options2.value;
    }
    if (this.type === "upce") {
      this.type = "ean8";
      options2.value = "0" + options2.value;
    }
    if (!Encodings[this.type]) {
      throw new Error("Encoding '" + this.type + "' is not supported.");
    }
    this.encoding = new Encodings[this.type]();
    this.options = deepExtend({}, this.options, options2);
  };
  return Barcode2;
}(class_default);
setDefaultOptions(Barcode, {
  name: "Barcode",
  renderAs: "svg",
  value: "",
  type: "code39",
  checksum: false,
  width: 0,
  height: 0,
  color: "black",
  background: "white",
  text: {
    visible: true,
    font: "16px Consolas, Monaco, Sans Mono, monospace, sans-serif",
    color: "black",
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  },
  border: {
    width: 0,
    dashType: "solid",
    color: "black"
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/qrcode/utils.js
var extend9 = Object.assign;
function splitInto(str, chunkLength) {
  var result = [];
  var idx = 0;
  while (idx < str.length) {
    result.push(str.substring(idx, idx + chunkLength));
    idx += chunkLength;
  }
  return result;
}
function toBitsString(value, length) {
  var bitString = Number(value).toString(2);
  if (bitString.length < length) {
    bitString = new Array(length - bitString.length + 1).join(0) + bitString;
  }
  return bitString;
}
function toDecimal(value) {
  return parseInt(value, 2);
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/free-cell-visitor.js
var FreeCellVisitor = function(Class3) {
  function FreeCellVisitor2(matrix) {
    Class3.call(this);
    this.matrix = matrix;
    this.row = matrix.length - 1;
    this.column = matrix.length - 1;
    this.startColumn = this.column;
    this.dir = -1;
    this.c = 0;
  }
  if (Class3)
    FreeCellVisitor2.__proto__ = Class3;
  FreeCellVisitor2.prototype = Object.create(Class3 && Class3.prototype);
  FreeCellVisitor2.prototype.constructor = FreeCellVisitor2;
  FreeCellVisitor2.prototype.move = function move() {
    this.row += this.dir * this.c;
    this.c ^= 1;
    this.column = this.startColumn - this.c;
  };
  FreeCellVisitor2.prototype.getNextCell = function getNextCell() {
    var this$1 = this;
    while (this.matrix[this.row][this.column] !== void 0) {
      this$1.move();
      if (this$1.row < 0 || this$1.row >= this$1.matrix.length) {
        this$1.dir = -this$1.dir;
        this$1.startColumn -= this$1.startColumn !== 8 ? 2 : 3;
        this$1.column = this$1.startColumn;
        this$1.row = this$1.dir < 0 ? this$1.matrix.length - 1 : 0;
      }
    }
    return {
      row: this.row,
      column: this.column
    };
  };
  FreeCellVisitor2.prototype.getNextRemainderCell = function getNextRemainderCell() {
    this.move();
    if (this.matrix[this.row][this.column] === void 0) {
      return {
        row: this.row,
        column: this.column
      };
    }
  };
  return FreeCellVisitor2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding-result.js
var EncodingResult = function(Class3) {
  function EncodingResult2(dataString, version) {
    Class3.call(this);
    this.dataString = dataString;
    this.version = version;
  }
  if (Class3)
    EncodingResult2.__proto__ = Class3;
  EncodingResult2.prototype = Object.create(Class3 && Class3.prototype);
  EncodingResult2.prototype.constructor = EncodingResult2;
  return EncodingResult2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/iso-encoder.js
var IsoEncoder = function(Class3) {
  function IsoEncoder2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    IsoEncoder2.__proto__ = Class3;
  IsoEncoder2.prototype = Object.create(Class3 && Class3.prototype);
  IsoEncoder2.prototype.constructor = IsoEncoder2;
  IsoEncoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var modes = getModes(inputString), dataCodewordsCount = getDataCodewordsCount(modes), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = getDataString(modes, version);
    return new EncodingResult(dataString, version);
  };
  return IsoEncoder2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/qr-data-mode.js
var QRDataMode = function(Class3) {
  function QRDataMode2() {
    Class3.call(this);
    this.initProperties();
  }
  if (Class3)
    QRDataMode2.__proto__ = Class3;
  QRDataMode2.prototype = Object.create(Class3 && Class3.prototype);
  QRDataMode2.prototype.constructor = QRDataMode2;
  QRDataMode2.prototype.initProperties = function initProperties() {
    extend9(this, {
      modeIndicator: "",
      bitsInCharacterCount: []
    });
  };
  QRDataMode2.prototype.getVersionIndex = function getVersionIndex(version) {
    if (version < 10) {
      return 0;
    } else if (version > 26) {
      return 2;
    }
    return 1;
  };
  QRDataMode2.prototype.getBitsCharacterCount = function getBitsCharacterCount(version) {
    return this.bitsInCharacterCount[this.getVersionIndex(version || 40)];
  };
  QRDataMode2.prototype.getModeCountString = function getModeCountString(length, version) {
    return this.modeIndicator + toBitsString(length, this.getBitsCharacterCount(version));
  };
  QRDataMode2.prototype.encode = function encode() {
  };
  QRDataMode2.prototype.getStringBitsLength = function getStringBitsLength() {
  };
  QRDataMode2.prototype.getValue = function getValue() {
  };
  return QRDataMode2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/numeric-data-mode.js
var NumericQRDataMode = function(QRDataMode2) {
  function NumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    NumericQRDataMode2.__proto__ = QRDataMode2;
  NumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  NumericQRDataMode2.prototype.constructor = NumericQRDataMode2;
  NumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend9(this, {
      bitsInCharacterCount: [10, 12, 14],
      modeIndicator: "0001"
    });
  };
  NumericQRDataMode2.prototype.getValue = function getValue(character) {
    return parseInt(character, 10);
  };
  NumericQRDataMode2.prototype.encode = function encode(str, version) {
    var mode = this, parts = splitInto(str, 3), result = mode.getModeCountString(str.length, version);
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      result += toBitsString(parts[i], 10);
    }
    return result + toBitsString(parts[i], 1 + 3 * parts[i].length);
  };
  NumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    var mod3 = inputLength % 3;
    return 4 + this.getBitsCharacterCount(version) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);
  };
  return NumericQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/alpha-numeric-data-mode.js
var AlphaNumericQRDataMode = function(QRDataMode2) {
  function AlphaNumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    AlphaNumericQRDataMode2.__proto__ = QRDataMode2;
  AlphaNumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  AlphaNumericQRDataMode2.prototype.constructor = AlphaNumericQRDataMode2;
  AlphaNumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend9(this, {
      characters: {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15,
        "G": 16,
        "H": 17,
        "I": 18,
        "J": 19,
        "K": 20,
        "L": 21,
        "M": 22,
        "N": 23,
        "O": 24,
        "P": 25,
        "Q": 26,
        "R": 27,
        "S": 28,
        "T": 29,
        "U": 30,
        "V": 31,
        "W": 32,
        "X": 33,
        "Y": 34,
        "Z": 35,
        " ": 36,
        "$": 37,
        "%": 38,
        "*": 39,
        "+": 40,
        "-": 41,
        ".": 42,
        "/": 43,
        ":": 44
      },
      bitsInCharacterCount: [9, 11, 13],
      modeIndicator: "0010"
    });
  };
  AlphaNumericQRDataMode2.prototype.getValue = function getValue(character) {
    return this.characters[character];
  };
  AlphaNumericQRDataMode2.prototype.encode = function encode(str, version) {
    var this$1 = this;
    var parts = splitInto(str, 2), result = this.getModeCountString(str.length, version), value;
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      value = 45 * this$1.getValue(parts[i].charAt(0)) + this$1.getValue(parts[i].charAt(1));
      result += toBitsString(value, 11);
    }
    value = parts[i].length === 2 ? 45 * this.getValue(parts[i].charAt(0)) + this.getValue(parts[i].charAt(1)) : this.getValue(parts[i].charAt(0));
    return result + toBitsString(value, 1 + 5 * parts[i].length);
  };
  AlphaNumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);
  };
  return AlphaNumericQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/byte-data-mode.js
var ByteQRDataMode = function(QRDataMode2) {
  function ByteQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    ByteQRDataMode2.__proto__ = QRDataMode2;
  ByteQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  ByteQRDataMode2.prototype.constructor = ByteQRDataMode2;
  ByteQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend9(this, {
      bitsInCharacterCount: [8, 16, 16],
      modeIndicator: "0100"
    });
  };
  ByteQRDataMode2.prototype.getValue = function getValue(character) {
    var code = character.charCodeAt(0);
    if (code <= 127 || 160 <= code && code <= 255) {
      return code;
    }
    throw new Error('Unsupported character in QR Code: "' + character + '".');
  };
  ByteQRDataMode2.prototype.encode = function encode(str, version) {
    var mode = this, result = mode.getModeCountString(str.length, version);
    for (var i = 0; i < str.length; i++) {
      result += toBitsString(mode.getValue(str.charAt(i)), 8);
    }
    return result;
  };
  ByteQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 8 * inputLength;
  };
  return ByteQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/data-mode-instances.js
var NUMERIC = "numeric";
var ALPHA_NUMERIC = "alphanumeric";
var BYTE = "byte";
var DataModeInstances = {};
DataModeInstances[NUMERIC] = new NumericQRDataMode();
DataModeInstances[ALPHA_NUMERIC] = new AlphaNumericQRDataMode();
DataModeInstances[BYTE] = new ByteQRDataMode();

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/utf8-encoder.js
var BYTE2 = "byte";
var Utf8Encoder = function(Class3) {
  function Utf8Encoder2() {
    Class3.call(this);
    this.initProperties();
    this.mode = DataModeInstances[this.encodingMode];
  }
  if (Class3)
    Utf8Encoder2.__proto__ = Class3;
  Utf8Encoder2.prototype = Object.create(Class3 && Class3.prototype);
  Utf8Encoder2.prototype.constructor = Utf8Encoder2;
  Utf8Encoder2.prototype.initProperties = function initProperties() {
    extend9(this, {
      encodingMode: BYTE2,
      utfBOM: "111011111011101110111111",
      initialModeCountStringLength: 20,
      ranges: [128, 2048, 65536, 2097152, 67108864]
    });
  };
  Utf8Encoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var data = this.encode(inputString), dataCodewordsCount = this.getDataCodewordsCount(data), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = this.mode.getModeCountString(data.length / 8, version) + data;
    return new EncodingResult(dataString, version);
  };
  Utf8Encoder2.prototype.getDataCodewordsCount = function getDataCodewordsCount2(data) {
    var dataLength = data.length, dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);
    return dataCodewordsCount;
  };
  Utf8Encoder2.prototype.encode = function encode(str) {
    var this$1 = this;
    var result = this.utfBOM;
    for (var i = 0; i < str.length; i++) {
      result += this$1.encodeCharacter(str.charCodeAt(i));
    }
    return result;
  };
  Utf8Encoder2.prototype.encodeCharacter = function encodeCharacter(code) {
    var bytesCount = this.getBytesCount(code), bc = bytesCount - 1, result = "";
    if (bytesCount === 1) {
      result = toBitsString(code, 8);
    } else {
      var significantOnes = 8 - bytesCount;
      for (var i = 0; i < bc; i++) {
        result = toBitsString(code >> i * 6 & 63 | 128, 8) + result;
      }
      result = (code >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;
    }
    return result;
  };
  Utf8Encoder2.prototype.getBytesCount = function getBytesCount(code) {
    var ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      if (code < ranges[i]) {
        return i + 1;
      }
    }
  };
  return Utf8Encoder2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/version-codewords.js
var VersionsCodewordsInformation = [{
  L: {
    groups: [
      [1, 19]
    ],
    totalDataCodewords: 19,
    errorCodewordsPerBlock: 7
  },
  M: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 10
  },
  Q: {
    groups: [
      [1, 13]
    ],
    totalDataCodewords: 13,
    errorCodewordsPerBlock: 13
  },
  H: {
    groups: [
      [1, 9]
    ],
    totalDataCodewords: 9,
    errorCodewordsPerBlock: 17
  }
}, {
  L: {
    groups: [
      [1, 34]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 10
  },
  M: {
    groups: [
      [1, 28]
    ],
    totalDataCodewords: 28,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [1, 22]
    ],
    totalDataCodewords: 22,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [1, 55]
    ],
    totalDataCodewords: 55,
    errorCodewordsPerBlock: 15
  },
  M: {
    groups: [
      [1, 44]
    ],
    totalDataCodewords: 44,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [2, 17]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 13]
    ],
    totalDataCodewords: 26,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [1, 80]
    ],
    totalDataCodewords: 80,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [2, 32]
    ],
    totalDataCodewords: 64,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 24]
    ],
    totalDataCodewords: 48,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [4, 9]
    ],
    totalDataCodewords: 36,
    errorCodewordsPerBlock: 16
  }
}, {
  L: {
    groups: [
      [1, 108]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [2, 43]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [2, 15],
      [2, 16]
    ],
    totalDataCodewords: 62,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 11],
      [2, 12]
    ],
    totalDataCodewords: 46,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [2, 68]
    ],
    totalDataCodewords: 136,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 27]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [4, 19]
    ],
    totalDataCodewords: 76,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [4, 15]
    ],
    totalDataCodewords: 60,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [2, 78]
    ],
    totalDataCodewords: 156,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [4, 31]
    ],
    totalDataCodewords: 124,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 14],
      [4, 15]
    ],
    totalDataCodewords: 88,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [4, 13],
      [1, 14]
    ],
    totalDataCodewords: 66,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 97]
    ],
    totalDataCodewords: 194,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [2, 38],
      [2, 39]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 18],
      [2, 19]
    ],
    totalDataCodewords: 110,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [4, 14],
      [2, 15]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 116]
    ],
    totalDataCodewords: 232,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 36],
      [2, 37]
    ],
    totalDataCodewords: 182,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 16],
      [4, 17]
    ],
    totalDataCodewords: 132,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [4, 12],
      [4, 13]
    ],
    totalDataCodewords: 100,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 68],
      [2, 69]
    ],
    totalDataCodewords: 274,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 43],
      [1, 44]
    ],
    totalDataCodewords: 216,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [6, 19],
      [2, 20]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [6, 15],
      [2, 16]
    ],
    totalDataCodewords: 122,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 81]
    ],
    totalDataCodewords: 324,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [1, 50],
      [4, 51]
    ],
    totalDataCodewords: 254,
    errorCodewordsPerBlock: 30
  },
  Q: {
    groups: [
      [4, 22],
      [4, 23]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [3, 12],
      [8, 13]
    ],
    totalDataCodewords: 140,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 92],
      [2, 93]
    ],
    totalDataCodewords: 370,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [6, 36],
      [2, 37]
    ],
    totalDataCodewords: 290,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 20],
      [6, 21]
    ],
    totalDataCodewords: 206,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [7, 14],
      [4, 15]
    ],
    totalDataCodewords: 158,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 107]
    ],
    totalDataCodewords: 428,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 37],
      [1, 38]
    ],
    totalDataCodewords: 334,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [8, 20],
      [4, 21]
    ],
    totalDataCodewords: 244,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [12, 11],
      [4, 12]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [3, 115],
      [1, 116]
    ],
    totalDataCodewords: 461,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 40],
      [5, 41]
    ],
    totalDataCodewords: 365,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [11, 16],
      [5, 17]
    ],
    totalDataCodewords: 261,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [11, 12],
      [5, 13]
    ],
    totalDataCodewords: 197,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 87],
      [1, 88]
    ],
    totalDataCodewords: 523,
    errorCodewordsPerBlock: 22
  },
  M: {
    groups: [
      [5, 41],
      [5, 42]
    ],
    totalDataCodewords: 415,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [5, 24],
      [7, 25]
    ],
    totalDataCodewords: 295,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 12],
      [7, 13]
    ],
    totalDataCodewords: 223,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 98],
      [1, 99]
    ],
    totalDataCodewords: 589,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [7, 45],
      [3, 46]
    ],
    totalDataCodewords: 453,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 19],
      [2, 20]
    ],
    totalDataCodewords: 325,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [3, 15],
      [13, 16]
    ],
    totalDataCodewords: 253,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [1, 107],
      [5, 108]
    ],
    totalDataCodewords: 647,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [10, 46],
      [1, 47]
    ],
    totalDataCodewords: 507,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 22],
      [15, 23]
    ],
    totalDataCodewords: 367,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [17, 15]
    ],
    totalDataCodewords: 283,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [5, 120],
      [1, 121]
    ],
    totalDataCodewords: 721,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [9, 43],
      [4, 44]
    ],
    totalDataCodewords: 563,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [1, 23]
    ],
    totalDataCodewords: 397,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [19, 15]
    ],
    totalDataCodewords: 313,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [3, 113],
      [4, 114]
    ],
    totalDataCodewords: 795,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 44],
      [11, 45]
    ],
    totalDataCodewords: 627,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 21],
      [4, 22]
    ],
    totalDataCodewords: 445,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [9, 13],
      [16, 14]
    ],
    totalDataCodewords: 341,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [3, 107],
      [5, 108]
    ],
    totalDataCodewords: 861,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 41],
      [13, 42]
    ],
    totalDataCodewords: 669,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [15, 24],
      [5, 25]
    ],
    totalDataCodewords: 485,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [15, 15],
      [10, 16]
    ],
    totalDataCodewords: 385,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 116],
      [4, 117]
    ],
    totalDataCodewords: 932,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 42]
    ],
    totalDataCodewords: 714,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [6, 23]
    ],
    totalDataCodewords: 512,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [19, 16],
      [6, 17]
    ],
    totalDataCodewords: 406,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [2, 111],
      [7, 112]
    ],
    totalDataCodewords: 1006,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 46]
    ],
    totalDataCodewords: 782,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [16, 25]
    ],
    totalDataCodewords: 568,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [34, 13]
    ],
    totalDataCodewords: 442,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [4, 121],
      [5, 122]
    ],
    totalDataCodewords: 1094,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 47],
      [14, 48]
    ],
    totalDataCodewords: 860,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [14, 25]
    ],
    totalDataCodewords: 614,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [16, 15],
      [14, 16]
    ],
    totalDataCodewords: 464,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 117],
      [4, 118]
    ],
    totalDataCodewords: 1174,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 45],
      [14, 46]
    ],
    totalDataCodewords: 914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [16, 25]
    ],
    totalDataCodewords: 664,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [30, 16],
      [2, 17]
    ],
    totalDataCodewords: 514,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 106],
      [4, 107]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 47],
      [13, 48]
    ],
    totalDataCodewords: 1e3,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [22, 25]
    ],
    totalDataCodewords: 718,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [13, 16]
    ],
    totalDataCodewords: 538,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [10, 114],
      [2, 115]
    ],
    totalDataCodewords: 1370,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [19, 46],
      [4, 47]
    ],
    totalDataCodewords: 1062,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [28, 22],
      [6, 23]
    ],
    totalDataCodewords: 754,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [33, 16],
      [4, 17]
    ],
    totalDataCodewords: 596,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 122],
      [4, 123]
    ],
    totalDataCodewords: 1468,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [22, 45],
      [3, 46]
    ],
    totalDataCodewords: 1128,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [8, 23],
      [26, 24]
    ],
    totalDataCodewords: 808,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [12, 15],
      [28, 16]
    ],
    totalDataCodewords: 628,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [3, 117],
      [10, 118]
    ],
    totalDataCodewords: 1531,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 45],
      [23, 46]
    ],
    totalDataCodewords: 1193,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [4, 24],
      [31, 25]
    ],
    totalDataCodewords: 871,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [31, 16]
    ],
    totalDataCodewords: 661,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [7, 116],
      [7, 117]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [21, 45],
      [7, 46]
    ],
    totalDataCodewords: 1267,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 23],
      [37, 24]
    ],
    totalDataCodewords: 911,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [26, 16]
    ],
    totalDataCodewords: 701,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [5, 115],
      [10, 116]
    ],
    totalDataCodewords: 1735,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [19, 47],
      [10, 48]
    ],
    totalDataCodewords: 1373,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 24],
      [25, 25]
    ],
    totalDataCodewords: 985,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [25, 16]
    ],
    totalDataCodewords: 745,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [3, 116]
    ],
    totalDataCodewords: 1843,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [2, 46],
      [29, 47]
    ],
    totalDataCodewords: 1455,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [42, 24],
      [1, 25]
    ],
    totalDataCodewords: 1033,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [28, 16]
    ],
    totalDataCodewords: 793,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115]
    ],
    totalDataCodewords: 1955,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [10, 46],
      [23, 47]
    ],
    totalDataCodewords: 1541,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [10, 24],
      [35, 25]
    ],
    totalDataCodewords: 1115,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [35, 16]
    ],
    totalDataCodewords: 845,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115],
      [1, 116]
    ],
    totalDataCodewords: 2071,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [21, 47]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [29, 24],
      [19, 25]
    ],
    totalDataCodewords: 1171,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [46, 16]
    ],
    totalDataCodewords: 901,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [6, 116]
    ],
    totalDataCodewords: 2191,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [23, 47]
    ],
    totalDataCodewords: 1725,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [44, 24],
      [7, 25]
    ],
    totalDataCodewords: 1231,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [59, 16],
      [1, 17]
    ],
    totalDataCodewords: 961,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [12, 121],
      [7, 122]
    ],
    totalDataCodewords: 2306,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [12, 47],
      [26, 48]
    ],
    totalDataCodewords: 1812,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [39, 24],
      [14, 25]
    ],
    totalDataCodewords: 1286,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [41, 16]
    ],
    totalDataCodewords: 986,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 121],
      [14, 122]
    ],
    totalDataCodewords: 2434,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 47],
      [34, 48]
    ],
    totalDataCodewords: 1914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [46, 24],
      [10, 25]
    ],
    totalDataCodewords: 1354,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [2, 15],
      [64, 16]
    ],
    totalDataCodewords: 1054,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 122],
      [4, 123]
    ],
    totalDataCodewords: 2566,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [29, 46],
      [14, 47]
    ],
    totalDataCodewords: 1992,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [49, 24],
      [10, 25]
    ],
    totalDataCodewords: 1426,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [24, 15],
      [46, 16]
    ],
    totalDataCodewords: 1096,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [4, 122],
      [18, 123]
    ],
    totalDataCodewords: 2702,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [13, 46],
      [32, 47]
    ],
    totalDataCodewords: 2102,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [48, 24],
      [14, 25]
    ],
    totalDataCodewords: 1502,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [42, 15],
      [32, 16]
    ],
    totalDataCodewords: 1142,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [20, 117],
      [4, 118]
    ],
    totalDataCodewords: 2812,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [40, 47],
      [7, 48]
    ],
    totalDataCodewords: 2216,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [43, 24],
      [22, 25]
    ],
    totalDataCodewords: 1582,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [10, 15],
      [67, 16]
    ],
    totalDataCodewords: 1222,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [19, 118],
      [6, 119]
    ],
    totalDataCodewords: 2956,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [18, 47],
      [31, 48]
    ],
    totalDataCodewords: 2334,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [34, 24],
      [34, 25]
    ],
    totalDataCodewords: 1666,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [20, 15],
      [61, 16]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 30
  }
}];

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding.js
var terminator = "0000";
var NUMERIC2 = "numeric";
var ALPHA_NUMERIC2 = "alphanumeric";
var BYTE3 = "byte";
var powersOfTwo = { "1": 0 };
var powersOfTwoResult = { "0": 1 };
var irregularAlignmentPatternsStartDistance = {
  15: 20,
  16: 20,
  18: 24,
  19: 24,
  22: 20,
  24: 22,
  26: 24,
  28: 20,
  30: 20,
  31: 24,
  32: 28,
  33: 24,
  36: 18,
  37: 22,
  39: 20,
  40: 24
};
var finderPattern = [1, 0, 1, 1, 1];
var alignmentPattern = [1, 0, 1];
var errorCorrectionPatterns = { L: "01", M: "00", Q: "11", H: "10" };
var formatMaskPattern = "101010000010010";
var formatGeneratorPolynomial = "10100110111";
var versionGeneratorPolynomial = "1111100100101";
var paddingCodewords = ["11101100", "00010001"];
var finderPatternValue = 93;
var maskPatternConditions = [
  function(row, column) {
    return (row + column) % 2 === 0;
  },
  function(row, column) {
    return row % 2 === 0;
  },
  function(row, column) {
    return column % 3 === 0;
  },
  function(row, column) {
    return (row + column) % 3 === 0;
  },
  function(row, column) {
    return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;
  },
  function(row, column) {
    return row * column % 2 + row * column % 3 === 0;
  },
  function(row, column) {
    return (row * column % 2 + row * column % 3) % 2 === 0;
  },
  function(row, column) {
    return ((row + column) % 2 + row * column % 3) % 2 === 0;
  }
];
var numberRegex4 = /^\d+/;
var alphaPattern = "A-Z0-9 $%*+./:-";
var alphaExclusiveSet = "A-Z $%*+./:-";
var alphaRegex = new RegExp("^[" + alphaExclusiveSet + "]+");
var alphaNumericRegex = new RegExp("^[" + alphaPattern + "]+");
var byteRegex = new RegExp("^[^" + alphaPattern + "]+");
var initMinNumericBeforeAlpha = 8;
var initMinNumericBeforeByte = 5;
var initMinAlphaBeforeByte = 8;
var minNumericBeforeAlpha = 17;
var minNumericBeforeByte = 9;
var minAlphaBeforeByte = 16;
var generatorPolynomials = [[1, 0], [1, 25, 0]];
function fillFunctionCell(matrices, bit, x, y) {
  for (var i = 0; i < matrices.length; i++) {
    matrices[i][x][y] = bit;
  }
}
function fillDataCell(matrices, bit, x, y) {
  for (var i = 0; i < maskPatternConditions.length; i++) {
    matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);
  }
}
function fillData(matrices, blocks) {
  var cellVisitor = new FreeCellVisitor(matrices[0]), block, codewordIdx, cell;
  for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
    block = blocks[blockIdx];
    codewordIdx = 0;
    while (block.length > 0) {
      for (var i = 0; i < block.length; i++) {
        for (var j = 0; j < 8; j++) {
          cell = cellVisitor.getNextCell();
          fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);
        }
      }
      codewordIdx++;
      while (block[0] && codewordIdx === block[0].length) {
        block.splice(0, 1);
      }
    }
  }
  while (cell = cellVisitor.getNextRemainderCell()) {
    fillDataCell(matrices, 0, cell.row, cell.column);
  }
}
function padDataString(initialDataString, totalDataCodewords) {
  var dataBitsCount = totalDataCodewords * 8, terminatorIndex = 0, paddingCodewordIndex = 0;
  var dataString = initialDataString;
  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {
    dataString += terminator.charAt(terminatorIndex++);
  }
  if (dataString.length % 8 !== 0) {
    dataString += new Array(9 - dataString.length % 8).join("0");
  }
  while (dataString.length < dataBitsCount) {
    dataString += paddingCodewords[paddingCodewordIndex];
    paddingCodewordIndex ^= 1;
  }
  return dataString;
}
function generatePowersOfTwo() {
  var result;
  var power;
  for (power = 1; power < 255; power++) {
    result = powersOfTwoResult[power - 1] * 2;
    if (result > 255) {
      result = result ^ 285;
    }
    powersOfTwoResult[power] = result;
    powersOfTwo[result] = power;
  }
  result = powersOfTwoResult[power - 1] * 2 ^ 285;
  powersOfTwoResult[power] = result;
  powersOfTwoResult[-1] = 0;
}
function xorPolynomials(x, y) {
  var result = [], idx = x.length - 2;
  for (var i = idx; i >= 0; i--) {
    result[i] = x[i] ^ y[i];
  }
  return result;
}
function multiplyPolynomials(x, y) {
  var result = [];
  for (var i = 0; i < x.length; i++) {
    for (var j = 0; j < y.length; j++) {
      if (result[i + j] === void 0) {
        result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;
      } else {
        result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];
      }
    }
  }
  return result;
}
function generateGeneratorPolynomials() {
  var maxErrorCorrectionCodeWordsCount = 68;
  for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {
    var firstPolynomial = generatorPolynomials[idx - 1], secondPolynomial = [idx, 0];
    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);
  }
}
generatePowersOfTwo();
generateGeneratorPolynomials();
function multiplyByConstant(polynomial, power) {
  var result = [], idx = polynomial.length - 1;
  do {
    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];
    idx--;
  } while (polynomial[idx] !== void 0);
  return result;
}
function generateErrorCodewords(data, errorCodewordsCount) {
  var generator = generatorPolynomials[errorCodewordsCount - 1], result = new Array(errorCodewordsCount).concat(data), generatorPolynomial = new Array(result.length - generator.length).concat(generator), steps = data.length, errorCodewords = [], divisor, idx;
  for (idx = 0; idx < steps; idx++) {
    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);
    generatorPolynomial.splice(0, 1);
    result = xorPolynomials(divisor, result);
  }
  for (idx = result.length - 1; idx >= 0; idx--) {
    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);
  }
  return errorCodewords;
}
function getBlocks(dataStream, versionCodewordsInformation) {
  var codewordStart = 0, dataBlocks = [], errorBlocks = [], dataBlock, versionGroups = versionCodewordsInformation.groups, blockCodewordsCount, groupBlocksCount, messagePolynomial, codeword;
  for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {
    groupBlocksCount = versionGroups[groupIdx][0];
    for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {
      blockCodewordsCount = versionGroups[groupIdx][1];
      dataBlock = [];
      messagePolynomial = [];
      for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {
        codeword = dataStream.substring(codewordStart, codewordStart + 8);
        dataBlock.push(codeword);
        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);
        codewordStart += 8;
      }
      dataBlocks.push(dataBlock);
      errorBlocks.push(generateErrorCodewords(
        messagePolynomial,
        versionCodewordsInformation.errorCodewordsPerBlock
      ));
    }
  }
  return [dataBlocks, errorBlocks];
}
function chooseMode(str, minNumericBeforeAlpha2, minNumericBeforeByte2, minAlphaBeforeByte2, previousMode) {
  var numeric = numberRegex4.exec(str), numericMatch = numeric ? numeric[0] : "", alpha = alphaRegex.exec(str), alphaMatch = alpha ? alpha[0] : "", alphaNumeric = alphaNumericRegex.exec(str), alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : "", mode, modeString;
  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha2 || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte2 && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {
    mode = NUMERIC2;
    modeString = numericMatch;
  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte2 || previousMode === ALPHA_NUMERIC2)) {
    mode = ALPHA_NUMERIC2;
    modeString = numericMatch || alphaMatch;
  } else {
    mode = BYTE3;
    if (alphaNumericMatch) {
      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];
    } else {
      modeString = byteRegex.exec(str)[0];
    }
  }
  return {
    mode,
    modeString
  };
}
function getModes(inputString) {
  var modes = [], previousMode, idx = 0;
  var str = inputString;
  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));
  previousMode = modes[0].mode;
  str = str.substr(modes[0].modeString.length);
  while (str.length > 0) {
    var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);
    if (nextMode.mode !== previousMode) {
      previousMode = nextMode.mode;
      modes.push(nextMode);
      idx++;
    } else {
      modes[idx].modeString += nextMode.modeString;
    }
    str = str.substr(nextMode.modeString.length);
  }
  return modes;
}
function getDataCodewordsCount(modes) {
  var length = 0, mode;
  for (var i = 0; i < modes.length; i++) {
    mode = DataModeInstances[modes[i].mode];
    length += mode.getStringBitsLength(modes[i].modeString.length);
  }
  return Math.ceil(length / 8);
}
function getVersion(dataCodewordsCount, errorCorrectionLevel) {
  var x = 0, y = VersionsCodewordsInformation.length - 1, version = Math.floor(VersionsCodewordsInformation.length / 2);
  do {
    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {
      y = version;
    } else {
      x = version;
    }
    version = x + Math.floor((y - x) / 2);
  } while (y - x > 1);
  if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {
    return version + 1;
  }
  return y + 1;
}
function getDataString(modes, version) {
  var dataString = "", mode;
  for (var i = 0; i < modes.length; i++) {
    mode = DataModeInstances[modes[i].mode];
    dataString += mode.encode(modes[i].modeString, version);
  }
  return dataString;
}
function encodeFormatInformation(format2) {
  var formatNumber2 = toDecimal(format2), encodedString, result = "";
  if (formatNumber2 === 0) {
    return "101010000010010";
  }
  encodedString = encodeBCH(toDecimal(format2), formatGeneratorPolynomial, 15);
  for (var i = 0; i < encodedString.length; i++) {
    result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);
  }
  return result;
}
function encodeBCH(value, generatorPolynomial, codeLength) {
  var generatorNumber = toDecimal(generatorPolynomial), polynomialLength = generatorPolynomial.length - 1, valueNumber = value << polynomialLength, length = codeLength - polynomialLength, valueString = toBitsString(value, length), result = dividePolynomials(valueNumber, generatorNumber);
  result = valueString + toBitsString(result, polynomialLength);
  return result;
}
function dividePolynomials(numberX, numberY) {
  var yLength = numberY.toString(2).length, xLength = numberX.toString(2).length;
  var x = numberX;
  do {
    x ^= numberY << xLength - yLength;
    xLength = x.toString(2).length;
  } while (xLength >= yLength);
  return x;
}
function getNumberAt(str, idx) {
  return parseInt(str.charAt(idx), 10);
}
function initMatrices(version) {
  var matrices = [], modules = 17 + 4 * version;
  for (var i = 0; i < maskPatternConditions.length; i++) {
    matrices[i] = new Array(modules);
    for (var j = 0; j < modules; j++) {
      matrices[i][j] = new Array(modules);
    }
  }
  return matrices;
}
function addFormatInformation(matrices, formatString2) {
  var matrix = matrices[0], x, y, idx = 0, length = formatString2.length;
  for (x = 0, y = 8; x <= 8; x++) {
    if (x !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x, y);
    }
  }
  for (x = 8, y = 7; y >= 0; y--) {
    if (y !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x, y);
    }
  }
  idx = 0;
  for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {
    fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x, y);
  }
  fillFunctionCell(matrices, 1, matrix.length - 8, 8);
  for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {
    fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x, y);
  }
}
function encodeVersionInformation(version) {
  return encodeBCH(version, versionGeneratorPolynomial, 18);
}
function addVersionInformation(matrices, dataString) {
  var matrix = matrices[0], modules = matrix.length, x1 = 0, y1 = modules - 11, x2 = modules - 11, y2 = 0, quotient, mod, value;
  for (var idx = 0; idx < dataString.length; idx++) {
    quotient = Math.floor(idx / 3);
    mod = idx % 3;
    value = getNumberAt(dataString, dataString.length - idx - 1);
    fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);
    fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);
  }
}
function addCentricPattern(matrices, pattern, x, y) {
  var size = pattern.length + 2, length = pattern.length + 1, value;
  for (var i = 0; i < pattern.length; i++) {
    for (var j = i; j < size - i; j++) {
      value = pattern[i];
      fillFunctionCell(matrices, value, x + j, y + i);
      fillFunctionCell(matrices, value, x + i, y + j);
      fillFunctionCell(matrices, value, x + length - j, y + length - i);
      fillFunctionCell(matrices, value, x + length - i, y + length - j);
    }
  }
}
function addFinderSeparator(matrices, direction, x, y) {
  var nextX = x, nextY = y, matrix = matrices[0];
  do {
    fillFunctionCell(matrices, 0, nextX, y);
    fillFunctionCell(matrices, 0, x, nextY);
    nextX += direction[0];
    nextY += direction[1];
  } while (nextX >= 0 && nextX < matrix.length);
}
function addFinderPatterns(matrices) {
  var modules = matrices[0].length;
  addCentricPattern(matrices, finderPattern, 0, 0);
  addFinderSeparator(matrices, [-1, -1], 7, 7);
  addCentricPattern(matrices, finderPattern, modules - 7, 0);
  addFinderSeparator(matrices, [1, -1], modules - 8, 7);
  addCentricPattern(matrices, finderPattern, 0, modules - 7);
  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);
}
function addAlignmentPatterns(matrices, version) {
  if (version < 2) {
    return;
  }
  var matrix = matrices[0], modules = matrix.length, pointsCount = Math.floor(version / 7), points3 = [6], startDistance, distance, idx = 0;
  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {
    distance = (modules - 13 - startDistance) / pointsCount;
  } else {
    startDistance = distance = (modules - 13) / (pointsCount + 1);
  }
  points3.push(points3[idx++] + startDistance);
  while (points3[idx] + distance < modules) {
    points3.push(points3[idx++] + distance);
  }
  for (var i = 0; i < points3.length; i++) {
    for (var j = 0; j < points3.length; j++) {
      if (matrix[points3[i]][points3[j]] === void 0) {
        addCentricPattern(matrices, alignmentPattern, points3[i] - 2, points3[j] - 2);
      }
    }
  }
}
function addTimingFunctions(matrices) {
  var row = 6, column = 6, value = 1, modules = matrices[0].length;
  for (var i = 8; i < modules - 8; i++) {
    fillFunctionCell(matrices, value, row, i);
    fillFunctionCell(matrices, value, i, column);
    value ^= 1;
  }
}
function scoreMaskMatrixes(matrices) {
  var scores = [], previousBits = [], darkModules = [], patterns = [], adjacentSameBits = [], matrix, i, row = 0, column = 1, modulesLength = matrices[0].length;
  for (i = 0; i < matrices.length; i++) {
    scores[i] = 0;
    darkModules[i] = 0;
    adjacentSameBits[i] = [0, 0];
    patterns[i] = [0, 0];
    previousBits[i] = [];
  }
  for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {
    for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {
      for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {
        matrix = matrices[matrixIndex];
        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);
        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {
          scores[matrixIndex] += 3;
        }
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);
      }
    }
  }
  var total3 = modulesLength * modulesLength, minIdx, min3 = Number.MAX_VALUE;
  for (i = 0; i < scores.length; i++) {
    scores[i] += calculateDarkModulesRatioScore(darkModules[i], total3);
    if (scores[i] < min3) {
      min3 = scores[i];
      minIdx = i;
    }
  }
  return minIdx;
}
function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {
  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;
  if (patterns[idx][rowColumn] === finderPatternValue) {
    scores[idx] += 40;
  }
}
function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {
  if (previousBits[idx][rowColumn] === bit) {
    adjacentBits[idx][rowColumn]++;
  } else {
    previousBits[idx][rowColumn] = bit;
    if (adjacentBits[idx][rowColumn] >= 5) {
      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;
    }
    adjacentBits[idx][rowColumn] = 1;
  }
}
function calculateDarkModulesRatioScore(darkModules, total3) {
  var percent = Math.floor(darkModules / total3 * 100), mod5 = percent % 5, previous = Math.abs(percent - mod5 - 50), next = Math.abs(percent + 5 - mod5 - 50), score = 10 * Math.min(previous / 5, next / 5);
  return score;
}
function createQRCodeDataEncoder(encoding) {
  if (encoding && encoding.toLowerCase().indexOf("utf_8") >= 0) {
    return new Utf8Encoder();
  }
  return new IsoEncoder();
}
function encodeData(inputString, errorCorrectionLevel, encoding) {
  var encoder = createQRCodeDataEncoder(encoding), encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel), version = encodingResult.version, versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel], dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords), blocks = getBlocks(dataString, versionInformation), matrices = initMatrices(version);
  addFinderPatterns(matrices);
  addAlignmentPatterns(matrices, version);
  addTimingFunctions(matrices);
  if (version >= 7) {
    addVersionInformation(matrices, toBitsString(0, 18));
  }
  addFormatInformation(matrices, toBitsString(0, 15));
  fillData(matrices, blocks);
  var minIdx = scoreMaskMatrixes(matrices), optimalMatrix = matrices[minIdx];
  if (version >= 7) {
    addVersionInformation([optimalMatrix], encodeVersionInformation(version));
  }
  var formatString2 = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);
  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString2));
  return optimalMatrix;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/qrcode.js
var round4 = Math.round;
var crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];
var squarePattern = [[0, 1], [1, 1], [1, 0]];
var QRCodeDefaults = {
  DEFAULT_SIZE: 200,
  QUIET_ZONE_LENGTH: 4,
  DEFAULT_ERROR_CORRECTION_LEVEL: "L",
  DEFAULT_BACKGROUND: "#fff",
  DEFAULT_DARK_MODULE_COLOR: "#000",
  MIN_BASE_UNIT_SIZE: 1,
  DEFAULT_LOGO_SIZE: 7
};
var QRCode = function(Class3) {
  function QRCode2(element2, options2, errorHandler) {
    if (errorHandler === void 0)
      errorHandler = defaultErrorHandler;
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.element = element2;
    this.wrapper = this.element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this.setOptions(options2);
  }
  if (Class3)
    QRCode2.__proto__ = Class3;
  QRCode2.prototype = Object.create(Class3 && Class3.prototype);
  QRCode2.prototype.constructor = QRCode2;
  QRCode2.prototype.destroy = function destroy2() {
    this._destroySurface();
  };
  QRCode2.prototype._initElement = function _initElement() {
    addClass(this.element, "k-qrcode");
  };
  QRCode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options2.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  QRCode2.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  QRCode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  QRCode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  QRCode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  QRCode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size,
      height: size
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  QRCode2.prototype.getSize = function getSize() {
    var element2 = this.element;
    var elementWidth = element2.clientWidth;
    var elementHeight = element2.clientHeight;
    var size = { width: 0, height: 0 };
    if (elementWidth > 0) {
      size.width = elementWidth;
    }
    if (elementHeight) {
      size.height = elementHeight;
    }
    return size;
  };
  QRCode2.prototype._resize = function _resize() {
    this.redraw();
  };
  QRCode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  QRCode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  QRCode2.prototype._render = function _render() {
    var value = this._value, baseUnit, border = this.options.border || {}, padding = this.options.padding || 0, borderWidth = border.width || 0, quietZoneSize, matrix, size, dataSize, contentSize;
    border.width = borderWidth;
    var visual = new drawing_exports.Group();
    try {
      if (value) {
        matrix = encodeData(value, this.options.errorCorrection, this.options.encoding);
        size = this._getSize();
        contentSize = size - 2 * (borderWidth + padding);
        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);
        dataSize = matrix.length * baseUnit;
        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;
        visual.append(this._renderBackground(size, border));
        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));
        if (this._hasCustomLogo()) {
          visual.append(this._renderLogo(size, baseUnit));
        } else if (this._isSwiss()) {
          visual.append(this._renderSwissCode(size, baseUnit));
        }
      }
    } catch (error2) {
      this.onError(error2);
    }
    return visual;
  };
  QRCode2.prototype._renderLogo = function _renderLogo(qrSize, baseUnit) {
    var image;
    var imageRect;
    var center = round4(qrSize / 2);
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    var logoUrl = this.options.overlay.imageUrl;
    var position3 = {
      x: center - logoSize.width / 2,
      y: center - logoSize.height / 2
    };
    imageRect = new geometry_exports.Rect(
      new geometry_exports.Point(position3.x, position3.y),
      new geometry_exports.Size(logoSize.width, logoSize.height)
    );
    image = new drawing_exports.Image(logoUrl, imageRect);
    return image;
  };
  QRCode2.prototype._renderSwissCode = function _renderSwissCode(qrSize, baseUnit) {
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    logoSize = Math.max(logoSize.width, logoSize.height);
    var crossSize = logoSize / 4;
    var crossOffset = crossSize / 2;
    var center = qrSize / 2;
    var start = {};
    var visual = new drawing_exports.Group();
    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);
    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, "#fff"));
    start.x = start.y = center - logoSize / 2;
    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));
    start.x = center + crossOffset - logoSize / 2;
    start.y = center + crossOffset + crossSize - logoSize / 2;
    visual.append(this._renderShape(start, crossSize, crossPattern, "#fff"));
    return visual;
  };
  QRCode2.prototype._renderShape = function _renderShape(start, step, pattern, color) {
    var path = new drawing_exports.MultiPath({
      fill: {
        color
      },
      stroke: null
    });
    path.moveTo(start.x, start.y);
    for (var i = 0; i < pattern.length; i++) {
      path.lineTo(start.x + step * pattern[i][0], start.y + step * pattern[i][1]);
    }
    path.close();
    return path;
  };
  QRCode2.prototype._getSize = function _getSize() {
    var size;
    if (this.options.size) {
      size = parseInt(this.options.size, 10);
    } else {
      var element2 = this.element;
      var elementSize3 = surfaceSize(element2, this.options.renderAs);
      var min3 = Math.min(elementSize3.width, elementSize3.height);
      if (min3 > 0) {
        size = min3;
      } else {
        size = QRCodeDefaults.DEFAULT_SIZE;
      }
    }
    return size;
  };
  QRCode2.prototype._calculateBaseUnit = function _calculateBaseUnit(size, matrixSize) {
    var baseUnit = Math.floor(size / matrixSize);
    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      var minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);
      this.onError(new Error(
        "Insufficient size for QR Code: the current size is " + size + "px and the minimum size is " + minSize + "px."
      ));
    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      baseUnit--;
    }
    return baseUnit;
  };
  QRCode2.prototype._renderMatrix = function _renderMatrix(matrix, baseUnit, quietZoneSize) {
    var path = new drawing_exports.MultiPath({
      fill: {
        color: this.options.color
      },
      stroke: null
    });
    for (var row = 0; row < matrix.length; row++) {
      var y = quietZoneSize + row * baseUnit;
      var column = 0;
      while (column < matrix.length) {
        while (matrix[row][column] === 0 && column < matrix.length) {
          column++;
        }
        if (column < matrix.length) {
          var x = column;
          while (matrix[row][column] === 1) {
            column++;
          }
          var x1 = round4(quietZoneSize + x * baseUnit);
          var y1 = round4(y);
          var x2 = round4(quietZoneSize + column * baseUnit);
          var y2 = round4(y + baseUnit);
          path.moveTo(x1, y1).lineTo(x1, y2).lineTo(x2, y2).lineTo(x2, y1).close();
        }
      }
    }
    return path;
  };
  QRCode2.prototype._renderBackground = function _renderBackground(size, border) {
    var box = new box_default(0, 0, size, size).unpad(border.width / 2);
    var background = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: this.options.background
      },
      stroke: {
        color: border.color,
        width: border.width
      }
    });
    return background;
  };
  QRCode2.prototype.setOptions = function setOptions(options2) {
    var newOptions = options2 || {};
    this.options = extend9(this.options, newOptions);
    if (options2.value !== void 0) {
      this._value = String(this.options.value);
    }
    this._initSurface();
    this.redraw();
  };
  QRCode2.prototype.value = function value(value$1) {
    if (value$1 === void 0) {
      return this._value;
    }
    this._value = String(value$1);
    this.redraw();
  };
  QRCode2.prototype._hasCustomLogo = function _hasCustomLogo() {
    return Boolean(this.options.overlay.imageUrl);
  };
  QRCode2.prototype._isSwiss = function _isSwiss() {
    return this.options.overlay.type === "swiss";
  };
  QRCode2.prototype._getLogoSize = function _getLogoSize(defautLogoSize) {
    var width = this.options.overlay.width;
    var height = this.options.overlay.height;
    if (!width && !height) {
      width = height = defautLogoSize;
    } else if (width && !height) {
      height = width;
    } else if (!width && height) {
      width = height;
    }
    return {
      width,
      height
    };
  };
  return QRCode2;
}(class_default);
setDefaultOptions(QRCode, {
  name: "QRCode",
  renderAs: "svg",
  encoding: "ISO_8859_1",
  value: "",
  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,
  background: QRCodeDefaults.DEFAULT_BACKGROUND,
  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,
  size: "",
  padding: 0,
  border: {
    color: "",
    width: 0
  },
  overlay: {
    type: "image",
    imageUrl: "",
    width: 0,
    height: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/map/datums.js
var WGS84 = {
  a: 6378137,
  // Semi-major radius
  b: 6356752314245179e-9,
  // Semi-minor radius
  f: 0.0033528106647474805,
  // Flattening
  e: 0.08181919084262149
  // Eccentricity
};
var datums = {
  WGS84
};

// node_modules/@progress/kendo-charts/dist/es/map/location.js
function toSquare(value) {
  return value * value;
}
var math = Math;
var abs = math.abs;
var atan = math.atan;
var atan2 = math.atan2;
var cos = math.cos;
var sin = math.sin;
var tan = math.tan;
var Location = function(Class3) {
  function Location2(lat, lng) {
    Class3.call(this);
    this.initProperties();
    if (arguments.length === 1) {
      this.lat = lat[0];
      this.lng = lat[1];
    } else {
      this.lat = lat;
      this.lng = lng;
    }
  }
  if (Class3)
    Location2.__proto__ = Class3;
  Location2.prototype = Object.create(Class3 && Class3.prototype);
  Location2.prototype.constructor = Location2;
  Location2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      DISTANCE_ITERATIONS: 100,
      DISTANCE_CONVERGENCE: 1e-12,
      DISTANCE_PRECISION: 2,
      FORMAT: "{0:N6}{1:N6}"
    });
  };
  Location2.prototype.toArray = function toArray() {
    return [
      this.lat,
      this.lng
    ];
  };
  Location2.prototype.equals = function equals(loc) {
    return loc && loc.lat === this.lat && loc.lng === this.lng;
  };
  Location2.prototype.clone = function clone2() {
    return new Location2(this.lat, this.lng);
  };
  Location2.prototype.round = function round$1(precision) {
    this.lng = round3(this.lng, precision);
    this.lat = round3(this.lat, precision);
    return this;
  };
  Location2.prototype.wrap = function wrap2() {
    this.lng = this.lng % 180;
    this.lat = this.lat % 90;
    return this;
  };
  Location2.prototype.distanceTo = function distanceTo(dest, datum) {
    return this.greatCircleTo(dest, datum).distance;
  };
  Location2.prototype.destination = function destination(distance, initialBearing, initialDatum) {
    var bearing = rad2(initialBearing);
    var datum = initialDatum || datums.WGS84;
    var fromLat = rad2(this.lat);
    var fromLng = rad2(this.lng);
    var dToR = distance / datum.a;
    var lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));
    var lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));
    return new Location2(deg2(lat), deg2(lng));
  };
  Location2.prototype.greatCircleTo = function greatCircleTo(initialDest, initialDatum) {
    var this$1 = this;
    var dest = Location2.create(dest);
    var datum = initialDatum || datums.WGS84;
    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {
      return {
        distance: 0,
        azimuthFrom: 0,
        azimuthTo: 0
      };
    }
    var a = datum.a;
    var b = datum.b;
    var f = datum.f;
    var L = rad2(dest.lng - this.lng);
    var U1 = atan((1 - f) * tan(rad2(this.lat)));
    var sinU1 = sin(U1);
    var cosU1 = cos(U1);
    var U2 = atan((1 - f) * tan(rad2(dest.lat)));
    var sinU2 = sin(U2);
    var cosU2 = cos(U2);
    var lambda = L;
    var prevLambda;
    var i = this.DISTANCE_ITERATIONS;
    var converged = false;
    var sinLambda;
    var cosLambda;
    var sino;
    var cosA2;
    var coso;
    var cos2om;
    var sigma;
    while (!converged && i-- > 0) {
      sinLambda = sin(lambda);
      cosLambda = cos(lambda);
      sino = math.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      sigma = atan2(sino, coso);
      var sinA = cosU1 * cosU2 * sinLambda / sino;
      cosA2 = 1 - toSquare(sinA);
      cos2om = 0;
      if (cosA2 !== 0) {
        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;
      }
      prevLambda = lambda;
      var C = f / 16 * cosA2 * (4 + f * (4 - 3 * cosA2));
      lambda = L + (1 - C) * f * sinA * (sigma + C * sino * (cos2om + C * coso * (-1 + 2 * toSquare(cos2om))));
      converged = abs(lambda - prevLambda) <= this$1.DISTANCE_CONVERGENCE;
    }
    var u2 = cosA2 * (toSquare(a) - toSquare(b)) / toSquare(b);
    var A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
    var B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
    var deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));
    var azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
    var azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
    return {
      distance: round3(b * A * (sigma - deltao), this.DISTANCE_PRECISION),
      azimuthFrom: deg2(azimuthFrom),
      azimuthTo: deg2(azimuthTo)
    };
  };
  Location2.prototype.toString = function toString3() {
    return String(this.lat) + "," + String(this.lng);
  };
  Location2.fromLngLat = function fromLngLat(lngAndLat) {
    return new Location2(lngAndLat[1], lngAndLat[0]);
  };
  Location2.fromLatLng = function fromLatLng(lngAndLat) {
    return new Location2(lngAndLat[0], lngAndLat[1]);
  };
  Location2.create = function create3(a, b) {
    if (defined2(a)) {
      if (a instanceof Location2) {
        return a.clone();
      } else if (arguments.length === 1 && a.length === 2) {
        return Location2.fromLatLng(a);
      }
      return new Location2(a, b);
    }
  };
  return Location2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/crs.js
var math2 = Math;
var atan3 = math2.atan;
var exp = math2.exp;
var pow3 = math2.pow;
var sin2 = math2.sin;
var log2 = math2.log;
var tan2 = math2.tan;
var Point5 = geometry_exports.Point;
var PI = math2.PI;
var PI_DIV_22 = PI / 2;
var PI_DIV_4 = PI / 4;
var DEG_TO_RAD2 = PI / 180;
var WGS842 = datums.WGS84;
var Mercator = function(Class3) {
  function Mercator2(options2) {
    Class3.call(this);
    this.initProperties();
    this._initOptions(options2);
  }
  if (Class3)
    Mercator2.__proto__ = Class3;
  Mercator2.prototype = Object.create(Class3 && Class3.prototype);
  Mercator2.prototype.constructor = Mercator2;
  Mercator2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Mercator2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      MAX_LNG: 180,
      MAX_LAT: 85.0840590501,
      INVERSE_ITERATIONS: 15,
      INVERSE_CONVERGENCE: 1e-12
    });
  };
  Mercator2.prototype.forward = function forward(loc, clamp) {
    var proj = this, options2 = proj.options, datum = options2.datum, r = datum.a, lng0 = options2.centralMeridian, lat = limitValue2(loc.lat, -proj.MAX_LAT, proj.MAX_LAT), lng = clamp ? limitValue2(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng, x = rad2(lng - lng0) * r, y = proj._projectLat(lat);
    return new Point5(x, y);
  };
  Mercator2.prototype._projectLat = function _projectLat(lat) {
    var datum = this.options.datum, ecc = datum.e, r = datum.a, y = rad2(lat), ts = tan2(PI_DIV_4 + y / 2), con = ecc * sin2(y), p = pow3((1 - con) / (1 + con), ecc / 2);
    return r * log2(ts * p);
  };
  Mercator2.prototype.inverse = function inverse(point2, clamp) {
    var proj = this, options2 = proj.options, datum = options2.datum, r = datum.a, lng0 = options2.centralMeridian, lng = point2.x / (DEG_TO_RAD2 * r) + lng0, lat = limitValue2(proj._inverseY(point2.y), -proj.MAX_LAT, proj.MAX_LAT);
    if (clamp) {
      lng = limitValue2(lng, -proj.MAX_LNG, proj.MAX_LNG);
    }
    return new Location(lat, lng);
  };
  Mercator2.prototype._inverseY = function _inverseY(y) {
    var proj = this, datum = proj.options.datum, r = datum.a, ecc = datum.e, ecch = ecc / 2, ts = exp(-y / r), phi = PI_DIV_22 - 2 * atan3(ts), i;
    for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {
      var con = ecc * sin2(phi), p = pow3((1 - con) / (1 + con), ecch), dphi = PI_DIV_22 - 2 * atan3(ts * p) - phi;
      phi += dphi;
      if (math2.abs(dphi) <= proj.INVERSE_CONVERGENCE) {
        break;
      }
    }
    return deg2(phi);
  };
  return Mercator2;
}(class_default);
setDefaultOptions(Mercator, {
  centralMeridian: 0,
  datum: WGS842
});
var SphericalMercator = function(Mercator2) {
  function SphericalMercator2() {
    Mercator2.apply(this, arguments);
  }
  if (Mercator2)
    SphericalMercator2.__proto__ = Mercator2;
  SphericalMercator2.prototype = Object.create(Mercator2 && Mercator2.prototype);
  SphericalMercator2.prototype.constructor = SphericalMercator2;
  SphericalMercator2.prototype.initProperties = function initProperties() {
    Mercator2.prototype.initProperties.call(this);
    deepExtend(this, {
      MAX_LAT: 85.0511287798
    });
  };
  SphericalMercator2.prototype._projectLat = function _projectLat(lat) {
    var r = this.options.datum.a, y = rad2(lat), ts = tan2(PI_DIV_4 + y / 2);
    return r * log2(ts);
  };
  SphericalMercator2.prototype._inverseY = function _inverseY(y) {
    var r = this.options.datum.a, ts = exp(-y / r);
    return deg2(PI_DIV_22 - 2 * atan3(ts));
  };
  return SphericalMercator2;
}(Mercator);
var Equirectangular = function(Class3) {
  function Equirectangular2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    Equirectangular2.__proto__ = Class3;
  Equirectangular2.prototype = Object.create(Class3 && Class3.prototype);
  Equirectangular2.prototype.constructor = Equirectangular2;
  Equirectangular2.prototype.forward = function forward(loc) {
    return new Point5(loc.lng, loc.lat);
  };
  Equirectangular2.prototype.inverse = function inverse(point2) {
    return new Location(point2.y, point2.x);
  };
  return Equirectangular2;
}(class_default);
var EPSG3857 = function(Class3) {
  function EPSG38572() {
    Class3.call(this);
    var crs = this, proj = crs._proj = new SphericalMercator();
    var c = this.c = 2 * PI * proj.options.datum.a;
    this._tm = geometry_exports.transform().translate(0.5, 0.5).scale(1 / c, -1 / c);
    this._itm = geometry_exports.transform().scale(c, -c).translate(-0.5, -0.5);
  }
  if (Class3)
    EPSG38572.__proto__ = Class3;
  EPSG38572.prototype = Object.create(Class3 && Class3.prototype);
  EPSG38572.prototype.constructor = EPSG38572;
  EPSG38572.prototype.toPoint = function toPoint(loc, scale, clamp) {
    var point2 = this._proj.forward(loc, clamp);
    return point2.transform(this._tm).scale(scale || 1);
  };
  EPSG38572.prototype.toLocation = function toLocation(point2, scale, clamp) {
    var newPoint = point2.clone().scale(1 / (scale || 1)).transform(this._itm);
    return this._proj.inverse(newPoint, clamp);
  };
  return EPSG38572;
}(class_default);
var EPSG3395 = function(Class3) {
  function EPSG33952() {
    Class3.call(this);
    this._proj = new Mercator();
  }
  if (Class3)
    EPSG33952.__proto__ = Class3;
  EPSG33952.prototype = Object.create(Class3 && Class3.prototype);
  EPSG33952.prototype.constructor = EPSG33952;
  EPSG33952.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG33952.prototype.toLocation = function toLocation(point2) {
    return this._proj.inverse(point2);
  };
  return EPSG33952;
}(class_default);
var EPSG4326 = function(Class3) {
  function EPSG43262() {
    Class3.call(this);
    this._proj = new Equirectangular();
  }
  if (Class3)
    EPSG43262.__proto__ = Class3;
  EPSG43262.prototype = Object.create(Class3 && Class3.prototype);
  EPSG43262.prototype.constructor = EPSG43262;
  EPSG43262.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG43262.prototype.toLocation = function toLocation(point2) {
    return this._proj.inverse(point2);
  };
  return EPSG43262;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/utils.js
var defineProperty = Object.defineProperty;
var convertToHtml = function(html) {
  var div = document.createElement("div");
  div.innerHTML = html;
  return div.firstChild;
};
var appendHtml = function(html, element2) {
  var div = document.createElement("div");
  div.innerHTML = html;
  while (div.childNodes.length > 0) {
    element2.appendChild(div.childNodes[0]);
  }
};
var removeChildren = function(element2) {
  while (element2.firstChild) {
    element2.removeChild(element2.firstChild);
  }
};
var prepend = function(element2, originElement) {
  originElement.insertBefore(element2, originElement.firstChild);
};
var wrapInner = function(parent, wrapper) {
  parent.appendChild(wrapper);
  while (parent.firstChild !== wrapper) {
    wrapper.appendChild(parent.firstChild);
  }
};
var toHyphens = function(str) {
  var result = str.replace(/([a-z][A-Z])/g, function(g) {
    return g.charAt(0) + "-" + g.charAt(1).toLowerCase();
  });
  return result;
};
var toPixels = function(value) {
  var result;
  if (value && String(value).endsWith("px")) {
    result = value;
  } else {
    result = String(value) + "px";
  }
  return result;
};
var detectOS = function(ua) {
  var os = false, minorVersion, match = [], agentRxs = {
    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.?(\d+(\.\d+)?)?/,
    iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
    ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
    meego: /(MeeGo).+NokiaBrowser\/(\d+)\.([\d\._]+)/,
    webos: /(webOS)\/(\d+)\.(\d+(\.\d+)?)/,
    blackberry: /(BlackBerry|BB10).*?Version\/(\d+)\.(\d+(\.\d+)?)/,
    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i,
    ffos: /(Mobile).*rv:(\d+)\.(\d+(\.\d+)?).*Firefox/
  }, osRxs = {
    ios: /^i(phone|pad|pod)$/i,
    android: /^android|fire$/i,
    blackberry: /^blackberry|playbook/i,
    windows: /windows/,
    wp: /wp/,
    flat: /sailfish|ffos|tizen/i,
    meego: /meego/
  }, formFactorRxs = {
    tablet: /playbook|ipad|fire/i
  }, browserRxs = {
    omini: /Opera\sMini/i,
    omobile: /Opera\sMobi/i,
    firefox: /Firefox|Fennec/i,
    mobilesafari: /version\/.*safari/i,
    ie: /MSIE|Windows\sPhone/i,
    chrome: /chrome|crios/i,
    webkit: /webkit/i
  };
  for (var agent in agentRxs) {
    if (agentRxs.hasOwnProperty(agent)) {
      match = ua.match(agentRxs[agent]);
      if (match) {
        if (agent === "windows" && "plugins" in navigator) {
          return false;
        }
        os = {};
        os.device = agent;
        os.tablet = testRegex(agent, formFactorRxs, false);
        os.browser = testRegex(ua, browserRxs, "default");
        os.name = testRegex(agent, osRxs);
        os[os.name] = true;
        os.majorVersion = match[2];
        os.minorVersion = (match[3] || "0").replace("_", ".");
        minorVersion = os.minorVersion.replace(".", "").substr(0, 2);
        os.flatVersion = os.majorVersion + minorVersion + new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join("0");
        break;
      }
    }
  }
  return os;
};
function testRegex(agent, regexes, dflt) {
  for (var regex in regexes) {
    if (regexes.hasOwnProperty(regex) && regexes[regex].test(agent)) {
      return regex;
    }
  }
  return dflt !== void 0 ? dflt : agent;
}
var hasNativeScrolling = function(userAgent) {
  var os = detectOS(userAgent);
  return os.ios || os.android;
};
var detectBrowser = function(userAgent) {
  var browser5 = false, match = [], browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome|crios)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
  };
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      match = userAgent.match(browserRxs[agent]);
      if (match) {
        browser5 = {};
        browser5[agent] = true;
        browser5[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser5.version = parseInt(document.documentMode || match[2], 10);
        break;
      }
    }
  }
  return browser5;
};
var getEventMap = function() {
  var eventMap = {
    down: "touchstart mousedown",
    move: "mousemove touchmove",
    up: "mouseup touchend touchcancel",
    cancel: "mouseleave touchcancel"
  };
  var support3 = getSupportedFeatures();
  if (support3.touch && (support3.mobileOS.ios || support3.mobileOS.android)) {
    eventMap = {
      down: "touchstart",
      move: "touchmove",
      up: "touchend touchcancel",
      cancel: "touchcancel"
    };
  } else if (support3.pointers) {
    eventMap = {
      down: "pointerdown",
      move: "pointermove",
      up: "pointerup",
      cancel: "pointercancel pointerleave"
    };
  } else if (support3.msPointers) {
    eventMap = {
      down: "MSPointerDown",
      move: "MSPointerMove",
      up: "MSPointerUp",
      cancel: "MSPointerCancel MSPointerLeave"
    };
  }
  return eventMap;
};
var getSupportedFeatures = function() {
  var os = detectOS(navigator.userAgent);
  var browser5 = detectBrowser(navigator.userAgent);
  var chrome = browser5.chrome, mobileChrome = browser5.crios, mozilla = browser5.mozilla, safari = browser5.safari;
  var support3 = {};
  support3.mobileOS = os;
  support3.touch = "ontouchstart" in window;
  support3.pointers = !chrome && !mobileChrome && !mozilla && !safari && window.PointerEvent;
  support3.msPointers = !chrome && window.MSPointerEvent;
  support3.mouseAndTouchPresent = support3.touch && !(support3.mobileOS.ios || support3.mobileOS.android);
  support3.eventCapture = document.documentElement.addEventListener;
  var table = document.createElement("table");
  var transitions = support3.transitions = false, transforms = support3.transforms = false;
  var STRING3 = "string";
  ["Moz", "webkit", "O", "ms"].forEach(function(prefix) {
    var hasTransitions = typeof table.style[prefix + "Transition"] === STRING3;
    if (hasTransitions || typeof table.style[prefix + "Transform"] === STRING3) {
      var lowPrefix = prefix.toLowerCase();
      transforms = {
        css: lowPrefix !== "ms" ? "-" + lowPrefix + "-" : "",
        prefix,
        event: lowPrefix === "o" || lowPrefix === "webkit" ? lowPrefix : ""
      };
      if (hasTransitions) {
        transitions = transforms;
        transitions.event = transitions.event ? transitions.event + "TransitionEnd" : "transitionend";
      }
      return false;
    }
  });
  table = null;
  support3.transforms = transforms;
  support3.transitions = transitions;
  support3.delayedClick = function() {
    if (support3.touch) {
      if (support3.mobileOS.ios) {
        return true;
      }
      if (support3.mobileOS.android) {
        if (!support3.browser.chrome) {
          return true;
        }
        if (support3.browser.version < 32) {
          return false;
        }
        var meta = document.querySelector("meta[name=viewport]");
        var contentAttr = meta ? meta.getAttribute("content") : "";
        return !contentAttr.match(/user-scalable=no/i);
      }
    }
    return false;
  };
  return support3;
};
var ownsElement = function(parent, element2) {
  if (!element2) {
    return false;
  }
  var node2 = element2.parentNode;
  while (node2 !== null) {
    if (node2 === parent) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
};
var contains = function(parent, element2) {
  return parent === element2 || ownsElement(parent, element2);
};
var proxy = function(method, context2) {
  return method.bind(context2);
};
function isString3(value) {
  return typeof value === "string";
}
var on = function(element2, events2, filter, handler, useCapture) {
  addEventListeners(element2, events2, filter, handler, useCapture);
};
var addEventListeners = function(element2, events2, filter, handler, useCapture) {
  var eventNames = isArray(events2) ? events2 : (events2 || "").split(" ");
  eventNames.forEach(function(eventName) {
    addEventListener(element2, eventName, filter, handler, useCapture);
  });
};
var addEventListener = function(element2, event, filter, handler, useCapture) {
  var eventHandler = handler;
  var eventFilter;
  if (filter && isFunction3(filter) && !handler) {
    eventHandler = filter;
  } else if (filter && isString3(filter) && isFunction3(eventHandler)) {
    eventFilter = filter;
  }
  element2.addEventListener(event, function(e) {
    var closestMatchingTarget = e.target ? e.target.closest(eventFilter) : null;
    if (!eventFilter || eventFilter && e.target && closestMatchingTarget) {
      var currentTarget = eventFilter ? closestMatchingTarget : e.currentTarget;
      defineProperty(e, "currentTarget", { value: currentTarget });
      defineProperty(e, "delegateTarget", { value: element2 });
      eventHandler(e);
    }
  }, Boolean(useCapture));
};
var off = function(element2, events2, filter, handler, useCapture) {
  removeEventListeners(element2, events2, filter, handler, useCapture);
};
var removeEventListeners = function(element2, events2, handler, useCapture) {
  var eventNames = isArray(events2) ? events2 : (events2 || "").split(" ");
  eventNames.forEach(function(eventName) {
    removeEventListener(element2, eventName, handler, useCapture);
  });
};
var removeEventListener = function(element2, event, handler, useCapture) {
  element2.removeEventListener(event, handler, Boolean(useCapture));
};
var applyEventMap = function(events2) {
  var eventMap = getEventMap(navigator.userAgent);
  function queryEventMap(e) {
    return eventMap[e] || e;
  }
  var eventRegEx = /([^ ]+)/g;
  var appliedEvents = events2.replace(eventRegEx, queryEventMap);
  return appliedEvents;
};
var setDefaultEvents = function(type, events2) {
  var proto = type.prototype;
  if (proto.events) {
    events2.forEach(function(event) {
      if (proto.events.indexOf(event) < 0) {
        proto.events.push(event);
      }
    });
  } else {
    proto.events = events2;
  }
};
var wheelDeltaY = function(jQueryEvent) {
  var e = jQueryEvent.originalEvent || jQueryEvent;
  var deltaY = e.wheelDeltaY;
  var delta;
  if (e.wheelDelta) {
    if (deltaY === void 0 || deltaY) {
      delta = e.wheelDelta;
    }
  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
    delta = -e.detail * 10;
  }
  return delta;
};
var now2 = function() {
  return Number(/* @__PURE__ */ new Date());
};
var noop = function() {
};
var renderPos = function(pos) {
  var result = [];
  if (pos) {
    var parts = toHyphens(pos).split("-");
    for (var i = 0; i < parts.length; i++) {
      result.push("k-pos-" + parts[i]);
    }
  }
  return result.join(" ");
};

// node_modules/@progress/kendo-charts/dist/es/map/scroller/observable.js
var STRING2 = "string";
var FUNCTION = "function";
var preventDefault3 = function() {
  this._defaultPrevented = true;
};
var isDefaultPrevented2 = function() {
  return this._defaultPrevented === true;
};
var Observable2 = function(Class3) {
  function Observable3() {
    Class3.call(this);
    this._events = {};
  }
  if (Class3)
    Observable3.__proto__ = Class3;
  Observable3.prototype = Object.create(Class3 && Class3.prototype);
  Observable3.prototype.constructor = Observable3;
  Observable3.prototype.destroy = function destroy2() {
    this.unbind();
  };
  Observable3.prototype.bind = function bind(event, handlers, one) {
    var that = this, idx, eventNames = typeof event === STRING2 ? [event] : event || [], length, original, handler, handlersIsFunction = typeof handlers === FUNCTION, events2;
    if (handlers === void 0) {
      for (idx in event) {
        that.bind(idx, event[idx]);
      }
      return that;
    }
    var loop = function() {
      var eventName = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName];
      if (handler) {
        if (one) {
          original = handler;
          handler = function() {
            that.unbind(eventName, handler);
            original.apply(that, arguments);
          };
          handler.original = original;
        }
        events2 = that._events[eventName] = that._events[eventName] || [];
        events2.push(handler);
      }
    };
    for (idx = 0, length = eventNames.length; idx < length; idx++)
      loop();
    return that;
  };
  Observable3.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable3.prototype.first = function first(eventName, handlers) {
    var that = this, idx, eventNames = typeof eventName === STRING2 ? [eventName] : eventName, length, handler, handlersIsFunction = typeof handlers === FUNCTION, events2;
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      var eventName$1 = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        events2 = that._events[eventName$1] = that._events[eventName$1] || [];
        events2.unshift(handler);
      }
    }
    return that;
  };
  Observable3.prototype.trigger = function trigger2(eventName, eventArgs2) {
    var that = this, events2 = that._events[eventName], idx, length;
    if (events2) {
      var e = eventArgs2 || {};
      e.sender = that;
      e._defaultPrevented = false;
      e.preventDefault = preventDefault3;
      e.isDefaultPrevented = isDefaultPrevented2;
      events2 = events2.slice();
      for (idx = 0, length = events2.length; idx < length; idx++) {
        events2[idx].call(that, e);
      }
      return e._defaultPrevented === true;
    }
    return false;
  };
  Observable3.prototype.unbind = function unbind(eventName, handler) {
    var that = this, events2 = that._events[eventName], idx;
    if (eventName === void 0) {
      that._events = {};
    } else if (events2) {
      if (handler) {
        for (idx = events2.length - 1; idx >= 0; idx--) {
          if (events2[idx] === handler || events2[idx].original === handler) {
            events2.splice(idx, 1);
          }
        }
      } else {
        that._events[eventName] = [];
      }
    }
    return that;
  };
  Observable3.prototype._setEvents = function _setEvents(options2) {
    var this$1 = this;
    var length = (this.events || []).length;
    for (var idx = 0; idx < length; idx++) {
      var e = this$1.events[idx];
      if (this$1.options[e] && options2[e]) {
        this$1.unbind(e, this$1.options[e]);
        if (this$1._events && this$1._events[e]) {
          delete this$1._events[e];
        }
      }
    }
    this.bind(this.events, options2);
  };
  return Observable3;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/attribution.js
var Attribution = function(Observable3) {
  function Attribution2(element2, options2) {
    Observable3.call(this);
    this.element = element2;
    this._initOptions(options2);
    this.items = [];
    addClass(this.element, "k-widget k-attribution");
  }
  if (Observable3)
    Attribution2.__proto__ = Observable3;
  Attribution2.prototype = Object.create(Observable3 && Observable3.prototype);
  Attribution2.prototype.constructor = Attribution2;
  Attribution2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Attribution2.prototype.filter = function filter(extent, zoom) {
    this._extent = extent;
    this._zoom = zoom;
    this._render();
  };
  Attribution2.prototype.add = function add3(item) {
    var newItem = item;
    if (defined2(item)) {
      if (typeof item === "string") {
        newItem = {
          text: item
        };
      }
      this.items.push(newItem);
      this._render();
    }
  };
  Attribution2.prototype.remove = function remove(text) {
    var this$1 = this;
    var result = [];
    for (var i = 0; i < this.items.length; i++) {
      var item = this$1.items[i];
      if (item.text !== text) {
        result.push(item);
      }
    }
    this.items = result;
    this._render();
  };
  Attribution2.prototype.clear = function clear4() {
    this.items = [];
    removeChildren(this.element);
  };
  Attribution2.prototype._render = function _render() {
    var this$1 = this;
    var result = [];
    for (var i = 0; i < this.items.length; i++) {
      var item = this$1.items[i];
      var text = this$1._itemText(item);
      if (text !== "") {
        result.push(text);
      }
    }
    if (result.length > 0) {
      removeChildren(this.element);
      var html = result.join(this.options.separator);
      appendHtml(html, this.element);
      this.showElement();
    } else {
      this.hideElement();
    }
  };
  Attribution2.prototype.hideElement = function hideElement() {
    this.element.style.display = "none";
  };
  Attribution2.prototype.showElement = function showElement() {
    this.element.style.display = "";
  };
  Attribution2.prototype._itemText = function _itemText(item) {
    var text = "";
    var inZoomLevel = this._inZoomLevel(item.minZoom, item.maxZoom);
    var inArea = this._inArea(item.extent);
    if (inZoomLevel && inArea) {
      text += item.text;
    }
    return text;
  };
  Attribution2.prototype._inZoomLevel = function _inZoomLevel(min3, max2) {
    var result = true;
    var newMin = valueOrDefault2(min3, -Number.MAX_VALUE);
    var newMax = valueOrDefault2(max2, Number.MAX_VALUE);
    result = this._zoom > newMin && this._zoom < newMax;
    return result;
  };
  Attribution2.prototype._inArea = function _inArea(area) {
    var result = true;
    if (area) {
      result = area.contains(this._extent);
    }
    return result;
  };
  return Attribution2;
}(Observable2);
setDefaultOptions(Attribution, {
  name: "Attribution",
  separator: "&nbsp;|&nbsp;"
});

// node_modules/@progress/kendo-charts/dist/es/map/navigator.js
var PAN = "pan";
var directionsMap = {
  up: {
    className: "k-navigator-n",
    iconClass: "k-i-caret-alt-up"
  },
  down: {
    className: "k-navigator-s",
    iconClass: "k-i-caret-alt-down"
  },
  right: {
    className: "k-navigator-e",
    iconClass: "k-i-caret-alt-right"
  },
  left: {
    className: "k-navigator-w",
    iconClass: "k-i-caret-alt-left"
  }
};
function createButton(direction) {
  var html = '<button class="k-button k-button-square k-rounded-full k-button-flat k-button-flat-base k-icon-button ' + directionsMap[direction].className + '" aria-label="move ' + direction + '"><span class="k-icon ' + directionsMap[direction].iconClass + '" /></button>';
  return convertToHtml(html);
}
var Navigator2 = function(Observable3) {
  function Navigator3(element2, options2) {
    Observable3.call(this);
    this.element = element2;
    this._initOptions(options2);
    var navigateUpButton = createButton("up");
    var navigateRightlButton = createButton("right");
    var navigateDownButton = createButton("down");
    var navigateLeftButton = createButton("left");
    this.element.appendChild(navigateUpButton);
    this.element.appendChild(navigateRightlButton);
    this.element.appendChild(navigateDownButton);
    this.element.appendChild(navigateLeftButton);
    addClass(this.element, "k-widget k-navigator");
    on(this.element, "click", ".k-button", proxy(this._click, this));
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = proxy(this._keydown, this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable3)
    Navigator3.__proto__ = Observable3;
  Navigator3.prototype = Object.create(Observable3 && Observable3.prototype);
  Navigator3.prototype.constructor = Navigator3;
  Navigator3.prototype.destroy = function destroy2() {
    this.dispose();
  };
  Navigator3.prototype.dispose = function dispose() {
    off(this._keyroot, "keydown", this._keydownHandler);
  };
  Navigator3.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element2 = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element2.getAttribute(TABINDEX);
    element2.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  Navigator3.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Navigator3.prototype._pan = function _pan(x, y) {
    var panStep = this.options.panStep;
    this.trigger(PAN, {
      x: x * panStep,
      y: y * panStep
    });
  };
  Navigator3.prototype._click = function _click(e) {
    var x = 0;
    var y = 0;
    var button = e.currentTarget;
    if (button.matches(".k-navigator-n")) {
      y = 1;
    } else if (button.matches(".k-navigator-s")) {
      y = -1;
    } else if (button.matches(".k-navigator-e")) {
      x = 1;
    } else if (button.matches(".k-navigator-w")) {
      x = -1;
    }
    this._pan(x, y);
    e.preventDefault();
  };
  Navigator3.prototype._keydown = function _keydown(e) {
    switch (e.which) {
      case keys_default.UP:
        this._pan(0, 1);
        e.preventDefault();
        break;
      case keys_default.DOWN:
        this._pan(0, -1);
        e.preventDefault();
        break;
      case keys_default.RIGHT:
        this._pan(1, 0);
        e.preventDefault();
        break;
      case keys_default.LEFT:
        this._pan(-1, 0);
        e.preventDefault();
        break;
      default:
        break;
    }
  };
  return Navigator3;
}(Observable2);
setDefaultOptions(Navigator2, {
  name: "Navigator",
  panStep: 1
});
setDefaultEvents(Navigator2, [
  PAN
]);

// node_modules/@progress/kendo-charts/dist/es/map/zoom.js
function createButton2(direction, iconClass) {
  var html = '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-zoom-' + direction + '" title="zoom-' + direction + '" aria-label="zoom-' + direction + '"><span class="k-icon ' + iconClass + '"></span></button>';
  return convertToHtml(html);
}
var PLUS = 187;
var MINUS = 189;
var FF_PLUS = 61;
var FF_MINUS = 173;
var CHANGE = "change";
var ZoomControl = function(Observable3) {
  function ZoomControl2(element2, options2) {
    Observable3.call(this);
    this.element = element2;
    this._initOptions(options2);
    var zoomInButton = createButton2("in", "k-i-plus");
    var zoomOutButton = createButton2("out", "k-i-minus");
    this.element.appendChild(zoomInButton);
    this.element.appendChild(zoomOutButton);
    addClass(this.element, "k-widget k-zoom-control k-button-group k-group-horizontal");
    this._clickHandler = this._click.bind(this);
    on(this.element, "click", ".k-button", this._clickHandler);
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = this._keydown.bind(this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable3)
    ZoomControl2.__proto__ = Observable3;
  ZoomControl2.prototype = Object.create(Observable3 && Observable3.prototype);
  ZoomControl2.prototype.constructor = ZoomControl2;
  ZoomControl2.prototype.destroy = function destroy2() {
    if (this.element) {
      off(this.element, "click", this._clickHandler);
    }
    if (this._keyroot) {
      off(this._keyroot, "keydown", this._keydownHandler);
    }
  };
  ZoomControl2.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element2 = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element2.getAttribute(TABINDEX);
    element2.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  ZoomControl2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  ZoomControl2.prototype._change = function _change(direction) {
    var zoomStep = this.options.zoomStep;
    this.trigger(CHANGE, { delta: direction * zoomStep });
  };
  ZoomControl2.prototype._click = function _click(e) {
    var button = e.currentTarget;
    var direction = 1;
    if (hasClasses(button, "k-zoom-out")) {
      direction = -1;
    }
    this._change(direction);
    e.preventDefault();
  };
  ZoomControl2.prototype._keydown = function _keydown(e) {
    switch (e.which) {
      case keys_default.NUMPAD_PLUS:
      case PLUS:
      case FF_PLUS:
        this._change(1);
        break;
      case keys_default.NUMPAD_MINUS:
      case MINUS:
      case FF_MINUS:
        this._change(-1);
        break;
      default:
        break;
    }
  };
  return ZoomControl2;
}(Observable2);
setDefaultOptions(ZoomControl, {
  name: "ZoomControl",
  zoomStep: 1
});
setDefaultEvents(ZoomControl, [
  CHANGE
]);

// node_modules/@progress/kendo-charts/dist/es/map/extent.js
var math3 = Math;
var max = math3.max;
var min = math3.min;
var Extent = function(Class3) {
  function Extent2(initialNw, initialSe) {
    Class3.call(this);
    var nw = Location.create(initialNw);
    var se = Location.create(initialSe);
    if (nw.lng + 180 > se.lng + 180 && nw.lat + 90 < se.lat + 90) {
      this.se = nw;
      this.nw = se;
    } else {
      this.se = se;
      this.nw = nw;
    }
  }
  if (Class3)
    Extent2.__proto__ = Class3;
  Extent2.prototype = Object.create(Class3 && Class3.prototype);
  Extent2.prototype.constructor = Extent2;
  var staticAccessors2 = { World: { configurable: true } };
  Extent2.prototype.contains = function contains2(loc) {
    var nw = this.nw, se = this.se, lng = valueOrDefault2(loc.lng, loc[1]), lat = valueOrDefault2(loc.lat, loc[0]);
    return loc && lng + 180 >= nw.lng + 180 && lng + 180 <= se.lng + 180 && lat + 90 >= se.lat + 90 && lat + 90 <= nw.lat + 90;
  };
  Extent2.prototype.center = function center() {
    var nw = this.nw;
    var se = this.se;
    var lng = nw.lng + (se.lng - nw.lng) / 2;
    var lat = nw.lat + (se.lat - nw.lat) / 2;
    return new Location(lat, lng);
  };
  Extent2.prototype.containsAny = function containsAny(locs) {
    var this$1 = this;
    var result = false;
    for (var i = 0; i < locs.length; i++) {
      result = result || this$1.contains(locs[i]);
    }
    return result;
  };
  Extent2.prototype.include = function include(loc) {
    var nw = this.nw, se = this.se, lng = valueOrDefault2(loc.lng, loc[1]), lat = valueOrDefault2(loc.lat, loc[0]);
    nw.lng = min(nw.lng, lng);
    nw.lat = max(nw.lat, lat);
    se.lng = max(se.lng, lng);
    se.lat = min(se.lat, lat);
  };
  Extent2.prototype.includeAll = function includeAll(locs) {
    var this$1 = this;
    for (var i = 0; i < locs.length; i++) {
      this$1.include(locs[i]);
    }
  };
  Extent2.prototype.edges = function edges() {
    var nw = this.nw, se = this.se;
    return {
      nw: this.nw,
      ne: new Location(nw.lat, se.lng),
      se: this.se,
      sw: new Location(se.lat, nw.lng)
    };
  };
  Extent2.prototype.toArray = function toArray() {
    var nw = this.nw, se = this.se;
    return [
      nw,
      new Location(nw.lat, se.lng),
      se,
      new Location(se.lat, nw.lng)
    ];
  };
  Extent2.prototype.overlaps = function overlaps(extent) {
    return this.containsAny(extent.toArray()) || extent.containsAny(this.toArray());
  };
  Extent2.create = function create3(a, b) {
    if (a instanceof Extent2) {
      return a;
    } else if (a && b) {
      return new Extent2(a, b);
    } else if (a && a.length === 4 && !b) {
      return new Extent2([
        a[0],
        a[1]
      ], [
        a[2],
        a[3]
      ]);
    }
  };
  staticAccessors2.World.get = function() {
    return new Extent2([90, -180], [-90, 180]);
  };
  Object.defineProperties(Extent2, staticAccessors2);
  return Extent2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/constants.js
var SHOW_TOOLTIP2 = "showTooltip";
var HIDE_TOOLTIP2 = "hideTooltip";
var CENTER_CHANGE = "centerChange";
var ZOOM_CHANGE = "zoomChange";
var INIT = "init";

// node_modules/@progress/kendo-charts/dist/es/map/tooltip/tooltip.js
var Tooltip2 = function(Class3) {
  function Tooltip3(widgetService, options2) {
    Class3.call(this);
    this.widgetService = widgetService;
    this.options = deepExtend({}, this.options, options2);
    this.offset = { x: 0, y: 0 };
  }
  if (Class3)
    Tooltip3.__proto__ = Class3;
  Tooltip3.prototype = Object.create(Class3 && Class3.prototype);
  Tooltip3.prototype.constructor = Tooltip3;
  var prototypeAccessors4 = { anchor: { configurable: true } };
  Tooltip3.prototype.show = function show2(anchor, args) {
    if (this.location === args.location) {
      return;
    }
    this.anchor = anchor;
    this.location = args.location;
    this.widgetService.notify(
      SHOW_TOOLTIP2,
      Object.assign({ anchor: this.anchor }, args)
    );
    this.visible = true;
  };
  Tooltip3.prototype.hide = function hide2() {
    if (this.widgetService) {
      this.widgetService.notify(HIDE_TOOLTIP2);
    }
    this.visible = false;
    this.location = null;
  };
  prototypeAccessors4.anchor.get = function() {
    return this._anchor;
  };
  prototypeAccessors4.anchor.set = function(anchor) {
    var documentPoint = this.widgetService.widget._toDocumentCoordinates({
      x: anchor.left - this.offset.x,
      y: anchor.top - this.offset.y
    });
    this._anchor = {
      left: documentPoint.left,
      top: documentPoint.top
    };
  };
  Tooltip3.prototype.destroy = function destroy2() {
    this.widgetService = null;
  };
  Object.defineProperties(Tooltip3.prototype, prototypeAccessors4);
  return Tooltip3;
}(class_default);
setDefaultOptions(Tooltip2, {
  border: {
    width: 1
  },
  opacity: 1
});

// node_modules/@progress/kendo-charts/dist/es/map/layers/layer.js
var Layer = function(Class3) {
  function Layer2(map2, options2) {
    Class3.call(this);
    this.support = getSupportedFeatures();
    this._initOptions(options2);
    this.map = map2;
    var element2 = document.createElement("div");
    addClass(element2, "k-layer");
    element2.style.zIndex = this.options.zIndex;
    element2.style.opacity = this.options.opacity;
    this.element = element2;
    map2.scrollElement.appendChild(this.element);
    this._beforeReset = this._beforeReset.bind(this);
    this._reset = this._reset.bind(this);
    this._resize = this._resize.bind(this);
    this._panEnd = this._panEnd.bind(this);
    this._activate();
    this._updateAttribution();
  }
  if (Class3)
    Layer2.__proto__ = Class3;
  Layer2.prototype = Object.create(Class3 && Class3.prototype);
  Layer2.prototype.constructor = Layer2;
  Layer2.prototype.destroy = function destroy2() {
    this._deactivate();
  };
  Layer2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Layer2.prototype.show = function show2() {
    this.reset();
    this._activate();
    this._applyExtent(true);
  };
  Layer2.prototype.hide = function hide2() {
    this._deactivate();
    this._setVisibility(false);
  };
  Layer2.prototype.reset = function reset() {
    this._beforeReset();
    this._reset();
  };
  Layer2.prototype._reset = function _reset() {
    this._applyExtent();
  };
  Layer2.prototype._beforeReset = function _beforeReset() {
  };
  Layer2.prototype._resize = function _resize() {
  };
  Layer2.prototype._panEnd = function _panEnd() {
    this._applyExtent();
  };
  Layer2.prototype._applyExtent = function _applyExtent() {
    var options2 = this.options;
    var zoom = this.map.zoom();
    var matchMinZoom = !defined2(options2.minZoom) || zoom >= options2.minZoom;
    var matchMaxZoom = !defined2(options2.maxZoom) || zoom <= options2.maxZoom;
    var extent = Extent.create(options2.extent);
    var inside = !extent || extent.overlaps(this.map.extent());
    this._setVisibility(matchMinZoom && matchMaxZoom && inside);
  };
  Layer2.prototype._setVisibility = function _setVisibility(visible) {
    this.element.style.display = visible ? "" : "none";
  };
  Layer2.prototype._activate = function _activate() {
    var map2 = this.map;
    this._deactivate();
    map2.bind("beforeReset", this._beforeReset);
    map2.bind("reset", this._reset);
    map2.bind("resize", this._resize);
    map2.bind("panEnd", this._panEnd);
  };
  Layer2.prototype._deactivate = function _deactivate() {
    var map2 = this.map;
    map2.unbind("beforeReset", this._beforeReset);
    map2.unbind("reset", this._reset);
    map2.unbind("resize", this._resize);
    map2.unbind("panEnd", this._panEnd);
  };
  Layer2.prototype._updateAttribution = function _updateAttribution() {
    var attribution = this.map.attribution;
    if (attribution) {
      attribution.add(this.options.attribution);
    }
  };
  Layer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  Layer2.prototype._hasData = function _hasData() {
    return this._data && this._data.length > 0;
  };
  Layer2.prototype._layerIndex = function _layerIndex() {
    var layers = this.map.layers || [];
    return layers.indexOf(this);
  };
  return Layer2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/tile.js
var math4 = Math;
var Point6 = geometry_exports.Point;
function compileTemplate(template3) {
  if (isFunction3(template3)) {
    return template3;
  }
  return template_service_default.compile(template3);
}
function roundPoint(point2) {
  return new Point6(round3(point2.x), round3(point2.y));
}
function renderSize(size) {
  var newSize = size;
  if (typeof size !== "string") {
    newSize += "px";
  }
  return newSize;
}
var TileLayer = function(Layer2) {
  function TileLayer2(map2, options2) {
    Layer2.call(this, map2, options2);
    if (typeof this.options.subdomains === "string") {
      this.options.subdomains = this.options.subdomains.split("");
    }
    var viewType = this._viewType();
    this._view = new viewType(this.element, this.options);
  }
  if (Layer2)
    TileLayer2.__proto__ = Layer2;
  TileLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  TileLayer2.prototype.constructor = TileLayer2;
  TileLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    this._view.destroy();
    this._view = null;
  };
  TileLayer2.prototype._beforeReset = function _beforeReset() {
    var map2 = this.map;
    var origin = map2.locationToLayer(map2.extent().nw).round();
    this._view.viewOrigin(origin);
  };
  TileLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._updateView();
    this._view.reset();
  };
  TileLayer2.prototype._viewType = function _viewType() {
    return TileView;
  };
  TileLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    if (!this.support.mobileOS) {
      if (!this._pan) {
        this._pan = throttle(this._render.bind(this), 100);
      }
      this.map.bind("pan", this._pan);
    }
  };
  TileLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    if (this._pan) {
      this.map.unbind("pan", this._pan);
    }
  };
  TileLayer2.prototype._updateView = function _updateView() {
    var view = this._view, map2 = this.map, extent = map2.extent(), extentToPoint = {
      nw: map2.locationToLayer(extent.nw).round(),
      se: map2.locationToLayer(extent.se).round()
    };
    view.center(map2.locationToLayer(map2.center()));
    view.extent(extentToPoint);
    view.zoom(map2.zoom());
  };
  TileLayer2.prototype._resize = function _resize() {
    this._render();
  };
  TileLayer2.prototype._panEnd = function _panEnd(e) {
    Layer2.prototype._panEnd.call(this, e);
    this._render();
  };
  TileLayer2.prototype._render = function _render() {
    this._updateView();
    this._view.render();
  };
  return TileLayer2;
}(Layer);
setDefaultOptions(TileLayer, {
  tileSize: 256,
  subdomains: ["a", "b", "c"],
  urlTemplate: "",
  zIndex: 1
});
var TileView = function(Class3) {
  function TileView2(element2, options2) {
    Class3.call(this);
    this.element = element2;
    this._initOptions(options2);
    this.pool = new TilePool();
  }
  if (Class3)
    TileView2.__proto__ = Class3;
  TileView2.prototype = Object.create(Class3 && Class3.prototype);
  TileView2.prototype.constructor = TileView2;
  TileView2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  TileView2.prototype.center = function center(center$1) {
    this._center = center$1;
  };
  TileView2.prototype.extent = function extent(extent$1) {
    this._extent = extent$1;
  };
  TileView2.prototype.viewOrigin = function viewOrigin(origin) {
    this._viewOrigin = origin;
  };
  TileView2.prototype.zoom = function zoom(zoom$1) {
    this._zoom = zoom$1;
  };
  TileView2.prototype.pointToTileIndex = function pointToTileIndex(point2) {
    return new Point6(math4.floor(point2.x / this.options.tileSize), math4.floor(point2.y / this.options.tileSize));
  };
  TileView2.prototype.tileCount = function tileCount() {
    var size = this.size(), firstTileIndex = this.pointToTileIndex(this._extent.nw), nw = this._extent.nw, point2 = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);
    return {
      x: math4.ceil((math4.abs(point2.x) + size.width) / this.options.tileSize),
      y: math4.ceil((math4.abs(point2.y) + size.height) / this.options.tileSize)
    };
  };
  TileView2.prototype.size = function size() {
    var nw = this._extent.nw, se = this._extent.se, diff = se.clone().translate(-nw.x, -nw.y);
    return {
      width: diff.x,
      height: diff.y
    };
  };
  TileView2.prototype.indexToPoint = function indexToPoint(index) {
    var x = index.x, y = index.y;
    return new Point6(x * this.options.tileSize, y * this.options.tileSize);
  };
  TileView2.prototype.subdomainText = function subdomainText() {
    var subdomains = this.options.subdomains;
    return subdomains[this.subdomainIndex++ % subdomains.length];
  };
  TileView2.prototype.destroy = function destroy2() {
    removeChildren(this.element);
    this.pool.empty();
  };
  TileView2.prototype.reset = function reset() {
    this.pool.reset();
    this.subdomainIndex = 0;
    this.render();
  };
  TileView2.prototype.render = function render() {
    var this$1 = this;
    var size = this.tileCount(), firstTileIndex = this.pointToTileIndex(this._extent.nw), tile, x, y;
    for (x = 0; x < size.x; x++) {
      for (y = 0; y < size.y; y++) {
        tile = this$1.createTile({
          x: firstTileIndex.x + x,
          y: firstTileIndex.y + y
        });
        if (!tile.visible) {
          tile.show();
        }
      }
    }
  };
  TileView2.prototype.createTile = function createTile(currentIndex) {
    var options2 = this.tileOptions(currentIndex);
    var tile = this.pool.get(this._center, options2);
    if (!tile.element.parentNode) {
      this.element.append(tile.element);
    }
    return tile;
  };
  TileView2.prototype.tileOptions = function tileOptions(currentIndex) {
    var index = this.wrapIndex(currentIndex), point2 = this.indexToPoint(currentIndex), origin = this._viewOrigin, offset3 = point2.clone().translate(-origin.x, -origin.y);
    return {
      index,
      currentIndex,
      point: point2,
      offset: roundPoint(offset3),
      zoom: this._zoom,
      size: this.options.tileSize,
      subdomain: this.subdomainText(),
      urlTemplate: this.options.urlTemplate,
      errorUrlTemplate: this.options.errorUrlTemplate
    };
  };
  TileView2.prototype.wrapIndex = function wrapIndex(index) {
    var boundary = math4.pow(2, this._zoom);
    return {
      x: this.wrapValue(index.x, boundary),
      y: limitValue2(index.y, 0, boundary - 1)
    };
  };
  TileView2.prototype.wrapValue = function wrapValue(value, boundary) {
    var remainder = math4.abs(value) % boundary;
    var wrappedValue = value;
    if (value >= 0) {
      wrappedValue = remainder;
    } else {
      wrappedValue = boundary - (remainder === 0 ? boundary : remainder);
    }
    return wrappedValue;
  };
  return TileView2;
}(class_default);
var ImageTile = function(Class3) {
  function ImageTile2(id, options2) {
    Class3.call(this);
    this.id = id;
    this.visible = true;
    this._initOptions(options2);
    this.createElement();
    this.show();
  }
  if (Class3)
    ImageTile2.__proto__ = Class3;
  ImageTile2.prototype = Object.create(Class3 && Class3.prototype);
  ImageTile2.prototype.constructor = ImageTile2;
  ImageTile2.prototype.destroy = function destroy2() {
    var element2 = this.element;
    var parentNode = element2 ? element2.parentNode : null;
    if (element2) {
      if (parentNode) {
        parentNode.removeChild(element2);
      }
      this.element = null;
    }
  };
  ImageTile2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  ImageTile2.prototype.createElement = function createElement17() {
    var el = document.createElement("img");
    var size = this.options.size + "px";
    el.style.position = "absolute";
    el.style.display = "block";
    el.style.width = el.style.maxWidth = size;
    el.style.height = el.style.maxHeight = size;
    this.element = el;
  };
  ImageTile2.prototype.show = function show2() {
    var element2 = this.element;
    element2.style.top = renderSize(this.options.offset.y);
    element2.style.left = renderSize(this.options.offset.x);
    var url = this.url();
    if (url) {
      element2.setAttribute("src", url);
    }
    element2.style.visibility = "visible";
    this.visible = true;
  };
  ImageTile2.prototype.hide = function hide2() {
    this.element.style.visibility = "hidden";
    this.visible = false;
  };
  ImageTile2.prototype.url = function url() {
    var urlResult = compileTemplate(this.options.urlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.errorUrl = function errorUrl() {
    var urlResult = compileTemplate(this.options.errorUrlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.urlOptions = function urlOptions() {
    var options2 = this.options;
    return {
      zoom: options2.zoom,
      subdomain: options2.subdomain,
      z: options2.zoom,
      x: options2.index.x,
      y: options2.index.y,
      s: options2.subdomain,
      quadkey: options2.quadkey,
      q: options2.quadkey,
      culture: options2.culture,
      c: options2.culture
    };
  };
  return ImageTile2;
}(class_default);
setDefaultOptions(ImageTile, {
  urlTemplate: "",
  errorUrlTemplate: ""
});
var TilePool = function(Class3) {
  function TilePool2() {
    Class3.call(this);
    this._items = [];
  }
  if (Class3)
    TilePool2.__proto__ = Class3;
  TilePool2.prototype = Object.create(Class3 && Class3.prototype);
  TilePool2.prototype.constructor = TilePool2;
  TilePool2.prototype.get = function get2(center, options2) {
    if (this._items.length >= this.options.maxSize) {
      this._remove(center);
    }
    return this._create(options2);
  };
  TilePool2.prototype.empty = function empty() {
    var items = this._items;
    for (var i = 0; i < items.length; i++) {
      items[i].destroy();
    }
    this._items = [];
  };
  TilePool2.prototype.reset = function reset() {
    var items = this._items;
    for (var i = 0; i < items.length; i++) {
      items[i].hide();
    }
  };
  TilePool2.prototype._create = function _create(options2) {
    var items = this._items;
    var tile;
    var id = hashKey2(options2.point.toString() + options2.offset.toString() + options2.zoom + options2.urlTemplate);
    for (var i = 0; i < items.length; i++) {
      if (items[i].id === id) {
        tile = items[i];
        break;
      }
    }
    if (tile) {
      tile.show();
    } else {
      tile = new ImageTile(id, options2);
      this._items.push(tile);
    }
    return tile;
  };
  TilePool2.prototype._remove = function _remove(center) {
    var items = this._items;
    var maxDist = -1;
    var index = -1;
    for (var i = 0; i < items.length; i++) {
      var dist = items[i].options.point.distanceTo(center);
      if (dist > maxDist && !items[i].visible) {
        index = i;
        maxDist = dist;
      }
    }
    if (index !== -1) {
      items[index].destroy();
      items.splice(index, 1);
    }
  };
  return TilePool2;
}(class_default);
setDefaultOptions(TilePool, {
  maxSize: 100
});

// node_modules/@progress/kendo-charts/dist/es/map/scroller/draggable.js
var extend10 = Object.assign;
var CHANGE2 = "change";
var TapCapture = function(Observable3) {
  function TapCapture2(element2, options2) {
    Observable3.call(this);
    var that = this, domElement = element2[0] || element2;
    that.capture = false;
    var eventMap = getEventMap(navigator.userAgent);
    if (domElement.addEventListener) {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._press, that), true);
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._release, that), true);
      });
    } else {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._press, that));
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._release, that));
      });
    }
    that.bind([
      "press",
      "release"
    ], options2 || {});
  }
  if (Observable3)
    TapCapture2.__proto__ = Observable3;
  TapCapture2.prototype = Object.create(Observable3 && Observable3.prototype);
  TapCapture2.prototype.constructor = TapCapture2;
  TapCapture2.prototype.captureNext = function captureNext() {
    this.capture = true;
  };
  TapCapture2.prototype.cancelCapture = function cancelCapture() {
    this.capture = false;
  };
  TapCapture2.prototype._press = function _press(e) {
    var that = this;
    that.trigger("press");
    if (that.capture) {
      e.preventDefault();
    }
  };
  TapCapture2.prototype._release = function _release(e) {
    var that = this;
    that.trigger("release");
    if (that.capture) {
      e.preventDefault();
      that.cancelCapture();
    }
  };
  return TapCapture2;
}(Observable2);
var PaneDimension = function(Observable3) {
  function PaneDimension2(options2) {
    Observable3.call(this);
    var that = this;
    that.forcedEnabled = false;
    extend10(that, options2);
    that.scale = 1;
    if (that.horizontal) {
      that.measure = "offsetWidth";
      that.scrollSize = "scrollWidth";
      that.axis = "x";
    } else {
      that.measure = "offsetHeight";
      that.scrollSize = "scrollHeight";
      that.axis = "y";
    }
  }
  if (Observable3)
    PaneDimension2.__proto__ = Observable3;
  PaneDimension2.prototype = Object.create(Observable3 && Observable3.prototype);
  PaneDimension2.prototype.constructor = PaneDimension2;
  PaneDimension2.prototype.makeVirtual = function makeVirtual() {
    extend10(this, {
      virtual: true,
      forcedEnabled: true,
      _virtualMin: 0,
      _virtualMax: 0
    });
  };
  PaneDimension2.prototype.virtualSize = function virtualSize(min3, max2) {
    if (this._virtualMin !== min3 || this._virtualMax !== max2) {
      this._virtualMin = min3;
      this._virtualMax = max2;
      this.update();
    }
  };
  PaneDimension2.prototype.outOfBounds = function outOfBounds(offset3) {
    return offset3 > this.max || offset3 < this.min;
  };
  PaneDimension2.prototype.forceEnabled = function forceEnabled() {
    this.forcedEnabled = true;
  };
  PaneDimension2.prototype.getSize = function getSize() {
    return this.container[this.measure];
  };
  PaneDimension2.prototype.getTotal = function getTotal() {
    return this.element[this.scrollSize];
  };
  PaneDimension2.prototype.rescale = function rescale(scale) {
    this.scale = scale;
  };
  PaneDimension2.prototype.update = function update(silent) {
    var that = this, total3 = that.virtual ? that._virtualMax : that.getTotal(), scaledTotal = total3 * that.scale, size = that.getSize();
    if (total3 === 0 && !that.forcedEnabled) {
      return;
    }
    that.max = that.virtual ? -that._virtualMin : 0;
    that.size = size;
    that.total = scaledTotal;
    that.min = Math.min(that.max, size - scaledTotal);
    that.minScale = size / total3;
    that.centerOffset = (scaledTotal - size) / 2;
    that.enabled = that.forcedEnabled || scaledTotal > size;
    if (!silent) {
      that.trigger(CHANGE2, that);
    }
  };
  return PaneDimension2;
}(Observable2);
var PaneDimensions = function(Observable3) {
  function PaneDimensions2(options2) {
    Observable3.call(this);
    var that = this;
    that.x = new PaneDimension(extend10({
      horizontal: true
    }, options2));
    that.y = new PaneDimension(extend10({
      horizontal: false
    }, options2));
    that.container = options2.container;
    that.forcedMinScale = options2.minScale;
    that.maxScale = options2.maxScale || 100;
    that.bind(CHANGE2, options2);
  }
  if (Observable3)
    PaneDimensions2.__proto__ = Observable3;
  PaneDimensions2.prototype = Object.create(Observable3 && Observable3.prototype);
  PaneDimensions2.prototype.constructor = PaneDimensions2;
  PaneDimensions2.prototype.rescale = function rescale(newScale) {
    this.x.rescale(newScale);
    this.y.rescale(newScale);
    this.refresh();
  };
  PaneDimensions2.prototype.centerCoordinates = function centerCoordinates() {
    return {
      x: Math.min(0, -this.x.centerOffset),
      y: Math.min(0, -this.y.centerOffset)
    };
  };
  PaneDimensions2.prototype.refresh = function refresh() {
    var that = this;
    that.x.update();
    that.y.update();
    that.enabled = that.x.enabled || that.y.enabled;
    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
    that.fitScale = Math.max(that.x.minScale, that.y.minScale);
    that.trigger(CHANGE2);
  };
  return PaneDimensions2;
}(Observable2);
var PaneAxis = function(Observable3) {
  function PaneAxis2(options2) {
    Observable3.call(this);
    extend10(this, options2);
  }
  if (Observable3)
    PaneAxis2.__proto__ = Observable3;
  PaneAxis2.prototype = Object.create(Observable3 && Observable3.prototype);
  PaneAxis2.prototype.constructor = PaneAxis2;
  PaneAxis2.prototype.outOfBounds = function outOfBounds() {
    return this.dimension.outOfBounds(this.movable[this.axis]);
  };
  PaneAxis2.prototype.dragMove = function dragMove(delta) {
    var that = this, dimension = that.dimension, axis = that.axis, movable = that.movable, position3 = movable[axis] + delta;
    if (!dimension.enabled) {
      return;
    }
    var dragDelta = delta;
    if (position3 < dimension.min && delta < 0 || position3 > dimension.max && delta > 0) {
      dragDelta *= that.resistance;
    }
    movable.translateAxis(axis, dragDelta);
    that.trigger(CHANGE2, that);
  };
  return PaneAxis2;
}(Observable2);
var Pane2 = function(Class3) {
  function Pane3(options2) {
    Class3.call(this);
    var that = this, x, y, resistance, movable;
    extend10(that, {
      elastic: true
    }, options2);
    resistance = that.elastic ? 0.5 : 0;
    movable = that.movable;
    that.x = x = new PaneAxis({
      axis: "x",
      dimension: that.dimensions.x,
      resistance,
      movable
    });
    that.y = y = new PaneAxis({
      axis: "y",
      dimension: that.dimensions.y,
      resistance,
      movable
    });
    that.userEvents.bind([
      "press",
      "move",
      "end",
      "gesturestart",
      "gesturechange"
    ], {
      gesturestart: function gesturestart(e) {
        that.gesture = e;
        that.offset = elementOffset2(that.dimensions.container);
      },
      press: function press(e) {
        var closestAnchor = e.event.target.closest("a");
        if (closestAnchor && closestAnchor.matches("[data-navigate-on-press=true]")) {
          e.sender.cancel();
        }
      },
      gesturechange: function gesturechange(e) {
        var previousGesture = that.gesture, previousCenter = previousGesture.center, center = e.center, scaleDelta = e.distance / previousGesture.distance, minScale = that.dimensions.minScale, maxScale = that.dimensions.maxScale, coordinates;
        if (movable.scale <= minScale && scaleDelta < 1) {
          scaleDelta += (1 - scaleDelta) * 0.8;
        }
        if (movable.scale * scaleDelta >= maxScale) {
          scaleDelta = maxScale / movable.scale;
        }
        var offsetX = movable.x + that.offset.left, offsetY = movable.y + that.offset.top;
        coordinates = {
          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
        };
        movable.scaleWith(scaleDelta);
        x.dragMove(coordinates.x);
        y.dragMove(coordinates.y);
        that.dimensions.rescale(movable.scale);
        that.gesture = e;
        e.preventDefault();
      },
      move: function move(e) {
        if (e.event.target.tagName.match(/textarea|input/i)) {
          return;
        }
        if (x.dimension.enabled || y.dimension.enabled) {
          x.dragMove(e.x.delta);
          y.dragMove(e.y.delta);
          e.preventDefault();
        } else {
          e.touch.skip();
        }
      },
      end: function end(e) {
        e.preventDefault();
      }
    });
  }
  if (Class3)
    Pane3.__proto__ = Class3;
  Pane3.prototype = Object.create(Class3 && Class3.prototype);
  Pane3.prototype.constructor = Pane3;
  return Pane3;
}(class_default);
var translate = function(x, y, scale) {
  return "translate3d(" + x + "px," + y + "px,0) scale(" + scale + ")";
};
var Movable = function(Observable3) {
  function Movable2(element2) {
    Observable3.call(this);
    var that = this;
    that.support = getSupportedFeatures();
    this.transformStyle = this.support.transitions.prefix + "Transform";
    that.element = element2;
    that.element.style.webkitTransformOrigin = "left top";
    that.x = 0;
    that.y = 0;
    that.scale = 1;
    var coordinates = translate(that.x, that.y, that.scale);
    that.element.style[this.transformStyle] = coordinates;
    that._saveCoordinates(coordinates);
  }
  if (Observable3)
    Movable2.__proto__ = Observable3;
  Movable2.prototype = Object.create(Observable3 && Observable3.prototype);
  Movable2.prototype.constructor = Movable2;
  Movable2.prototype.translateAxis = function translateAxis(axis, by) {
    this[axis] += by;
    this.refresh();
  };
  Movable2.prototype.scaleTo = function scaleTo(scale) {
    this.scale = scale;
    this.refresh();
  };
  Movable2.prototype.scaleWith = function scaleWith(scaleDelta) {
    this.scale *= scaleDelta;
    this.refresh();
  };
  Movable2.prototype.translate = function translate2(coordinates) {
    this.x += coordinates.x;
    this.y += coordinates.y;
    this.refresh();
  };
  Movable2.prototype.moveAxis = function moveAxis(axis, value) {
    this[axis] = value;
    this.refresh();
  };
  Movable2.prototype.moveTo = function moveTo(coordinates) {
    extend10(this, coordinates);
    this.refresh();
  };
  Movable2.prototype.refresh = function refresh() {
    var that = this, x = that.x, y = that.y, newCoordinates;
    if (that.round) {
      x = Math.round(x);
      y = Math.round(y);
    }
    newCoordinates = translate(x, y, that.scale);
    if (newCoordinates !== that.coordinates) {
      that.element.style[this.transformStyle] = newCoordinates;
      that._saveCoordinates(newCoordinates);
      that.trigger(CHANGE2);
    }
  };
  Movable2.prototype._saveCoordinates = function _saveCoordinates(coordinates) {
    this.coordinates = coordinates;
  };
  return Movable2;
}(Observable2);

// node_modules/@progress/kendo-charts/dist/es/map/layers/shape.js
var Group9 = drawing_exports.Group;
var ShapeLayer = function(Layer2) {
  function ShapeLayer2(map2, options2) {
    Layer2.call(this, map2, options2);
    this._pan = proxy(this._pan, this);
    this.surface = drawing_exports.Surface.create(this.element, {
      width: map2.scrollElement.clientWidth,
      height: map2.scrollElement.clientHeight
    });
    this._initRoot();
    this.movable = new Movable(this.surface.element);
    this._markers = [];
    this._click = this._handler("shapeClick");
    this.surface.bind("click", this._click);
    this._mouseleave = this._handler("shapeMouseLeave");
    this.surface.bind("mouseleave", this._mouseleave);
    this.surface.bind("mouseenter", this._mouseenter.bind(this));
  }
  if (Layer2)
    ShapeLayer2.__proto__ = Layer2;
  ShapeLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  ShapeLayer2.prototype.constructor = ShapeLayer2;
  ShapeLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    this.surface.destroy();
  };
  ShapeLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._translateSurface();
    this._data = this._readData();
    if (this._hasData()) {
      this._load(this._data);
    }
  };
  ShapeLayer2.prototype._initRoot = function _initRoot() {
    this._root = new Group9();
    this.surface.draw(this._root);
  };
  ShapeLayer2.prototype._beforeReset = function _beforeReset() {
    this.surface.clear();
    this._initRoot();
  };
  ShapeLayer2.prototype._resize = function _resize() {
    this.surface.size(this.map.size());
  };
  ShapeLayer2.prototype._readData = function _readData() {
    var data = Layer2.prototype._readData.call(this);
    if (data.type === "FeatureCollection") {
      return data.features;
    }
    if (data.type === "GeometryCollection") {
      return data.geometries;
    }
    return data;
  };
  ShapeLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this._clearMarkers();
    if (!this._loader) {
      this._loader = new GeoJsonLoader(this.map, this.options.style, this);
    }
    var container = new Group9();
    for (var i = 0; i < data.length; i++) {
      var shape2 = this$1._loader.parse(data[i]);
      if (shape2) {
        container.append(shape2);
      }
    }
    this._root.clear();
    this._root.append(container);
  };
  ShapeLayer2.prototype.shapeCreated = function shapeCreated(shape2) {
    var cancelled = false;
    if (shape2 instanceof drawing_exports.Circle && this.map.options.renderPointsAsMarkers) {
      cancelled = defined2(this._createMarker(shape2));
    }
    if (!cancelled) {
      var args = {
        layer: this,
        shape: shape2
      };
      cancelled = this.map.trigger("shapeCreated", args);
    }
    return cancelled;
  };
  ShapeLayer2.prototype.featureCreated = function featureCreated(e) {
    e.layer = this;
    this.map.trigger("shapeFeatureCreated", e);
  };
  ShapeLayer2.prototype._createMarker = function _createMarker(shape2) {
    var marker = this.map.markers.bind({
      location: shape2.location
    }, shape2.dataItem);
    if (marker) {
      this._markers.push(marker);
    }
    return marker;
  };
  ShapeLayer2.prototype._clearMarkers = function _clearMarkers() {
    var this$1 = this;
    for (var i = 0; i < this._markers.length; i++) {
      this$1.map.markers.remove(this$1._markers[i]);
    }
    this._markers = [];
  };
  ShapeLayer2.prototype._pan = function _pan() {
    if (!this._panning) {
      this._panning = true;
      this.surface.suspendTracking();
    }
  };
  ShapeLayer2.prototype._panEnd = function _panEnd(e) {
    Layer2.prototype._panEnd.call(this, e);
    this._translateSurface();
    this.surface.resumeTracking();
    this._panning = false;
  };
  ShapeLayer2.prototype._translateSurface = function _translateSurface() {
    var map2 = this.map;
    var nw = map2.locationToView(map2.extent().nw);
    if (this.surface.translate) {
      this.surface.translate(nw);
      this.movable.moveTo({
        x: nw.x,
        y: nw.y
      });
    }
  };
  ShapeLayer2.prototype._eventArgs = function _eventArgs(e) {
    return {
      layer: this,
      layerIndex: this._layerIndex(),
      shape: e.element,
      shapeIndex: (this._data || []).indexOf(e.element.dataItem),
      originalEvent: e.originalEvent
    };
  };
  ShapeLayer2.prototype._handler = function _handler(eventName) {
    var this$1 = this;
    return function(e) {
      if (e.element) {
        this$1.map.trigger(eventName, this$1._eventArgs(e));
      }
    };
  };
  ShapeLayer2.prototype._mouseenter = function _mouseenter2(e) {
    if (!e.element) {
      return;
    }
    this.map.trigger("shapeMouseEnter", this._eventArgs(e));
    var shape2 = e.element;
    var anchor = this._tooltipAnchor(e);
    this.map._tooltip.show(anchor, this._tooltipContext(shape2));
  };
  ShapeLayer2.prototype._tooltipContext = function _tooltipContext(shape2) {
    return {
      type: "shape",
      layerIndex: this._layerIndex(),
      className: "k-map-shape-tooltip",
      dataItem: shape2.dataItem,
      location: shape2.location
    };
  };
  ShapeLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e) {
    var cursor = this.map.eventOffset(e.originalEvent);
    return {
      top: cursor.y,
      left: cursor.x
    };
  };
  ShapeLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    this._panHandler = proxy(this._pan, this);
    this.map.bind("pan", this.panHandler);
  };
  ShapeLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    this.map.unbind("pan", this._panHandler);
  };
  return ShapeLayer2;
}(Layer);
setDefaultOptions(ShapeLayer, {
  autoBind: true,
  zIndex: 100
});
var GeoJsonLoader = function(Class3) {
  function GeoJsonLoader2(locator, defaultStyle, observer) {
    Class3.call(this);
    this.observer = observer;
    this.locator = locator;
    this.style = defaultStyle;
  }
  if (Class3)
    GeoJsonLoader2.__proto__ = Class3;
  GeoJsonLoader2.prototype = Object.create(Class3 && Class3.prototype);
  GeoJsonLoader2.prototype.constructor = GeoJsonLoader2;
  GeoJsonLoader2.prototype.parse = function parse(item) {
    var root = new Group9();
    var unwrap = true;
    if (item.type === "Feature") {
      unwrap = false;
      this._loadGeometryTo(root, item.geometry, item);
      this._featureCreated(root, item);
    } else {
      this._loadGeometryTo(root, item, item);
    }
    if (unwrap && root.children.length < 2) {
      root = root.children[0];
    }
    return root;
  };
  GeoJsonLoader2.prototype._shapeCreated = function _shapeCreated(shape2) {
    var cancelled = false;
    if (this.observer && this.observer.shapeCreated) {
      cancelled = this.observer.shapeCreated(shape2);
    }
    return cancelled;
  };
  GeoJsonLoader2.prototype._featureCreated = function _featureCreated(group, dataItem) {
    if (this.observer && this.observer.featureCreated) {
      this.observer.featureCreated({
        group,
        dataItem,
        properties: dataItem.properties
      });
    }
  };
  GeoJsonLoader2.prototype._loadGeometryTo = function _loadGeometryTo(container, geometry, dataItem) {
    var this$1 = this;
    var coords = geometry.coordinates;
    var i;
    var path;
    switch (geometry.type) {
      case "LineString":
        path = this._loadPolygon(container, [coords], dataItem);
        this._setLineFill(path);
        break;
      case "MultiLineString":
        for (i = 0; i < coords.length; i++) {
          path = this$1._loadPolygon(container, [coords[i]], dataItem);
          this$1._setLineFill(path);
        }
        break;
      case "Polygon":
        this._loadPolygon(container, coords, dataItem);
        break;
      case "MultiPolygon":
        for (i = 0; i < coords.length; i++) {
          this$1._loadPolygon(container, coords[i], dataItem);
        }
        break;
      case "Point":
        this._loadPoint(container, coords, dataItem);
        break;
      case "MultiPoint":
        for (i = 0; i < coords.length; i++) {
          this$1._loadPoint(container, coords[i], dataItem);
        }
        break;
      default:
        break;
    }
  };
  GeoJsonLoader2.prototype._setLineFill = function _setLineFill(path) {
    var segments = path.segments;
    if (segments.length < 4 || !segments[0].anchor().equals(last2(segments).anchor())) {
      path.options.fill = null;
    }
  };
  GeoJsonLoader2.prototype._loadShape = function _loadShape(container, shape2) {
    if (!this._shapeCreated(shape2)) {
      container.append(shape2);
    }
    return shape2;
  };
  GeoJsonLoader2.prototype._loadPolygon = function _loadPolygon(container, rings, dataItem) {
    var shape2 = this._buildPolygon(rings);
    shape2.dataItem = dataItem;
    shape2.location = this.locator.viewToLocation(shape2.bbox().center());
    return this._loadShape(container, shape2);
  };
  GeoJsonLoader2.prototype._buildPolygon = function _buildPolygon(rings) {
    var this$1 = this;
    var type = rings.length > 1 ? drawing_exports.MultiPath : drawing_exports.Path;
    var path = new type(this.style);
    for (var i = 0; i < rings.length; i++) {
      for (var j = 0; j < rings[i].length; j++) {
        var point2 = this$1.locator.locationToView(Location.fromLngLat(rings[i][j]));
        if (j === 0) {
          path.moveTo(point2.x, point2.y);
        } else {
          path.lineTo(point2.x, point2.y);
        }
      }
    }
    return path;
  };
  GeoJsonLoader2.prototype._loadPoint = function _loadPoint(container, coords, dataItem) {
    var location = Location.fromLngLat(coords);
    var point2 = this.locator.locationToView(location);
    var circle = new geometry_exports.Circle(point2, 10);
    var shape2 = new drawing_exports.Circle(circle, this.style);
    shape2.dataItem = dataItem;
    shape2.location = location;
    return this._loadShape(container, shape2);
  };
  return GeoJsonLoader2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/bubble.js
var BubbleLayer = function(ShapeLayer2) {
  function BubbleLayer2() {
    ShapeLayer2.apply(this, arguments);
  }
  if (ShapeLayer2)
    BubbleLayer2.__proto__ = ShapeLayer2;
  BubbleLayer2.prototype = Object.create(ShapeLayer2 && ShapeLayer2.prototype);
  BubbleLayer2.prototype.constructor = BubbleLayer2;
  BubbleLayer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  BubbleLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this.surface.clear();
    if (data.length === 0) {
      return;
    }
    var options2 = this.options;
    var getValue = getter(options2.valueField);
    var newData = data.slice(0);
    newData.sort(function(a, b) {
      return getValue(b) - getValue(a);
    });
    var scaleType = this._scaleType();
    var scale;
    var getLocation = getter(this.options.locationField);
    for (var i = 0; i < newData.length; i++) {
      var dataItem = newData[i];
      var location = getLocation(dataItem);
      var value = getValue(dataItem);
      if (defined2(location) && defined2(value)) {
        if (!scale) {
          scale = new scaleType([
            0,
            value
          ], [
            options2.minSize,
            options2.maxSize
          ]);
        }
        location = Location.create(location);
        var center = this$1.map.locationToView(location);
        var size = scale.map(value);
        var symbol = this$1._createSymbol({
          center,
          size,
          style: options2.style,
          dataItem,
          location
        });
        symbol.dataItem = dataItem;
        symbol.location = location;
        symbol.value = value;
        this$1._drawSymbol(symbol);
      }
    }
  };
  BubbleLayer2.prototype._scaleType = function _scaleType() {
    var scale = this.options.scale;
    if (isFunction3(scale)) {
      return scale;
    }
    return Scales[scale];
  };
  BubbleLayer2.prototype._createSymbol = function _createSymbol(args) {
    var symbol = this.options.symbol;
    if (!isFunction3(symbol)) {
      symbol = Symbols[symbol];
    }
    return symbol(args);
  };
  BubbleLayer2.prototype._drawSymbol = function _drawSymbol(shape2) {
    var args = {
      layer: this,
      shape: shape2
    };
    var cancelled = this.map.trigger("shapeCreated", args);
    if (!cancelled) {
      this.surface.draw(shape2);
    }
  };
  BubbleLayer2.prototype._tooltipContext = function _tooltipContext(shape2) {
    return {
      type: "bubble",
      layerIndex: this._layerIndex(),
      className: "k-map-bubble-tooltip",
      dataItem: shape2.dataItem,
      location: shape2.location,
      value: shape2.value
    };
  };
  BubbleLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e) {
    var shape2 = e.element;
    var center = shape2.bbox().center();
    return {
      top: center.y,
      left: center.x
    };
  };
  return BubbleLayer2;
}(ShapeLayer);
setDefaultOptions(BubbleLayer, {
  // autoBind: true,
  locationField: "location",
  valueField: "value",
  minSize: 0,
  maxSize: 100,
  scale: "sqrt",
  symbol: "circle",
  // ensure bubble layers are displayed over tile and shape layers
  zIndex: 200
});
var SqrtScale = function(Class3) {
  function SqrtScale2(domain, range) {
    Class3.call(this);
    this._domain = domain;
    this._range = range;
    var domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);
    var outputRange = range[1] - range[0];
    this._ratio = outputRange / domainRange;
  }
  if (Class3)
    SqrtScale2.__proto__ = Class3;
  SqrtScale2.prototype = Object.create(Class3 && Class3.prototype);
  SqrtScale2.prototype.constructor = SqrtScale2;
  SqrtScale2.prototype.map = function map2(value) {
    var rel = (Math.sqrt(value) - Math.sqrt(this._domain[0])) * this._ratio;
    return this._range[0] + rel;
  };
  return SqrtScale2;
}(class_default);
var Scales = {
  sqrt: SqrtScale
};
var Symbols = {
  circle: function(args) {
    var geo = new geometry_exports.Circle(args.center, args.size / 2);
    return new drawing_exports.Circle(geo, args.style);
  },
  square: function(args) {
    var path = new drawing_exports.Path(args.style);
    var halfSize = args.size / 2;
    var center = args.center;
    path.moveTo(center.x - halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y + halfSize).lineTo(center.x - halfSize, center.y + halfSize).close();
    return path;
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/marker.js
var CLICK = "click";
var MOUSE_ENTER = "mouseenter";
var MOUSE_LEAVE = "mouseleave";
var extend11 = Object.assign;
var MARKER_CLASS_NAME = "k-marker";
var MARKER_CLASS = "." + MARKER_CLASS_NAME;
var MarkerLayer = function(Layer2) {
  function MarkerLayer2(map2, options2) {
    Layer2.call(this, map2, options2);
    this._markerClickHandler = proxy(this._markerClick, this);
    on(this.element, CLICK, MARKER_CLASS, this._markerClickHandler);
    this.items = [];
    this._load(this._readData());
  }
  if (Layer2)
    MarkerLayer2.__proto__ = Layer2;
  MarkerLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  MarkerLayer2.prototype.constructor = MarkerLayer2;
  MarkerLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    off(this.element, CLICK, this._markerClickHandler);
    this.clear();
  };
  MarkerLayer2.prototype.add = function add3(args) {
    var this$1 = this;
    if (isArray(args)) {
      for (var i = 0; i < args.length; i++) {
        this$1._addOne(args[i]);
      }
    } else {
      return this._addOne(args);
    }
  };
  MarkerLayer2.prototype.remove = function remove(marker) {
    marker.destroy();
    var index = (this.items || []).indexOf(marker);
    if (index > -1) {
      this.items.splice(index, 1);
    }
  };
  MarkerLayer2.prototype.clear = function clear4() {
    var this$1 = this;
    for (var i = 0; i < this.items.length; i++) {
      this$1.items[i].destroy();
    }
    this.items = [];
  };
  MarkerLayer2.prototype.update = function update(marker) {
    var location = marker.location();
    if (location) {
      marker.showAt(this.map.locationToView(location));
      var args = {
        marker,
        layer: this
      };
      this.map.trigger("markerActivate", args);
    }
  };
  MarkerLayer2.prototype._reset = function _reset() {
    var this$1 = this;
    Layer2.prototype._reset.call(this);
    var items = this.items;
    for (var i = 0; i < items.length; i++) {
      this$1.update(items[i]);
    }
  };
  MarkerLayer2.prototype.bind = function bind(options2, dataItem) {
    var marker = Marker.create(options2, this.options);
    marker.dataItem = dataItem;
    var args = {
      marker,
      layer: this
    };
    var cancelled = this.map.trigger("markerCreated", args);
    if (!cancelled) {
      this.add(marker);
      return marker;
    }
  };
  MarkerLayer2.prototype._addOne = function _addOne(arg) {
    var marker = Marker.create(arg, this.options);
    marker.addTo(this);
    return marker;
  };
  MarkerLayer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  MarkerLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this.clear();
    var getLocation = getter(this.options.locationField);
    var getTitle = getter(this.options.titleField);
    for (var i = 0; i < data.length; i++) {
      var dataItem = data[i];
      this$1.bind({
        location: getLocation(dataItem),
        title: getTitle(dataItem)
      }, dataItem);
    }
  };
  MarkerLayer2.prototype._markerClick = function _markerClick(e) {
    var marker = e.currentTarget._kendoNode;
    var args = {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker),
      originalEvent: e
    };
    this.map.trigger("markerClick", args);
  };
  MarkerLayer2.prototype._markerMouseEnter = function _markerMouseEnter(e) {
    var args = this._createMarkerEventArgs(e);
    this.map.trigger("markerMouseEnter", args);
  };
  MarkerLayer2.prototype._markerMouseLeave = function _markerMouseLeave(e) {
    var args = this._createMarkerEventArgs(e);
    this.map.trigger("markerMouseLeave", args);
  };
  MarkerLayer2.prototype._createMarkerEventArgs = function _createMarkerEventArgs(e) {
    var marker = e.marker;
    var args = extend11({}, {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker)
    }, e);
    return args;
  };
  return MarkerLayer2;
}(Layer);
setDefaultOptions(MarkerLayer, {
  zIndex: 1e3,
  autoBind: true,
  locationField: "location",
  titleField: "title",
  template: ""
});
var Marker = function(Class3) {
  function Marker2(options2) {
    Class3.call(this);
    this.options = options2 || {};
  }
  if (Class3)
    Marker2.__proto__ = Class3;
  Marker2.prototype = Object.create(Class3 && Class3.prototype);
  Marker2.prototype.constructor = Marker2;
  Marker2.prototype.destroy = function destroy2() {
    this.layer = null;
    this.unbindEvents();
    this.hide();
  };
  Marker2.prototype.addTo = function addTo(parent) {
    this.layer = parent.markers || parent;
    this.layer.items.push(this);
    this.layer.update(this);
  };
  Marker2.prototype.location = function location(value) {
    if (value) {
      this.options.location = Location.create(value).toArray();
      if (this.layer) {
        this.layer.update(this);
      }
      return this;
    }
    return Location.create(this.options.location);
  };
  Marker2.prototype.showAt = function showAt(point2) {
    this.render();
    this._anchor = { left: Math.round(point2.x), top: Math.round(point2.y) };
    this.element.style.left = toPixels(this._anchor.left);
    this.element.style.top = toPixels(this._anchor.top);
  };
  Marker2.prototype.hide = function hide2() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  };
  Marker2.prototype.bindEvents = function bindEvents3() {
    if (!this.element) {
      return;
    }
    this._mouseEnterHandler = proxy(this._mouseEnter, this);
    on(this.element, MOUSE_ENTER, MARKER_CLASS, this._mouseEnterHandler);
    this._mouseLeaveHandler = proxy(this._mouseLeave, this);
    on(this.element, MOUSE_LEAVE, MARKER_CLASS, this._mouseLeaveHandler);
  };
  Marker2.prototype.unbindEvents = function unbindEvents3() {
    if (!this.element) {
      return;
    }
    off(this.element, MOUSE_ENTER, this._mouseEnterHandler);
    off(this.element, MOUSE_LEAVE, this._mouseLeaveHandler);
  };
  Marker2.prototype.render = function render() {
    if (!this.element) {
      var options2 = this.options;
      var layer = this.layer;
      var element2 = document.createElement("span");
      addClass(element2, MARKER_CLASS_NAME);
      if (this.options.template) {
        var templateFn = this._compileTemplate(this.options.template);
        var templateHtml = templateFn(this.dataItem);
        var templateElement = convertToHtml(templateHtml);
        element2.appendChild(templateElement);
      } else {
        addClass(element2, "k-icon k-icon-xxl k-i-marker-" + toHyphens(options2.shape || "pin"));
      }
      if (options2.title) {
        element2.setAttribute("title", options2.title);
      }
      var attributes = options2.attributes || {};
      Object.keys(attributes).forEach(function(key) {
        element2.setAttribute(key, attributes[key]);
      });
      element2._kendoNode = this;
      element2.style.zIndex = options2.zIndex;
      this.element = element2;
      if (layer) {
        layer.element.appendChild(this.element);
      }
      this.bindEvents();
    }
  };
  Marker2.prototype._mouseEnter = function _mouseEnter(e) {
    var args = this._createEventArgs(e);
    this.layer._markerMouseEnter(args);
    this.layer.map._tooltip.show({
      top: this._anchor.top - this.element.offsetHeight,
      left: this._anchor.left
    }, this._tooltipContext());
  };
  Marker2.prototype._tooltipContext = function _tooltipContext() {
    return {
      type: "marker",
      layerIndex: this.layer._layerIndex(),
      className: "k-map-marker-tooltip",
      dataItem: this.dataItem,
      title: this.options.title,
      location: this.location()
    };
  };
  Marker2.prototype._mouseLeave = function _mouseLeave(e) {
    var args = this._createEventArgs(e);
    this.layer._markerMouseLeave(args);
  };
  Marker2.prototype._createEventArgs = function _createEventArgs(e) {
    var args = {
      marker: this,
      originalEvent: e
    };
    return args;
  };
  Marker2.prototype._compileTemplate = function _compileTemplate(template3) {
    return template_service_default.compile(template3, {
      paramName: "dataItem",
      useWithBlock: false
    });
  };
  Marker2.create = function create3(arg, defaults) {
    if (arg instanceof Marker2) {
      return arg;
    }
    return new Marker2(deepExtend({}, defaults, arg));
  };
  return Marker2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/fx.js
var extend12 = Object.assign;
function animationFrame(callback) {
  window.requestAnimationFrame(callback);
}
var Animation2 = function(Class3) {
  function Animation3() {
    Class3.call(this);
    var that = this;
    that._tickProxy = proxy(that._tick, that);
    that._started = false;
  }
  if (Class3)
    Animation3.__proto__ = Class3;
  Animation3.prototype = Object.create(Class3 && Class3.prototype);
  Animation3.prototype.constructor = Animation3;
  Animation3.prototype.tick = function tick() {
  };
  Animation3.prototype.done = function done() {
  };
  Animation3.prototype.onEnd = function onEnd() {
  };
  Animation3.prototype.onCancel = function onCancel() {
  };
  Animation3.prototype.start = function start() {
    if (!this.enabled()) {
      return;
    }
    if (!this.done()) {
      this._started = true;
      animationFrame(this._tickProxy);
    } else {
      this.onEnd();
    }
  };
  Animation3.prototype.enabled = function enabled() {
    return true;
  };
  Animation3.prototype.cancel = function cancel() {
    this._started = false;
    this.onCancel();
  };
  Animation3.prototype._tick = function _tick() {
    var that = this;
    if (!that._started) {
      return;
    }
    that.tick();
    if (!that.done()) {
      animationFrame(that._tickProxy);
    } else {
      that._started = false;
      that.onEnd();
    }
  };
  return Animation3;
}(class_default);
var Transition = function(Animation3) {
  function Transition2(options2) {
    Animation3.call(this);
    extend12(this, options2);
  }
  if (Animation3)
    Transition2.__proto__ = Animation3;
  Transition2.prototype = Object.create(Animation3 && Animation3.prototype);
  Transition2.prototype.constructor = Transition2;
  Transition2.prototype.done = function done() {
    return this.timePassed() >= this.duration;
  };
  Transition2.prototype.timePassed = function timePassed() {
    return Math.min(this.duration, now2() - this.startDate);
  };
  Transition2.prototype.moveTo = function moveTo(options2) {
    var that = this, movable = that.movable;
    that.initial = movable[that.axis];
    that.delta = options2.location - that.initial;
    that.duration = typeof options2.duration === "number" ? options2.duration : 300;
    that.tick = that._easeProxy(options2.ease);
    that.startDate = now2();
    that.start();
  };
  Transition2.prototype._easeProxy = function _easeProxy(ease) {
    var that = this;
    return function() {
      that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
    };
  };
  Transition2.easeOutExpo = function easeOutExpo(t, b, c, d) {
    return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  };
  return Transition2;
}(Animation2);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/user-events.js
var extend13 = Object.assign;
var preventDefault4 = function(e) {
  e.preventDefault();
};
var DEFAULT_MIN_HOLD = 800;
var CLICK_DELAY = 300;
var DEFAULT_THRESHOLD = 0;
var PRESS = "press";
var HOLD = "hold";
var SELECT2 = "select";
var START2 = "start";
var MOVE2 = "move";
var END2 = "end";
var CANCEL = "cancel";
var TAP = "tap";
var DOUBLETAP = "doubleTap";
var RELEASE = "release";
var GESTURESTART = "gesturestart";
var GESTURECHANGE = "gesturechange";
var GESTUREEND = "gestureend";
var GESTURETAP = "gesturetap";
var THRESHOLD = {
  "api": 0,
  "touch": 0,
  "mouse": 9,
  "pointer": 9
};
function touchDelta(touch1, touch2) {
  var x1 = touch1.x.location, y1 = touch1.y.location, x2 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x2, dy = y1 - y2;
  return {
    center: {
      x: (x1 + x2) / 2,
      y: (y1 + y2) / 2
    },
    distance: Math.sqrt(dx * dx + dy * dy)
  };
}
function getTouches(e) {
  var support3 = getSupportedFeatures();
  var touches = [], originalEvent = e.originalEvent || e, currentTarget = e.currentTarget, idx = 0, length, changedTouches, touch;
  if (e.api) {
    touches.push({
      id: 2,
      event: e,
      target: e.target,
      currentTarget: e.target,
      location: e,
      type: "api"
    });
  } else if (e.type.match(/touch/)) {
    changedTouches = originalEvent ? originalEvent.changedTouches : [];
    for (length = changedTouches.length; idx < length; idx++) {
      touch = changedTouches[idx];
      touches.push({
        location: touch,
        event: e,
        target: touch.target,
        currentTarget,
        id: touch.identifier,
        type: "touch"
      });
    }
  } else if (support3.pointers || support3.msPointers) {
    touches.push({
      location: originalEvent,
      event: e,
      target: e.target,
      currentTarget,
      id: originalEvent.pointerId,
      type: "pointer"
    });
  } else {
    touches.push({
      id: 1,
      event: e,
      target: e.target,
      currentTarget,
      location: e,
      type: "mouse"
    });
  }
  return touches;
}
var TouchAxis = function(Class3) {
  function TouchAxis2(axis, location) {
    Class3.call(this);
    var that = this;
    that.support = getSupportedFeatures();
    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;
    that.axis = axis;
    that._updateLocationData(location);
    that.startLocation = that.location;
    that.velocity = that.delta = 0;
    that.timeStamp = now2();
  }
  if (Class3)
    TouchAxis2.__proto__ = Class3;
  TouchAxis2.prototype = Object.create(Class3 && Class3.prototype);
  TouchAxis2.prototype.constructor = TouchAxis2;
  TouchAxis2.prototype.move = function move(location) {
    var that = this, offset3 = location["page" + that.axis], timeStamp = now2(), timeDelta = timeStamp - that.timeStamp || 1;
    if (!offset3 && this.invalidZeroEvents) {
      return;
    }
    that.delta = offset3 - that.location;
    that._updateLocationData(location);
    that.initialDelta = offset3 - that.startLocation;
    that.velocity = that.delta / timeDelta;
    that.timeStamp = timeStamp;
  };
  TouchAxis2.prototype._updateLocationData = function _updateLocationData(location) {
    var that = this, axis = that.axis;
    that.location = location["page" + axis];
    that.client = location["client" + axis];
    that.screen = location["screen" + axis];
  };
  return TouchAxis2;
}(class_default);
var Touch = function(Class3) {
  function Touch2(userEvents, target, touchInfo) {
    Class3.call(this);
    extend13(this, {
      x: new TouchAxis("X", touchInfo.location),
      y: new TouchAxis("Y", touchInfo.location),
      type: touchInfo.type,
      useClickAsTap: userEvents.useClickAsTap,
      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],
      userEvents,
      target,
      currentTarget: touchInfo.currentTarget,
      initialTouch: touchInfo.target,
      id: touchInfo.id,
      pressEvent: touchInfo,
      _clicks: userEvents._clicks,
      supportDoubleTap: userEvents.supportDoubleTap,
      _moved: false,
      _finished: false
    });
  }
  if (Class3)
    Touch2.__proto__ = Class3;
  Touch2.prototype = Object.create(Class3 && Class3.prototype);
  Touch2.prototype.constructor = Touch2;
  Touch2.prototype.press = function press() {
    this._holdTimeout = setTimeout(proxy(this._hold, this), this.userEvents.minHold);
    this._trigger(PRESS, this.pressEvent);
  };
  Touch2.prototype._tap = function _tap(touchInfo) {
    var that = this;
    that.userEvents._clicks++;
    if (that.userEvents._clicks === 1) {
      that._clickTimeout = setTimeout(function() {
        if (that.userEvents._clicks === 1) {
          that._trigger(TAP, touchInfo);
        } else {
          that._trigger(DOUBLETAP, touchInfo);
        }
        that.userEvents._clicks = 0;
      }, CLICK_DELAY);
    }
  };
  Touch2.prototype._hold = function _hold() {
    this._trigger(HOLD, this.pressEvent);
  };
  Touch2.prototype.move = function move(touchInfo) {
    var that = this;
    var preventMove = touchInfo.type !== "api" && that.userEvents._shouldNotMove;
    if (that._finished || preventMove) {
      return;
    }
    that.x.move(touchInfo.location);
    that.y.move(touchInfo.location);
    if (!that._moved) {
      if (that._withinIgnoreThreshold()) {
        return;
      }
      if (!UserEvents.current || UserEvents.current === that.userEvents) {
        that._start(touchInfo);
      } else {
        return that.dispose();
      }
    }
    if (!that._finished) {
      that._trigger(MOVE2, touchInfo);
    }
  };
  Touch2.prototype.end = function end(touchInfo) {
    this.endTime = now2();
    if (this._finished) {
      return;
    }
    this._finished = true;
    this._trigger(RELEASE, touchInfo);
    if (this._moved) {
      this._trigger(END2, touchInfo);
    } else {
      if (!this.useClickAsTap) {
        if (this.supportDoubleTap) {
          this._tap(touchInfo);
        } else {
          this._trigger(TAP, touchInfo);
        }
      }
    }
    clearTimeout(this._holdTimeout);
    this.dispose();
  };
  Touch2.prototype.dispose = function dispose() {
    var userEvents = this.userEvents, activeTouches = userEvents.touches || [];
    this._finished = true;
    this.pressEvent = null;
    clearTimeout(this._holdTimeout);
    var activeTouchIndex = activeTouches.indexOf(this);
    activeTouches.splice(activeTouchIndex, 1);
  };
  Touch2.prototype.skip = function skip() {
    this.dispose();
  };
  Touch2.prototype.cancel = function cancel() {
    this.dispose();
  };
  Touch2.prototype.isMoved = function isMoved() {
    return this._moved;
  };
  Touch2.prototype._start = function _start(touchInfo) {
    clearTimeout(this._holdTimeout);
    this.startTime = now2();
    this._moved = true;
    this._trigger(START2, touchInfo);
  };
  Touch2.prototype._trigger = function _trigger(name2, touchInfo) {
    var that = this, jQueryEvent = touchInfo.event, data = {
      touch: that,
      x: that.x,
      y: that.y,
      target: that.target,
      event: jQueryEvent
    };
    if (that.userEvents.notify(name2, data)) {
      jQueryEvent.preventDefault();
    }
  };
  Touch2.prototype._withinIgnoreThreshold = function _withinIgnoreThreshold() {
    var xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;
  };
  return Touch2;
}(class_default);
function withEachUpEvent(callback) {
  var eventMap = getEventMap(navigator.userAgent);
  var downEvents = eventMap.up.split(" "), idx = 0, length = downEvents.length;
  for (; idx < length; idx++) {
    callback(downEvents[idx]);
  }
}
var UserEvents = function(Observable3) {
  function UserEvents2(element2, options2) {
    Observable3.call(this);
    var that = this;
    var filter;
    var support3 = getSupportedFeatures();
    this.support = support3;
    options2 = options2 || {};
    this.options = options2;
    filter = that.filter = options2.filter;
    that.threshold = options2.threshold || DEFAULT_THRESHOLD;
    that.minHold = options2.minHold || DEFAULT_MIN_HOLD;
    that.touches = [];
    that._maxTouches = options2.multiTouch ? 2 : 1;
    that.allowSelection = options2.allowSelection;
    that.captureUpIfMoved = options2.captureUpIfMoved;
    that.useClickAsTap = !options2.fastTap && !support3.delayedClick();
    that._clicks = 0;
    that.supportDoubleTap = options2.supportDoubleTap;
    var enableGlobalSurface = !support3.touch || support3.mouseAndTouchPresent;
    extend13(that, {
      element: element2,
      surface: options2.global && enableGlobalSurface ? element2.ownerDocument.documentElement : options2.surface || element2,
      stopPropagation: options2.stopPropagation,
      pressed: false
    });
    this._surfaceMoveHandler = proxy(this._move, this);
    on(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    this._surfaceEndHandler = proxy(this._end, this);
    on(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    this._elementStartHandler = proxy(this._start, this);
    on(element2, applyEventMap("down"), filter, this._elementStartHandler);
    if (that.useClickAsTap) {
      this._elementClickHandler = proxy(this._click, this);
      on(element2, applyEventMap("click"), filter, this._elementClickHandler);
    }
    if (support3.pointers || support3.msPointers) {
      if (support3.browser.version < 11) {
        var defaultAction = "pinch-zoom double-tap-zoom";
        element2.style["-ms-touch-action"] = options2.touchAction && options2.touchAction !== "none" ? defaultAction + " " + options2.touchAction : defaultAction;
      } else {
        element2.style["touch-action"] = options2.touchAction || "none";
      }
    }
    if (options2.preventDragEvent) {
      this._elementDragStartHandler = preventDefault4;
      on(element2, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    this._elementSelectHandler = proxy(this._select, this);
    on(element2, applyEventMap("mousedown"), filter, this._elementSelectHandler);
    if (that.captureUpIfMoved && support3.eventCapture) {
      var surfaceElement = that.surface, preventIfMovingProxy = proxy(that.preventIfMoving, that);
      withEachUpEvent(function(eventName) {
        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);
      });
    }
    that.bind([
      PRESS,
      HOLD,
      TAP,
      DOUBLETAP,
      START2,
      MOVE2,
      END2,
      RELEASE,
      CANCEL,
      GESTURESTART,
      GESTURECHANGE,
      GESTUREEND,
      GESTURETAP,
      SELECT2
    ], options2);
  }
  if (Observable3)
    UserEvents2.__proto__ = Observable3;
  UserEvents2.prototype = Object.create(Observable3 && Observable3.prototype);
  UserEvents2.prototype.constructor = UserEvents2;
  UserEvents2.prototype.preventIfMoving = function preventIfMoving(e) {
    if (this._isMoved()) {
      e.preventDefault();
    }
  };
  UserEvents2.prototype.destroy = function destroy2() {
    var that = this;
    var options2 = this.options;
    var element2 = this.element;
    if (that._destroyed) {
      return;
    }
    that._destroyed = true;
    if (that.captureUpIfMoved && this.support.eventCapture) {
      var surfaceElement = that.surface;
      withEachUpEvent(function(eventName) {
        surfaceElement.removeEventListener(eventName, that.preventIfMoving);
      });
    }
    off(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    off(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    off(element2, applyEventMap("down"), this._elementStartHandler);
    if (that.useClickAsTap) {
      off(element2, applyEventMap("click"), this._elementClickHandler);
    }
    if (options2.preventDragEvent) {
      off(element2, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    off(element2, applyEventMap("mousedown"), this._elementSelectHandler);
    that._disposeAll();
    that.unbind();
    delete that.surface;
    delete that.element;
    delete that.currentTarget;
  };
  UserEvents2.prototype.capture = function capture() {
    UserEvents2.current = this;
  };
  UserEvents2.prototype.cancel = function cancel() {
    this._disposeAll();
    this.trigger(CANCEL);
  };
  UserEvents2.prototype.notify = function notify3(event, data) {
    var that = this, touches = that.touches;
    var eventName = event;
    if (this._isMultiTouch()) {
      switch (eventName) {
        case MOVE2:
          eventName = GESTURECHANGE;
          break;
        case END2:
          eventName = GESTUREEND;
          break;
        case TAP:
          eventName = GESTURETAP;
          break;
        default:
          break;
      }
      extend13(data, {
        touches
      }, touchDelta(touches[0], touches[1]));
    }
    return this.trigger(eventName, extend13(data, {
      type: eventName
    }));
  };
  UserEvents2.prototype.press = function press(x, y, target) {
    this._apiCall("_start", x, y, target);
  };
  UserEvents2.prototype.move = function move(x, y) {
    this._apiCall("_move", x, y);
  };
  UserEvents2.prototype.end = function end(x, y) {
    this._apiCall("_end", x, y);
  };
  UserEvents2.prototype._isMultiTouch = function _isMultiTouch() {
    return this.touches.length > 1;
  };
  UserEvents2.prototype._maxTouchesReached = function _maxTouchesReached() {
    return this.touches.length >= this._maxTouches;
  };
  UserEvents2.prototype._disposeAll = function _disposeAll() {
    var touches = this.touches;
    while (touches.length > 0) {
      touches.pop().dispose();
    }
  };
  UserEvents2.prototype._isMoved = function _isMoved() {
    return grep(this.touches, function(touch) {
      return touch.isMoved();
    }).length;
  };
  UserEvents2.prototype._select = function _select(e) {
    if (!this.allowSelection || this.trigger(SELECT2, { event: e })) {
      e.preventDefault();
    }
  };
  UserEvents2.prototype._start = function _start(e) {
    var that = this, idx = 0, filter = that.filter, target, touches = getTouches(e), length = touches.length, touch, which = e.which;
    if (which && which > 1 || that._maxTouchesReached()) {
      return;
    }
    UserEvents2.current = null;
    that.currentTarget = e.currentTarget;
    if (that.stopPropagation) {
      e.stopPropagation();
    }
    for (; idx < length; idx++) {
      if (that._maxTouchesReached()) {
        break;
      }
      touch = touches[idx];
      if (filter) {
        target = touch.currentTarget;
      } else {
        target = that.element;
      }
      if (target && target.length === 0) {
        continue;
      }
      touch = new Touch(that, target, touch);
      that.touches.push(touch);
      touch.press();
      if (that._isMultiTouch()) {
        that.notify("gesturestart", {});
      }
    }
  };
  UserEvents2.prototype._move = function _move(e) {
    this._eachTouch("move", e);
  };
  UserEvents2.prototype._end = function _end(e) {
    this._eachTouch("end", e);
  };
  UserEvents2.prototype._click = function _click(e) {
    var data = {
      touch: {
        initialTouch: e.target,
        target: e.currentTarget,
        endTime: now2(),
        x: {
          location: e.pageX,
          client: e.clientX
        },
        y: {
          location: e.pageY,
          client: e.clientY
        }
      },
      x: e.pageX,
      y: e.pageY,
      target: e.currentTarget,
      event: e,
      type: "tap"
    };
    if (this.trigger("tap", data)) {
      e.preventDefault();
    }
  };
  UserEvents2.prototype._eachTouch = function _eachTouch(methodName, e) {
    var that = this, dict = {}, touches = getTouches(e), activeTouches = that.touches, idx, touch, touchInfo, matchingTouch;
    for (idx = 0; idx < activeTouches.length; idx++) {
      touch = activeTouches[idx];
      dict[touch.id] = touch;
    }
    for (idx = 0; idx < touches.length; idx++) {
      touchInfo = touches[idx];
      matchingTouch = dict[touchInfo.id];
      if (matchingTouch) {
        matchingTouch[methodName](touchInfo);
      }
    }
  };
  UserEvents2.prototype._apiCall = function _apiCall(type, x, y, target) {
    this[type]({
      api: true,
      pageX: x,
      pageY: y,
      clientX: x,
      clientY: y,
      target: target || this.element,
      stopPropagation: noop,
      preventDefault: noop
    });
  };
  UserEvents2.defaultThreshold = function defaultThreshold(value) {
    DEFAULT_THRESHOLD = value;
  };
  UserEvents2.minHold = function minHold(value) {
    DEFAULT_MIN_HOLD = value;
  };
  return UserEvents2;
}(Observable2);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/scroller.js
var extend14 = Object.assign;
var abs2 = Math.abs;
var SNAPBACK_DURATION = 500;
var SCROLLBAR_OPACITY = 0.7;
var FRICTION = 0.96;
var VELOCITY_MULTIPLIER = 10;
var MAX_VELOCITY = 55;
var OUT_OF_BOUNDS_FRICTION = 0.5;
var ANIMATED_SCROLLER_PRECISION = 5;
var PULL = "pull";
var CHANGE3 = "change";
var RESIZE = "resize";
var SCROLL = "scroll";
var MOUSE_WHEEL_ID = 2;
var ZoomSnapBack = function(Animation3) {
  function ZoomSnapBack2(options2) {
    Animation3.call(this, options2);
    var that = this;
    extend14(that, options2);
    that.userEvents.bind("gestureend", that.start.bind(this));
    that.tapCapture.bind("press", that.cancel.bind(this));
  }
  if (Animation3)
    ZoomSnapBack2.__proto__ = Animation3;
  ZoomSnapBack2.prototype = Object.create(Animation3 && Animation3.prototype);
  ZoomSnapBack2.prototype.constructor = ZoomSnapBack2;
  ZoomSnapBack2.prototype.enabled = function enabled() {
    return this.movable.scale < this.dimensions.minScale;
  };
  ZoomSnapBack2.prototype.done = function done() {
    return this.dimensions.minScale - this.movable.scale < 0.01;
  };
  ZoomSnapBack2.prototype.tick = function tick() {
    var movable = this.movable;
    movable.scaleWith(1.1);
    this.dimensions.rescale(movable.scale);
  };
  ZoomSnapBack2.prototype.onEnd = function onEnd() {
    var movable = this.movable;
    movable.scaleTo(this.dimensions.minScale);
    this.dimensions.rescale(movable.scale);
  };
  return ZoomSnapBack2;
}(Animation2);
var DragInertia = function(Animation3) {
  function DragInertia2(options2) {
    Animation3.call(this);
    var that = this;
    extend14(that, options2, {
      transition: new Transition({
        axis: options2.axis,
        movable: options2.movable,
        onEnd: function onEnd() {
          that._end();
        }
      })
    });
    that.tapCapture.bind("press", function() {
      that.cancel();
    });
    that.userEvents.bind("end", proxy(that.start, that));
    that.userEvents.bind("gestureend", proxy(that.start, that));
    that.userEvents.bind("tap", proxy(that.onEnd, that));
  }
  if (Animation3)
    DragInertia2.__proto__ = Animation3;
  DragInertia2.prototype = Object.create(Animation3 && Animation3.prototype);
  DragInertia2.prototype.constructor = DragInertia2;
  DragInertia2.prototype.onCancel = function onCancel() {
    this.transition.cancel();
  };
  DragInertia2.prototype.freeze = function freeze(location) {
    var that = this;
    that.cancel();
    that._moveTo(location);
  };
  DragInertia2.prototype.onEnd = function onEnd() {
    var that = this;
    if (that.paneAxis.outOfBounds()) {
      that._snapBack();
    } else {
      that._end();
    }
  };
  DragInertia2.prototype.done = function done() {
    return abs2(this.velocity) < 1;
  };
  DragInertia2.prototype.start = function start(e) {
    var that = this, velocity;
    if (!that.dimension.enabled) {
      return;
    }
    if (that.paneAxis.outOfBounds()) {
      if (that.transition._started) {
        that.transition.cancel();
        that.velocity = Math.min(e.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);
        Animation3.prototype.start.call(this);
      } else {
        that._snapBack();
      }
    } else {
      velocity = e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[that.axis].velocity;
      that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);
      that.tapCapture.captureNext();
      Animation3.prototype.start.call(this);
    }
  };
  DragInertia2.prototype.tick = function tick() {
    var that = this, dimension = that.dimension, friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction, delta = that.velocity *= friction, location = that.movable[that.axis] + delta;
    if (!that.elastic && dimension.outOfBounds(location)) {
      location = Math.max(Math.min(location, dimension.max), dimension.min);
      that.velocity = 0;
    }
    that.movable.moveAxis(that.axis, location);
  };
  DragInertia2.prototype._end = function _end() {
    this.tapCapture.cancelCapture();
    this.end();
  };
  DragInertia2.prototype._snapBack = function _snapBack() {
    var that = this, dimension = that.dimension, snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;
    that._moveTo(snapBack);
  };
  DragInertia2.prototype._moveTo = function _moveTo(location) {
    this.transition.moveTo({
      location,
      duration: SNAPBACK_DURATION,
      ease: Transition.easeOutExpo
    });
  };
  return DragInertia2;
}(Animation2);
var AnimatedScroller = function(Animation3) {
  function AnimatedScroller2(options2) {
    Animation3.call(this, options2);
    var that = this;
    extend14(that, options2, {
      origin: {},
      destination: {},
      offset: {}
    });
  }
  if (Animation3)
    AnimatedScroller2.__proto__ = Animation3;
  AnimatedScroller2.prototype = Object.create(Animation3 && Animation3.prototype);
  AnimatedScroller2.prototype.constructor = AnimatedScroller2;
  AnimatedScroller2.prototype.tick = function tick() {
    this._updateCoordinates();
    this.moveTo(this.origin);
  };
  AnimatedScroller2.prototype.done = function done() {
    return abs2(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs2(this.offset.x) < ANIMATED_SCROLLER_PRECISION;
  };
  AnimatedScroller2.prototype.onEnd = function onEnd() {
    this.moveTo(this.destination);
    if (this.callback) {
      this.callback.call();
    }
  };
  AnimatedScroller2.prototype.setCoordinates = function setCoordinates(from, to) {
    this.offset = {};
    this.origin = from;
    this.destination = to;
  };
  AnimatedScroller2.prototype.setCallback = function setCallback(callback) {
    if (callback && isFunction3(callback)) {
      this.callback = callback;
    } else {
      callback = void 0;
    }
  };
  AnimatedScroller2.prototype._updateCoordinates = function _updateCoordinates() {
    this.offset = {
      x: (this.destination.x - this.origin.x) / 4,
      y: (this.destination.y - this.origin.y) / 4
    };
    this.origin = {
      y: this.origin.y + this.offset.y,
      x: this.origin.x + this.offset.x
    };
  };
  return AnimatedScroller2;
}(Animation2);
var ScrollBar = function(Class3) {
  function ScrollBar2(options2) {
    Class3.call(this);
    var that = this, horizontal = options2.axis === "x";
    var orientation = horizontal ? "horizontal" : "vertical";
    var element2 = convertToHtml('<div class="km-touch-scrollbar km-' + orientation + '-scrollbar" />');
    extend14(that, options2, {
      element: element2,
      elementSize: 0,
      movable: new Movable(element2),
      scrollMovable: options2.movable,
      alwaysVisible: options2.alwaysVisible,
      size: horizontal ? "width" : "height"
    });
    that.scrollMovable.bind(CHANGE3, that.refresh.bind(that));
    that.container.appendChild(element2);
    if (options2.alwaysVisible) {
      that.show();
    }
  }
  if (Class3)
    ScrollBar2.__proto__ = Class3;
  ScrollBar2.prototype = Object.create(Class3 && Class3.prototype);
  ScrollBar2.prototype.constructor = ScrollBar2;
  ScrollBar2.prototype.refresh = function refresh() {
    var that = this, axis = that.axis, dimension = that.dimension, paneSize = dimension.size, scrollMovable = that.scrollMovable, sizeRatio = paneSize / dimension.total, position3 = Math.round(-scrollMovable[axis] * sizeRatio), size = Math.round(paneSize * sizeRatio);
    if (sizeRatio >= 1) {
      this.element.style.display = "none";
    } else {
      this.element.style.display = "";
    }
    if (position3 + size > paneSize) {
      size = paneSize - position3;
    } else if (position3 < 0) {
      size += position3;
      position3 = 0;
    }
    if (that.elementSize !== size) {
      that.element.style[that.size] = size + "px";
      that.elementSize = size;
    }
    that.movable.moveAxis(axis, position3);
  };
  ScrollBar2.prototype.show = function show2() {
    this.element.style.opacity = SCROLLBAR_OPACITY;
    this.element.style.visibility = "visible";
  };
  ScrollBar2.prototype.hide = function hide2() {
    if (!this.alwaysVisible) {
      this.element.style.opacity = 0;
    }
  };
  return ScrollBar2;
}(class_default);
var Scroller = function(Observable3) {
  function Scroller2(element2, options2) {
    Observable3.call(this);
    var that = this;
    this.element = element2;
    this._initOptions(options2);
    var hasScrolling = hasNativeScrolling(navigator.userAgent);
    that._native = that.options.useNative && hasScrolling;
    var scrollHeader = convertToHtml('<div class="km-scroll-header"/>');
    if (that._native) {
      addClass(element2, "km-native-scroller");
      prepend(scrollHeader, element2);
      extend14(that, {
        scrollElement: element2,
        fixedContainer: element2.children[0]
      });
      return;
    }
    element2.style.overflow = "hidden";
    addClass(element2, "km-scroll-wrapper");
    var scrollContainer = convertToHtml('<div class="km-scroll-container"/>');
    wrapInner(element2, scrollContainer);
    prepend(scrollHeader, element2);
    var inner = element2.children[1], tapCapture = new TapCapture(element2), movable = new Movable(inner), dimensions = new PaneDimensions({
      element: inner,
      container: element2,
      forcedEnabled: that.options.zoom
    }), avoidScrolling2 = this.options.avoidScrolling, userEvents = new UserEvents(element2, {
      touchAction: "pan-y",
      fastTap: true,
      allowSelection: true,
      preventDragEvent: true,
      captureUpIfMoved: true,
      multiTouch: that.options.zoom,
      supportDoubleTap: that.options.supportDoubleTap,
      start: function start(e) {
        dimensions.refresh();
        var velocityX = abs2(e.x.velocity), velocityY = abs2(e.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = contains(that.fixedContainer, e.event.target), verticalSwipe = velocityY * 2 >= velocityX;
        if (!originatedFromFixedContainer && !avoidScrolling2(e) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {
          userEvents.capture();
        } else {
          userEvents.cancel();
        }
      }
    }), pane = new Pane2({
      movable,
      dimensions,
      userEvents,
      elastic: that.options.elastic
    }), zoomSnapBack = new ZoomSnapBack({
      movable,
      dimensions,
      userEvents,
      tapCapture
    }), animatedScroller = new AnimatedScroller({
      moveTo: function moveTo(coordinates) {
        that.scrollTo(coordinates.x, coordinates.y);
      }
    });
    movable.bind(CHANGE3, function() {
      that.scrollTop = -movable.y;
      that.scrollLeft = -movable.x;
      that.trigger(SCROLL, {
        scrollTop: that.scrollTop,
        scrollLeft: that.scrollLeft
      });
    });
    if (that.options.mousewheelScrolling) {
      this._wheelScrollHandler = this._wheelScroll.bind(this);
      on(element2, "wheel", this._wheelScrollHandler);
    }
    extend14(that, {
      movable,
      dimensions,
      zoomSnapBack,
      animatedScroller,
      userEvents,
      pane,
      tapCapture,
      pulled: false,
      enabled: true,
      scrollElement: inner,
      scrollTop: 0,
      scrollLeft: 0,
      fixedContainer: element2.children[0]
    });
    that._initAxis("x");
    that._initAxis("y");
    that._wheelEnd = function() {
      that._wheel = false;
      that.userEvents.end(0, that._wheelY);
    };
    dimensions.refresh();
    if (that.options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  if (Observable3)
    Scroller2.__proto__ = Observable3;
  Scroller2.prototype = Object.create(Observable3 && Observable3.prototype);
  Scroller2.prototype.constructor = Scroller2;
  Scroller2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Scroller2.prototype._wheelScroll = function _wheelScroll(e) {
    if (e.ctrlKey) {
      return;
    }
    if (!this._wheel) {
      this._wheel = true;
      this._wheelY = 0;
      this.userEvents.press(0, this._wheelY);
    }
    clearTimeout(this._wheelTimeout);
    this._wheelTimeout = setTimeout(this._wheelEnd, 50);
    var delta = wheelDeltaY(e);
    if (delta) {
      this._wheelY += delta;
      this.userEvents.move(0, this._wheelY);
    }
    e.preventDefault();
  };
  Scroller2.prototype.makeVirtual = function makeVirtual() {
    this.dimensions.y.makeVirtual();
  };
  Scroller2.prototype.virtualSize = function virtualSize(min3, max2) {
    this.dimensions.y.virtualSize(min3, max2);
  };
  Scroller2.prototype.height = function height() {
    return this.dimensions.y.size;
  };
  Scroller2.prototype.scrollHeight = function scrollHeight() {
    return this.scrollElement.scrollHeight;
  };
  Scroller2.prototype.scrollWidth = function scrollWidth() {
    return this.scrollElement.scrollWidth;
  };
  Scroller2.prototype._resize = function _resize() {
    if (!this._native) {
      this.contentResized();
    }
  };
  Scroller2.prototype.setOptions = function setOptions(options2) {
    var that = this;
    this._initOptions(options2);
    if (options2.pullToRefresh) {
      that._initPullToRefresh();
    }
  };
  Scroller2.prototype.reset = function reset() {
    if (this._native) {
      this.scrollElement.scrollTop(0);
    } else {
      this.movable.moveTo({
        x: 0,
        y: 0
      });
      this._scale(1);
    }
  };
  Scroller2.prototype.contentResized = function contentResized() {
    this.dimensions.refresh();
    if (this.pane.x.outOfBounds()) {
      this.movable.moveAxis("x", this.dimensions.x.min);
    }
    if (this.pane.y.outOfBounds()) {
      this.movable.moveAxis("y", this.dimensions.y.min);
    }
  };
  Scroller2.prototype.zoomOut = function zoomOut() {
    var dimensions = this.dimensions;
    dimensions.refresh();
    this._scale(dimensions.fitScale);
    this.movable.moveTo(dimensions.centerCoordinates());
  };
  Scroller2.prototype.enable = function enable() {
    this.enabled = true;
  };
  Scroller2.prototype.disable = function disable() {
    this.enabled = false;
  };
  Scroller2.prototype.scrollTo = function scrollTo(x, y) {
    if (this._native) {
      this.scrollElement.scrollLeft(abs2(x));
      this.scrollElement.scrollTop(abs2(y));
    } else {
      this.dimensions.refresh();
      this.movable.moveTo({
        x,
        y
      });
    }
  };
  Scroller2.prototype.animatedScrollTo = function animatedScrollTo(x, y, callback) {
    var from, to;
    if (this._native) {
      this.scrollTo(x, y);
    } else {
      from = {
        x: this.movable.x,
        y: this.movable.y
      };
      to = {
        x,
        y
      };
      this.animatedScroller.setCoordinates(from, to);
      this.animatedScroller.setCallback(callback);
      this.animatedScroller.start();
    }
  };
  Scroller2.prototype.pullHandled = function pullHandled() {
  };
  Scroller2.prototype.destroy = function destroy2() {
    var element2 = this.element;
    off(element2, "wheel", this._wheelScrollHandler);
    if (this.userEvents) {
      this.userEvents.destroy();
    }
  };
  Scroller2.prototype._scale = function _scale(scale) {
    this.dimensions.rescale(scale);
    this.movable.scaleTo(scale);
  };
  Scroller2.prototype._initPullToRefresh = function _initPullToRefresh() {
  };
  Scroller2.prototype._dragEnd = function _dragEnd() {
  };
  Scroller2.prototype._paneChange = function _paneChange() {
  };
  Scroller2.prototype._initAxis = function _initAxis(axis) {
    var that = this, movable = that.movable, dimension = that.dimensions[axis], tapCapture = that.tapCapture, paneAxis = that.pane[axis], scrollBar = new ScrollBar({
      axis,
      movable,
      dimension,
      container: that.element,
      alwaysVisible: that.options.visibleScrollHints
    });
    dimension.bind(CHANGE3, function() {
      scrollBar.refresh();
    });
    paneAxis.bind(CHANGE3, function() {
      scrollBar.show();
    });
    that[axis + "inertia"] = new DragInertia({
      axis,
      paneAxis,
      movable,
      tapCapture,
      userEvents: that.userEvents,
      dimension,
      elastic: that.options.elastic,
      friction: that.options.friction || FRICTION,
      velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,
      end: function end() {
        scrollBar.hide();
        that.trigger("scrollEnd", {
          axis,
          scrollTop: that.scrollTop,
          scrollLeft: that.scrollLeft
        });
      }
    });
  };
  return Scroller2;
}(Observable2);
setDefaultOptions(Scroller, {
  name: "Scroller",
  zoom: false,
  pullOffset: 140,
  visibleScrollHints: false,
  elastic: true,
  useNative: false,
  mousewheelScrolling: true,
  avoidScrolling: function avoidScrolling() {
    return false;
  },
  pullToRefresh: false,
  messages: {
    pullTemplate: "Pull to refresh",
    releaseTemplate: "Release to refresh",
    refreshTemplate: "Refreshing"
  }
});
setDefaultEvents(Scroller, [
  PULL,
  SCROLL,
  RESIZE
]);

// node_modules/@progress/kendo-charts/dist/es/services/map-service.js
var MapService = function MapService2(widget, context2) {
  if (context2 === void 0)
    context2 = {};
  this.sender = context2.sender || widget;
  this.widget = widget;
  this.rtl = Boolean(context2.rtl);
};
MapService.prototype.notify = function notify2(name2, args) {
  if (this.widget) {
    this.widget.trigger(name2, args);
  }
};
var map_service_default = MapService;

// node_modules/@progress/kendo-charts/dist/es/map/map.js
var math5 = Math;
var min2 = math5.min;
var pow4 = math5.pow;
var Point7 = geometry_exports.Point;
var MARKER = "marker";
var LOCATION = "location";
var FRICTION2 = 0.9;
var FRICTION_MOBILE = 0.93;
var MOUSEWHEEL2 = "wheel";
var MOUSEWHEEL_THROTTLE = 50;
var VELOCITY_MULTIPLIER2 = 5;
var DEFAULT_ZOOM_RATE = 1;
var layersMap = {
  bubble: BubbleLayer,
  shape: ShapeLayer,
  tile: TileLayer
};
layersMap[MARKER] = MarkerLayer;
var Map2 = function(Observable3) {
  function Map3(element2, options2, themeOptions, context2) {
    if (options2 === void 0)
      options2 = {};
    if (themeOptions === void 0)
      themeOptions = {};
    if (context2 === void 0)
      context2 = {};
    Observable3.call(this);
    this._init(element2, options2, themeOptions, context2);
  }
  if (Observable3)
    Map3.__proto__ = Observable3;
  Map3.prototype = Object.create(Observable3 && Observable3.prototype);
  Map3.prototype.constructor = Map3;
  Map3.prototype.destroy = function destroy2() {
    var this$1 = this;
    this.scroller.destroy();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this.navigator) {
      this.navigator.destroy();
    }
    if (this.attribution) {
      this.attribution.destroy();
    }
    if (this.zoomControl) {
      this.zoomControl.destroy();
    }
    if (isArray(this.markers)) {
      this.markers.forEach(function(markerLayer) {
        markerLayer.destroy();
      });
    } else {
      this.markers.destroy();
    }
    for (var i = 0; i < this.layers.length; i++) {
      this$1.layers[i].destroy();
    }
    off(this.element, MOUSEWHEEL2, this._mousewheelHandler);
    Observable3.prototype.destroy.call(this);
  };
  Map3.prototype._init = function _init(element2, options2, themeOptions, context2) {
    if (options2 === void 0)
      options2 = {};
    if (themeOptions === void 0)
      themeOptions = {};
    if (context2 === void 0)
      context2 = {};
    this.support = getSupportedFeatures();
    this.context = context2;
    this.initObserver(context2);
    this.initServices(context2);
    this._notifyObserver(INIT);
    this._initOptions(options2);
    this._setEvents(options2);
    this.crs = new EPSG3857();
    this._initElement(element2);
    this._viewOrigin = this._getOrigin();
    this._tooltip = this._createTooltip();
    this._initScroller();
    this._initMarkers();
    this._initControls();
    this._initLayers();
    this._reset();
    var mousewheelThrottled = throttle(this._mousewheel.bind(this), MOUSEWHEEL_THROTTLE);
    this._mousewheelHandler = function(e) {
      e.preventDefault();
      mousewheelThrottled(e);
    };
    on(this.element, MOUSEWHEEL2, this._mousewheelHandler);
  };
  Map3.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Map3.prototype._initElement = function _initElement(element2) {
    this.element = element2;
    addClass(element2, "k-map");
    element2.style.position = "relative";
    element2.setAttribute("data-role", "map");
    removeChildren(element2);
    var div = convertToHtml("<div />");
    this.element.appendChild(div);
  };
  Map3.prototype.initServices = function initServices(context2) {
    if (context2 === void 0)
      context2 = {};
    this.widgetService = new map_service_default(this, context2);
  };
  Map3.prototype.initObserver = function initObserver(context2) {
    if (context2 === void 0)
      context2 = {};
    this.observers = [];
    this.addObserver(context2.observer);
  };
  Map3.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Map3.prototype.removeObserver = function removeObserver(observer) {
    var index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  };
  Map3.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers = this.observers;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Map3.prototype.trigger = function trigger2(name2, args) {
    if (args === void 0)
      args = {};
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented3 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented3 = true;
      }
    }
    if (!isDefaultPrevented3) {
      Observable3.prototype.trigger.call(this, name2, args);
    }
    return isDefaultPrevented3;
  };
  Map3.prototype._notifyObserver = function _notifyObserver(name2, args) {
    if (args === void 0)
      args = {};
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented3 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name2, args)) {
        isDefaultPrevented3 = true;
      }
    }
    return isDefaultPrevented3;
  };
  Map3.prototype.zoom = function zoom(level) {
    var options2 = this.options;
    var result;
    if (defined2(level)) {
      var zoomLevel2 = math5.round(limitValue2(level, options2.minZoom, options2.maxZoom));
      if (options2.zoom !== zoomLevel2) {
        options2.zoom = zoomLevel2;
        this.widgetService.notify(ZOOM_CHANGE, { zoom: options2.zoom });
        this._reset();
      }
      result = this;
    } else {
      result = options2.zoom;
    }
    return result;
  };
  Map3.prototype.center = function center(center$1) {
    var result;
    if (center$1) {
      var current4 = Location.create(center$1);
      var previous = Location.create(this.options.center);
      if (!current4.equals(previous)) {
        this.options.center = current4.toArray();
        this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
        this._reset();
      }
      result = this;
    } else {
      result = Location.create(this.options.center);
    }
    return result;
  };
  Map3.prototype.extent = function extent(extent$1) {
    var result;
    if (extent$1) {
      this._setExtent(extent$1);
      result = this;
    } else {
      result = this._getExtent();
    }
    return result;
  };
  Map3.prototype.setOptions = function setOptions(options2) {
    if (options2 === void 0)
      options2 = {};
    var element2 = this.element;
    this.destroy();
    removeChildren(element2);
    this._init(element2, options2, {}, this.context);
    this._reset();
  };
  Map3.prototype.locationToLayer = function locationToLayer(location, zoom) {
    var clamp = !this.options.wraparound;
    var locationObject = Location.create(location);
    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp);
  };
  Map3.prototype.layerToLocation = function layerToLocation(point2, zoom) {
    var clamp = !this.options.wraparound;
    var pointObject = Point7.create(point2);
    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp);
  };
  Map3.prototype.locationToView = function locationToView(location) {
    var locationObject = Location.create(location);
    var origin = this.locationToLayer(this._viewOrigin);
    var point2 = this.locationToLayer(locationObject);
    return point2.translateWith(origin.scale(-1));
  };
  Map3.prototype.viewToLocation = function viewToLocation(point2, zoom) {
    var origin = this.locationToLayer(this._getOrigin(), zoom);
    var pointObject = Point7.create(point2);
    var pointResult = pointObject.clone().translateWith(origin);
    return this.layerToLocation(pointResult, zoom);
  };
  Map3.prototype.eventOffset = function eventOffset(e) {
    var x;
    var y;
    var offset3 = elementOffset2(this.element);
    if (e.x && e.x[LOCATION] || e.y && e.y[LOCATION]) {
      x = e.x[LOCATION] - offset3.left;
      y = e.y[LOCATION] - offset3.top;
    } else {
      var event = e.originalEvent || e;
      x = valueOrDefault2(event.pageX, event.clientX) - offset3.left;
      y = valueOrDefault2(event.pageY, event.clientY) - offset3.top;
    }
    var point2 = new geometry_exports.Point(x, y);
    return point2;
  };
  Map3.prototype.eventToView = function eventToView(e) {
    var cursor = this.eventOffset(e);
    return this.locationToView(this.viewToLocation(cursor));
  };
  Map3.prototype.eventToLayer = function eventToLayer(e) {
    return this.locationToLayer(this.eventToLocation(e));
  };
  Map3.prototype.eventToLocation = function eventToLocation(e) {
    var cursor = this.eventOffset(e);
    return this.viewToLocation(cursor);
  };
  Map3.prototype.viewSize = function viewSize() {
    var element2 = this.element;
    var scale = this._layerSize();
    var width = element2.clientWidth;
    if (!this.options.wraparound) {
      width = min2(scale, width);
    }
    return {
      width,
      height: min2(scale, element2.clientHeight)
    };
  };
  Map3.prototype.exportVisual = function exportVisual() {
    this._reset();
    return false;
  };
  Map3.prototype.hideTooltip = function hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  };
  Map3.prototype._setOrigin = function _setOrigin(origin, zoom) {
    var size = this.viewSize(), topLeft;
    var originLocation = this._origin = Location.create(origin);
    topLeft = this.locationToLayer(originLocation, zoom);
    topLeft.x += size.width / 2;
    topLeft.y += size.height / 2;
    this.options.center = this.layerToLocation(topLeft, zoom).toArray();
    this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
    return this;
  };
  Map3.prototype._getOrigin = function _getOrigin(invalidate) {
    var size = this.viewSize(), topLeft;
    if (invalidate || !this._origin) {
      topLeft = this.locationToLayer(this.center());
      topLeft.x -= size.width / 2;
      topLeft.y -= size.height / 2;
      this._origin = this.layerToLocation(topLeft);
    }
    return this._origin;
  };
  Map3.prototype._setExtent = function _setExtent(newExtent) {
    var this$1 = this;
    var raw = Extent.create(newExtent);
    var se = raw.se.clone();
    if (this.options.wraparound && se.lng < 0 && newExtent.nw.lng > 0) {
      se.lng = 180 + (180 + se.lng);
    }
    var extent = new Extent(raw.nw, se);
    this.center(extent.center());
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    var zoom;
    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {
      var topLeft = this$1.locationToLayer(extent.nw, zoom);
      var bottomRight = this$1.locationToLayer(extent.se, zoom);
      var layerWidth = math5.abs(bottomRight.x - topLeft.x);
      var layerHeight = math5.abs(bottomRight.y - topLeft.y);
      if (layerWidth <= width && layerHeight <= height) {
        break;
      }
    }
    this.zoom(zoom);
  };
  Map3.prototype._getExtent = function _getExtent() {
    var nw = this._getOrigin();
    var bottomRight = this.locationToLayer(nw);
    var size = this.viewSize();
    bottomRight.x += size.width;
    bottomRight.y += size.height;
    var se = this.layerToLocation(bottomRight);
    return new Extent(nw, se);
  };
  Map3.prototype._zoomAround = function _zoomAround(pivot, level) {
    this._setOrigin(this.layerToLocation(pivot, level), level);
    this.zoom(level);
  };
  Map3.prototype._initControls = function _initControls() {
    var controls = this.options.controls;
    if (controls.attribution) {
      this._createAttribution(controls.attribution);
    }
    if (!this.support.mobileOS) {
      if (controls.navigator) {
        this._createNavigator(controls.navigator);
      }
      if (controls.zoom) {
        this._createZoomControl(controls.zoom);
      }
    }
  };
  Map3.prototype._createControlElement = function _createControlElement(options2, defaultPosition) {
    var pos = options2.position || defaultPosition;
    var posSelector = "." + renderPos(pos).replace(" ", ".");
    var wrap2 = this.element.querySelector(".k-map-controls" + posSelector) || [];
    if (wrap2.length === 0) {
      var div$1 = document.createElement("div");
      addClass(div$1, "k-map-controls " + renderPos(pos));
      wrap2 = div$1;
      this.element.appendChild(wrap2);
    }
    var div = document.createElement("div");
    wrap2.appendChild(div);
    return div;
  };
  Map3.prototype._createAttribution = function _createAttribution(options2) {
    var element2 = this._createControlElement(options2, "bottomRight");
    this.attribution = new Attribution(element2, options2);
  };
  Map3.prototype._createNavigator = function _createNavigator(options2) {
    var element2 = this._createControlElement(options2, "topLeft");
    var navigator2 = this.navigator = new Navigator2(element2, options2);
    this._navigatorPan = this._navigatorPan.bind(this);
    navigator2.bind("pan", this._navigatorPan);
    this._navigatorCenter = this._navigatorCenter.bind(this);
    navigator2.bind("center", this._navigatorCenter);
  };
  Map3.prototype._navigatorPan = function _navigatorPan(e) {
    var scroller = this.scroller;
    var x = scroller.scrollLeft + e.x;
    var y = scroller.scrollTop - e.y;
    var bounds = this._virtualSize;
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    x = limitValue2(x, bounds.x.min, bounds.x.max - width);
    y = limitValue2(y, bounds.y.min, bounds.y.max - height);
    this.scroller.one("scroll", proxy(this._scrollEnd, this));
    this.scroller.scrollTo(-x, -y);
  };
  Map3.prototype._navigatorCenter = function _navigatorCenter() {
    this.center(this.options.center);
  };
  Map3.prototype._createZoomControl = function _createZoomControl(options2) {
    var element2 = this._createControlElement(options2, "topLeft");
    var zoomControl = this.zoomControl = new ZoomControl(element2, options2);
    this._zoomControlChange = this._zoomControlChange.bind(this);
    zoomControl.bind("change", this._zoomControlChange);
  };
  Map3.prototype._zoomControlChange = function _zoomControlChange(e) {
    if (!this.trigger("zoomStart", { originalEvent: e })) {
      this.zoom(this.zoom() + e.delta);
      this.trigger("zoomEnd", {
        originalEvent: e
      });
    }
  };
  Map3.prototype._initScroller = function _initScroller() {
    var friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION2;
    var zoomable = this.options.zoomable !== false;
    var scroller = this.scroller = new Scroller(this.element.children[0], {
      friction,
      velocityMultiplier: VELOCITY_MULTIPLIER2,
      zoom: zoomable,
      mousewheelScrolling: false,
      supportDoubleTap: true
    });
    scroller.bind("scroll", proxy(this._scroll, this));
    scroller.bind("scrollEnd", proxy(this._scrollEnd, this));
    scroller.userEvents.bind("gesturestart", proxy(this._scaleStart, this));
    scroller.userEvents.bind("gestureend", proxy(this._scale, this));
    scroller.userEvents.bind("doubleTap", proxy(this._doubleTap, this));
    scroller.userEvents.bind("tap", proxy(this._tap, this));
    this.scrollElement = scroller.scrollElement;
  };
  Map3.prototype._initLayers = function _initLayers() {
    var this$1 = this;
    var defs = this.options.layers, layers = this.layers = [];
    for (var i = 0; i < defs.length; i++) {
      var options2 = defs[i];
      var layer = this$1._createLayer(options2);
      layers.push(layer);
    }
  };
  Map3.prototype._createLayer = function _createLayer(options2) {
    var type = options2.type || "shape";
    var layerDefaults = this.options.layerDefaults[type];
    var layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options2) : deepExtend({}, layerDefaults, options2);
    var layerConstructor = layersMap[type];
    var layer = new layerConstructor(this, layerOptions);
    if (type === MARKER) {
      this.markers = layer;
    }
    return layer;
  };
  Map3.prototype._createTooltip = function _createTooltip() {
    return new Tooltip2(this.widgetService, this.options.tooltip);
  };
  Map3.prototype._initMarkers = function _initMarkers() {
    var markerLayers = (this.options.layers || []).filter(function(x) {
      return x && x.type === MARKER;
    });
    if (markerLayers.length > 0) {
      return;
    }
    this.markers = new MarkerLayer(this, this.options.markerDefaults);
    this.markers.add(this.options.markers);
  };
  Map3.prototype._scroll = function _scroll(e) {
    var origin = this.locationToLayer(this._viewOrigin).round();
    var movable = e.sender.movable;
    var offset3 = new geometry_exports.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);
    origin.x += offset3.x;
    origin.y += offset3.y;
    this._scrollOffset = offset3;
    this._tooltip.offset = offset3;
    this.hideTooltip();
    this._setOrigin(this.layerToLocation(origin));
    this.trigger("pan", {
      originalEvent: e,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map3.prototype._scrollEnd = function _scrollEnd(e) {
    if (!this._scrollOffset || !this._panComplete()) {
      return;
    }
    this._scrollOffset = null;
    this._panEndTimestamp = now2();
    this.trigger("panEnd", {
      originalEvent: e,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map3.prototype._panComplete = function _panComplete() {
    return now2() - (this._panEndTimestamp || 0) > 50;
  };
  Map3.prototype._scaleStart = function _scaleStart(e) {
    if (this.trigger("zoomStart", { originalEvent: e })) {
      var touch = e.touches[1];
      if (touch) {
        touch.cancel();
      }
    }
  };
  Map3.prototype._scale = function _scale(e) {
    var scale = this.scroller.movable.scale;
    var zoom = this._scaleToZoom(scale);
    var gestureCenter = new geometry_exports.Point(e.center.x, e.center.y);
    var centerLocation = this.viewToLocation(gestureCenter, zoom);
    var centerPoint = this.locationToLayer(centerLocation, zoom);
    var originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);
    this._zoomAround(originPoint, zoom);
    this.trigger("zoomEnd", {
      originalEvent: e
    });
  };
  Map3.prototype._scaleToZoom = function _scaleToZoom(scaleDelta) {
    var scale = this._layerSize() * scaleDelta;
    var tiles = scale / this.options.minSize;
    var zoom = math5.log(tiles) / math5.log(2);
    return math5.round(zoom);
  };
  Map3.prototype._reset = function _reset() {
    if (this.attribution) {
      this.attribution.filter(this.center(), this.zoom());
    }
    this._viewOrigin = this._getOrigin(true);
    this._resetScroller();
    this.hideTooltip();
    this.trigger("beforeReset");
    this.trigger("reset");
  };
  Map3.prototype._resetScroller = function _resetScroller() {
    var scroller = this.scroller;
    var x = scroller.dimensions.x;
    var y = scroller.dimensions.y;
    var scale = this._layerSize();
    var nw = this.extent().nw;
    var topLeft = this.locationToLayer(nw).round();
    scroller.movable.round = true;
    scroller.reset();
    scroller.userEvents.cancel();
    var zoom = this.zoom();
    scroller.dimensions.forcedMinScale = pow4(2, this.options.minZoom - zoom);
    scroller.dimensions.maxScale = pow4(2, this.options.maxZoom - zoom);
    var xBounds = {
      min: -topLeft.x,
      max: scale - topLeft.x
    };
    var yBounds = {
      min: -topLeft.y,
      max: scale - topLeft.y
    };
    if (this.options.wraparound) {
      xBounds.max = 20 * scale;
      xBounds.min = -xBounds.max;
    }
    if (this.options.pannable === false) {
      var viewSize = this.viewSize();
      xBounds.min = yBounds.min = 0;
      xBounds.max = viewSize.width;
      yBounds.max = viewSize.height;
    }
    x.makeVirtual();
    y.makeVirtual();
    x.virtualSize(xBounds.min, xBounds.max);
    y.virtualSize(yBounds.min, yBounds.max);
    this._virtualSize = {
      x: xBounds,
      y: yBounds
    };
  };
  Map3.prototype._renderLayers = function _renderLayers() {
  };
  Map3.prototype._layerSize = function _layerSize(zoom) {
    var newZoom = valueOrDefault2(zoom, this.options.zoom);
    return this.options.minSize * pow4(2, newZoom);
  };
  Map3.prototype._tap = function _tap(e) {
    if (!this._panComplete()) {
      return;
    }
    var cursor = this.eventOffset(e);
    this.hideTooltip();
    this.trigger("click", {
      originalEvent: e,
      location: this.viewToLocation(cursor)
    });
  };
  Map3.prototype._doubleTap = function _doubleTap(e) {
    var options2 = this.options;
    if (options2.zoomable !== false) {
      if (!this.trigger("zoomStart", { originalEvent: e })) {
        var toZoom = this.zoom() + DEFAULT_ZOOM_RATE;
        var cursor = this.eventOffset(e);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e
        });
      }
    }
  };
  Map3.prototype._mousewheel = function _mousewheel(e) {
    var delta = mousewheelDelta(e) > 0 ? -1 : 1;
    var options2 = this.options;
    var fromZoom = this.zoom();
    var toZoom = limitValue2(fromZoom + delta, options2.minZoom, options2.maxZoom);
    if (options2.zoomable !== false && toZoom !== fromZoom) {
      if (!this.trigger("zoomStart", { originalEvent: e })) {
        var cursor = this.eventOffset(e);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e
        });
      }
    }
  };
  Map3.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point2) {
    var offset3 = elementOffset2(this.element);
    return {
      left: round3(point2.x + offset3.left),
      top: round3(point2.y + offset3.top)
    };
  };
  return Map3;
}(Observable2);
setDefaultOptions(Map2, {
  name: "Map",
  controls: {
    attribution: true,
    navigator: {
      panStep: 100
    },
    zoom: true
  },
  layers: [],
  layerDefaults: {
    shape: {
      style: {
        fill: {
          color: "#fff"
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    bubble: {
      style: {
        fill: {
          color: "#fff",
          opacity: 0.5
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    marker: {
      shape: "pinTarget",
      tooltip: {
        position: "top"
      }
    }
  },
  center: [
    0,
    0
  ],
  zoom: 3,
  minSize: 256,
  minZoom: 1,
  maxZoom: 19,
  markers: [],
  markerDefaults: {
    shape: "pinTarget",
    tooltip: {
      position: "top"
    }
  },
  wraparound: true,
  // If set to true, GeoJSON layer "Point" features will be rendered as markers.
  // Otherwise, the points will be rendered as circles.
  // Defaults to `true` for KUI/jQuery, `false` everywhere else.
  renderPointsAsMarkers: false
});
setDefaultEvents(Map2, [
  "beforeReset",
  "click",
  "markerActivate",
  "markerClick",
  "markerCreated",
  // Events for implementing custom tooltips.
  "markerMouseEnter",
  "markerMouseLeave",
  "pan",
  "panEnd",
  "reset",
  "shapeClick",
  "shapeCreated",
  "shapeFeatureCreated",
  "shapeMouseEnter",
  "shapeMouseLeave",
  "zoomEnd",
  "zoomStart"
]);

// node_modules/@progress/kendo-charts/dist/es/chart/base-theme.js
var BAR_GAP = 1.5;
var BAR_SPACING = 0.4;
var BLACK2 = "#000";
var SANS = "Arial, Helvetica, sans-serif";
var SANS11 = "11px " + SANS;
var SANS12 = "12px " + SANS;
var SANS16 = "16px " + SANS;
var TRANSPARENT = "transparent";
var WHITE2 = "#fff";
var notes = function() {
  return {
    icon: {
      border: {
        width: 1
      }
    },
    label: {
      font: SANS12,
      padding: 3
    },
    line: {
      length: 10,
      width: 2
    },
    visible: true
  };
};
var axisDefaults = function() {
  return {
    labels: {
      font: SANS12
    },
    notes: notes(),
    title: {
      font: SANS16,
      margin: 5
    }
  };
};
var areaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    opacity: 0.4
  };
};
var rangeAreaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    opacity: 0.4
  };
};
var barSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING
  };
};
var boxPlotSeries = function() {
  return {
    outliersField: "",
    meanField: "",
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE2,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      whiskers: {
        width: 3
      },
      mean: {
        width: 2
      },
      median: {
        width: 2
      }
    },
    mean: {
      width: 2
    },
    median: {
      width: 2
    },
    spacing: 0.3,
    whiskers: {
      width: 2
    }
  };
};
var bubbleSeries = function() {
  return {
    border: {
      width: 0
    },
    labels: {
      background: TRANSPARENT
    },
    opacity: 0.6
  };
};
var bulletSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    target: {
      color: "#ff0000"
    }
  };
};
var candlestickSeries = function() {
  return {
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE2,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      line: {
        width: 2
      }
    },
    line: {
      color: BLACK2,
      width: 1
    },
    spacing: 0.3
  };
};
var columnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING
  };
};
var donutSeries = function() {
  return {
    margin: 1
  };
};
var lineSeries = function() {
  return {
    width: 2
  };
};
var ohlcSeries = function() {
  return {
    gap: 1,
    highlight: {
      line: {
        opacity: 1,
        width: 3
      }
    },
    line: {
      width: 1
    },
    spacing: 0.3
  };
};
var radarAreaSeries = function() {
  return {
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    opacity: 0.5
  };
};
var radarLineSeries = function() {
  return {
    markers: {
      visible: false
    },
    width: 2
  };
};
var rangeBarSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING
  };
};
var rangeColumnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING
  };
};
var scatterLineSeries = function() {
  return {
    width: 1
  };
};
var waterfallSeries = function() {
  return {
    gap: 0.5,
    line: {
      color: BLACK2,
      width: 1
    },
    spacing: BAR_SPACING
  };
};
var pieSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    }
  };
};
var funnelSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    }
  };
};
var heatmapSeries = function() {
  return {
    labels: {
      color: "",
      background: TRANSPARENT,
      visible: true
    },
    highlight: {
      border: {
        width: 0
      }
    }
  };
};
var seriesDefaults = function(options2) {
  return {
    visible: true,
    labels: {
      font: SANS11
    },
    overlay: options2.gradients ? {} : {
      gradient: "none"
    },
    area: areaSeries(),
    rangeArea: rangeAreaSeries(),
    verticalRangeArea: rangeAreaSeries(),
    bar: barSeries(),
    boxPlot: boxPlotSeries(),
    bubble: bubbleSeries(),
    bullet: bulletSeries(),
    candlestick: candlestickSeries(),
    column: columnSeries(),
    heatmap: heatmapSeries(),
    pie: pieSeries(),
    donut: donutSeries(),
    funnel: funnelSeries(),
    horizontalWaterfall: waterfallSeries(),
    line: lineSeries(),
    notes: notes(),
    ohlc: ohlcSeries(),
    radarArea: radarAreaSeries(),
    radarLine: radarLineSeries(),
    polarArea: radarAreaSeries(),
    polarLine: radarLineSeries(),
    rangeBar: rangeBarSeries(),
    rangeColumn: rangeColumnSeries(),
    scatterLine: scatterLineSeries(),
    verticalArea: areaSeries(),
    verticalBoxPlot: boxPlotSeries(),
    verticalBullet: bulletSeries(),
    verticalLine: lineSeries(),
    waterfall: waterfallSeries()
  };
};
var title = function() {
  return {
    font: SANS16
  };
};
var subtitle = function() {
  return {
    font: SANS12
  };
};
var legend = function() {
  return {
    labels: {
      font: SANS12
    }
  };
};
var baseTheme = function(options2) {
  if (options2 === void 0)
    options2 = {};
  return {
    axisDefaults: axisDefaults(),
    categoryAxis: {
      majorGridLines: {
        visible: true
      }
    },
    navigator: {
      pane: {
        height: 90,
        margin: {
          top: 10
        }
      }
    },
    seriesDefaults: seriesDefaults(options2),
    title: title(),
    subtitle: subtitle(),
    legend: legend()
  };
};

// node_modules/@progress/kendo-react-common/dist/es/contexts/ZIndexContext.js
var React2 = __toESM(require_react());
var ZIndexContext = React2.createContext(0);
ZIndexContext.displayName = "KendoReactZIndexContext";

// node_modules/@progress/kendo-react-common/dist/es/canUseDOM.js
var canUseDOM = Boolean(
  // from fbjs
  typeof window !== "undefined" && window.document && window.document.createElement
);

// node_modules/@progress/kendo-react-common/dist/es/classNames.js
var classNames = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var result = {};
  var addLeafKeys = function(arg) {
    return typeof arg === "object" ? Object.keys(arg).forEach(function(key) {
      result[key] = arg[key];
    }) : result[arg] = true;
  };
  ;
  var addKeys = function(list) {
    return list.filter(function(arg) {
      return arg !== true && !!arg;
    }).map(function(arg) {
      return Array.isArray(arg) ? addKeys(arg) : addLeafKeys(arg);
    });
  };
  ;
  addKeys(args);
  return Object.keys(result).map(function(key) {
    return result[key] && key || null;
  }).filter(function(el) {
    return el !== null;
  }).join(" ");
};

// node_modules/@progress/kendo-react-common/dist/es/validate-package.js
function validatePackage2(packageMetadata4) {
  if (typeof index_esm_exports !== "undefined") {
    validatePackage(packageMetadata4);
  } else {
    var message = "License activation failed for ".concat(packageMetadata4.name, "\n");
    message += "The @progress/kendo-licensing script is not loaded.\n";
    message += "See ".concat(packageMetadata4.licensingDocsUrl, " for more information.\n");
    console.warn(message);
  }
}

// node_modules/@progress/kendo-react-charts/dist/es/utils/main.js
function hasParent(element2, parent) {
  var current4 = element2;
  while (current4 && current4 !== parent) {
    current4 = current4.parentNode;
  }
  return current4 ? true : false;
}
function validateChildren(props, propName, componentName, childType) {
  var prop = props[propName];
  if (prop) {
    if (Array.isArray(prop)) {
      for (var _i = 0, prop_1 = prop; _i < prop_1.length; _i++) {
        var value = prop_1[_i];
        if (!value.type || value.type !== childType) {
          return new Error("".concat(componentName, " children should be Array of type ").concat(childType.displayName, "."));
        }
      }
    }
  }
  return null;
}
var toggle = function(flag) {
  return flag === void 0 ? false : !flag;
};

// node_modules/@progress/kendo-react-charts/dist/es/events/dom-events.js
var getTouch = function(domEvent) {
  return {
    x: {
      location: domEvent.pageX
    },
    y: {
      location: domEvent.pageY
    }
  };
};
var eventArgs = function(e, previousArgs) {
  var pointers = e.pointers;
  var pointer = pointers[0];
  var xLocation = pointer.pageX;
  var yLocation = pointer.pageY;
  var distance = 0;
  if (pointers.length > 1) {
    var pointer1 = pointers[0];
    var pointer2 = pointers[1];
    distance = Math.sqrt(Math.pow(pointer1.pageX - pointer2.pageX, 2) + Math.pow(pointer1.pageY - pointer2.pageY, 2));
  }
  return {
    distance,
    event: e.srcEvent,
    preventDefault: function() {
      e.preventDefault();
    },
    target: e.target,
    touches: pointers.map(getTouch),
    type: e.type,
    x: {
      delta: previousArgs ? xLocation - previousArgs.x.location : 0,
      initialDelta: e.deltaX,
      location: xLocation,
      startLocation: xLocation - e.deltaX
    },
    y: {
      delta: previousArgs ? yLocation - previousArgs.y.location : 0,
      initialDelta: e.deltaY,
      location: yLocation,
      startLocation: yLocation - e.deltaY
    }
  };
};
function shouldBindGroup(groupNames, events2) {
  for (var idx = 0; idx < groupNames.length; idx++) {
    if (events2[groupNames[idx]]) {
      return true;
    }
  }
  return false;
}
var eventGroups = [{
  end: "panend",
  move: "panmove",
  start: "panstart"
}, {
  gesturechange: "pinchmove",
  gestureend: "pinchend",
  gesturestart: "pinchstart"
}, {
  press: "press"
}, {
  tap: "tap"
}];
var DomEvents = (
  /** @class */
  function() {
    function DomEvents2(hammerInstance, events2) {
      this.hammerInstance = hammerInstance;
      this.eventHandlers = {};
      this.tap = this.tap.bind(this);
      this.press = this.press.bind(this);
      this.panstart = this.panstart.bind(this);
      this.panmove = this.panmove.bind(this);
      this.panend = this.panend.bind(this);
      this.pinchstart = this.pinchstart.bind(this);
      this.pinchmove = this.pinchmove.bind(this);
      this.pinchend = this.pinchend.bind(this);
      if (events2) {
        this.bind(events2);
      }
    }
    DomEvents2.prototype.tap = function(e) {
      this.trigger("tap", e);
    };
    DomEvents2.prototype.press = function(e) {
      this.trigger("press", e);
    };
    DomEvents2.prototype.panstart = function(e) {
      delete this.previous;
      this.previous = this.trigger("start", e);
    };
    DomEvents2.prototype.panmove = function(e) {
      this.previous = this.trigger("move", e);
    };
    DomEvents2.prototype.panend = function(e) {
      this.trigger("end", e);
      delete this.previous;
    };
    DomEvents2.prototype.pinchstart = function(e) {
      this.trigger("gesturestart", e);
    };
    DomEvents2.prototype.pinchmove = function(e) {
      this.trigger("gesturechange", e);
    };
    DomEvents2.prototype.pinchend = function(e) {
      this.trigger("gestureend", e);
    };
    DomEvents2.prototype.trigger = function(name2, e) {
      var args = eventArgs(e, this.previous);
      if (this.eventHandlers[name2]) {
        this.eventHandlers[name2](args);
      }
      return args;
    };
    DomEvents2.prototype.bind = function(events2) {
      if (events2 === void 0) {
        events2 = {};
      }
      this.unbind();
      this.eventHandlers = events2;
      for (var idx = 0; idx < eventGroups.length; idx++) {
        var eventGroup = eventGroups[idx];
        var groupNames = Object.keys(eventGroup);
        if (shouldBindGroup(groupNames, events2)) {
          for (var nameIdx = 0; nameIdx < groupNames.length; nameIdx++) {
            var name_1 = eventGroup[groupNames[nameIdx]];
            this.hammerInstance.on(name_1, this[name_1]);
          }
        }
      }
    };
    DomEvents2.prototype.unbind = function() {
      if (this.hammerInstance) {
        this.hammerInstance.off();
      }
      this.eventHandlers = {};
    };
    DomEvents2.prototype.destroy = function() {
      if (this.hammerInstance) {
        this.hammerInstance.destroy();
        delete this.hammerInstance;
      }
      delete this.eventHandlers;
    };
    DomEvents2.prototype.toggleDrag = function(enable) {
      this.toggle("pan", enable);
    };
    DomEvents2.prototype.toggleZoom = function(enable) {
      this.toggle("pinch", enable);
    };
    DomEvents2.prototype.toggle = function(recognizer, enable) {
      if (this.hammerInstance) {
        var instanceRecognizer = this.hammerInstance.get(recognizer);
        instanceRecognizer.set({
          enable
        });
      }
    };
    return DomEvents2;
  }()
);

// node_modules/@progress/kendo-react-charts/dist/es/events/dom-events-builder.js
var MISSING_HAMMER_MESSAGE = "Hammerjs is not loaded.Solution: http://www.telerik.com/kendo-react-ui/components/charts/troubleshooting/#toc-installation";
var DomEventsBuilder3 = (
  /** @class */
  function() {
    function DomEventsBuilder4() {
    }
    DomEventsBuilder4.create = function(element2, events2) {
      if (typeof window !== "undefined") {
        var HAMMER = window.Hammer;
        if (!HAMMER) {
          if (true) {
            console.warn(MISSING_HAMMER_MESSAGE);
          }
          return;
        }
        var hammerInstance = new HAMMER(element2, {
          recognizers: [
            [HAMMER.Tap],
            [HAMMER.Pan],
            [HAMMER.Pinch],
            [HAMMER.Press, { time: 0 }]
          ]
        });
        return new DomEvents(hammerInstance, events2);
      }
    };
    return DomEventsBuilder4;
  }()
);

// node_modules/@progress/kendo-react-charts/dist/es/events/base-event.js
var BaseEvent = (
  /** @class */
  function() {
    function BaseEvent2(target) {
      this.target = target;
    }
    return BaseEvent2;
  }()
);

// node_modules/@progress/kendo-react-charts/dist/es/events/axis-label-click-event.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var AxisLabelClickEvent = (
  /** @class */
  function(_super) {
    __extends(AxisLabelClickEvent2, _super);
    function AxisLabelClickEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axis = e.axis;
      _this.dataItem = e.dataItem;
      _this.index = e.index;
      _this.text = e.text;
      _this.value = e.value;
      return _this;
    }
    return AxisLabelClickEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/preventable-event.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PreventableEvent = (
  /** @class */
  function(_super) {
    __extends2(PreventableEvent2, _super);
    function PreventableEvent2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.prevented = false;
      return _this;
    }
    PreventableEvent2.prototype.preventDefault = function() {
      this.prevented = true;
    };
    PreventableEvent2.prototype.isDefaultPrevented = function() {
      return this.prevented;
    };
    return PreventableEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/drag-event.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragEvent = (
  /** @class */
  function(_super) {
    __extends3(DragEvent2, _super);
    function DragEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axisRanges = e.axisRanges;
      _this.nativeEvent = e.originalEvent;
      return _this;
    }
    return DragEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/drag-end-event.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragEndEvent = (
  /** @class */
  function(_super) {
    __extends4(DragEndEvent2, _super);
    function DragEndEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axisRanges = e.axisRanges;
      _this.nativeEvent = e.originalEvent;
      return _this;
    }
    return DragEndEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/drag-start-event.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DragStartEvent = (
  /** @class */
  function(_super) {
    __extends5(DragStartEvent2, _super);
    function DragStartEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axisRanges = e.axisRanges;
      _this.nativeEvent = e.originalEvent;
      return _this;
    }
    return DragStartEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/legend-item-hover-event.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LegendItemHoverEvent = (
  /** @class */
  function(_super) {
    __extends6(LegendItemHoverEvent2, _super);
    function LegendItemHoverEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.series = e.series;
      _this.seriesIndex = e.seriesIndex;
      _this.pointIndex = e.pointIndex;
      _this.text = e.text;
      return _this;
    }
    LegendItemHoverEvent2.prototype.preventDefault = function() {
      _super.prototype.preventDefault.call(this);
    };
    return LegendItemHoverEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/legend-item-click-event.js
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LegendItemClickEvent = (
  /** @class */
  function(_super) {
    __extends7(LegendItemClickEvent2, _super);
    function LegendItemClickEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.series = e.series;
      _this.seriesIndex = e.seriesIndex;
      _this.pointIndex = e.pointIndex;
      _this.text = e.text;
      return _this;
    }
    LegendItemClickEvent2.prototype.preventDefault = function() {
      _super.prototype.preventDefault.call(this);
    };
    return LegendItemClickEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/legend-item-leave-event.js
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var LegendItemLeaveEvent = (
  /** @class */
  function(_super) {
    __extends8(LegendItemLeaveEvent2, _super);
    function LegendItemLeaveEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.series = e.series;
      _this.seriesIndex = e.seriesIndex;
      _this.pointIndex = e.pointIndex;
      _this.text = e.text;
      return _this;
    }
    LegendItemLeaveEvent2.prototype.preventDefault = function() {
      _super.prototype.preventDefault.call(this);
    };
    return LegendItemLeaveEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/navigator-filter-event.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NavigatorFilterEvent = (
  /** @class */
  function(_super) {
    __extends9(NavigatorFilterEvent2, _super);
    function NavigatorFilterEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.from = e.from;
      _this.to = e.to;
      return _this;
    }
    return NavigatorFilterEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/note-click-event.js
var __extends10 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NoteClickEvent = (
  /** @class */
  function(_super) {
    __extends10(NoteClickEvent2, _super);
    function NoteClickEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.category = e.category;
      _this.dataItem = e.dataItem;
      _this.series = e.series;
      _this.value = e.value;
      _this.visual = e.visual;
      return _this;
    }
    return NoteClickEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/note-hover-event.js
var __extends11 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NoteHoverEvent = (
  /** @class */
  function(_super) {
    __extends11(NoteHoverEvent2, _super);
    function NoteHoverEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.category = e.category;
      _this.dataItem = e.dataItem;
      _this.series = e.series;
      _this.value = e.value;
      _this.visual = e.visual;
      return _this;
    }
    return NoteHoverEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/plot-area-click-event.js
var __extends12 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PlotAreaClickEvent = (
  /** @class */
  function(_super) {
    __extends12(PlotAreaClickEvent2, _super);
    function PlotAreaClickEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.category = e.category;
      _this.nativeEvent = e.originalEvent;
      _this.value = e.value;
      _this.x = e.x;
      _this.y = e.y;
      return _this;
    }
    return PlotAreaClickEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/plot-area-hover-event.js
var __extends13 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var PlotAreaHoverEvent = (
  /** @class */
  function(_super) {
    __extends13(PlotAreaHoverEvent2, _super);
    function PlotAreaHoverEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.category = e.category;
      _this.nativeEvent = e.originalEvent;
      _this.value = e.value;
      _this.x = e.x;
      _this.y = e.y;
      return _this;
    }
    return PlotAreaHoverEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/render-event.js
var __extends14 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var RenderEvent = (
  /** @class */
  function(_super) {
    __extends14(RenderEvent2, _super);
    function RenderEvent2(_e, sender) {
      return _super.call(this, sender) || this;
    }
    return RenderEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/select-event.js
var __extends15 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SelectEvent = (
  /** @class */
  function(_super) {
    __extends15(SelectEvent2, _super);
    function SelectEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axis = e.axis;
      _this.from = e.from;
      _this.to = e.to;
      return _this;
    }
    return SelectEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/select-end-event.js
var __extends16 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SelectEndEvent = (
  /** @class */
  function(_super) {
    __extends16(SelectEndEvent2, _super);
    function SelectEndEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axis = e.axis;
      _this.from = e.from;
      _this.to = e.to;
      return _this;
    }
    return SelectEndEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/select-start-event.js
var __extends17 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SelectStartEvent = (
  /** @class */
  function(_super) {
    __extends17(SelectStartEvent2, _super);
    function SelectStartEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axis = e.axis;
      _this.from = e.from;
      _this.to = e.to;
      return _this;
    }
    return SelectStartEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/series-click-event.js
var __extends18 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SeriesClickEvent = (
  /** @class */
  function(_super) {
    __extends18(SeriesClickEvent2, _super);
    function SeriesClickEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.category = e.category;
      _this.dataItem = e.dataItem;
      _this.nativeEvent = e.originalEvent;
      _this.percentage = e.percentage;
      _this.point = e.point;
      _this.series = e.series;
      _this.stackValue = e.stackValue;
      _this.value = e.value;
      return _this;
    }
    return SeriesClickEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/series-hover-event.js
var __extends19 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SeriesHoverEvent = (
  /** @class */
  function(_super) {
    __extends19(SeriesHoverEvent2, _super);
    function SeriesHoverEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.category = e.category;
      _this.categoryPoints = e.categoryPoints;
      _this.dataItem = e.dataItem;
      _this.nativeEvent = e.originalEvent;
      _this.percentage = e.percentage;
      _this.point = e.point;
      _this.series = e.series;
      _this.stackValue = e.stackValue;
      _this.value = e.value;
      return _this;
    }
    return SeriesHoverEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/zoom-event.js
var __extends20 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ZoomEvent = (
  /** @class */
  function(_super) {
    __extends20(ZoomEvent2, _super);
    function ZoomEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axisRanges = e.axisRanges;
      _this.delta = e.delta;
      _this.nativeEvent = e.originalEvent;
      return _this;
    }
    return ZoomEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/zoom-end-event.js
var __extends21 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ZoomEndEvent = (
  /** @class */
  function(_super) {
    __extends21(ZoomEndEvent2, _super);
    function ZoomEndEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axisRanges = e.axisRanges;
      _this.nativeEvent = e.originalEvent;
      return _this;
    }
    return ZoomEndEvent2;
  }(BaseEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/zoom-start-event.js
var __extends22 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ZoomStartEvent = (
  /** @class */
  function(_super) {
    __extends22(ZoomStartEvent2, _super);
    function ZoomStartEvent2(e, target) {
      var _this = _super.call(this, target) || this;
      _this.axisRanges = e.axisRanges;
      _this.nativeEvent = e.originalEvent;
      return _this;
    }
    return ZoomStartEvent2;
  }(PreventableEvent)
);

// node_modules/@progress/kendo-react-charts/dist/es/events/chart-event-builder.js
var EVENT_MAP = {
  axisLabelClick: AxisLabelClickEvent,
  drag: DragEvent,
  dragEnd: DragEndEvent,
  dragStart: DragStartEvent,
  legendItemHover: LegendItemHoverEvent,
  legendItemClick: LegendItemClickEvent,
  legendItemLeave: LegendItemLeaveEvent,
  navigatorFilter: NavigatorFilterEvent,
  noteClick: NoteClickEvent,
  noteHover: NoteHoverEvent,
  plotAreaClick: PlotAreaClickEvent,
  plotAreaHover: PlotAreaHoverEvent,
  render: RenderEvent,
  select: SelectEvent,
  selectEnd: SelectEndEvent,
  selectStart: SelectStartEvent,
  seriesClick: SeriesClickEvent,
  seriesHover: SeriesHoverEvent,
  zoom: ZoomEvent,
  zoomEnd: ZoomEndEvent,
  zoomStart: ZoomStartEvent
};
function create2(name2, args, sender) {
  if (EVENT_MAP[name2]) {
    return new EVENT_MAP[name2](args, sender);
  }
}

// node_modules/@progress/kendo-react-charts/dist/es/events/dom-event.js
var DomEvent = (
  /** @class */
  function() {
    function DomEvent2(sender, e) {
      this.sender = sender;
      this.syntheticEvent = e;
    }
    return DomEvent2;
  }()
);
function toDomEvent(sender, e) {
  return new DomEvent(sender, e);
}

// node_modules/@progress/kendo-react-charts/dist/es/theming/theme-service.js
var font = function(style) {
  return "".concat(style.fontWeight, " ").concat(style.fontSize, " ").concat(style.fontFamily);
};
var computedBackgroundColor = function(element2) {
  return window.getComputedStyle(element2).backgroundColor;
};
var letterPos = function(letter) {
  return letter.toLowerCase().charCodeAt(0) - "a".charCodeAt(0);
};
var seriesPos = function(name2) {
  var alpha = name2.match(/series-([a-z])$/);
  if (alpha !== null) {
    return letterPos(alpha[1]);
  }
  var num = name2.split("--series-")[1];
  return parseInt(num, 10) - 1;
};
var SERIES_COLORS = 30;
var seriesTemplate = function() {
  var result = '\n      <div class="k-var--series-a"></div>\n      <div class="k-var--series-b"></div>\n      <div class="k-var--series-c"></div>\n      <div class="k-var--series-d"></div>\n      <div class="k-var--series-e"></div>\n      <div class="k-var--series-f"></div>\n';
  for (var i = 0; i < SERIES_COLORS; i++) {
    result += '\n      <div class="k-var--series-'.concat(i + 1, '"></div>');
  }
  return result;
};
var template2 = '\n    <div class="k-var--primary"></div>\n    <div class="k-var--base"></div>\n    <div class="k-var--background"></div>\n\n    <div class="k-var--normal-background"></div>\n    <div class="k-var--normal-text-color"></div>\n    <div class="k-var--hover-background"></div>\n    <div class="k-var--hover-text-color"></div>\n    <div class="k-var--selected-background"></div>\n    <div class="k-var--selected-text-color"></div>\n    <div class="k-var--chart-error-bars-background"></div>\n    <div class="k-var--chart-notes-background"></div>\n    <div class="k-var--chart-notes-border"></div>\n    <div class="k-var--chart-notes-lines"></div>\n    <div class="k-var--chart-crosshair-background"></div>\n\n    <div class="k-var--chart-inactive"></div>\n    <div class="k-var--chart-major-lines"></div>\n    <div class="k-var--chart-minor-lines"></div>\n    <div class="k-var--chart-area-opacity"></div>\n    <div class="k-var--chart-area-inactive-opacity"></div>\n    <div class="k-var--chart-line-inactive-opacity"></div>\n\n    <div class="k-widget k-chart">\n        <div class="k-var--chart-font"></div>\n        <div class="k-var--chart-title-font"></div>\n        <div class="k-var--chart-pane-title-font"></div>\n        <div class="k-var--chart-label-font"></div>\n    </div>\n\n    <div class="k-var--series-unset"></div>\n    <div class="k-var--series">\n      '.concat(seriesTemplate(), "\n    </div>\n");
var ThemeService = (
  /** @class */
  function() {
    function ThemeService2(store) {
      this.store = store;
    }
    ThemeService2.prototype.setStyle = function(field, value) {
      this.store.dispatch({ type: "set", payload: { field, value } });
    };
    ThemeService2.prototype.setColors = function() {
      this.mapColor("axisDefaults.crosshair.color", "chart-crosshair-background");
      this.mapColor("axisDefaults.labels.color", "normal-text-color");
      this.mapColor("axisDefaults.line.color", "chart-major-lines");
      this.mapColor("axisDefaults.majorGridLines.color", "chart-major-lines");
      this.mapColor("axisDefaults.minorGridLines.color", "chart-minor-lines");
      this.mapColor("axisDefaults.notes.icon.background", "chart-notes-background");
      this.mapColor("axisDefaults.notes.icon.border.color", "chart-notes-border");
      this.mapColor("axisDefaults.notes.line.color", "chart-notes-lines");
      this.mapColor("axisDefaults.title.color", "normal-text-color");
      this.mapColor("chartArea.background", "background");
      this.mapColor("legend.inactiveItems.labels.color", "chart-inactive");
      this.mapColor("legend.inactiveItems.markers.color", "chart-inactive");
      this.mapColor("legend.labels.color", "normal-text-color");
      this.mapColor("seriesDefaults.boxPlot.downColor", "chart-major-lines");
      this.mapColor("seriesDefaults.boxPlot.mean.color", "base");
      this.mapColor("seriesDefaults.boxPlot.median.color", "base");
      this.mapColor("seriesDefaults.boxPlot.whiskers.color", "primary");
      this.mapColor("seriesDefaults.bullet.target.color", "normal-text-color");
      this.mapColor("seriesDefaults.candlestick.downColor", "normal-text-color");
      this.mapColor("seriesDefaults.candlestick.line.color", "normal-text-color");
      this.mapColor("seriesDefaults.errorBars.color", "chart-error-bars-background");
      this.mapColor("seriesDefaults.horizontalWaterfall.line.color", "chart-major-lines");
      this.mapColor("seriesDefaults.icon.border.color", "chart-major-lines");
      this.mapColor("seriesDefaults.labels.background", "background");
      this.mapColor("seriesDefaults.labels.color", "normal-text-color");
      this.mapColor("seriesDefaults.notes.icon.background", "chart-notes-background");
      this.mapColor("seriesDefaults.notes.icon.border.color", "chart-notes-border");
      this.mapColor("seriesDefaults.notes.line.color", "chart-notes-lines");
      this.mapColor("seriesDefaults.verticalBoxPlot.downColor", "chart-major-lines");
      this.mapColor("seriesDefaults.verticalBoxPlot.mean.color", "base");
      this.mapColor("seriesDefaults.verticalBoxPlot.median.color", "base");
      this.mapColor("seriesDefaults.verticalBoxPlot.whiskers.color", "primary");
      this.mapColor("seriesDefaults.verticalBullet.target.color", "normal-text-color");
      this.mapColor("seriesDefaults.waterfall.line.color", "chart-major-lines");
      this.mapColor("title.color", "normal-text-color");
      this.mapColor("subtitle.color", "normal-text-color");
      var opacity = parseFloat(this.queryStyle("chart-area-opacity").opacity);
      if (!isNaN(opacity)) {
        this.setStyle("seriesDefaults.area.opacity", opacity);
        this.setStyle("seriesDefaults.radarArea.opacity", opacity);
        this.setStyle("seriesDefaults.verticalArea.opacity", opacity);
        this.setStyle("seriesDefaults.labels.opacity", opacity);
      }
      this.setInactiveOpacity(["area", "verticalArea"], "chart-area-inactive-opacity");
      this.setInactiveOpacity(["line", "verticalLine"], "chart-line-inactive-opacity");
    };
    ThemeService2.prototype.setFonts = function() {
      var defaultFont = font(this.queryStyle("chart-font"));
      var titleFont = font(this.queryStyle("chart-title-font"));
      var paneTitleFont = font(this.queryStyle("chart-pane-title-font"));
      var labelFont = font(this.queryStyle("chart-label-font"));
      this.setStyle("axisDefaults.labels.font", labelFont);
      this.setStyle("axisDefaults.notes.label.font", defaultFont);
      this.setStyle("axisDefaults.title.font", defaultFont);
      this.setStyle("legend.labels.font", defaultFont);
      this.setStyle("seriesDefaults.labels.font", labelFont);
      this.setStyle("seriesDefaults.notes.label.font", defaultFont);
      this.setStyle("title.font", titleFont);
      this.setStyle("subtitle.font", paneTitleFont);
      this.setStyle("paneDefaults.title.font", paneTitleFont);
    };
    ThemeService2.prototype.setSeriesColors = function() {
      var element2 = this.element;
      var series = [].slice.call(element2.querySelectorAll(".k-var--series div"));
      var unsetColor = computedBackgroundColor(element2.querySelector(".k-var--series-unset"));
      var seriesColors = series.reduce(
        function(arr, el) {
          var pos = seriesPos(el.className);
          var color = computedBackgroundColor(el);
          if (color !== unsetColor) {
            arr[pos] = color;
          }
          return arr;
        },
        []
        // Will populate the series colors in this array
      );
      this.setStyle("seriesColors", seriesColors);
    };
    ThemeService2.prototype.mapColor = function(key, varName) {
      this.setStyle(key, this.queryStyle(varName).backgroundColor);
    };
    ThemeService2.prototype.queryStyle = function(varName) {
      var element2 = this.element;
      return window.getComputedStyle(element2.querySelector(".k-var--".concat(varName)));
    };
    ThemeService2.prototype.setInactiveOpacity = function(seriesTypes, selector) {
      var _this = this;
      var inactiveOpacity = parseFloat(this.queryStyle(selector).opacity);
      if (!isNaN(inactiveOpacity) && inactiveOpacity < 1) {
        seriesTypes.forEach(function(type) {
          return _this.setStyle("seriesDefaults.".concat(type, ".highlight.inactiveOpacity"), inactiveOpacity);
        });
      }
    };
    return ThemeService2;
  }()
);
var loadTheme = function(store, done, doc) {
  var service = new ThemeService(store);
  if (typeof doc === "undefined") {
    store.dispatch({ type: "push", payload: baseTheme() });
    return;
  }
  var container = service.element = doc.createElement("div");
  container.style.display = "none";
  container.innerHTML = template2;
  doc.body.appendChild(container);
  try {
    store.dispatch({ type: "push", payload: baseTheme() });
    service.setColors();
    service.setFonts();
    service.setSeriesColors();
  } finally {
    doc.body.removeChild(service.element);
    delete service.element;
    done();
  }
};

// node_modules/@progress/kendo-react-charts/dist/es/store/store.js
var THROTTLE_MS = 1e3 / 60;
var createStore = function(reducer) {
  var state;
  var timerId;
  var listeners = [];
  var getState = function() {
    return state;
  };
  var dispatch = function(action) {
    state = reducer(state, action);
    if (canUseDOM) {
      window.clearTimeout(timerId);
      timerId = window.setTimeout(function() {
        return listeners.forEach(function(l) {
          return l();
        });
      }, THROTTLE_MS);
    }
  };
  var subscribe = function(listener) {
    listeners.push(listener);
    return function() {
      return listeners = listeners.filter(function(l) {
        return l !== listener;
      });
    };
  };
  dispatch({});
  return { getState, dispatch, subscribe };
};
var store_default = createStore;

// node_modules/@progress/kendo-react-charts/dist/es/store/reducer.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var optionsReducer = function(currentState, action) {
  if (action.chartCollectionIdxKey) {
    return reducers.collectionConfigurationItem(currentState, action);
  } else if (action.chartKey) {
    return reducers.configurationItem(currentState, action);
  } else {
    return {};
  }
};
var themeReducer = function(currentState, action) {
  if (action.type) {
    switch (action.type) {
      case "set":
        return reducers.themeItem(currentState, action);
      case "push":
        return Object.assign(currentState, action.payload);
      default:
        return currentState;
    }
  } else {
    return {};
  }
};
var observersReducer = function(currentState, action) {
  if (action.type) {
    switch (action.type) {
      case "add":
        return __spreadArray(__spreadArray([], currentState, true), [action.payload], false);
      case "remove":
        return currentState.filter(function(element2) {
          return element2 !== action.payload;
        });
      default:
        return currentState;
    }
  } else {
    return [];
  }
};
var reducers = {
  configurationItem: function(currentState, action) {
    var _a;
    return Object.assign(currentState, (_a = {}, _a[action.chartKey] = action.payload, _a));
  },
  collectionConfigurationItem: function(currentState, action) {
    var _a;
    var inCollection = false;
    var _b = action.chartCollectionIdxKey.split("_"), collectionName = _b[0], collectionIdx = _b[1];
    var collection = currentState[collectionName].map(function(item, index) {
      if (parseInt(collectionIdx, 10) === index) {
        inCollection = true;
        return action.payload;
      }
      return item;
    });
    if (inCollection === false) {
      collection.splice(parseInt(collectionIdx, 10), 0, action.payload);
    }
    return Object.assign(currentState, (_a = {}, _a[collectionName] = collection, _a));
  },
  themeItem: function(currentState, action) {
    var store = {};
    var nextStore = Object.assign(store, currentState);
    var _a = action.payload, field = _a.field, value = _a.value;
    var parts = field.split(".");
    var key = parts.shift();
    while (parts.length > 0) {
      store = store[key] = store[key] || {};
      key = parts.shift();
    }
    store[key] = value;
    return nextStore;
  }
};

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/Series.js
var React8 = __toESM(require_react());

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/Point.js
var TooltipPoint = (
  /** @class */
  function() {
    function TooltipPoint2(point2, format2) {
      this.value = point2.value;
      this.category = point2.category;
      this.categoryIndex = point2.categoryIx;
      this.series = point2.series;
      this.dataItem = point2.dataItem;
      this.percentage = point2.percentage;
      this.runningTotal = point2.runningTotal;
      this.total = point2.total;
      this.low = point2.low;
      this.high = point2.high;
      this.xLow = point2.xLow;
      this.xHigh = point2.xHigh;
      this.yLow = point2.yLow;
      this.yHigh = point2.yHigh;
      this.point = point2;
      this.format = ((point2.options || {}).tooltip || {}).format || format2;
    }
    Object.defineProperty(TooltipPoint2.prototype, "formattedValue", {
      get: function() {
        return this.format ? this.point.formatValue(this.format) : String(this.value);
      },
      enumerable: false,
      configurable: true
    });
    return TooltipPoint2;
  }()
);

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/SharedTooltipContent.js
var React3 = __toESM(require_react());
var TOOLTIP_MARKER_CLASS = "k-chart-shared-tooltip-marker";
var SharedTooltipContent = function(props) {
  var categoryText = props.categoryText, colorMarker = props.colorMarker, colspan = props.colspan, nameColumn = props.nameColumn, points3 = props.points;
  var pointsMap = function(point2, idx) {
    return React3.createElement(
      "tr",
      { key: idx },
      colorMarker && React3.createElement(
        "td",
        null,
        React3.createElement("span", { className: TOOLTIP_MARKER_CLASS, style: { backgroundColor: point2.series.color } })
      ),
      nameColumn && React3.createElement("td", null, point2.series.name),
      React3.createElement("td", { dangerouslySetInnerHTML: { __html: point2.formattedValue } })
    );
  };
  return React3.createElement(
    "table",
    null,
    React3.createElement(
      "thead",
      null,
      React3.createElement(
        "tr",
        null,
        React3.createElement("th", { colSpan: colspan }, categoryText)
      )
    ),
    React3.createElement("tbody", null, points3.map(pointsMap))
  );
};

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/Popup.js
var React7 = __toESM(require_react());

// node_modules/@progress/kendo-react-popup/dist/es/Popup.js
var React5 = __toESM(require_react());

// node_modules/@progress/kendo-react-popup/dist/es/PopupWithoutContext.js
var React4 = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var PropTypes = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-popup/dist/es/animation.js
var clearSlide = function(element2) {
  element2.style.transitionDuration = "";
  Array.from(element2.classList).forEach(function(c) {
    if (c.startsWith("k-slide-")) {
      element2.classList.remove(c);
    }
  });
};
var firefox = typeof window !== "undefined" && /Firefox/.test(window.navigator.userAgent);
var slide = function(element2, direction, duration2, type, callback) {
  if (duration2 === 0) {
    return callback();
  }
  var slideClass = "k-slide-" + direction + "-" + type;
  var slideActiveClass = slideClass + "-active";
  var transitionend = function(e) {
    if (e.target === element2) {
      element2.removeEventListener("transitionend", transitionend);
      clearSlide(element2);
      if (type === "exit") {
        element2.style.display = "none";
      } else {
        element2.style.display = "";
      }
      callback();
    }
  };
  element2.addEventListener("transitionend", transitionend);
  var ownerDocument2 = element2.ownerDocument;
  if (!ownerDocument2) {
    return;
  }
  var defaultView = ownerDocument2.defaultView;
  if (!defaultView) {
    return;
  }
  var animate = function() {
    clearSlide(element2);
    element2.classList.add(slideClass);
    defaultView.requestAnimationFrame(function() {
      element2.style.transitionDuration = duration2 + "ms";
      element2.classList.add(slideActiveClass);
    });
  };
  if (firefox) {
    defaultView.requestAnimationFrame(animate);
  } else {
    animate();
  }
};

// node_modules/@progress/kendo-popup-common/dist/es/align-point.js
var align_point_default = {
  "bottom": "bottom",
  "center": "center",
  "middle": "middle",
  "left": "left",
  "right": "right",
  "top": "top"
};

// node_modules/@progress/kendo-popup-common/dist/es/align.js
var align2 = function(options2) {
  var anchorRect = options2.anchorRect;
  var anchorAlign = options2.anchorAlign;
  var elementRect = options2.elementRect;
  var elementAlign = options2.elementAlign;
  var margin = options2.margin;
  if (margin === void 0)
    margin = {};
  var anchorHorizontal = anchorAlign.horizontal;
  var anchorVertical = anchorAlign.vertical;
  var elementHorizontal = elementAlign.horizontal;
  var elementVertical = elementAlign.vertical;
  var horizontalMargin = margin.horizontal || 0;
  var verticalMargin = margin.vertical || 0;
  var top = anchorRect.top;
  var left = anchorRect.left;
  if (anchorVertical === align_point_default.bottom) {
    top += anchorRect.height;
  }
  if (anchorVertical === align_point_default.center || anchorVertical === align_point_default.middle) {
    top += Math.round(anchorRect.height / 2);
  }
  if (elementVertical === align_point_default.bottom) {
    top -= elementRect.height;
    verticalMargin *= -1;
  }
  if (elementVertical === align_point_default.center || elementVertical === align_point_default.middle) {
    top -= Math.round(elementRect.height / 2);
    verticalMargin *= -1;
  }
  if (anchorHorizontal === align_point_default.right) {
    left += anchorRect.width;
  }
  if (anchorHorizontal === align_point_default.center || anchorHorizontal === align_point_default.middle) {
    left += Math.round(anchorRect.width / 2);
  }
  if (elementHorizontal === align_point_default.right) {
    left -= elementRect.width;
    horizontalMargin *= -1;
  }
  if (elementHorizontal === align_point_default.center || elementHorizontal === align_point_default.middle) {
    left -= Math.round(elementRect.width / 2);
    horizontalMargin *= -1;
  }
  return {
    top: top + verticalMargin,
    left: left + horizontalMargin
  };
};
var align_default = align2;

// node_modules/@progress/kendo-popup-common/dist/es/add-scroll.js
function addScroll(rect, scroll) {
  return {
    top: rect.top + scroll.y,
    left: rect.left + scroll.x,
    height: rect.height,
    width: rect.width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/owner-document.js
function ownerDocument(element2) {
  return element2.ownerDocument || element2.document || element2;
}

// node_modules/@progress/kendo-popup-common/dist/es/window.js
var getWindow = function(element2) {
  return ownerDocument(element2).defaultView;
};
var window_default = getWindow;

// node_modules/@progress/kendo-popup-common/dist/es/document.js
var getDocument = function(element2) {
  return ownerDocument(element2).documentElement;
};
var document_default = getDocument;

// node_modules/@progress/kendo-popup-common/dist/es/scrollbar-width.js
var cachedWidth = 0;
function scrollbarWidth() {
  if (!cachedWidth && typeof document !== "undefined") {
    var div = document.createElement("div");
    div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
    div.innerHTML = "&nbsp;";
    document.body.appendChild(div);
    cachedWidth = div.offsetWidth - div.scrollWidth;
    document.body.removeChild(div);
  }
  return cachedWidth;
}

// node_modules/@progress/kendo-popup-common/dist/es/window-viewport.js
function windowViewport(element2) {
  var win = window_default(element2);
  var document2 = document_default(element2);
  var result = {
    height: win.innerHeight,
    width: win.innerWidth
  };
  if (document2.scrollHeight - document2.clientHeight > 0) {
    result.width -= scrollbarWidth();
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/bounding-offset.js
var boundingOffset = function(element2) {
  if (!element2.getBoundingClientRect) {
    var viewport = windowViewport(element2);
    return {
      bottom: viewport.height,
      left: 0,
      right: viewport.width,
      top: 0
    };
  }
  var ref2 = element2.getBoundingClientRect();
  var bottom = ref2.bottom;
  var left = ref2.left;
  var right = ref2.right;
  var top = ref2.top;
  return {
    bottom,
    left,
    right,
    top
  };
};
var bounding_offset_default = boundingOffset;

// node_modules/@progress/kendo-popup-common/dist/es/offset-parent.js
var offsetParent = function(element2) {
  var offsetParent2 = element2.offsetParent;
  while (offsetParent2 && offsetParent2.style.position === "static") {
    offsetParent2 = offsetParent2.offsetParent;
  }
  return offsetParent2 || document_default(element2);
};
var offset_parent_default = offsetParent;

// node_modules/@progress/kendo-popup-common/dist/es/offset.js
var rectOfHiddenElement = function(element2) {
  var ref2 = element2.style;
  var display = ref2.display;
  var left = ref2.left;
  var position3 = ref2.position;
  element2.style.display = "";
  element2.style.left = "-10000px";
  element2.style.position = "absolute";
  var rect = element2.getBoundingClientRect();
  element2.style.display = display;
  element2.style.left = left;
  element2.style.position = position3;
  return rect;
};
var offset = function(element2) {
  var rect = element2.getBoundingClientRect();
  var left = rect.left;
  var top = rect.top;
  if (!rect.height && !rect.width) {
    rect = rectOfHiddenElement(element2);
  }
  return {
    top,
    left,
    height: rect.height,
    width: rect.width
  };
};
var offset_default = offset;

// node_modules/@progress/kendo-popup-common/dist/es/parents.js
function parents_default(element2, until) {
  var result = [];
  var next = element2.parentNode;
  while (next) {
    result.push(next);
    if (next === until) {
      break;
    }
    next = next.parentNode;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/scroll-position.js
function scrollPosition(element2) {
  var documentElement = document_default(element2);
  var win = window_default(element2);
  return {
    x: win.pageXOffset || documentElement.scrollLeft || 0,
    y: win.pageYOffset || documentElement.scrollTop || 0
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/element-scroll-position.js
function element_scroll_position_default(element2) {
  if (element2 === (element2.ownerDocument || {}).body) {
    return scrollPosition(element2);
  }
  return {
    x: element2.scrollLeft,
    y: element2.scrollTop
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/parent-scroll-position.js
function parentScrollPosition(element2) {
  var parent = offset_parent_default(element2);
  return parent ? element_scroll_position_default(parent) : { x: 0, y: 0 };
}

// node_modules/@progress/kendo-popup-common/dist/es/position.js
var position = function(element2, parent) {
  var win = window_default(element2);
  var elementStyles3 = win.getComputedStyle(element2);
  var offset3 = offset_default(element2);
  var parentElement = parent || offset_parent_default(element2);
  var ownerDocument2 = element2.ownerDocument;
  var useRelative = parentElement !== ownerDocument2.body && parentElement !== ownerDocument2.documentElement;
  var parentOffset = { top: 0, left: 0 };
  if (elementStyles3.position !== "fixed" && useRelative) {
    var parentStyles = win.getComputedStyle(parentElement);
    parentOffset = offset_default(parentElement);
    parentOffset.top += parseInt(parentStyles.borderTopWidth, 10);
    parentOffset.left += parseInt(parentStyles.borderLeftWidth, 10);
  }
  return {
    top: offset3.top - parentOffset.top,
    left: offset3.left - parentOffset.left,
    height: offset3.height,
    width: offset3.width
  };
};
var position_default = position;

// node_modules/@progress/kendo-popup-common/dist/es/offset-parent-scroll-position.js
function offset_parent_scroll_position_default(offsetParentElement, element2) {
  return (
    // eslint-disable-line no-arrow-condition
    offsetParentElement ? element_scroll_position_default(offsetParentElement) : parentScrollPosition(element2)
  );
}

// node_modules/@progress/kendo-popup-common/dist/es/position-with-scroll.js
function position_with_scroll_default(element2, parent, scale) {
  if (scale === void 0)
    scale = 1;
  var offsetParentElement = parent ? offset_parent_default(parent) : null;
  var ref2 = position_default(element2, offsetParentElement);
  var top = ref2.top;
  var left = ref2.left;
  var height = ref2.height;
  var width = ref2.width;
  var ref$1 = offset_parent_scroll_position_default(offsetParentElement, element2);
  var x = ref$1.x;
  var y = ref$1.y;
  var ownerDocument2 = element2.ownerDocument;
  var positionScale = offsetParentElement === ownerDocument2.body || offsetParentElement === ownerDocument2.documentElement ? 1 : scale;
  return {
    top: top + y * positionScale,
    left: left + x * positionScale,
    height,
    width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/remove-scroll.js
function removeScroll(rect, scroll) {
  return {
    top: rect.top - scroll.y,
    left: rect.left - scroll.x,
    height: rect.height,
    width: rect.width
  };
}

// node_modules/@progress/kendo-popup-common/dist/es/collision.js
var collision_default = {
  "fit": "fit",
  "flip": "flip",
  "none": "none"
};

// node_modules/@progress/kendo-popup-common/dist/es/restrict-to-view.js
var fit2 = function(position3, size, viewPortSize) {
  var output = 0;
  if (position3 + size > viewPortSize) {
    output = viewPortSize - (position3 + size);
  }
  if (position3 < 0) {
    output = -position3;
  }
  return output;
};
var flip = function(ref2) {
  var offset3 = ref2.offset;
  var size = ref2.size;
  var anchorSize = ref2.anchorSize;
  var viewPortSize = ref2.viewPortSize;
  var anchorAlignPoint = ref2.anchorAlignPoint;
  var elementAlignPoint = ref2.elementAlignPoint;
  var margin = ref2.margin;
  var output = 0;
  var isPositionCentered = elementAlignPoint === align_point_default.center || elementAlignPoint === align_point_default.middle;
  var isOriginCentered = anchorAlignPoint === align_point_default.center || anchorAlignPoint === align_point_default.middle;
  var marginToAdd = 2 * margin;
  if (elementAlignPoint !== anchorAlignPoint && !isPositionCentered && !isOriginCentered) {
    var isBeforeAnchor = anchorAlignPoint === align_point_default.top || anchorAlignPoint === align_point_default.left;
    if (offset3 < 0 && isBeforeAnchor) {
      output = size + anchorSize + marginToAdd;
      if (offset3 + output + size > viewPortSize) {
        output = 0;
      }
    } else if (offset3 >= 0 && !isBeforeAnchor) {
      if (offset3 + size > viewPortSize) {
        output += -(anchorSize + size + marginToAdd);
      }
      if (offset3 + output < 0) {
        output = 0;
      }
    }
  }
  return output;
};
var restrictToView = function(options2) {
  var anchorRect = options2.anchorRect;
  var anchorAlign = options2.anchorAlign;
  var elementRect = options2.elementRect;
  var elementAlign = options2.elementAlign;
  var collisions = options2.collisions;
  var viewPort = options2.viewPort;
  var margin = options2.margin;
  if (margin === void 0)
    margin = {};
  var elementTop = elementRect.top;
  var elementLeft = elementRect.left;
  var elementHeight = elementRect.height;
  var elementWidth = elementRect.width;
  var viewPortHeight = viewPort.height;
  var viewPortWidth = viewPort.width;
  var horizontalMargin = margin.horizontal || 0;
  var verticalMargin = margin.vertical || 0;
  var left = 0;
  var top = 0;
  var isVerticalFit = collisions.vertical === collision_default.fit;
  var isHorizontalFit = collisions.horizontal === collision_default.fit;
  var isVerticalFlip = collisions.vertical === collision_default.flip;
  var isHorizontalFlip = collisions.horizontal === collision_default.flip;
  if (isVerticalFit) {
    top += fit2(elementTop, elementHeight, viewPortHeight);
  }
  if (isHorizontalFit) {
    left += fit2(elementLeft, elementWidth, viewPortWidth);
  }
  if (isVerticalFlip) {
    top += flip({
      margin: verticalMargin,
      offset: elementTop,
      size: elementHeight,
      anchorSize: anchorRect.height,
      viewPortSize: viewPortHeight,
      anchorAlignPoint: anchorAlign.vertical,
      elementAlignPoint: elementAlign.vertical
    });
  }
  if (isHorizontalFlip) {
    left += flip({
      margin: horizontalMargin,
      offset: elementLeft,
      size: elementWidth,
      anchorSize: anchorRect.width,
      viewPortSize: viewPortWidth,
      anchorAlignPoint: anchorAlign.horizontal,
      elementAlignPoint: elementAlign.horizontal
    });
  }
  var flippedVertical = isVerticalFlip && top !== 0;
  var flippedHorizontal = isHorizontalFlip && left !== 0;
  var fittedVertical = isVerticalFit && top !== 0;
  var fittedHorizontal = isHorizontalFit && left !== 0;
  return {
    flipped: flippedHorizontal || flippedVertical,
    fitted: fittedVertical || fittedHorizontal,
    flip: {
      horizontal: flippedHorizontal,
      vertical: flippedVertical
    },
    fit: {
      horizontal: fittedHorizontal,
      vertical: fittedVertical
    },
    offset: {
      left,
      top
    }
  };
};
var restrict_to_view_default = restrictToView;

// node_modules/@progress/kendo-popup-common/dist/es/siblings.js
function siblings_default(element2) {
  var result = [];
  var sibling = element2.parentNode.firstElementChild;
  while (sibling) {
    if (sibling !== element2) {
      result.push(sibling);
    }
    sibling = sibling.nextElementSibling;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/sibling-container.js
function sibling_container_default(anchor, container) {
  var parentElements = parents_default(anchor);
  var containerElement = container;
  var siblingElements;
  var result;
  while (containerElement) {
    siblingElements = siblings_default(containerElement);
    result = parentElements.reduce(
      function(list, p) {
        return list.concat(siblingElements.filter(function(s) {
          return s === p;
        }));
      },
      []
    )[0];
    if (result) {
      break;
    }
    containerElement = containerElement.parentElement;
  }
  return result;
}

// node_modules/@progress/kendo-popup-common/dist/es/utils.js
var eitherRect = function(rect, offset3) {
  if (!rect) {
    return { height: 0, left: offset3.left, top: offset3.top, width: 0 };
  }
  return rect;
};
var scaleRect = function(rect, scale) {
  if (!rect || scale === 1) {
    return rect;
  }
  return {
    height: rect.height / scale,
    left: rect.left / scale,
    top: rect.top / scale,
    width: rect.width / scale
  };
};
var removeStackingOffset = function(rect, stackingOffset) {
  if (!stackingOffset) {
    return rect;
  }
  var result = {
    height: rect.height,
    left: rect.left - stackingOffset.left,
    top: rect.top - stackingOffset.top,
    width: rect.width
  };
  return result;
};
function memoize(fun) {
  var result;
  var called = false;
  return function() {
    var args = [], len = arguments.length;
    while (len--)
      args[len] = arguments[len];
    if (called) {
      return result;
    }
    result = fun.apply(void 0, args);
    called = true;
    return result;
  };
}
var hasRelativeStackingContext = memoize(function(elementSource) {
  if (!canUseDOM2()) {
    return false;
  }
  var currentDocument = elementSource ? elementSource.ownerDocument : document;
  if (!currentDocument || !currentDocument.body) {
    return false;
  }
  var top = 10;
  var parent = currentDocument.createElement("div");
  parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  parent.innerHTML = '<div style="position: fixed; top: ' + top + 'px;">child</div>';
  currentDocument.body.appendChild(parent);
  var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
  currentDocument.body.removeChild(parent);
  return isDifferent;
});
var canUseDOM2 = function() {
  return Boolean(
    // from fbjs
    typeof window !== "undefined" && window.document && window.document.createElement
  );
};
var utils = {
  eitherRect,
  scaleRect,
  removeStackingOffset,
  hasRelativeStackingContext,
  canUseDOM: canUseDOM2
};
var utils_default = utils;

// node_modules/@progress/kendo-popup-common/dist/es/dom-utils.js
var STYLES = [
  "font-size",
  "font-family",
  "font-stretch",
  "font-style",
  "font-weight",
  "line-height"
];
var addOffset = function(current4, addition) {
  return {
    left: current4.left + addition.left,
    top: current4.top + addition.top
  };
};
var getWindow2 = function() {
  return utils_default.canUseDOM() ? window : null;
};
var getFontStyles = function(el) {
  var window2 = getWindow2();
  if (!window2 || !el) {
    return [];
  }
  var computedStyles = window2.getComputedStyle(el);
  return STYLES.map(function(font2) {
    return { key: font2, value: computedStyles[font2] };
  });
};
var hasOffsetParent = function(el) {
  if (!el) {
    return false;
  }
  return Boolean(el.offsetParent);
};
var offset2 = function(el) {
  if (!el) {
    return null;
  }
  return offset_default(el);
};
var offsetAtPoint = function(element2, currentLocation) {
  if (!element2) {
    return null;
  }
  var ref2 = element2.style;
  var left = ref2.left;
  var top = ref2.top;
  var transition = ref2.transition;
  element2.style.transition = "none";
  element2.style.left = currentLocation.left + "px";
  element2.style.top = currentLocation.top + "px";
  var currentOffset = offset_default(element2);
  element2.style.left = left;
  element2.style.top = top;
  element2.offsetHeight;
  element2.style.transition = transition;
  return currentOffset;
};
var position2 = function(element2, popupElement, scale) {
  if (!element2 || !popupElement) {
    return null;
  }
  var currentScale = scale || 1;
  return position_with_scroll_default(element2, popupElement, currentScale);
};
var OVERFLOW_REGEXP = /auto|scroll/;
var overflowElementStyle = function(element2) {
  return "" + element2.style.overflow + element2.style.overflowX + element2.style.overflowY;
};
var overflowComputedStyle = function(element2) {
  var styles = window.getComputedStyle(element2);
  return "" + styles.overflow + styles.overflowX + styles.overflowY;
};
var overflowStyle = function(element2) {
  return overflowElementStyle(element2) || overflowComputedStyle(element2);
};
var scrollableParents = function(element2) {
  var parentElements = [];
  if (!utils_default.canUseDOM()) {
    return parentElements;
  }
  var parent = element2.parentElement;
  while (parent) {
    if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute("data-scrollable")) {
      parentElements.push(parent);
    }
    parent = parent.parentElement;
  }
  parentElements.push(window);
  return parentElements;
};
var getRelativeContextElement = function(el) {
  if (!el || !utils_default.hasRelativeStackingContext()) {
    return null;
  }
  var parent = el.parentElement;
  while (parent) {
    if (window.getComputedStyle(parent).transform !== "none") {
      return parent;
    }
    parent = parent.parentElement;
  }
  return null;
};
var stackingElementOffset = function(el) {
  var relativeContextElement = getRelativeContextElement(el);
  if (!relativeContextElement) {
    return null;
  }
  return offset_default(relativeContextElement);
};
var stackingElementScroll = function(el) {
  var relativeContextElement = getRelativeContextElement(el);
  if (!relativeContextElement) {
    return { x: 0, y: 0 };
  }
  return {
    x: relativeContextElement.scrollLeft,
    y: relativeContextElement.scrollTop
  };
};
var stackingElementViewPort = function(el) {
  var relativeContextElement = getRelativeContextElement(el);
  if (!relativeContextElement) {
    return null;
  }
  return {
    height: relativeContextElement.scrollHeight,
    width: relativeContextElement.scrollWidth
  };
};
var useRelativePosition = function(el) {
  return Boolean(getRelativeContextElement(el));
};
var zoomLevel = function() {
  if (!utils_default.canUseDOM()) {
    return 1;
  }
  return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;
};
var isZoomed = function() {
  return zoomLevel() > 1;
};
var zIndex = function(anchor, container) {
  if (!anchor || !utils_default.canUseDOM()) {
    return null;
  }
  var sibling = sibling_container_default(anchor, container);
  if (!sibling) {
    return null;
  }
  var result = [anchor].concat(parents_default(anchor, sibling)).reduce(
    function(index, p) {
      var zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;
      var current4 = parseInt(zIndexStyle, 10);
      return current4 > index ? current4 : index;
    },
    0
  );
  return result ? result + 1 : null;
};
var domUtils = {
  addOffset,
  addScroll,
  align: align_default,
  boundingOffset: bounding_offset_default,
  getFontStyles,
  getWindow: getWindow2,
  hasOffsetParent,
  offset: offset2,
  offsetAtPoint,
  position: position2,
  removeScroll,
  restrictToView: restrict_to_view_default,
  scrollPosition,
  scrollableParents,
  getRelativeContextElement,
  stackingElementOffset,
  stackingElementScroll,
  stackingElementViewPort,
  useRelativePosition,
  windowViewPort: windowViewport,
  zoomLevel,
  isZoomed,
  zIndex
};
var dom_utils_default = domUtils;

// node_modules/@progress/kendo-popup-common/dist/es/align-element.js
var absoluteRect = function(anchor, element2, offset3, scale) {
  var scrollPos = elementScrollPosition(anchor, element2);
  var rect = utils_default.eitherRect(dom_utils_default.offset(anchor), offset3);
  var stackScale = 2 * scale;
  var stackScroll = dom_utils_default.stackingElementScroll(element2);
  if (scale !== 1 && stackScroll) {
    stackScroll.x /= stackScale;
    stackScroll.y /= stackScale;
  }
  var stackOffset = dom_utils_default.stackingElementOffset(element2);
  if (scale !== 1 && stackOffset) {
    stackOffset.left /= stackScale;
    stackOffset.top /= stackScale;
  }
  return dom_utils_default.removeScroll(
    dom_utils_default.addScroll(
      utils_default.removeStackingOffset(
        utils_default.scaleRect(rect, scale),
        stackOffset
      ),
      stackScroll
    ),
    scrollPos
  );
};
var relativeRect = function(anchor, element2, offset3, scale) {
  var rect = utils_default.eitherRect(dom_utils_default.position(anchor, element2, scale), offset3);
  return utils_default.scaleRect(rect, scale);
};
var elementScrollPosition = function(anchor, element2) {
  return anchor ? { x: 0, y: 0 } : dom_utils_default.scrollPosition(element2);
};
var alignElement = function(settings) {
  var anchor = settings.anchor;
  var element2 = settings.element;
  var anchorAlign = settings.anchorAlign;
  var elementAlign = settings.elementAlign;
  var margin = settings.margin;
  var offset3 = settings.offset;
  var positionMode = settings.positionMode;
  var scale = settings.scale;
  var currentScale = scale || 1;
  var fixedMode = positionMode === "fixed" || !dom_utils_default.hasOffsetParent(element2);
  var anchorRect = fixedMode ? absoluteRect(anchor, element2, offset3, currentScale) : relativeRect(anchor, element2, offset3, currentScale);
  var elementRect = utils_default.scaleRect(dom_utils_default.offset(element2), currentScale);
  var result = dom_utils_default.align({
    anchorAlign,
    anchorRect,
    elementAlign,
    elementRect,
    margin
  });
  return result;
};
var align_element_default = alignElement;

// node_modules/@progress/kendo-popup-common/dist/es/position-element.js
var positionElement = function(settings) {
  var anchor = settings.anchor;
  var currentLocation = settings.currentLocation;
  var element2 = settings.element;
  var anchorAlign = settings.anchorAlign;
  var elementAlign = settings.elementAlign;
  var collisions = settings.collisions;
  var margin = settings.margin;
  var scale = settings.scale;
  var currentScale = scale || 1;
  var elementOffset3 = dom_utils_default.offsetAtPoint(element2, currentLocation);
  var elementRect = utils_default.scaleRect(elementOffset3, currentScale);
  var anchorOffset = utils_default.scaleRect(dom_utils_default.offset(anchor), currentScale);
  var anchorRect = utils_default.eitherRect(anchorOffset, currentLocation);
  var viewPort = settings.viewPort || dom_utils_default.windowViewPort(element2);
  viewPort.width = viewPort.width / currentScale;
  viewPort.height = viewPort.height / currentScale;
  var result = dom_utils_default.restrictToView({
    anchorAlign,
    anchorRect,
    collisions,
    elementAlign,
    elementRect,
    margin,
    viewPort
  });
  var offset3 = dom_utils_default.addOffset(currentLocation, result.offset);
  return {
    flip: result.flip,
    flipped: result.flipped,
    offset: offset3
  };
};
var position_element_default = positionElement;

// node_modules/@progress/kendo-react-popup/dist/es/util.js
var FRAME_DURATION = 1e3 / 60;
var throttle2 = function(func2, wait, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var timeout, context2, args, result;
  var previous = 0;
  options2 = options2 || {};
  var later = function() {
    previous = options2.leading === false ? 0 : (/* @__PURE__ */ new Date()).getTime();
    timeout = void 0;
    result = func2.apply(context2, args);
    if (!timeout) {
      context2 = args = null;
    }
  };
  var throttled = function() {
    var now3 = (/* @__PURE__ */ new Date()).getTime();
    if (!previous && options2.leading === false) {
      previous = now3;
    }
    var remaining = wait - (now3 - previous);
    context2 = void 0;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = void 0;
      }
      previous = now3;
      result = func2.apply(context2, args);
      if (!timeout) {
        context2 = args = null;
      }
    } else if (!timeout && options2.trailing !== false) {
      timeout = window.setTimeout(later, remaining);
    }
    return result;
  };
  return throttled;
};

// node_modules/@progress/kendo-react-popup/dist/es/package-metadata.js
var packageMetadata2 = {
  name: "@progress/kendo-react-popup",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1686225147,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-react-popup/dist/es/PopupWithoutContext.js
var __extends23 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var DEFAULT_POPUP_ZINDEX = 100;
var ZINDEX_POPUP_STEP = 1;
function isEquivalent(a, b) {
  if (a === b) {
    return true;
  }
  if (!!a !== !!b) {
    return false;
  }
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b);
  if (aProps.length !== bProps.length) {
    return false;
  }
  for (var i = 0; i < aProps.length; i++) {
    var propName = aProps[i];
    if (a[propName] !== b[propName]) {
      return false;
    }
  }
  return true;
}
var DEFAULT_OFFSET = {
  left: -1e3,
  top: 0
};
var Status;
(function(Status2) {
  Status2["hiding"] = "hiding";
  Status2["hidden"] = "hidden";
  Status2["showing"] = "showing";
  Status2["shown"] = "shown";
  Status2["reposition"] = "reposition";
})(Status || (Status = {}));
var ANIMATION_CONTAINER = "k-animation-container";
var ANIMATION_CONTAINER_SHOWN = "k-animation-container-shown";
var ANIMATION_CONTAINER_RELATIVE = "k-animation-container-relative";
var ANIMATION_CONTAINER_CHILD = "k-child-animation-container";
var K_POPUP = "k-popup";
var PopupWithoutContext = (
  /** @class */
  function(_super) {
    __extends23(PopupWithoutContext2, _super);
    function PopupWithoutContext2(props) {
      var _this = _super.call(this, props) || this;
      _this.context = 0;
      _this.state = { current: Status.hidden, previous: Status.hidden, props: {} };
      _this._popup = null;
      _this.show = function(popup) {
        _this.setPosition(popup);
        _this.animate(popup.firstChild, "enter", _this.onOpened);
        _this.setState({ current: Status.shown, previous: _this.state.current });
      };
      _this.setPosition = function(popup) {
        var _a = _this.props, anchorAlign = _a.anchorAlign, popupAlign = _a.popupAlign, collision = _a.collision, offset3 = _a.offset, anchor = _a.anchor, margin = _a.margin, scale = _a.scale, positionMode = _a.positionMode;
        var _b = popup.style, width = _b.width, height = _b.height;
        popup.style.width = popup.offsetWidth + "px";
        popup.style.height = popup.offsetHeight + "px";
        var alignedOffset = align_element_default({
          anchor,
          anchorAlign,
          element: popup,
          elementAlign: popupAlign,
          offset: offset3,
          margin,
          positionMode,
          scale
        });
        var position3 = position_element_default({
          anchor,
          anchorAlign,
          element: popup,
          elementAlign: popupAlign,
          collisions: collision,
          currentLocation: alignedOffset,
          margin: _this.props.margin
        });
        popup.style.top = position3.offset.top + "px";
        popup.style.left = position3.offset.left + "px";
        popup.style.width = width;
        popup.style.height = height;
        _this._collisions = {
          fit: position3.fit,
          fitted: position3.fitted,
          flip: position3.flip,
          flipped: position3.flipped
        };
        if (_this.props.onPosition) {
          var event_1 = {
            target: _this,
            flipped: position3.flipped,
            fitted: position3.fitted
          };
          _this.props.onPosition.call(void 0, event_1);
        }
      };
      _this.onOpened = function() {
        var element2 = _this._popup;
        if (!element2) {
          return;
        }
        if (_this.props.show) {
          element2.classList.add(ANIMATION_CONTAINER_SHOWN);
        }
        _this.attachRepositionHandlers(element2);
        if (_this.props.onOpen) {
          _this.props.onOpen.call(void 0, { target: _this });
        }
      };
      _this.animate = function(element2, type, callback) {
        if (!_this.props.popupAlign) {
          return;
        }
        var animationDirection;
        var _a = _this.props.popupAlign, horizontal = _a.horizontal, vertical = _a.vertical;
        if (horizontal === "left" && vertical === "center") {
          animationDirection = "right";
        } else if (horizontal === "right" && vertical === "center") {
          animationDirection = "left";
        } else if (vertical === "top") {
          animationDirection = "down";
        } else {
          animationDirection = "up";
        }
        var flipPositions = {
          down: "up",
          up: "down",
          left: "right",
          right: "left"
        };
        if (_this._collisions && _this._collisions.flipped) {
          animationDirection = flipPositions[animationDirection];
        }
        slide(element2, animationDirection, _this.animationDuration[type], type, callback);
      };
      _this.onClosing = function(popup) {
        if (!_this.props.show) {
          popup.classList.remove(ANIMATION_CONTAINER_SHOWN);
        }
        _this.detachRepositionHandlers();
      };
      _this.onClosed = function() {
        if (_this.state.current === Status.hiding && _this.state.previous === Status.shown) {
          _this.setState({ current: Status.hidden, previous: _this.state.current });
        }
        if (_this.props.onClose) {
          _this.props.onClose.call(void 0, { target: _this });
        }
      };
      _this.getCurrentZIndex = function() {
        return _this.context ? _this.context + ZINDEX_POPUP_STEP : DEFAULT_POPUP_ZINDEX;
      };
      validatePackage2(packageMetadata2);
      _this.reposition = throttle2(_this.reposition.bind(_this), FRAME_DURATION);
      return _this;
    }
    Object.defineProperty(PopupWithoutContext2.prototype, "element", {
      /**
       * Represents the Popup DOM element.
       */
      get: function() {
        return this._popup;
      },
      enumerable: false,
      configurable: true
    });
    PopupWithoutContext2.getDerivedStateFromProps = function(props, state) {
      var show2 = props.show, anchor = props.anchor, anchorAlign = props.anchorAlign, appendTo = props.appendTo, collision = props.collision, popupAlign = props.popupAlign, className = props.className, popupClass = props.popupClass, style = props.style, offset3 = props.offset, contentKey = props.contentKey;
      var nextState = __assign(__assign({}, state), { props: {
        show: show2,
        anchor,
        anchorAlign,
        appendTo,
        collision,
        popupAlign,
        className,
        popupClass,
        style,
        offset: offset3,
        contentKey
      } });
      if (props.show) {
        if (state.current === Status.hidden || state.current === Status.hiding) {
          return __assign(__assign({}, nextState), { current: Status.showing, previous: state.current });
        }
        if (state.current === Status.showing) {
          return __assign(__assign({}, nextState), { current: Status.shown, previous: state.current });
        }
        if (state.current === Status.shown && (!isEquivalent(offset3, state.props.offset) || !isEquivalent(anchorAlign, state.props.anchorAlign) || !isEquivalent(appendTo, state.props.appendTo) || !isEquivalent(collision, state.props.collision) || !isEquivalent(popupAlign, state.props.popupAlign) || !isEquivalent(style, state.props.style) || anchor !== state.props.anchor || popupClass !== state.props.popupClass || className !== state.props.className)) {
          return __assign(__assign({}, nextState), { current: Status.reposition, previous: state.current });
        }
        return nextState;
      }
      if (state.current === Status.hiding || state.current === Status.hidden) {
        return __assign(__assign({}, nextState), { current: Status.hidden, previous: state.current });
      }
      return __assign(__assign({}, nextState), { current: Status.hiding, previous: state.current });
    };
    PopupWithoutContext2.prototype.componentDidUpdate = function(prevProps) {
      if (this.state.current === Status.showing && this._popup) {
        this.show(this._popup);
      } else if (this.state.current === Status.hiding && this._popup) {
        this.onClosing(this._popup);
        this.animate(this._popup.firstChild, "exit", this.onClosed);
      } else if (this.state.current === Status.reposition && this.state.previous === Status.shown) {
        this.setState({ current: Status.shown, previous: this.state.current });
      } else if (this.state.current === Status.shown && prevProps.contentKey !== this.props.contentKey && this._popup) {
        this.setPosition(this._popup);
      }
    };
    PopupWithoutContext2.prototype.componentDidMount = function() {
      if (this.state.current === Status.showing && this._popup) {
        this.show(this._popup);
      }
    };
    PopupWithoutContext2.prototype.componentWillUnmount = function() {
      this.detachRepositionHandlers();
    };
    PopupWithoutContext2.prototype.render = function() {
      var _this = this;
      var _a = this.props, children = _a.children, className = _a.className, popupClass = _a.popupClass, show2 = _a.show, id = _a.id, positionMode = _a.positionMode;
      var calculatedAppendTo = this.props.appendTo ? this.props.appendTo : canUseDOM ? this.props.anchor && this.props.anchor.ownerDocument ? this.props.anchor.ownerDocument.body : document.body : void 0;
      if (this.state.current === Status.reposition && this.state.previous === Status.shown && this._popup) {
        this.setPosition(this._popup);
      }
      var style = Object.assign({}, { position: positionMode, top: 0, left: -1e4 }, this.props.style || {});
      var closing = this.state.current === Status.hiding;
      if ((show2 || closing) && calculatedAppendTo) {
        var currentZIndex = this.getCurrentZIndex();
        var popupElement = React4.createElement(
          ZIndexContext.Provider,
          { value: currentZIndex },
          React4.createElement(
            "div",
            { className: classNames(ANIMATION_CONTAINER, ANIMATION_CONTAINER_RELATIVE, className), id, ref: function(e) {
              return _this._popup = e;
            }, style: __assign({ zIndex: currentZIndex }, style) },
            React4.createElement("div", { role: this.props.role, className: classNames(K_POPUP, popupClass, ANIMATION_CONTAINER_CHILD), style: { transitionDelay: "0ms" } }, children)
          )
        );
        return this.props.appendTo !== null ? ReactDOM.createPortal(popupElement, calculatedAppendTo) : popupElement;
      }
      return null;
    };
    Object.defineProperty(PopupWithoutContext2.prototype, "animationDuration", {
      get: function() {
        var animate = this.props.animate;
        var enter = 0;
        var exit = 0;
        if (animate) {
          if (animate === true) {
            enter = exit = 300;
          } else {
            enter = animate.openDuration || 0;
            exit = animate.closeDuration || 0;
          }
        }
        return { enter, exit };
      },
      enumerable: false,
      configurable: true
    });
    PopupWithoutContext2.prototype.attachRepositionHandlers = function(element2) {
      var _this = this;
      this.detachRepositionHandlers();
      this._scrollableParents = dom_utils_default.scrollableParents(this.props.anchor || element2);
      if (this._scrollableParents) {
        this._scrollableParents.map(function(p) {
          return p.addEventListener("scroll", _this.reposition);
        });
      }
      window.addEventListener("resize", this.reposition);
    };
    PopupWithoutContext2.prototype.detachRepositionHandlers = function() {
      var _this = this;
      if (this._scrollableParents) {
        this._scrollableParents.map(function(p) {
          return p.removeEventListener("scroll", _this.reposition);
        });
        this._scrollableParents = void 0;
      }
      window.removeEventListener("resize", this.reposition);
    };
    PopupWithoutContext2.prototype.reposition = function() {
      this.setState({ current: Status.reposition, previous: this.state.current });
    };
    PopupWithoutContext2.propTypes = {
      anchor: function(props) {
        var anchor = props.anchor;
        if (anchor && typeof anchor.nodeType !== "number") {
          return new Error("Invalid prop `anchor` supplied to `Kendo React Popup`. Validation failed.");
        }
        return null;
      },
      appendTo: function(props) {
        var element2 = props.appendTo;
        if (element2 && typeof element2.nodeType !== "number") {
          return new Error("Invalid prop `appendTo` supplied to `Kendo React Popup`. Validation failed.");
        }
        return null;
      },
      className: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.object
      ]),
      id: PropTypes.string,
      popupClass: PropTypes.oneOfType([
        PropTypes.string,
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.object
      ]),
      collision: PropTypes.shape({
        horizontal: PropTypes.oneOf([
          collision_default.fit,
          collision_default.flip,
          collision_default.none
        ]),
        vertical: PropTypes.oneOf([
          collision_default.fit,
          collision_default.flip,
          collision_default.none
        ])
      }),
      anchorAlign: PropTypes.shape({
        horizontal: PropTypes.oneOf([
          align_point_default.left,
          align_point_default.center,
          align_point_default.right
        ]),
        vertical: PropTypes.oneOf([
          align_point_default.top,
          align_point_default.center,
          align_point_default.bottom
        ])
      }),
      popupAlign: PropTypes.shape({
        horizontal: PropTypes.oneOf([
          align_point_default.left,
          align_point_default.center,
          align_point_default.right
        ]),
        vertical: PropTypes.oneOf([
          align_point_default.top,
          align_point_default.center,
          align_point_default.bottom
        ])
      }),
      offset: PropTypes.shape({
        left: PropTypes.number,
        top: PropTypes.number
      }),
      children: PropTypes.oneOfType([
        PropTypes.element,
        PropTypes.node
      ]),
      show: PropTypes.bool,
      animate: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.shape({
          openDuration: PropTypes.number,
          closeDuration: PropTypes.number
        })
      ]),
      margin: PropTypes.shape({
        horizontal: PropTypes.number,
        vertical: PropTypes.number
      }),
      positionMode: PropTypes.oneOf([
        "fixed",
        "absolute"
      ]),
      scale: PropTypes.number,
      style: PropTypes.object,
      onClose: PropTypes.func,
      onPosition: PropTypes.func,
      onOpen: PropTypes.func
    };
    PopupWithoutContext2.defaultProps = {
      collision: {
        horizontal: collision_default.fit,
        vertical: collision_default.flip
      },
      anchorAlign: {
        horizontal: align_point_default.left,
        vertical: align_point_default.bottom
      },
      popupAlign: {
        horizontal: align_point_default.left,
        vertical: align_point_default.top
      },
      offset: DEFAULT_OFFSET,
      animate: true,
      show: false,
      margin: {
        horizontal: 0,
        vertical: 0
      },
      positionMode: "absolute"
    };
    PopupWithoutContext2.contextType = ZIndexContext;
    PopupWithoutContext2.displayName = "PopupComponent";
    return PopupWithoutContext2;
  }(React4.Component)
);

// node_modules/@progress/kendo-react-popup/dist/es/Popup.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var PopupPropsContext = React5.createContext(function(props) {
  return props;
});
var Popup = React5.forwardRef(function(props, ref2) {
  var contextPropsCallback = React5.useContext(PopupPropsContext);
  var popupProps = contextPropsCallback.call(void 0, props);
  return React5.createElement(PopupWithoutContext, __assign2({ ref: ref2 }, popupProps));
});
Popup.displayName = "Popup";

// node_modules/@progress/kendo-react-charts/dist/es/ChartContext.js
var React6 = __toESM(require_react());
var ChartContext = React6.createContext(null);
ChartContext.displayName = "ChartContext";

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/Popup.js
var __extends24 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var COLLISION = { horizontal: "fit", vertical: "fit" };
var TOOLTIP_CLASS = "k-chart-tooltip";
var POPUP_WRAPPER_CLASS = "k-chart-tooltip-wrapper";
var TooltipPopup = (
  /** @class */
  function(_super) {
    __extends24(TooltipPopup2, _super);
    function TooltipPopup2(props, context2) {
      var _this = _super.call(this, props, context2) || this;
      _this.context = null;
      _this.element = null;
      _this.onChartMouseLeave = function(e) {
        var syntheticEvent = e.syntheticEvent;
        if (hasParent(syntheticEvent.relatedTarget, _this.element)) {
          return true;
        }
        return false;
      };
      _this.onMouseLeave = function(e) {
        var domEvent = toDomEvent(_this, e);
        var isDefaultPrevented3 = _this.context.childrenObserver.trigger("onMouseLeave", domEvent);
        if (isDefaultPrevented3) {
          e.preventDefault();
        }
      };
      _this.chartObserver = new instance_observer_default(_this, {
        onMouseLeave: "onChartMouseLeave"
      });
      context2.observersStore.dispatch({
        type: "add",
        payload: _this.chartObserver
      });
      return _this;
    }
    TooltipPopup2.prototype.render = function() {
      var _this = this;
      var _a = this.props, popupShown = _a.popupShown, popupAlign = _a.popupAlign, popupOffset = _a.popupOffset, popupStyles = _a.popupStyles, popupContent = _a.popupContent, className = _a.className;
      var wrapperClass = [TOOLTIP_CLASS, className].join(" ").trim();
      var popupComponent = React7.createElement(
        Popup,
        { animate: false, popupAlign, offset: popupOffset, show: popupShown, collision: COLLISION, className: POPUP_WRAPPER_CLASS },
        React7.createElement("div", { className: wrapperClass, style: popupStyles, onMouseLeave: this.onMouseLeave, ref: function(el) {
          return _this.element = el;
        } }, popupContent())
      );
      return popupComponent;
    };
    TooltipPopup2.prototype.componentWillUnmount = function() {
      this.context.observersStore.dispatch({
        type: "remove",
        payload: this.chartObserver
      });
    };
    TooltipPopup2.contextType = ChartContext;
    return TooltipPopup2;
  }(React7.Component)
);

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/Series.js
var __extends25 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var SHARED_TOOLTIP_CLASS = "k-chart-shared-tooltip";
var INVERSE_TOOLTIP_CLASS = "k-chart-tooltip-inverse";
var SeriesTooltip = (
  /** @class */
  function(_super) {
    __extends25(SeriesTooltip2, _super);
    function SeriesTooltip2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.context = null;
      _this.state = {
        popupShown: false
      };
      _this.chartObserver = null;
      return _this;
    }
    SeriesTooltip2.prototype.componentDidMount = function() {
      this.chartObserver = new instance_observer_default(this, {
        showTooltip: "onShowTooltip",
        hideTooltip: "onHideTooltip"
      });
      this.context.observersStore.dispatch({
        type: "add",
        payload: this.chartObserver
      });
    };
    SeriesTooltip2.prototype.render = function() {
      var _a;
      var _this = this;
      var _b = this.state, popupContext = _b.popupContext, shared = _b.shared, className = _b.className, tooltipProps = __rest(_b, ["popupContext", "shared", "className"]);
      var tooltipContent = this.state.popupShown ? function() {
        var render = _this.findRenderFunction();
        if (shared) {
          return render !== null ? render(popupContext) : React8.createElement(SharedTooltipContent, __assign3({}, popupContext));
        } else {
          var point2 = popupContext.point;
          var seriesRenderer = _this.findRenderFunctionByIndex(point2.series.index);
          if (seriesRenderer !== null) {
            return seriesRenderer(popupContext);
          } else if (render !== null) {
            return render(popupContext);
          } else {
            return React8.createElement("span", { dangerouslySetInnerHTML: { __html: popupContext.point.formattedValue } });
          }
        }
      } : Function.prototype;
      var popupContainerClassName = classNames((_a = {}, _a[SHARED_TOOLTIP_CLASS] = shared, _a[INVERSE_TOOLTIP_CLASS] = !!className, _a));
      return React8.createElement(TooltipPopup, __assign3({}, tooltipProps, { popupContent: tooltipContent, className: popupContainerClassName }));
    };
    SeriesTooltip2.prototype.componentWillUnmount = function() {
      this.context.observersStore.dispatch({
        type: "remove",
        payload: this.chartObserver
      });
    };
    SeriesTooltip2.prototype.onShowTooltip = function(e) {
      var anchor = e.anchor, style = e.style, shared = e.shared, className = e.className, crosshair = e.crosshair;
      var context2;
      if (crosshair) {
        return;
      }
      if (shared) {
        context2 = this.createSharedTooltipContext(e);
      } else {
        context2 = this.createTooltipContext(e);
      }
      this.setState({
        popupShown: true,
        popupAlign: anchor.align,
        popupOffset: anchor.point,
        popupContext: context2,
        popupStyles: style,
        className,
        shared
      });
    };
    SeriesTooltip2.prototype.onHideTooltip = function() {
      this.setState({
        popupShown: false,
        popupStyles: {},
        className: void 0
      });
    };
    SeriesTooltip2.prototype.createSharedTooltipContext = function(e) {
      var points3 = e.points, categoryText = e.categoryText;
      var nameColumn = points3.filter(function(point2) {
        return typeof point2.series.name !== "undefined";
      }).length > 0;
      var colorMarker = e.series.length > 1;
      var colspan = 1;
      if (nameColumn) {
        colspan++;
      }
      if (colorMarker) {
        colspan++;
      }
      return {
        categoryText,
        colorMarker,
        colspan,
        nameColumn,
        points: e.points.map(function(point2) {
          return new TooltipPoint(point2, e.format);
        })
      };
    };
    SeriesTooltip2.prototype.createTooltipContext = function(e) {
      var point2 = e.point, format2 = e.format;
      return { point: new TooltipPoint(point2, format2) };
    };
    SeriesTooltip2.prototype.findRenderFunctionByIndex = function(seriesIdx) {
      var series = this.context.optionsStore.getState().series;
      if (series !== void 0 && Array.isArray(series) && series[seriesIdx] !== void 0 && series[seriesIdx].hasOwnProperty("tooltip") && series[seriesIdx].tooltip.hasOwnProperty("render")) {
        return series[seriesIdx].tooltip.render;
      }
      return null;
    };
    SeriesTooltip2.prototype.findRenderFunction = function() {
      var tooltip = this.context.optionsStore.getState().tooltip;
      if (tooltip !== void 0 && tooltip.hasOwnProperty("render")) {
        return tooltip.render;
      }
      return null;
    };
    SeriesTooltip2.contextType = ChartContext;
    return SeriesTooltip2;
  }(React8.Component)
);

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/CrosshairContainer.js
var React10 = __toESM(require_react());

// node_modules/@progress/kendo-react-charts/dist/es/Container.js
var Container = function(props) {
  return props.children;
};
Container.displayName = "Container";

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/Crosshair.js
var React9 = __toESM(require_react());
var __extends26 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var CROSSHAIR_TOOLTIP_CLASS = "k-chart-crosshair-tooltip";
var INVERSE_TOOLTIP_CLASS2 = "k-chart-tooltip-inverse";
var CrosshairTooltip2 = (
  /** @class */
  function(_super) {
    __extends26(CrosshairTooltip3, _super);
    function CrosshairTooltip3(props, context2) {
      var _this = _super.call(this, props, context2) || this;
      _this.context = null;
      _this.state = {
        popupShown: false
      };
      _this.chartObserver = new instance_observer_default(_this, {
        showTooltip: "onShowTooltip",
        hideTooltip: "onHideTooltip"
      });
      context2.observersStore.dispatch({
        type: "add",
        payload: _this.chartObserver
      });
      return _this;
    }
    CrosshairTooltip3.prototype.render = function() {
      var _a;
      var _b = this.state, popupContend = _b.popupContend, className = _b.className, tooltipProps = __rest2(_b, ["popupContend", "className"]);
      var tooltipContent = this.state.popupShown ? function() {
        return popupContend;
      } : Function.prototype;
      var popupContainerClassName = classNames((_a = {}, _a[CROSSHAIR_TOOLTIP_CLASS] = true, _a[INVERSE_TOOLTIP_CLASS2] = !!className, _a));
      return React9.createElement(TooltipPopup, __assign4({}, tooltipProps, { popupContent: tooltipContent, className: popupContainerClassName }));
    };
    CrosshairTooltip3.prototype.componentWillUnmount = function() {
      var _a;
      (_a = this.context) === null || _a === void 0 ? void 0 : _a.observersStore.dispatch({
        type: "remove",
        payload: this.chartObserver
      });
    };
    CrosshairTooltip3.prototype.onShowTooltip = function(e) {
      var anchor = e.anchor, style = e.style, className = e.className, crosshair = e.crosshair, axisName = e.axisName, axisIndex = e.axisIndex, value = e.value;
      var _a = this.props, name2 = _a.name, index = _a.index;
      if (!crosshair) {
        return;
      }
      if (axisName === name2 && axisIndex === index) {
        this.setState({
          popupShown: true,
          popupAlign: anchor.align,
          popupOffset: anchor.point,
          popupContend: value,
          popupStyles: style,
          className
        });
      }
    };
    CrosshairTooltip3.prototype.onHideTooltip = function() {
      this.setState({
        popupShown: false,
        popupStyles: {},
        className: void 0
      });
    };
    CrosshairTooltip3.contextType = ChartContext;
    return CrosshairTooltip3;
  }(React9.Component)
);

// node_modules/@progress/kendo-react-charts/dist/es/tooltip/CrosshairContainer.js
var __extends27 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var AXES = ["categoryAxis", "valueAxis", "xAxis", "yAxis"];
function mapTooltips(options2) {
  var map2 = {};
  for (var idx = 0; idx < AXES.length; idx++) {
    var tooltips = axesCrosshairTooltipOptions(options2, AXES[idx]);
    for (var tooltipIdx = 0; tooltipIdx < tooltips.length; tooltipIdx++) {
      var tooltip = tooltips[tooltipIdx];
      map2[tooltip.name + tooltip.index] = tooltip;
    }
  }
  return map2;
}
function axesCrosshairTooltipOptions(options2, name2) {
  var result = [];
  if (options2[name2]) {
    var axes = [].concat(options2[name2]);
    for (var idx = 0; idx < axes.length; idx++) {
      var tooltip = (axes[idx].crosshair || {}).tooltip;
      if (tooltip && tooltip.visible) {
        result.push({
          index: idx,
          name: name2
        });
      }
    }
  }
  return result;
}
var CrosshairTooltipContainer = (
  /** @class */
  function(_super) {
    __extends27(CrosshairTooltipContainer2, _super);
    function CrosshairTooltipContainer2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.context = null;
      _this.state = {
        tooltips: {}
      };
      _this.storeUnsubscriber = Function.prototype;
      _this.subscriber = function() {
        var _a;
        _this.setState({
          tooltips: mapTooltips((_a = _this.context) === null || _a === void 0 ? void 0 : _a.optionsStore.getState())
        });
      };
      return _this;
    }
    CrosshairTooltipContainer2.prototype.componentDidMount = function() {
      this.storeUnsubscriber = this.context.optionsStore.subscribe(this.subscriber);
    };
    CrosshairTooltipContainer2.prototype.render = function() {
      var tooltips = this.state.tooltips;
      var childrenMap = Object.keys(tooltips).map(function(key) {
        return React10.createElement(CrosshairTooltip2, __assign5({}, tooltips[key], { key }));
      });
      return React10.createElement(Container, null, childrenMap);
    };
    CrosshairTooltipContainer2.prototype.componentWillUnmount = function() {
      this.storeUnsubscriber();
    };
    CrosshairTooltipContainer2.contextType = ChartContext;
    return CrosshairTooltipContainer2;
  }(React10.Component)
);

// node_modules/@progress/kendo-react-charts/dist/es/package-metadata.js
var packageMetadata3 = {
  name: "@progress/kendo-react-charts",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1686225237,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-react-charts/dist/es/BaseChart.js
var __extends28 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var BaseChart = (
  /** @class */
  function(_super) {
    __extends28(BaseChart2, _super);
    function BaseChart2(props) {
      var _this = _super.call(this, props) || this;
      _this.chartInstance = null;
      _this.surface = null;
      _this._element = null;
      _this.optionsStore = {};
      _this.optionsUnsubscriber = Function.prototype;
      _this.themeStore = {};
      _this.themeUnsubscriber = Function.prototype;
      _this.observersStore = {};
      _this.suppressTransitions = false;
      _this.onRender = function(e) {
        if (_this.chartInstance !== null) {
          _this.surface = e.sender.surface;
          _this.trigger("render", e);
        }
      };
      _this.onLegendItemClick = function(e) {
        if (_this.chartInstance !== null) {
          if (_this.props.onLegendItemClick) {
            _this.trigger("legendItemClick", e);
          } else {
            var series = _this.optionsStore.getState().series;
            if (!series) {
              return;
            }
            var payload = {};
            var seriesIndex = e.seriesIndex, pointIndex = e.pointIndex;
            var seriesByIndex = series[seriesIndex];
            if (pointIndex === void 0) {
              payload = Object.assign({}, seriesByIndex, { visible: toggle(seriesByIndex.visible) });
            } else {
              var pv = seriesByIndex.pointVisibility = seriesByIndex.pointVisibility || [];
              pv[pointIndex] = toggle(pv[pointIndex]);
              payload = Object.assign({}, seriesByIndex);
            }
            _this.optionsStore.dispatch({
              chartCollectionIdxKey: "series_".concat(seriesIndex),
              payload
            });
            _this.suppressTransitions = true;
          }
        }
      };
      _this.onWindowResize = function() {
        if (_this.chartInstance !== null) {
          _this.chartInstance.resize();
        }
      };
      _this.onChartMouseLeave = function(e) {
        var domEvent = toDomEvent(_this, e);
        var isDefaultPrevented3 = _this.triggerDomEvent("onMouseLeave", domEvent);
        if (isDefaultPrevented3) {
          e.preventDefault();
        } else if (_this.chartInstance !== null) {
          _this.chartInstance.hideElements();
        }
      };
      _this.onChildMouseLeave = function(e) {
        var syntheticEvent = e.syntheticEvent;
        if (_this.chartInstance && !hasParent(syntheticEvent.relatedTarget, _this.element)) {
          _this.chartInstance.hideElements();
        }
        return false;
      };
      validatePackage2(packageMetadata3);
      _this.optionsStore = store_default(optionsReducer);
      _this.observersStore = store_default(observersReducer);
      _this.childrenObserver = new instance_observer_default(_this, { onMouseLeave: "onChildMouseLeave" });
      _this.contextValue = {
        optionsStore: _this.optionsStore,
        observersStore: _this.observersStore,
        childrenObserver: _this.childrenObserver
      };
      _this.themeStore = store_default(themeReducer);
      _this.chartObserver = new instance_observer_default(_this, { render: "onRender", legendItemClick: "onLegendItemClick" });
      return _this;
    }
    Object.defineProperty(BaseChart2.prototype, "element", {
      /**
       * @hidden
       */
      get: function() {
        return this._element;
      },
      enumerable: false,
      configurable: true
    });
    BaseChart2.prototype.componentDidMount = function() {
      var _a;
      var doc = ((_a = this._element) === null || _a === void 0 ? void 0 : _a.ownerDocument) || document;
      loadTheme(this.themeStore, this.instantiateCoreChart.bind(this), doc);
      this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this));
      this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this));
      window.addEventListener("resize", this.onWindowResize);
    };
    BaseChart2.prototype.componentWillUnmount = function() {
      this.optionsUnsubscriber();
      this.themeUnsubscriber();
      if (this.chartInstance !== null) {
        this.chartInstance.destroy();
        this.chartInstance = null;
      }
      window.removeEventListener("resize", this.onWindowResize);
    };
    BaseChart2.prototype.componentDidUpdate = function(prevProps) {
      var _a = this.props, dir = _a.dir, children = _a.children, spreadProps = __rest3(_a, ["dir", "children"]);
      if (this.chartInstance !== null) {
        var currentIntlService = provideIntlService(this);
        var chartService = this.chartInstance.chartService;
        var localeChanged = currentIntlService.locale !== chartService._intlService.locale;
        var shouldUpdate = Object.entries(prevProps).filter(function(keyValue) {
          return keyValue[0] !== "dir" && keyValue[0] !== "children";
        }).some(function(keyValue) {
          var key = keyValue[0], value = keyValue[1];
          return !(spreadProps.hasOwnProperty(key) && spreadProps[key] === value);
        });
        if (localeChanged) {
          this.chartInstance.chartService._intlService = currentIntlService;
          this.chartInstance.chartService.format._intlService = currentIntlService;
          if (!shouldUpdate) {
            this.chartInstance.noTransitionsRedraw();
          }
        }
        if (shouldUpdate) {
          this.refresh();
        }
        if (prevProps.dir !== dir) {
          this.chartInstance.setDirection(this.getDirection(dir));
        }
      }
    };
    BaseChart2.prototype.render = function() {
      var _this = this;
      var _a = this.props, _b = _a.style, style = _b === void 0 ? {} : _b, className = _a.className, wrapper = _a.wrapper, children = _a.children;
      var chartStyles = Object.assign({}, style, { position: "relative" });
      var content = React11.createElement(wrapper, {
        className,
        style: chartStyles,
        key: "chartElement"
      }, React11.createElement("div", { onMouseLeave: this.onChartMouseLeave, ref: function(el) {
        return _this._element = el;
      }, className: "k-chart-surface" }, children));
      return React11.createElement(
        ChartContext.Provider,
        { value: this.contextValue },
        React11.createElement(SeriesTooltip, { key: "seriesTooltip" }),
        React11.createElement(CrosshairTooltipContainer, { key: "crosshairTooltips" }),
        content
      );
    };
    BaseChart2.prototype.getDirection = function(dir) {
      var _this = this;
      var directionFromWindow = function() {
        return canUseDOM && window.getComputedStyle(_this.element).direction;
      };
      var direction = dir !== void 0 ? dir : directionFromWindow() || "ltr";
      return direction === "rtl";
    };
    BaseChart2.prototype.getChartOptions = function() {
      var _a = this.props, renderAs = _a.renderAs, pannable = _a.pannable, zoomable = _a.zoomable, paneDefaults = _a.paneDefaults, panes = _a.panes, transitions = _a.transitions, seriesColors = _a.seriesColors, seriesDefaults2 = _a.seriesDefaults, axisDefaults2 = _a.axisDefaults, deriveOptionsFromParent = _a.deriveOptionsFromParent;
      var chartOptions = {};
      if (renderAs !== void 0) {
        chartOptions.renderAs = renderAs;
      }
      if (pannable !== void 0) {
        chartOptions.pannable = pannable;
      }
      if (zoomable !== void 0) {
        chartOptions.zoomable = zoomable;
      }
      if (paneDefaults !== void 0) {
        chartOptions.paneDefaults = paneDefaults;
      }
      if (panes !== void 0) {
        chartOptions.panes = panes;
      }
      if (transitions !== void 0) {
        chartOptions.transitions = transitions;
      }
      if (seriesColors !== void 0) {
        chartOptions.seriesColors = seriesColors;
      }
      if (seriesDefaults2 !== void 0) {
        chartOptions.seriesDefaults = seriesDefaults2;
      }
      if (axisDefaults2 !== void 0) {
        chartOptions.axisDefaults = axisDefaults2;
      }
      chartOptions = Object.assign(chartOptions, this.optionsStore.getState());
      if (deriveOptionsFromParent) {
        chartOptions = deriveOptionsFromParent(chartOptions);
      }
      return chartOptions;
    };
    BaseChart2.prototype.refresh = function() {
      if (this.chartInstance !== null) {
        var themeOptions = this.themeStore.getState();
        var chartOptions = this.getChartOptions();
        var transitions = chartOptions.transitions;
        if (this.suppressTransitions) {
          chartOptions.transitions = false;
        }
        if (this.props.onRefresh) {
          this.props.onRefresh.call(void 0, chartOptions, themeOptions, this.chartInstance);
        } else {
          this.chartInstance.setOptions(chartOptions, themeOptions);
        }
        if (this.suppressTransitions) {
          chartOptions.transitions = transitions;
          this.suppressTransitions = false;
        }
      }
    };
    BaseChart2.prototype.instantiateCoreChart = function() {
      var _a = this.props, dir = _a.dir, chartConstructor = _a.chartConstructor;
      var chartOptions = this.getChartOptions();
      this.chartInstance = new chartConstructor(this.element, chartOptions, this.themeStore.getState(), {
        rtl: this.getDirection(dir),
        intlService: provideIntlService(this),
        observer: this.chartObserver,
        sender: this
      });
    };
    BaseChart2.prototype.trigger = function(name2, e) {
      var target = this.props.getTarget();
      var eventObject = create2(name2, e, target);
      var handler = "on" + name2.charAt(0).toUpperCase() + name2.slice(1);
      var observers = this.observersStore.getState();
      var isDefaultPrevented3 = false;
      for (var idx = 0; idx < observers.length; idx++) {
        if (observers[idx].trigger(name2, e)) {
          isDefaultPrevented3 = true;
        }
      }
      if (isDefaultPrevented3 === false && eventObject && this.props.hasOwnProperty(handler)) {
        this.props[handler].call(void 0, eventObject);
        return eventObject.isDefaultPrevented && eventObject.isDefaultPrevented();
      }
      return isDefaultPrevented3;
    };
    BaseChart2.prototype.requiresHandlers = function(names) {
      for (var idx = 0; idx < names.length; idx++) {
        var name_1 = names[idx];
        var handler = "on" + name_1.charAt(0).toUpperCase() + name_1.slice(1);
        if (this.props.hasOwnProperty(handler)) {
          return true;
        }
      }
      return false;
    };
    BaseChart2.prototype.triggerDomEvent = function(name2, e) {
      var observers = this.observersStore.getState();
      var isDefaultPrevented3 = false;
      for (var idx = 0; idx < observers.length; idx++) {
        if (observers[idx].trigger(name2, e)) {
          isDefaultPrevented3 = true;
        }
      }
      return isDefaultPrevented3;
    };
    BaseChart2.propTypes = {
      dir: PropTypes2.string,
      renderAs: PropTypes2.oneOf(["svg", "canvas"])
    };
    BaseChart2.defaultProps = {
      renderAs: "svg"
    };
    return BaseChart2;
  }(React11.Component)
);
registerForIntl(BaseChart);
dom_events_builder_default.register(DomEventsBuilder3);

// node_modules/@progress/kendo-react-charts/dist/es/DonutCenter.js
var React12 = __toESM(require_react());
var __extends29 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DonutCenter = (
  /** @class */
  function(_super) {
    __extends29(DonutCenter2, _super);
    function DonutCenter2(props, context2) {
      var _this = _super.call(this, props, context2) || this;
      _this.context = null;
      _this.state = {
        donutCenterStyles: null
      };
      _this.chartObserver = new instance_observer_default(_this, {
        render: "onRender"
      });
      context2.observersStore.dispatch({
        type: "add",
        payload: _this.chartObserver
      });
      return _this;
    }
    DonutCenter2.prototype.render = function() {
      var render = this.props.render;
      var donutCenterStyles = this.state.donutCenterStyles;
      var renderer = null;
      if (render && donutCenterStyles) {
        renderer = React12.createElement("div", { className: "k-chart-donut-center", style: donutCenterStyles }, render());
      }
      return renderer;
    };
    DonutCenter2.prototype.onRender = function(event) {
      var _a;
      var series = (_a = this.context) === null || _a === void 0 ? void 0 : _a.optionsStore.getState().series;
      var firstSeries = Array.isArray(series) ? series[0] : null;
      var charts = event.sender._plotArea.charts;
      if (!firstSeries || firstSeries.type !== "donut" || charts[0].points.length === 0) {
        return;
      }
      var sector = charts[0].points[0].sector;
      var radius = sector.innerRadius;
      var top = sector.center.y - radius;
      var left = sector.center.x - radius;
      var size = radius * 2;
      this.setState({
        donutCenterStyles: {
          height: size,
          left,
          top,
          width: size
        }
      });
    };
    DonutCenter2.contextType = ChartContext;
    return DonutCenter2;
  }(React12.Component)
);

// node_modules/@progress/kendo-react-charts/dist/es/Chart.js
var __extends30 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var Chart2 = (
  /** @class */
  function(_super) {
    __extends30(Chart3, _super);
    function Chart3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._baseChart = null;
      _this.getTarget = function() {
        return _this;
      };
      return _this;
    }
    Object.defineProperty(Chart3.prototype, "chartInstance", {
      /**
       * @hidden
       */
      get: function() {
        if (this._baseChart !== null) {
          return this._baseChart.chartInstance;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Chart3.prototype, "surface", {
      /**
       * The Drawing `Surface` of the Chart.
       */
      get: function() {
        if (this._baseChart !== null) {
          return this._baseChart.surface;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Chart3.prototype, "element", {
      /**
       * The DOM element of the Chart.
       */
      get: function() {
        if (this._baseChart !== null) {
          return this._baseChart.element;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Chart3.prototype.render = function() {
      var _this = this;
      var _a = this.props, donutCenterRender = _a.donutCenterRender, children = _a.children, className = _a.className, baseChartProps = __rest4(_a, ["donutCenterRender", "children", "className"]);
      return React13.createElement(
        BaseChart,
        __assign6({}, baseChartProps, { ref: function(baseChart) {
          return _this._baseChart = baseChart;
        }, chartConstructor: chart_default, getTarget: this.getTarget, wrapper: "div", className: classNames("k-chart k-widget", className) }),
        children,
        React13.createElement(DonutCenter, { render: donutCenterRender })
      );
    };
    return Chart3;
  }(React13.Component)
);

// node_modules/@progress/kendo-react-charts/dist/es/components/base/CollectionConfigurationComponent.js
var React14 = __toESM(require_react());
var __extends31 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var CollectionConfigurationComponent = (
  /** @class */
  function(_super) {
    __extends31(CollectionConfigurationComponent2, _super);
    function CollectionConfigurationComponent2(props, context2) {
      var _this = _super.call(this, props, context2) || this;
      _this.optionsStore = context2.optionsStore;
      return _this;
    }
    CollectionConfigurationComponent2.prototype.renderChildren = function(child, index) {
      var children = child.props.children;
      var _a = this.props, _chartKey = _a._chartKey, _parentStore = _a._parentStore;
      var collectionItemProps = __assign7(__assign7({}, child.props), { _chartCollectionIdxKey: "".concat(_chartKey, "_").concat(index), _parentStore });
      return React14.cloneElement(child, collectionItemProps, children);
    };
    CollectionConfigurationComponent2.prototype.render = function() {
      var _this = this;
      var _a = this.props, _chartKey = _a._chartKey, _parentStore = _a._parentStore, children = _a.children;
      var store = _parentStore || this.optionsStore;
      store.dispatch({
        chartKey: _chartKey,
        payload: []
      });
      return React14.Children.map(children, function(child, index) {
        if (React14.isValidElement(child)) {
          return _this.renderChildren(child, index);
        }
        return child;
      });
    };
    CollectionConfigurationComponent2.contextType = ChartContext;
    return CollectionConfigurationComponent2;
  }(React14.Component)
);

// node_modules/@progress/kendo-react-charts/dist/es/components/base/ConfigurationComponent.js
var React15 = __toESM(require_react());
var __extends32 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var __rest5 = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ConfigurationComponent = (
  /** @class */
  function(_super) {
    __extends32(ConfigurationComponent2, _super);
    function ConfigurationComponent2(props, context2) {
      var _this = _super.call(this, props, context2) || this;
      _this.optionsStore = context2.optionsStore;
      _this.childStore = store_default(optionsReducer);
      return _this;
    }
    ConfigurationComponent2.prototype.render = function() {
      var _this = this;
      var children = this.props.children;
      return children !== void 0 ? React15.Children.map(children, function(child) {
        if (React15.isValidElement(child)) {
          return _this.renderChildren(child);
        }
        return child;
      }) : null;
    };
    ConfigurationComponent2.prototype.componentDidMount = function() {
      this.dispatch();
    };
    ConfigurationComponent2.prototype.componentDidUpdate = function() {
      this.dispatch();
    };
    ConfigurationComponent2.prototype.dispatch = function() {
      var _a = this.props, _chartKey = _a._chartKey, _chartCollectionIdxKey = _a._chartCollectionIdxKey, _parentStore = _a._parentStore, children = _a.children, options2 = __rest5(_a, ["_chartKey", "_chartCollectionIdxKey", "_parentStore", "children"]);
      var store = _parentStore || this.optionsStore;
      store.dispatch({
        chartKey: _chartKey,
        chartCollectionIdxKey: _chartCollectionIdxKey,
        payload: Object.assign({}, options2, this.childStore.getState())
      });
    };
    ConfigurationComponent2.prototype.renderChildren = function(child) {
      var children = child.props.children;
      var configurationItemProps = __assign8(__assign8({}, child.props), { _parentStore: this.childStore });
      return React15.cloneElement(child, configurationItemProps, children);
    };
    ConfigurationComponent2.contextType = ChartContext;
    return ConfigurationComponent2;
  }(React15.Component)
);

// node_modules/@progress/kendo-react-charts/dist/es/components/CategoryAxis.js
var React17 = __toESM(require_react());

// node_modules/@progress/kendo-react-charts/dist/es/components/CategoryAxisItem.js
var React16 = __toESM(require_react());
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var ChartCategoryAxisItem = function(props) {
  return React16.createElement(ConfigurationComponent, __assign9({}, props));
};
ChartCategoryAxisItem.displayName = "ChartCategoryAxisItem";

// node_modules/@progress/kendo-react-charts/dist/es/components/CategoryAxis.js
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var ChartCategoryAxis = function(props) {
  return React17.createElement(CollectionConfigurationComponent, __assign10({}, props, { _chartKey: "categoryAxis" }));
};
ChartCategoryAxis.propTypes = {
  children: function(props, propName, componentName) {
    return validateChildren(props, propName, componentName, ChartCategoryAxisItem);
  }
};

// node_modules/@progress/kendo-react-charts/dist/es/components/Legend.js
var React18 = __toESM(require_react());
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
var ChartLegend = function(props) {
  return React18.createElement(ConfigurationComponent, __assign11({}, props, { _chartKey: "legend" }));
};
ChartLegend.defaultProps = {
  visible: true
};

// node_modules/@progress/kendo-react-charts/dist/es/components/Series.js
var React20 = __toESM(require_react());

// node_modules/@progress/kendo-react-charts/dist/es/components/SeriesItem.js
var React19 = __toESM(require_react());
var __assign12 = function() {
  __assign12 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign12.apply(this, arguments);
};
var ChartSeriesItem = function(props) {
  return React19.createElement(ConfigurationComponent, __assign12({}, props));
};
ChartSeriesItem.displayName = "ChartSeriesItem";

// node_modules/@progress/kendo-react-charts/dist/es/components/Series.js
var __assign13 = function() {
  __assign13 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign13.apply(this, arguments);
};
var ChartSeries = function(props) {
  return React20.createElement(CollectionConfigurationComponent, __assign13({}, props, { _chartKey: "series" }));
};
ChartSeries.propTypes = {
  children: function(props, propName, componentName) {
    return validateChildren(props, propName, componentName, ChartSeriesItem);
  }
};

// node_modules/@progress/kendo-react-charts/dist/es/components/series-item/Labels.js
var React21 = __toESM(require_react());
var __assign14 = function() {
  __assign14 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign14.apply(this, arguments);
};
var ChartSeriesLabels = function(props) {
  return React21.createElement(ConfigurationComponent, __assign14({}, props, { _chartKey: "labels" }));
};
ChartSeriesLabels.defaultProps = {
  visible: true
};

// app/kendo/charts/column/kendoColumnChart.client.js
var import_hammerjs = __toESM(require_hammer());
var import_jsx_dev_runtime = __toESM(require_jsx_dev_runtime());
function MultiColumnChartContainer({ categories, series }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(Chart2, { style: { height: 250 }, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(ChartLegend, { position: "top", orientation: "horizontal" }, void 0, false, {
      fileName: "app/kendo/charts/column/kendoColumnChart.client.js",
      lineNumber: 18,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(ChartCategoryAxis, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(
      ChartCategoryAxisItem,
      {
        categories
      },
      void 0,
      false,
      {
        fileName: "app/kendo/charts/column/kendoColumnChart.client.js",
        lineNumber: 20,
        columnNumber: 15
      },
      this
    ) }, void 0, false, {
      fileName: "app/kendo/charts/column/kendoColumnChart.client.js",
      lineNumber: 19,
      columnNumber: 13
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(ChartSeries, { children: series.map((s) => /* @__PURE__ */ (0, import_jsx_dev_runtime.jsxDEV)(ChartSeriesItem, { name: s.name, data: s.data, type: "column" }, s.name, false, {
      fileName: "app/kendo/charts/column/kendoColumnChart.client.js",
      lineNumber: 25,
      columnNumber: 13
    }, this)) }, void 0, false, {
      fileName: "app/kendo/charts/column/kendoColumnChart.client.js",
      lineNumber: 23,
      columnNumber: 13
    }, this)
  ] }, void 0, true, {
    fileName: "app/kendo/charts/column/kendoColumnChart.client.js",
    lineNumber: 16,
    columnNumber: 9
  }, this);
}

// app/kendo/charts/column/WrapperColumnChart.jsx
var import_jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime());
var Fallback = () => {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)("svg", { width: 24, height: 24, fill: "none", children: /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(
    "path",
    {
      d: "M12 4.75v1.5M17.127 6.873l-1.061 1.061M19.25 12h-1.5M17.127 17.127l-1.061-1.061M12 17.75v1.5M7.934 16.066l-1.06 1.06M6.25 12h-1.5M7.934 7.934l-1.06-1.06",
      stroke: "currentColor",
      strokeWidth: 1.5,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    },
    void 0,
    false,
    {
      fileName: "app/kendo/charts/column/WrapperColumnChart.jsx",
      lineNumber: 8,
      columnNumber: 9
    },
    this
  ) }, void 0, false, {
    fileName: "app/kendo/charts/column/WrapperColumnChart.jsx",
    lineNumber: 7,
    columnNumber: 11
  }, this) }, void 0, false, {
    fileName: "app/kendo/charts/column/WrapperColumnChart.jsx",
    lineNumber: 6,
    columnNumber: 12
  }, this);
};
function WrapperMultiColumnChart({ category, series }) {
  return typeof document !== "undefined" ? /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(MultiColumnChartContainer, { categories: category, series }, void 0, false, {
    fileName: "app/kendo/charts/column/WrapperColumnChart.jsx",
    lineNumber: 20,
    columnNumber: 46
  }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime2.jsxDEV)(Fallback, {}, void 0, false, {
    fileName: "app/kendo/charts/column/WrapperColumnChart.jsx",
    lineNumber: 20,
    columnNumber: 116
  }, this);
}

// app/kendo/charts/donut/kendoDonutChart.client.js
var React22 = __toESM(require_react());
var ReactDOM2 = __toESM(require_react_dom());
var import_hammerjs2 = __toESM(require_hammer());
var import_jsx_dev_runtime3 = __toESM(require_jsx_dev_runtime());
var labelContent = (props) => {
  let formatedNumber = Number(props.dataItem.value).toLocaleString(void 0, {
    style: "percent",
    minimumFractionDigits: 2
  });
  return `${formatedNumber}`;
};
function DonutChartContainer({ series }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(Chart2, { style: { height: 250 }, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(ChartSeries, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
      ChartSeriesItem,
      {
        type: "donut",
        data: series,
        categoryField: "category",
        field: "value",
        children: /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(
          ChartSeriesLabels,
          {
            color: "#fff",
            background: "none",
            content: labelContent
          },
          void 0,
          false,
          {
            fileName: "app/kendo/charts/donut/kendoDonutChart.client.js",
            lineNumber: 30,
            columnNumber: 11
          },
          this
        )
      },
      void 0,
      false,
      {
        fileName: "app/kendo/charts/donut/kendoDonutChart.client.js",
        lineNumber: 24,
        columnNumber: 9
      },
      this
    ) }, void 0, false, {
      fileName: "app/kendo/charts/donut/kendoDonutChart.client.js",
      lineNumber: 23,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime3.jsxDEV)(ChartLegend, { visible: true }, void 0, false, {
      fileName: "app/kendo/charts/donut/kendoDonutChart.client.js",
      lineNumber: 37,
      columnNumber: 7
    }, this)
  ] }, void 0, true, {
    fileName: "app/kendo/charts/donut/kendoDonutChart.client.js",
    lineNumber: 22,
    columnNumber: 5
  }, this);
}

// app/kendo/charts/donut/WrapperDonutChart.jsx
var import_jsx_dev_runtime4 = __toESM(require_jsx_dev_runtime());
var Fallback2 = () => {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)("svg", { width: 20, height: 20, fill: "none", children: /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(
    "path",
    {
      d: "M12 4.75v1.5M17.127 6.873l-1.061 1.061M19.25 12h-1.5M17.127 17.127l-1.061-1.061M12 17.75v1.5M7.934 16.066l-1.06 1.06M6.25 12h-1.5M7.934 7.934l-1.06-1.06",
      stroke: "currentColor",
      strokeWidth: 0,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    },
    void 0,
    false,
    {
      fileName: "app/kendo/charts/donut/WrapperDonutChart.jsx",
      lineNumber: 7,
      columnNumber: 9
    },
    this
  ) }, void 0, false, {
    fileName: "app/kendo/charts/donut/WrapperDonutChart.jsx",
    lineNumber: 6,
    columnNumber: 11
  }, this) }, void 0, false, {
    fileName: "app/kendo/charts/donut/WrapperDonutChart.jsx",
    lineNumber: 5,
    columnNumber: 12
  }, this);
};
function WrapperDonutChart({ series }) {
  return typeof document !== "undefined" ? /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(DonutChartContainer, { series }, void 0, false, {
    fileName: "app/kendo/charts/donut/WrapperDonutChart.jsx",
    lineNumber: 20,
    columnNumber: 46
  }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime4.jsxDEV)(Fallback2, {}, void 0, false, {
    fileName: "app/kendo/charts/donut/WrapperDonutChart.jsx",
    lineNumber: 20,
    columnNumber: 88
  }, this);
}

// app/kendo/charts/stackcol/kendoStackColChart.client.js
var import_hammerjs3 = __toESM(require_hammer());
var import_jsx_dev_runtime5 = __toESM(require_jsx_dev_runtime());
function MultiStackColChartContainer({ categories, series, name: name2 }) {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(Chart2, { style: { height: 250 }, children: [
    /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(ChartLegend, { position: "top", orientation: "horizontal" }, void 0, false, {
      fileName: "app/kendo/charts/stackcol/kendoStackColChart.client.js",
      lineNumber: 17,
      columnNumber: 8
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(ChartCategoryAxis, { children: /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(ChartCategoryAxisItem, { categories }, void 0, false, {
      fileName: "app/kendo/charts/stackcol/kendoStackColChart.client.js",
      lineNumber: 19,
      columnNumber: 10
    }, this) }, void 0, false, {
      fileName: "app/kendo/charts/stackcol/kendoStackColChart.client.js",
      lineNumber: 18,
      columnNumber: 8
    }, this),
    /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(ChartSeries, { children: series.map((s) => /* @__PURE__ */ (0, import_jsx_dev_runtime5.jsxDEV)(ChartSeriesItem, { name: s.name, data: s.data, type: "column", stack: true, tooltip: { visible: true } }, s.name, false, {
      fileName: "app/kendo/charts/stackcol/kendoStackColChart.client.js",
      lineNumber: 23,
      columnNumber: 8
    }, this)) }, void 0, false, {
      fileName: "app/kendo/charts/stackcol/kendoStackColChart.client.js",
      lineNumber: 21,
      columnNumber: 8
    }, this)
  ] }, void 0, true, {
    fileName: "app/kendo/charts/stackcol/kendoStackColChart.client.js",
    lineNumber: 15,
    columnNumber: 4
  }, this);
}

// app/kendo/charts/stackcol/WrapperStackColChart.jsx
var import_jsx_dev_runtime6 = __toESM(require_jsx_dev_runtime());
var Fallback3 = () => {
  return /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("div", { children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)("svg", { width: 24, height: 24, fill: "none", children: /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(
    "path",
    {
      d: "M12 4.75v1.5M17.127 6.873l-1.061 1.061M19.25 12h-1.5M17.127 17.127l-1.061-1.061M12 17.75v1.5M7.934 16.066l-1.06 1.06M6.25 12h-1.5M7.934 7.934l-1.06-1.06",
      stroke: "currentColor",
      strokeWidth: 1.5,
      strokeLinecap: "round",
      strokeLinejoin: "round"
    },
    void 0,
    false,
    {
      fileName: "app/kendo/charts/stackcol/WrapperStackColChart.jsx",
      lineNumber: 7,
      columnNumber: 9
    },
    this
  ) }, void 0, false, {
    fileName: "app/kendo/charts/stackcol/WrapperStackColChart.jsx",
    lineNumber: 6,
    columnNumber: 11
  }, this) }, void 0, false, {
    fileName: "app/kendo/charts/stackcol/WrapperStackColChart.jsx",
    lineNumber: 5,
    columnNumber: 12
  }, this);
};
function WrapperMultiStackColChart({ category, series }) {
  return typeof document !== "undefined" ? /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(MultiStackColChartContainer, { categories: category, series }, void 0, false, {
    fileName: "app/kendo/charts/stackcol/WrapperStackColChart.jsx",
    lineNumber: 19,
    columnNumber: 44
  }, this) : /* @__PURE__ */ (0, import_jsx_dev_runtime6.jsxDEV)(Fallback3, {}, void 0, false, {
    fileName: "app/kendo/charts/stackcol/WrapperStackColChart.jsx",
    lineNumber: 19,
    columnNumber: 116
  }, this);
}

export {
  WrapperMultiColumnChart,
  WrapperDonutChart,
  WrapperMultiStackColChart
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)
*/
//# sourceMappingURL=/build/_shared/chunk-4KNWJ5NN.js.map
